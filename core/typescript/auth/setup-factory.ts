/**
 * Auth Setup Factory
 *
 * Creates Playwright auth setup project configurations for each role.
 * These projects run before browser tests to establish authenticated sessions.
 *
 * FR-007: Persist authentication state to files and reuse valid state across test runs
 * FR-009: Support multiple named roles with separate credentials and storage states
 *
 * @module auth/setup-factory
 */

import * as path from 'node:path';
import type { AuthSetupOptions, AuthSetupProject } from './types.js';
import type { ARTKConfig, AuthConfig, RoleConfig } from '../config/types.js';
import { DEFAULT_STORAGE_STATE_CONFIG } from './storage-state.js';
import { createLogger } from '../utils/logger.js';

const logger = createLogger('auth', 'setup-factory');

// =============================================================================
// Default Configuration
// =============================================================================

/**
 * Default auth setup options
 */
const DEFAULT_AUTH_SETUP_OPTIONS: Required<AuthSetupOptions> = {
  outputDir: DEFAULT_STORAGE_STATE_CONFIG.directory,
  filePattern: DEFAULT_STORAGE_STATE_CONFIG.filePattern,
  forceReauth: false,
};

// =============================================================================
// Auth Setup Factory
// =============================================================================

/**
 * Create Playwright auth setup project configuration for a role
 *
 * Creates a project configuration that:
 * 1. Runs before browser tests
 * 2. Checks for valid existing storage state
 * 3. Authenticates and saves storage state if needed
 *
 * @param role - Role name (e.g., 'admin', 'standardUser')
 * @param authConfig - Authentication configuration
 * @param options - Optional setup configuration
 * @returns Playwright project configuration with name, testMatch, and setup paths
 */
export function createAuthSetup(
  role: string,
  authConfig: AuthConfig,
  _options: AuthSetupOptions = {}
): AuthSetupProject {
  logger.debug('Creating auth setup for role', { role });

  // Validate role exists
  const roleConfig = authConfig.roles[role];
  if (!roleConfig) {
    throw new Error(`Role "${role}" not found in auth configuration`);
  }

  // Generate project name
  const projectName = `auth-setup-${role}`;

  return {
    name: projectName,
    testMatch: '**/auth.setup.ts',
    setup: `auth/setup/${role}.setup.ts`,
  };
}

/**
 * Create auth setup projects for all configured roles
 *
 * FR-009: Support multiple named roles with separate credentials and storage states
 *
 * @param authConfig - Authentication configuration
 * @param options - Optional setup configuration
 * @returns Array of Playwright project configurations for all roles
 */
export function createAllAuthSetups(
  authConfig: AuthConfig,
  options: AuthSetupOptions = {}
): AuthSetupProject[] {
  const roles = Object.keys(authConfig.roles);

  logger.debug('Creating auth setups for all roles', { roles });

  return roles.map((role) => createAuthSetup(role, authConfig, options));
}

/**
 * Create auth setup code for a role
 *
 * Generates the TypeScript code for an auth setup file that can be
 * imported into Playwright's globalSetup.
 *
 * @param role - Role name
 * @param authConfig - Authentication configuration
 * @returns TypeScript code as string
 */
export function generateAuthSetupCode(role: string, authConfig: AuthConfig): string {
  const roleConfig = authConfig.roles[role];
  if (!roleConfig) {
    throw new Error(`Role "${role}" not found in auth configuration`);
  }

  return `/**
 * Auth Setup for role: ${role}
 *
 * This file is auto-generated by ARTK.
 * It runs before browser tests to establish an authenticated session.
 */

import { chromium } from '@playwright/test';
import {
  getCredentials,
  saveStorageState,
  loadStorageState,
  cleanupExpiredStorageStates,
  createAuthProviderFromConfig,
} from '@artk/core/auth';
import { loadConfig } from '@artk/core/config';

async function setup() {
  // Load configuration
  const config = await loadConfig();

  // Cleanup expired storage states (NFR-007)
  await cleanupExpiredStorageStates();

  // Check for valid existing storage state
  const existingState = await loadStorageState('${role}', {
    directory: config.auth.storageState.directory,
    maxAgeMinutes: config.auth.storageState.maxAgeMinutes,
  });

  if (existingState) {
    console.log('Reusing existing storage state for role: ${role}');
    return;
  }

  console.log('Authenticating for role: ${role}');

  // Get credentials
  const credentials = getCredentials('${role}', config.auth);

  // Create auth provider
  const provider = createAuthProviderFromConfig(config.auth, '${role}');

  // Launch browser
  const browser = await chromium.launch();
  const context = await browser.newContext();
  const page = await context.newPage();

  try {
    // Perform login
    await provider.login(page, credentials);

    // Save storage state
    await saveStorageState(context, '${role}', {
      directory: config.auth.storageState.directory,
      filePattern: config.auth.storageState.filePattern,
    });

    console.log('Authentication successful for role: ${role}');
  } finally {
    await browser.close();
  }
}

export default setup;
`;
}

// =============================================================================
// Playwright Config Integration
// =============================================================================

/**
 * Generate Playwright project configurations for auth setup
 *
 * Creates the full project configuration array needed for playwright.config.ts
 * including dependencies between auth setups and browser tests.
 *
 * Use these projects in playwright.config.ts by spreading them into the projects
 * array and setting browser test projects to depend on them.
 *
 * @param config - Full ARTK configuration
 * @returns Array of Playwright project configurations with name, testMatch, and metadata
 */
export function generateAuthProjects(config: ARTKConfig): PlaywrightAuthProject[] {
  const authConfig = config.auth;
  const roles = Object.keys(authConfig.roles);

  return roles.map((role) => ({
    name: `auth-setup-${role}`,
    testMatch: /auth\.setup\.ts$/,
    metadata: {
      role,
      storageStatePath: getStorageStatePath(role, {
        outputDir: authConfig.storageState.directory,
        filePattern: authConfig.storageState.filePattern,
      }),
    },
  }));
}

/**
 * Get storage state file path for a role
 */
function getStorageStatePath(role: string, options: AuthSetupOptions): string {
  const directory = options.outputDir ?? DEFAULT_AUTH_SETUP_OPTIONS.outputDir;
  const pattern = options.filePattern ?? DEFAULT_AUTH_SETUP_OPTIONS.filePattern;

  const filename = pattern.replace('{role}', role).replace('{env}', 'default');
  return path.join(directory, filename.endsWith('.json') ? filename : `${filename}.json`);
}

/**
 * Playwright project configuration for auth
 */
export interface PlaywrightAuthProject {
  name: string;
  testMatch: RegExp;
  metadata: {
    role: string;
    storageStatePath: string;
  };
}

// =============================================================================
// Auth Provider Factory
// =============================================================================

/**
 * Create an auth provider from configuration
 *
 * Factory function that creates the appropriate AuthProvider based on
 * the configuration's provider type.
 *
 * @param authConfig - Authentication configuration
 * @param role - Role name for provider setup
 * @returns AuthProvider instance
 */
export function createAuthProviderFromConfig(
  authConfig: AuthConfig,
  role: string
): AuthProviderLike {
  const roleConfig = authConfig.roles[role];
  if (!roleConfig) {
    throw new Error(`Role "${role}" not found in auth configuration`);
  }

  const providerType = authConfig.provider;

  // Lazy import to avoid circular dependencies
  switch (providerType) {
    case 'oidc': {
      // Dynamic import would be ideal, but for now we return a factory pattern
      return {
        type: 'oidc',
        role,
        config: authConfig.oidc!,
        roleOverrides: roleConfig.oidcOverrides,
      } as AuthProviderLike;
    }

    case 'form': {
      return {
        type: 'form',
        role,
        config: authConfig.form!,
      } as AuthProviderLike;
    }

    case 'token': {
      return {
        type: 'token',
        role,
        // Token config would be in a similar structure
      } as AuthProviderLike;
    }

    case 'custom': {
      return {
        type: 'custom',
        role,
      } as AuthProviderLike;
    }

    default:
      throw new Error(`Unknown auth provider type: ${providerType}`);
  }
}

/**
 * Auth provider-like object for lazy instantiation
 */
export interface AuthProviderLike {
  type: 'oidc' | 'form' | 'token' | 'custom';
  role: string;
  config?: unknown;
  roleOverrides?: unknown;
}

// =============================================================================
// Helper Functions
// =============================================================================

/**
 * Get all configured role names
 */
export function getRoleNames(authConfig: AuthConfig): string[] {
  return Object.keys(authConfig.roles);
}

/**
 * Get storage state directory path
 */
export function getStorageStateDirectory(authConfig: AuthConfig, projectRoot: string = process.cwd()): string {
  return path.join(projectRoot, authConfig.storageState.directory);
}

/**
 * Check if a role is configured
 */
export function hasRole(role: string, authConfig: AuthConfig): boolean {
  return role in authConfig.roles;
}

/**
 * Get role configuration
 */
export function getRoleConfig(role: string, authConfig: AuthConfig): RoleConfig | undefined {
  return authConfig.roles[role];
}

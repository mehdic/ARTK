{"version":3,"sources":["../../src/heal/rules.ts","../../src/heal/logger.ts","../../src/heal/fixes/selector.ts","../../src/heal/fixes/navigation.ts","../../src/heal/fixes/timing.ts","../../src/heal/loop.ts","../../src/heal/fixes/data.ts"],"names":["existsSync","readFileSync","writeFileSync"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Healing Rules - Define allowed and forbidden healing operations\n * @see T061 - Define healing rules (allowed/forbidden fixes) per detailed spec Section 16\n */\nimport type { FailureCategory, FailureClassification } from '../verify/classifier.js';\n\n/**\n * Types of healing fixes\n */\nexport type HealFixType =\n  | 'selector-refine'      // Replace CSS with role/label/testid\n  | 'add-exact'            // Add exact: true to locator\n  | 'missing-await'        // Add missing await\n  | 'navigation-wait'      // Add waitForURL/toHaveURL\n  | 'timeout-increase'     // Increase timeout (bounded)\n  | 'web-first-assertion'; // Convert to web-first assertion\n\n/**\n * Forbidden fix types that must never be applied\n */\nexport type ForbiddenFixType =\n  | 'add-sleep'            // Never add waitForTimeout\n  | 'remove-assertion'     // Never remove assertions\n  | 'weaken-assertion'     // Never change toBe to toContain\n  | 'force-click'          // Never add force: true\n  | 'bypass-auth';         // Never skip authentication\n\n/**\n * Healing rule definition\n */\nexport interface HealingRule {\n  /** Fix type identifier */\n  fixType: HealFixType;\n  /** Categories this fix applies to */\n  appliesTo: FailureCategory[];\n  /** Priority (lower = try first) */\n  priority: number;\n  /** Human-readable description */\n  description: string;\n  /** Whether enabled by default */\n  enabledByDefault: boolean;\n}\n\n/**\n * Healing configuration\n */\nexport interface HealingConfig {\n  /** Whether healing is enabled */\n  enabled: boolean;\n  /** Maximum healing attempts */\n  maxAttempts: number;\n  /** Allowed fix types */\n  allowedFixes: HealFixType[];\n  /** Forbidden fix types (always blocked) */\n  forbiddenFixes: ForbiddenFixType[];\n  /** Timeout increase limit in ms */\n  maxTimeoutIncrease: number;\n}\n\n/**\n * Healing rule result\n */\nexport interface HealingRuleResult {\n  /** Whether healing is allowed for this failure */\n  canHeal: boolean;\n  /** Applicable fix types in priority order */\n  applicableFixes: HealFixType[];\n  /** Reason if healing not allowed */\n  reason?: string;\n}\n\n/**\n * Default healing rules\n */\nexport const DEFAULT_HEALING_RULES: HealingRule[] = [\n  {\n    fixType: 'missing-await',\n    appliesTo: ['selector', 'timing', 'script'],\n    priority: 1,\n    description: 'Add missing await to async operations',\n    enabledByDefault: true,\n  },\n  {\n    fixType: 'selector-refine',\n    appliesTo: ['selector'],\n    priority: 2,\n    description: 'Replace CSS selector with role/label/testid',\n    enabledByDefault: true,\n  },\n  {\n    fixType: 'add-exact',\n    appliesTo: ['selector'],\n    priority: 3,\n    description: 'Add exact: true to resolve ambiguous locators',\n    enabledByDefault: true,\n  },\n  {\n    fixType: 'navigation-wait',\n    appliesTo: ['navigation', 'timing'],\n    priority: 4,\n    description: 'Add waitForURL or toHaveURL assertion',\n    enabledByDefault: true,\n  },\n  {\n    fixType: 'web-first-assertion',\n    appliesTo: ['timing', 'data'],\n    priority: 5,\n    description: 'Convert to auto-retrying web-first assertion',\n    enabledByDefault: true,\n  },\n  {\n    fixType: 'timeout-increase',\n    appliesTo: ['timing'],\n    priority: 6,\n    description: 'Increase operation timeout (bounded)',\n    enabledByDefault: false, // Disabled by default as it can mask real issues\n  },\n];\n\n/**\n * Default healing configuration\n */\nexport const DEFAULT_HEALING_CONFIG: HealingConfig = {\n  enabled: true,\n  maxAttempts: 3,\n  allowedFixes: [\n    'selector-refine',\n    'add-exact',\n    'missing-await',\n    'navigation-wait',\n    'web-first-assertion',\n  ],\n  forbiddenFixes: [\n    'add-sleep',\n    'remove-assertion',\n    'weaken-assertion',\n    'force-click',\n    'bypass-auth',\n  ],\n  maxTimeoutIncrease: 30000, // Max 30 seconds\n};\n\n/**\n * Categories that cannot be healed automatically\n */\nexport const UNHEALABLE_CATEGORIES: FailureCategory[] = [\n  'auth',     // Requires credential/session fix\n  'env',      // Requires environment fix\n  'unknown',  // Cannot determine appropriate fix\n];\n\n/**\n * Check if a failure category is healable\n */\nexport function isCategoryHealable(category: FailureCategory): boolean {\n  return !UNHEALABLE_CATEGORIES.includes(category);\n}\n\n/**\n * Get applicable healing rules for a failure classification\n */\nexport function getApplicableRules(\n  classification: FailureClassification,\n  config: HealingConfig = DEFAULT_HEALING_CONFIG\n): HealingRule[] {\n  if (!config.enabled) {\n    return [];\n  }\n\n  if (!isCategoryHealable(classification.category)) {\n    return [];\n  }\n\n  return DEFAULT_HEALING_RULES\n    .filter((rule) => {\n      // Must apply to this failure category\n      if (!rule.appliesTo.includes(classification.category)) {\n        return false;\n      }\n      // Must be in allowed list\n      if (!config.allowedFixes.includes(rule.fixType)) {\n        return false;\n      }\n      return true;\n    })\n    .sort((a, b) => a.priority - b.priority);\n}\n\n/**\n * Evaluate healing possibilities for a failure\n */\nexport function evaluateHealing(\n  classification: FailureClassification,\n  config: HealingConfig = DEFAULT_HEALING_CONFIG\n): HealingRuleResult {\n  if (!config.enabled) {\n    return {\n      canHeal: false,\n      applicableFixes: [],\n      reason: 'Healing is disabled',\n    };\n  }\n\n  if (!isCategoryHealable(classification.category)) {\n    return {\n      canHeal: false,\n      applicableFixes: [],\n      reason: `Category '${classification.category}' cannot be healed automatically`,\n    };\n  }\n\n  const applicableRules = getApplicableRules(classification, config);\n\n  if (applicableRules.length === 0) {\n    return {\n      canHeal: false,\n      applicableFixes: [],\n      reason: 'No applicable healing rules for this failure',\n    };\n  }\n\n  return {\n    canHeal: true,\n    applicableFixes: applicableRules.map((r) => r.fixType),\n  };\n}\n\n/**\n * Get the next fix to try for a failure\n */\nexport function getNextFix(\n  classification: FailureClassification,\n  attemptedFixes: HealFixType[],\n  config: HealingConfig = DEFAULT_HEALING_CONFIG\n): HealFixType | null {\n  const evaluation = evaluateHealing(classification, config);\n\n  if (!evaluation.canHeal) {\n    return null;\n  }\n\n  // Find first fix that hasn't been tried\n  for (const fix of evaluation.applicableFixes) {\n    if (!attemptedFixes.includes(fix)) {\n      return fix;\n    }\n  }\n\n  return null; // All fixes exhausted\n}\n\n/**\n * Validate that a proposed fix is allowed\n */\nexport function isFixAllowed(\n  fixType: HealFixType,\n  config: HealingConfig = DEFAULT_HEALING_CONFIG\n): boolean {\n  return config.enabled && config.allowedFixes.includes(fixType);\n}\n\n/**\n * Validate that a fix is not forbidden\n */\nexport function isFixForbidden(\n  fixType: string\n): fixType is ForbiddenFixType {\n  const forbidden: string[] = [\n    'add-sleep',\n    'remove-assertion',\n    'weaken-assertion',\n    'force-click',\n    'bypass-auth',\n  ];\n  return forbidden.includes(fixType);\n}\n\n/**\n * Get healing recommendation based on failure\n */\nexport function getHealingRecommendation(\n  classification: FailureClassification\n): string {\n  switch (classification.category) {\n    case 'selector':\n      return 'Refine selector to use role, label, or testid locator strategy';\n    case 'timing':\n      return 'Add explicit wait for expected state or use web-first assertion';\n    case 'navigation':\n      return 'Add waitForURL or toHaveURL assertion after navigation';\n    case 'data':\n      return 'Verify test data and consider using expect.poll for dynamic values';\n    case 'auth':\n      return 'Check authentication state; may need to refresh session';\n    case 'env':\n      return 'Verify environment connectivity and application availability';\n    case 'script':\n      return 'Fix the JavaScript/TypeScript error in the test code';\n    default:\n      return 'Review error details manually to determine appropriate fix';\n  }\n}\n\n/**\n * Get next steps after healing exhausted\n */\nexport function getPostHealingRecommendation(\n  classification: FailureClassification,\n  attemptCount: number\n): string {\n  const baseMsg = `Healing exhausted after ${attemptCount} attempts.`;\n\n  switch (classification.category) {\n    case 'selector':\n      return `${baseMsg} Consider adding data-testid to the target element or quarantining the test.`;\n    case 'timing':\n      return `${baseMsg} The application may have a genuine performance issue. Consider quarantining.`;\n    case 'navigation':\n      return `${baseMsg} The navigation flow may have changed. Review Journey steps.`;\n    default:\n      return `${baseMsg} Consider quarantining the test and filing a bug report.`;\n  }\n}\n","/**\n * Healing Attempt Logger - Track healing attempts in heal-log.json\n * @see T066 - Implement healing attempt logger (heal-log.json)\n */\nimport { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs';\nimport { dirname, join } from 'node:path';\nimport type { HealFixType } from './rules.js';\nimport type { FailureCategory } from '../verify/classifier.js';\n\n/**\n * Single healing attempt record\n */\nexport interface HealingAttempt {\n  /** Attempt number (1-based) */\n  attempt: number;\n  /** Timestamp of the attempt */\n  timestamp: string;\n  /** Type of failure being healed */\n  failureType: FailureCategory;\n  /** Fix type applied */\n  fixType: HealFixType;\n  /** File that was modified */\n  file: string;\n  /** Diff or description of the change */\n  change: string;\n  /** Evidence files (traces, screenshots) */\n  evidence: string[];\n  /** Result of the attempt */\n  result: 'pass' | 'fail' | 'error';\n  /** Error message if failed */\n  errorMessage?: string;\n  /** Duration in ms */\n  duration: number;\n}\n\n/**\n * Complete healing log for a journey\n */\nexport interface HealingLog {\n  /** Journey ID */\n  journeyId: string;\n  /** Session start time */\n  sessionStart: string;\n  /** Session end time */\n  sessionEnd?: string;\n  /** Maximum attempts allowed */\n  maxAttempts: number;\n  /** Final status */\n  status: 'in_progress' | 'healed' | 'failed' | 'exhausted';\n  /** All healing attempts */\n  attempts: HealingAttempt[];\n  /** Summary statistics */\n  summary?: HealingSummary;\n}\n\n/**\n * Summary statistics\n */\nexport interface HealingSummary {\n  /** Total attempts made */\n  totalAttempts: number;\n  /** Successful fixes */\n  successfulFixes: number;\n  /** Failed attempts */\n  failedAttempts: number;\n  /** Total healing duration in ms */\n  totalDuration: number;\n  /** Fix types attempted */\n  fixTypesAttempted: HealFixType[];\n  /** Final recommendation if not healed */\n  recommendation?: string;\n}\n\n/**\n * Healing logger class\n */\nexport class HealingLogger {\n  private log: HealingLog;\n  private outputPath: string;\n\n  constructor(journeyId: string, outputDir: string, maxAttempts: number = 3) {\n    this.outputPath = join(outputDir, `${journeyId}.heal-log.json`);\n    this.log = {\n      journeyId,\n      sessionStart: new Date().toISOString(),\n      maxAttempts,\n      status: 'in_progress',\n      attempts: [],\n    };\n  }\n\n  /**\n   * Log a healing attempt\n   */\n  logAttempt(attempt: Omit<HealingAttempt, 'timestamp'>): void {\n    this.log.attempts.push({\n      ...attempt,\n      timestamp: new Date().toISOString(),\n    });\n    this.save();\n  }\n\n  /**\n   * Mark healing as complete (success)\n   */\n  markHealed(): void {\n    this.log.status = 'healed';\n    this.log.sessionEnd = new Date().toISOString();\n    this.calculateSummary();\n    this.save();\n  }\n\n  /**\n   * Mark healing as failed (gave up)\n   */\n  markFailed(recommendation?: string): void {\n    this.log.status = 'failed';\n    this.log.sessionEnd = new Date().toISOString();\n    this.calculateSummary();\n    if (recommendation && this.log.summary) {\n      this.log.summary.recommendation = recommendation;\n    }\n    this.save();\n  }\n\n  /**\n   * Mark healing as exhausted (all attempts used)\n   */\n  markExhausted(recommendation?: string): void {\n    this.log.status = 'exhausted';\n    this.log.sessionEnd = new Date().toISOString();\n    this.calculateSummary();\n    if (recommendation && this.log.summary) {\n      this.log.summary.recommendation = recommendation;\n    }\n    this.save();\n  }\n\n  /**\n   * Get current log\n   */\n  getLog(): HealingLog {\n    return { ...this.log };\n  }\n\n  /**\n   * Get last attempt\n   */\n  getLastAttempt(): HealingAttempt | null {\n    return this.log.attempts[this.log.attempts.length - 1] || null;\n  }\n\n  /**\n   * Get attempt count\n   */\n  getAttemptCount(): number {\n    return this.log.attempts.length;\n  }\n\n  /**\n   * Check if max attempts reached\n   */\n  isMaxAttemptsReached(): boolean {\n    return this.log.attempts.length >= this.log.maxAttempts;\n  }\n\n  /**\n   * Calculate summary statistics\n   */\n  private calculateSummary(): void {\n    const attempts = this.log.attempts;\n\n    this.log.summary = {\n      totalAttempts: attempts.length,\n      successfulFixes: attempts.filter((a) => a.result === 'pass').length,\n      failedAttempts: attempts.filter((a) => a.result === 'fail' || a.result === 'error').length,\n      totalDuration: attempts.reduce((sum, a) => sum + a.duration, 0),\n      fixTypesAttempted: [...new Set(attempts.map((a) => a.fixType))],\n    };\n  }\n\n  /**\n   * Save log to file\n   */\n  private save(): void {\n    const dir = dirname(this.outputPath);\n    if (!existsSync(dir)) {\n      mkdirSync(dir, { recursive: true });\n    }\n    writeFileSync(this.outputPath, JSON.stringify(this.log, null, 2), 'utf-8');\n  }\n\n  /**\n   * Get output path\n   */\n  getOutputPath(): string {\n    return this.outputPath;\n  }\n}\n\n/**\n * Load existing healing log\n */\nexport function loadHealingLog(filePath: string): HealingLog | null {\n  if (!existsSync(filePath)) {\n    return null;\n  }\n\n  try {\n    const content = readFileSync(filePath, 'utf-8');\n    return JSON.parse(content) as HealingLog;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Format healing log for display\n */\nexport function formatHealingLog(log: HealingLog): string {\n  const lines: string[] = [];\n\n  // Header\n  lines.push(`# Healing Log: ${log.journeyId}`);\n  lines.push('');\n  lines.push(`Status: ${log.status.toUpperCase()}`);\n  lines.push(`Started: ${log.sessionStart}`);\n  if (log.sessionEnd) {\n    lines.push(`Ended: ${log.sessionEnd}`);\n  }\n  lines.push('');\n\n  // Attempts\n  lines.push('## Attempts');\n  lines.push('');\n\n  for (const attempt of log.attempts) {\n    const icon = attempt.result === 'pass' ? '' : '';\n    lines.push(`### Attempt ${attempt.attempt} ${icon}`);\n    lines.push('');\n    lines.push(`- **Fix Type**: ${attempt.fixType}`);\n    lines.push(`- **Failure Type**: ${attempt.failureType}`);\n    lines.push(`- **File**: ${attempt.file}`);\n    lines.push(`- **Duration**: ${attempt.duration}ms`);\n    lines.push(`- **Result**: ${attempt.result}`);\n    if (attempt.errorMessage) {\n      lines.push(`- **Error**: ${attempt.errorMessage}`);\n    }\n    if (attempt.change) {\n      lines.push(`- **Change**: ${attempt.change}`);\n    }\n    if (attempt.evidence.length > 0) {\n      lines.push(`- **Evidence**: ${attempt.evidence.join(', ')}`);\n    }\n    lines.push('');\n  }\n\n  // Summary\n  if (log.summary) {\n    lines.push('## Summary');\n    lines.push('');\n    lines.push(`- Total Attempts: ${log.summary.totalAttempts}`);\n    lines.push(`- Successful Fixes: ${log.summary.successfulFixes}`);\n    lines.push(`- Failed Attempts: ${log.summary.failedAttempts}`);\n    lines.push(`- Total Duration: ${log.summary.totalDuration}ms`);\n    lines.push(`- Fix Types Tried: ${log.summary.fixTypesAttempted.join(', ')}`);\n    if (log.summary.recommendation) {\n      lines.push('');\n      lines.push(`**Recommendation**: ${log.summary.recommendation}`);\n    }\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Create healing report summary\n */\nexport function createHealingReport(log: HealingLog): {\n  success: boolean;\n  attemptCount: number;\n  fixApplied?: HealFixType;\n  recommendation?: string;\n} {\n  const lastSuccessfulAttempt = log.attempts.find((a) => a.result === 'pass');\n\n  return {\n    success: log.status === 'healed',\n    attemptCount: log.attempts.length,\n    fixApplied: lastSuccessfulAttempt?.fixType,\n    recommendation: log.summary?.recommendation,\n  };\n}\n\n/**\n * Aggregate healing logs from multiple journeys\n */\nexport function aggregateHealingLogs(logs: HealingLog[]): {\n  totalJourneys: number;\n  healed: number;\n  failed: number;\n  exhausted: number;\n  totalAttempts: number;\n  mostCommonFixes: Array<{ fix: HealFixType; count: number }>;\n  mostCommonFailures: Array<{ failure: FailureCategory; count: number }>;\n} {\n  const fixCounts = new Map<HealFixType, number>();\n  const failureCounts = new Map<FailureCategory, number>();\n  let totalAttempts = 0;\n\n  for (const log of logs) {\n    for (const attempt of log.attempts) {\n      totalAttempts++;\n      fixCounts.set(attempt.fixType, (fixCounts.get(attempt.fixType) || 0) + 1);\n      failureCounts.set(attempt.failureType, (failureCounts.get(attempt.failureType) || 0) + 1);\n    }\n  }\n\n  const mostCommonFixes = [...fixCounts.entries()]\n    .sort((a, b) => b[1] - a[1])\n    .map(([fix, count]) => ({ fix, count }));\n\n  const mostCommonFailures = [...failureCounts.entries()]\n    .sort((a, b) => b[1] - a[1])\n    .map(([failure, count]) => ({ failure, count }));\n\n  return {\n    totalJourneys: logs.length,\n    healed: logs.filter((l) => l.status === 'healed').length,\n    failed: logs.filter((l) => l.status === 'failed').length,\n    exhausted: logs.filter((l) => l.status === 'exhausted').length,\n    totalAttempts,\n    mostCommonFixes,\n    mostCommonFailures,\n  };\n}\n","/**\n * Selector Fix Strategy - Refine CSS selectors to role/label/testid\n * @see T062 - Implement selector refinement fix (CSS  role/label/testid)\n */\n\n/**\n * Selector fix context\n */\nexport interface SelectorFixContext {\n  /** Original code containing the selector */\n  code: string;\n  /** Line number where selector appears */\n  lineNumber: number;\n  /** The failing selector expression */\n  selector: string;\n  /** Error message from Playwright */\n  errorMessage: string;\n  /** Available ARIA information (if captured) */\n  ariaInfo?: ARIANodeInfo;\n}\n\n/**\n * ARIA node information for selector inference\n */\nexport interface ARIANodeInfo {\n  role?: string;\n  name?: string;\n  level?: number;\n  hasTestId?: boolean;\n  testId?: string;\n  label?: string;\n  placeholder?: string;\n}\n\n/**\n * Selector fix result\n */\nexport interface SelectorFixResult {\n  /** Whether a fix was applied */\n  applied: boolean;\n  /** The modified code */\n  code: string;\n  /** Description of the fix */\n  description: string;\n  /** The new locator expression */\n  newLocator?: string;\n  /** Confidence in the fix (0-1) */\n  confidence: number;\n}\n\n/**\n * CSS selector patterns to replace\n */\nconst CSS_SELECTOR_PATTERNS = [\n  // page.locator('.class') or page.locator('#id')\n  /page\\.locator\\s*\\(\\s*['\"`]([.#][^'\"`]+)['\"`]\\s*\\)/g,\n  // page.locator('[attribute]')\n  /page\\.locator\\s*\\(\\s*['\"`](\\[[^\\]]+\\])['\"`]\\s*\\)/g,\n  // page.locator('tag.class')\n  /page\\.locator\\s*\\(\\s*['\"`]([a-z]+[.#][^'\"`]+)['\"`]\\s*\\)/g,\n];\n\n/**\n * Map of common UI patterns to role-based selectors\n */\nconst UI_PATTERN_TO_ROLE: Record<string, { role: string; nameHint?: string }> = {\n  'button': { role: 'button' },\n  'btn': { role: 'button' },\n  'submit': { role: 'button', nameHint: 'submit' },\n  'input': { role: 'textbox' },\n  'textbox': { role: 'textbox' },\n  'checkbox': { role: 'checkbox' },\n  'radio': { role: 'radio' },\n  'select': { role: 'combobox' },\n  'dropdown': { role: 'combobox' },\n  'link': { role: 'link' },\n  'heading': { role: 'heading' },\n  'h1': { role: 'heading' },\n  'h2': { role: 'heading' },\n  'h3': { role: 'heading' },\n  'dialog': { role: 'dialog' },\n  'modal': { role: 'dialog' },\n  'alert': { role: 'alert' },\n  'tab': { role: 'tab' },\n  'menu': { role: 'menu' },\n  'menuitem': { role: 'menuitem' },\n  'table': { role: 'table' },\n  'row': { role: 'row' },\n  'cell': { role: 'cell' },\n  'grid': { role: 'grid' },\n  'list': { role: 'list' },\n  'listitem': { role: 'listitem' },\n  'img': { role: 'img' },\n  'image': { role: 'img' },\n  'nav': { role: 'navigation' },\n  'navigation': { role: 'navigation' },\n  'search': { role: 'search' },\n  'main': { role: 'main' },\n  'banner': { role: 'banner' },\n  'footer': { role: 'contentinfo' },\n};\n\n/**\n * Extract CSS selector from code\n */\nexport function extractCSSSelector(code: string): string | null {\n  for (const pattern of CSS_SELECTOR_PATTERNS) {\n    pattern.lastIndex = 0;\n    const match = pattern.exec(code);\n    if (match) {\n      return match[1] ?? null;\n    }\n  }\n  return null;\n}\n\n/**\n * Check if code contains a CSS selector\n */\nexport function containsCSSSelector(code: string): boolean {\n  return CSS_SELECTOR_PATTERNS.some((pattern) => {\n    pattern.lastIndex = 0;\n    return pattern.test(code);\n  });\n}\n\n/**\n * Infer role from CSS selector class/id names\n */\nexport function inferRoleFromSelector(selector: string): { role: string; name?: string } | null {\n  const lowerSelector = selector.toLowerCase();\n\n  for (const [pattern, roleInfo] of Object.entries(UI_PATTERN_TO_ROLE)) {\n    if (lowerSelector.includes(pattern)) {\n      return roleInfo;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Extract potential name from selector\n */\nexport function extractNameFromSelector(selector: string): string | null {\n  // Extract text between brackets for attribute selectors\n  const attrMatch = selector.match(/\\[(?:aria-label|title|alt|name)=['\"]([^'\"]+)['\"]\\]/);\n  if (attrMatch) {\n    return attrMatch[1] ?? null;\n  }\n\n  // Extract class name parts that might be descriptive\n  const classMatch = selector.match(/\\.([a-zA-Z][-a-zA-Z0-9_]*)/);\n  if (classMatch) {\n    // Convert class name to readable format\n    const className = classMatch[1]!;\n    // Convert kebab-case or snake_case to words\n    const words = className.split(/[-_]/).filter(Boolean);\n    if (words.length > 0 && words[0]!.length > 2) {\n      return words.join(' ');\n    }\n  }\n\n  return null;\n}\n\n/**\n * Generate role-based locator from inferred information\n */\nexport function generateRoleLocator(\n  role: string,\n  name?: string,\n  options?: { exact?: boolean; level?: number }\n): string {\n  const parts: string[] = [];\n\n  if (name) {\n    if (options?.exact) {\n      parts.push(`{ name: '${name}', exact: true }`);\n    } else {\n      parts.push(`{ name: '${name}' }`);\n    }\n  }\n\n  if (options?.level !== undefined && role === 'heading') {\n    if (parts.length > 0) {\n      // Merge with existing options\n      const existing = parts[0]!.slice(0, -2); // Remove ' }'\n      parts[0] = `${existing}, level: ${options.level} }`;\n    } else {\n      parts.push(`{ level: ${options.level} }`);\n    }\n  }\n\n  if (parts.length > 0) {\n    return `page.getByRole('${role}', ${parts[0]})`;\n  }\n\n  return `page.getByRole('${role}')`;\n}\n\n/**\n * Generate label-based locator\n */\nexport function generateLabelLocator(label: string, exact?: boolean): string {\n  if (exact) {\n    return `page.getByLabel('${label}', { exact: true })`;\n  }\n  return `page.getByLabel('${label}')`;\n}\n\n/**\n * Generate text-based locator\n */\nexport function generateTextLocator(text: string, exact?: boolean): string {\n  if (exact) {\n    return `page.getByText('${text}', { exact: true })`;\n  }\n  return `page.getByText('${text}')`;\n}\n\n/**\n * Generate testid-based locator\n */\nexport function generateTestIdLocator(testId: string): string {\n  return `page.getByTestId('${testId}')`;\n}\n\n/**\n * Apply selector fix to code\n */\nexport function applySelectorFix(context: SelectorFixContext): SelectorFixResult {\n  const { code, ariaInfo } = context;\n\n  // If we have ARIA info, use it\n  if (ariaInfo) {\n    return applySelectorFixWithARIA(code, ariaInfo);\n  }\n\n  // Try to infer from CSS selector\n  const cssSelector = extractCSSSelector(code);\n  if (!cssSelector) {\n    return {\n      applied: false,\n      code,\n      description: 'No CSS selector found to refine',\n      confidence: 0,\n    };\n  }\n\n  return applySelectorFixFromCSS(code, cssSelector);\n}\n\n/**\n * Apply selector fix using ARIA information\n */\nfunction applySelectorFixWithARIA(code: string, ariaInfo: ARIANodeInfo): SelectorFixResult {\n  let newLocator: string | null = null;\n  let confidence = 0;\n\n  // Priority: testid > role+name > label > text\n  if (ariaInfo.testId) {\n    newLocator = generateTestIdLocator(ariaInfo.testId);\n    confidence = 1.0;\n  } else if (ariaInfo.role && ariaInfo.name) {\n    newLocator = generateRoleLocator(ariaInfo.role, ariaInfo.name, {\n      exact: true,\n      level: ariaInfo.level,\n    });\n    confidence = 0.9;\n  } else if (ariaInfo.label) {\n    newLocator = generateLabelLocator(ariaInfo.label, true);\n    confidence = 0.85;\n  } else if (ariaInfo.role) {\n    newLocator = generateRoleLocator(ariaInfo.role);\n    confidence = 0.6;\n  }\n\n  if (!newLocator) {\n    return {\n      applied: false,\n      code,\n      description: 'Unable to generate locator from ARIA info',\n      confidence: 0,\n    };\n  }\n\n  // Replace CSS selector in code\n  let modifiedCode = code;\n  for (const pattern of CSS_SELECTOR_PATTERNS) {\n    modifiedCode = modifiedCode.replace(pattern, newLocator);\n  }\n\n  return {\n    applied: modifiedCode !== code,\n    code: modifiedCode,\n    description: `Replaced CSS selector with ${newLocator.split('(')[0]}`,\n    newLocator,\n    confidence,\n  };\n}\n\n/**\n * Apply selector fix by inferring from CSS selector\n */\nfunction applySelectorFixFromCSS(code: string, cssSelector: string): SelectorFixResult {\n  // Try to infer role from selector\n  const roleInfo = inferRoleFromSelector(cssSelector);\n  const extractedName = extractNameFromSelector(cssSelector);\n\n  let newLocator: string | null = null;\n  let confidence = 0;\n\n  if (roleInfo) {\n    const name = extractedName;\n    if (name) {\n      newLocator = generateRoleLocator(roleInfo.role, name);\n      confidence = 0.6;\n    } else {\n      newLocator = generateRoleLocator(roleInfo.role);\n      confidence = 0.4;\n    }\n  } else if (extractedName) {\n    // Fall back to text locator if we have a name but no role\n    newLocator = generateTextLocator(extractedName);\n    confidence = 0.3;\n  }\n\n  if (!newLocator) {\n    return {\n      applied: false,\n      code,\n      description: 'Unable to infer semantic locator from CSS selector',\n      confidence: 0,\n    };\n  }\n\n  // Replace CSS selector in code\n  let modifiedCode = code;\n  for (const pattern of CSS_SELECTOR_PATTERNS) {\n    modifiedCode = modifiedCode.replace(pattern, newLocator);\n  }\n\n  return {\n    applied: modifiedCode !== code,\n    code: modifiedCode,\n    description: `Inferred ${newLocator.split('(')[0]} from CSS selector pattern`,\n    newLocator,\n    confidence,\n  };\n}\n\n/**\n * Add exact: true to existing locator\n */\nexport function addExactToLocator(code: string): SelectorFixResult {\n  let modifiedCode = code;\n  let applied = false;\n\n  // Add exact: true to getByRole\n  modifiedCode = modifiedCode.replace(\n    /page\\.getByRole\\s*\\(\\s*['\"](\\w+)['\"]\\s*,\\s*\\{\\s*name:\\s*['\"]([^'\"]+)['\"]\\s*\\}\\s*\\)/g,\n    (_, role, name) => {\n      applied = true;\n      return `page.getByRole('${role}', { name: '${name}', exact: true })`;\n    }\n  );\n\n  // Add exact: true to getByLabel\n  modifiedCode = modifiedCode.replace(\n    /page\\.getByLabel\\s*\\(\\s*['\"]([^'\"]+)['\"]\\s*\\)/g,\n    (_, label) => {\n      applied = true;\n      return `page.getByLabel('${label}', { exact: true })`;\n    }\n  );\n\n  // Add exact: true to getByText\n  modifiedCode = modifiedCode.replace(\n    /page\\.getByText\\s*\\(\\s*['\"]([^'\"]+)['\"]\\s*\\)/g,\n    (_, text) => {\n      applied = true;\n      return `page.getByText('${text}', { exact: true })`;\n    }\n  );\n\n  return {\n    applied,\n    code: modifiedCode,\n    description: applied ? 'Added exact: true to locator' : 'No locator found to add exact option',\n    confidence: applied ? 0.8 : 0,\n  };\n}\n","/**\n * Navigation Wait Fix - Add waitForURL/toHaveURL assertions\n * @see T063 - Implement navigation wait fix\n */\n\n/**\n * Navigation fix context\n */\nexport interface NavigationFixContext {\n  /** Original code */\n  code: string;\n  /** Line number where navigation issue occurs */\n  lineNumber: number;\n  /** Expected URL pattern (if known) */\n  expectedUrl?: string;\n  /** Error message from Playwright */\n  errorMessage: string;\n}\n\n/**\n * Navigation fix result\n */\nexport interface NavigationFixResult {\n  /** Whether a fix was applied */\n  applied: boolean;\n  /** The modified code */\n  code: string;\n  /** Description of the fix */\n  description: string;\n  /** Confidence in the fix (0-1) */\n  confidence: number;\n}\n\n// Navigation patterns defined for reference, used in pattern matching\n\n/**\n * Patterns for existing waits (to avoid duplicates)\n */\nconst EXISTING_WAIT_PATTERNS = [\n  /await\\s+page\\.waitForURL/,\n  /await\\s+expect\\s*\\(\\s*page\\s*\\)\\.toHaveURL/,\n  /await\\s+page\\.waitForNavigation/,\n  /await\\s+page\\.waitForLoadState/,\n];\n\n/**\n * Check if code already has navigation wait\n */\nexport function hasNavigationWait(code: string): boolean {\n  return EXISTING_WAIT_PATTERNS.some((pattern) => pattern.test(code));\n}\n\n/**\n * Extract URL pattern from error message\n */\nexport function extractUrlFromError(errorMessage: string): string | null {\n  // Pattern: Expected URL to match '/pattern/'\n  const matchPattern = errorMessage.match(/Expected\\s+URL\\s+to\\s+match\\s+['\"]([^'\"]+)['\"]/i);\n  if (matchPattern) {\n    return matchPattern[1] ?? null;\n  }\n\n  // Pattern: expected \"url\" to match\n  const matchUrl = errorMessage.match(/expected\\s+['\"]([^'\"]+)['\"]\\s+to\\s+match/i);\n  if (matchUrl) {\n    return matchUrl[1] ?? null;\n  }\n\n  // Pattern: waiting for URL pattern\n  const waitingPattern = errorMessage.match(/waiting\\s+for\\s+URL\\s+['\"]([^'\"]+)['\"]/i);\n  if (waitingPattern) {\n    return waitingPattern[1] ?? null;\n  }\n\n  return null;\n}\n\n/**\n * Extract URL from goto call\n */\nexport function extractUrlFromGoto(code: string): string | null {\n  const match = code.match(/page\\.goto\\s*\\(\\s*['\"`]([^'\"`]+)['\"`]/);\n  return match ? (match[1] ?? null) : null;\n}\n\n/**\n * Infer expected URL pattern from navigation action\n */\nexport function inferUrlPattern(code: string, errorMessage: string): string | null {\n  // First try to extract from error message\n  const errorUrl = extractUrlFromError(errorMessage);\n  if (errorUrl) {\n    return errorUrl;\n  }\n\n  // Try to extract from goto call\n  const gotoUrl = extractUrlFromGoto(code);\n  if (gotoUrl) {\n    return gotoUrl;\n  }\n\n  return null;\n}\n\n/**\n * Generate waitForURL statement\n */\nexport function generateWaitForURL(urlPattern: string, options?: { timeout?: number }): string {\n  const opts = options?.timeout ? `, { timeout: ${options.timeout} }` : '';\n\n  // Determine if pattern should be regex or string\n  if (urlPattern.includes('*') || urlPattern.includes('\\\\')) {\n    return `await page.waitForURL(/${urlPattern}/${opts})`;\n  }\n\n  return `await page.waitForURL('${urlPattern}'${opts})`;\n}\n\n/**\n * Generate toHaveURL assertion\n */\nexport function generateToHaveURL(urlPattern: string): string {\n  // Determine if pattern should be regex or string\n  if (urlPattern.includes('*') || urlPattern.includes('\\\\')) {\n    return `await expect(page).toHaveURL(/${urlPattern}/)`;\n  }\n\n  return `await expect(page).toHaveURL('${urlPattern}')`;\n}\n\n/**\n * Insert navigation wait after an action\n */\nexport function insertNavigationWait(\n  code: string,\n  lineNumber: number,\n  urlPattern: string\n): NavigationFixResult {\n  const lines = code.split('\\n');\n\n  if (lineNumber < 1 || lineNumber > lines.length) {\n    return {\n      applied: false,\n      code,\n      description: 'Invalid line number',\n      confidence: 0,\n    };\n  }\n\n  // Check if there's already a wait nearby\n  const contextStart = Math.max(0, lineNumber - 2);\n  const contextEnd = Math.min(lines.length, lineNumber + 2);\n  const context = lines.slice(contextStart, contextEnd).join('\\n');\n\n  if (hasNavigationWait(context)) {\n    return {\n      applied: false,\n      code,\n      description: 'Navigation wait already exists in context',\n      confidence: 0,\n    };\n  }\n\n  // Get the line where action occurs\n  const actionLine = lines[lineNumber - 1]!;\n  const indentation = actionLine.match(/^(\\s*)/)?.[1] || '';\n\n  // Insert toHaveURL assertion after the action\n  const waitStatement = `${indentation}${generateToHaveURL(urlPattern)}`;\n  lines.splice(lineNumber, 0, waitStatement);\n\n  return {\n    applied: true,\n    code: lines.join('\\n'),\n    description: `Added toHaveURL assertion for '${urlPattern}'`,\n    confidence: 0.7,\n  };\n}\n\n/**\n * Apply navigation wait fix to code\n */\nexport function applyNavigationFix(context: NavigationFixContext): NavigationFixResult {\n  const { code, lineNumber, expectedUrl, errorMessage } = context;\n\n  // First, try to infer URL pattern\n  const urlPattern = expectedUrl || inferUrlPattern(code, errorMessage);\n\n  if (!urlPattern) {\n    // If we can't determine URL, add waitForLoadState instead\n    return applyLoadStateWait(code, lineNumber);\n  }\n\n  // Check if code already has navigation wait\n  if (hasNavigationWait(code)) {\n    return {\n      applied: false,\n      code,\n      description: 'Navigation wait already exists',\n      confidence: 0,\n    };\n  }\n\n  return insertNavigationWait(code, lineNumber, urlPattern);\n}\n\n/**\n * Apply waitForLoadState as fallback\n */\nfunction applyLoadStateWait(code: string, lineNumber: number): NavigationFixResult {\n  const lines = code.split('\\n');\n\n  if (lineNumber < 1 || lineNumber > lines.length) {\n    return {\n      applied: false,\n      code,\n      description: 'Invalid line number',\n      confidence: 0,\n    };\n  }\n\n  // Get the line where action occurs\n  const actionLine = lines[lineNumber - 1]!;\n  const indentation = actionLine.match(/^(\\s*)/)?.[1] || '';\n\n  // Insert waitForLoadState after the action\n  const waitStatement = `${indentation}await page.waitForLoadState('networkidle')`;\n  lines.splice(lineNumber, 0, waitStatement);\n\n  return {\n    applied: true,\n    code: lines.join('\\n'),\n    description: 'Added waitForLoadState as fallback',\n    confidence: 0.5,\n  };\n}\n\n/**\n * Fix missing await on goto\n */\nexport function fixMissingGotoAwait(code: string): NavigationFixResult {\n  const pattern = /(?<!\\bawait\\s+)(\\bpage\\.goto\\s*\\()/g;\n\n  if (!pattern.test(code)) {\n    return {\n      applied: false,\n      code,\n      description: 'No missing await on goto found',\n      confidence: 0,\n    };\n  }\n\n  const modifiedCode = code.replace(\n    /(?<!\\bawait\\s+)(\\bpage\\.goto\\s*\\()/g,\n    'await $1'\n  );\n\n  return {\n    applied: modifiedCode !== code,\n    code: modifiedCode,\n    description: 'Added missing await to page.goto',\n    confidence: 0.9,\n  };\n}\n\n/**\n * Add navigation wait after click that likely navigates\n */\nexport function addNavigationWaitAfterClick(\n  code: string,\n  clickLineNumber: number,\n  expectedUrl?: string\n): NavigationFixResult {\n  const urlPattern = expectedUrl || '.*';\n\n  return insertNavigationWait(code, clickLineNumber, urlPattern);\n}\n","/**\n * Timing/Async Fix - Handle timeout and async issues\n * @see T064 - Implement timing/async fix\n */\n\n/**\n * Timing fix context\n */\nexport interface TimingFixContext {\n  /** Original code */\n  code: string;\n  /** Line number where timing issue occurs */\n  lineNumber: number;\n  /** Current timeout (if known) */\n  currentTimeout?: number;\n  /** Error message from Playwright */\n  errorMessage: string;\n}\n\n/**\n * Timing fix result\n */\nexport interface TimingFixResult {\n  /** Whether a fix was applied */\n  applied: boolean;\n  /** The modified code */\n  code: string;\n  /** Description of the fix */\n  description: string;\n  /** Confidence in the fix (0-1) */\n  confidence: number;\n}\n\n/**\n * Patterns for missing await detection\n */\nconst MISSING_AWAIT_PATTERNS = [\n  // Playwright actions without await\n  /(?<!\\bawait\\s+)(page\\.(?:click|fill|type|check|uncheck|selectOption|hover|focus|press|dblclick|dragTo)\\s*\\()/g,\n  // Expectations without await\n  /(?<!\\bawait\\s+)(expect\\s*\\([^)]+\\)\\.(?:toBeVisible|toBeHidden|toHaveText|toContainText|toHaveValue|toHaveURL|toHaveTitle)\\s*\\()/g,\n  // Locator actions without await\n  /(?<!\\bawait\\s+)([a-zA-Z_$][a-zA-Z0-9_$]*\\.(?:click|fill|type|check|hover|press)\\s*\\()/g,\n];\n\n// Web-first assertion patterns used in conversion logic below\n\n/**\n * Extract timeout from error message\n */\nexport function extractTimeoutFromError(errorMessage: string): number | null {\n  const match = errorMessage.match(/timeout\\s+(\\d+)ms/i);\n  return match ? parseInt(match[1]!, 10) : null;\n}\n\n/**\n * Calculate suggested timeout increase\n */\nexport function suggestTimeoutIncrease(\n  currentTimeout: number,\n  maxTimeout: number = 30000\n): number {\n  // Increase by 50%, but cap at maxTimeout\n  const suggested = Math.min(Math.round(currentTimeout * 1.5), maxTimeout);\n  return suggested;\n}\n\n/**\n * Fix missing await statements\n */\nexport function fixMissingAwait(code: string): TimingFixResult {\n  let modifiedCode = code;\n  let fixCount = 0;\n\n  for (const pattern of MISSING_AWAIT_PATTERNS) {\n    // Reset lastIndex for global patterns\n    pattern.lastIndex = 0;\n\n    modifiedCode = modifiedCode.replace(pattern, (_match, p1) => {\n      fixCount++;\n      return `await ${p1}`;\n    });\n  }\n\n  return {\n    applied: fixCount > 0,\n    code: modifiedCode,\n    description: fixCount > 0 ? `Added ${fixCount} missing await statement(s)` : 'No missing await found',\n    confidence: fixCount > 0 ? 0.9 : 0,\n  };\n}\n\n/**\n * Convert to web-first assertion\n */\nexport function convertToWebFirstAssertion(code: string): TimingFixResult {\n  let modifiedCode = code;\n  let applied = false;\n\n  // Convert textContent extraction to toHaveText\n  modifiedCode = modifiedCode.replace(\n    /const\\s+(\\w+)\\s*=\\s*await\\s+(\\w+)\\.textContent\\s*\\(\\s*\\)\\s*;?\\s*\\n(\\s*)expect\\s*\\(\\s*\\1\\s*\\)\\.toBe\\s*\\(\\s*(['\"][^'\"]+['\"])\\s*\\)/g,\n    (_, _varName, locator, indent, expected) => {\n      applied = true;\n      return `${indent}await expect(${locator}).toHaveText(${expected})`;\n    }\n  );\n\n  // Convert innerText extraction to toHaveText\n  modifiedCode = modifiedCode.replace(\n    /const\\s+(\\w+)\\s*=\\s*await\\s+(\\w+)\\.innerText\\s*\\(\\s*\\)\\s*;?\\s*\\n(\\s*)expect\\s*\\(\\s*\\1\\s*\\)\\.toBe\\s*\\(\\s*(['\"][^'\"]+['\"])\\s*\\)/g,\n    (_, _varName, locator, indent, expected) => {\n      applied = true;\n      return `${indent}await expect(${locator}).toHaveText(${expected})`;\n    }\n  );\n\n  // Convert isVisible check to toBeVisible\n  modifiedCode = modifiedCode.replace(\n    /const\\s+(\\w+)\\s*=\\s*await\\s+(\\w+)\\.isVisible\\s*\\(\\s*\\)\\s*;?\\s*\\n(\\s*)expect\\s*\\(\\s*\\1\\s*\\)\\.toBe\\s*\\(\\s*true\\s*\\)/g,\n    (_, _varName, locator, indent) => {\n      applied = true;\n      return `${indent}await expect(${locator}).toBeVisible()`;\n    }\n  );\n\n  // Convert isHidden check to toBeHidden\n  modifiedCode = modifiedCode.replace(\n    /const\\s+(\\w+)\\s*=\\s*await\\s+(\\w+)\\.isHidden\\s*\\(\\s*\\)\\s*;?\\s*\\n(\\s*)expect\\s*\\(\\s*\\1\\s*\\)\\.toBe\\s*\\(\\s*true\\s*\\)/g,\n    (_, _varName, locator, indent) => {\n      applied = true;\n      return `${indent}await expect(${locator}).toBeHidden()`;\n    }\n  );\n\n  return {\n    applied,\n    code: modifiedCode,\n    description: applied ? 'Converted to web-first assertion' : 'No conversion needed',\n    confidence: applied ? 0.85 : 0,\n  };\n}\n\n/**\n * Add explicit timeout to action\n */\nexport function addTimeout(\n  code: string,\n  lineNumber: number,\n  timeout: number\n): TimingFixResult {\n  const lines = code.split('\\n');\n\n  if (lineNumber < 1 || lineNumber > lines.length) {\n    return {\n      applied: false,\n      code,\n      description: 'Invalid line number',\n      confidence: 0,\n    };\n  }\n\n  const line = lines[lineNumber - 1]!;\n\n  // Check if line already has timeout\n  if (/\\btimeout\\s*:/i.test(line)) {\n    return {\n      applied: false,\n      code,\n      description: 'Timeout already specified',\n      confidence: 0,\n    };\n  }\n\n  // Add timeout to action patterns\n  let modifiedLine = line;\n\n  // Pattern: .click(), .fill(), etc. with empty options\n  modifiedLine = modifiedLine.replace(\n    /\\.(click|fill|press|type|hover|focus|check|uncheck)\\s*\\(\\s*\\)/g,\n    `.$1({ timeout: ${timeout} })`\n  );\n\n  // Pattern: .click('text'), .fill('selector', 'value')\n  modifiedLine = modifiedLine.replace(\n    /\\.(click|fill|press|type|hover|focus|check|uncheck)\\s*\\(\\s*(['\"][^'\"]*['\"])\\s*\\)/g,\n    `.$1($2, { timeout: ${timeout} })`\n  );\n\n  // Pattern: .click({ options })\n  modifiedLine = modifiedLine.replace(\n    /\\.(click|fill|press|type|hover|focus|check|uncheck)\\s*\\(\\s*\\{([^}]*)\\}\\s*\\)/g,\n    (_, action, options) => {\n      if (options.includes('timeout')) {\n        return _; // Already has timeout\n      }\n      return `.${action}({ ${options.trim()}, timeout: ${timeout} })`;\n    }\n  );\n\n  // Pattern: expect().toBeVisible() etc.\n  modifiedLine = modifiedLine.replace(\n    /\\.(toBeVisible|toBeHidden|toHaveText|toContainText|toHaveValue)\\s*\\(\\s*\\)/g,\n    `.$1({ timeout: ${timeout} })`\n  );\n\n  const applied = modifiedLine !== line;\n  lines[lineNumber - 1] = modifiedLine;\n\n  return {\n    applied,\n    code: lines.join('\\n'),\n    description: applied ? `Added timeout: ${timeout}ms` : 'Unable to add timeout',\n    confidence: applied ? 0.6 : 0,\n  };\n}\n\n/**\n * Apply timing fix to code\n */\nexport function applyTimingFix(context: TimingFixContext): TimingFixResult {\n  const { code, lineNumber, currentTimeout, errorMessage } = context;\n\n  // First, try to fix missing await (most common cause)\n  const awaitFix = fixMissingAwait(code);\n  if (awaitFix.applied) {\n    return awaitFix;\n  }\n\n  // Try converting to web-first assertion\n  const webFirstFix = convertToWebFirstAssertion(code);\n  if (webFirstFix.applied) {\n    return webFirstFix;\n  }\n\n  // As last resort, increase timeout\n  const timeout = currentTimeout || extractTimeoutFromError(errorMessage) || 5000;\n  const newTimeout = suggestTimeoutIncrease(timeout);\n\n  return addTimeout(code, lineNumber, newTimeout);\n}\n\n/**\n * Wrap with expect.toPass for complex conditions\n */\nexport function wrapWithExpectToPass(\n  code: string,\n  lineStart: number,\n  lineEnd: number,\n  options?: { timeout?: number; intervals?: number[] }\n): TimingFixResult {\n  const lines = code.split('\\n');\n\n  if (lineStart < 1 || lineEnd > lines.length || lineStart > lineEnd) {\n    return {\n      applied: false,\n      code,\n      description: 'Invalid line range',\n      confidence: 0,\n    };\n  }\n\n  // Extract the code block to wrap\n  const blockLines = lines.slice(lineStart - 1, lineEnd);\n  const indentation = blockLines[0]!.match(/^(\\s*)/)?.[1] || '';\n\n  // Build options string\n  const optParts: string[] = [];\n  if (options?.timeout) {\n    optParts.push(`timeout: ${options.timeout}`);\n  }\n  if (options?.intervals) {\n    optParts.push(`intervals: [${options.intervals.join(', ')}]`);\n  }\n  const optString = optParts.length > 0 ? `, { ${optParts.join(', ')} }` : '';\n\n  // Wrap with expect.toPass\n  const wrapped = [\n    `${indentation}await expect(async () => {`,\n    ...blockLines.map((line) => `  ${line}`),\n    `${indentation}}).toPass(${optString.slice(2)})`,\n  ];\n\n  lines.splice(lineStart - 1, lineEnd - lineStart + 1, ...wrapped);\n\n  return {\n    applied: true,\n    code: lines.join('\\n'),\n    description: 'Wrapped with expect.toPass for retry behavior',\n    confidence: 0.7,\n  };\n}\n\n/**\n * Wrap with expect.poll for dynamic values\n */\nexport function wrapWithExpectPoll(\n  _code: string,\n  _lineNumber: number,\n  getter: string,\n  expected: string,\n  options?: { timeout?: number; intervals?: number[] }\n): string {\n  const optParts: string[] = [];\n  if (options?.timeout) {\n    optParts.push(`timeout: ${options.timeout}`);\n  }\n  if (options?.intervals) {\n    optParts.push(`intervals: [${options.intervals.join(', ')}]`);\n  }\n  const optString = optParts.length > 0 ? `, { ${optParts.join(', ')} }` : '';\n\n  return `await expect.poll(async () => ${getter}${optString}).toBe(${expected})`;\n}\n","/**\n * Bounded Healing Loop Controller - Orchestrate healing attempts\n * @see T067 - Implement bounded healing loop controller\n */\nimport { readFileSync, writeFileSync, existsSync } from 'node:fs';\nimport type { HealFixType, HealingConfig } from './rules.js';\nimport {\n  DEFAULT_HEALING_CONFIG,\n  evaluateHealing,\n  getNextFix,\n  getPostHealingRecommendation,\n} from './rules.js';\nimport { HealingLogger, type HealingAttempt } from './logger.js';\nimport { applySelectorFix, addExactToLocator } from './fixes/selector.js';\nimport { applyNavigationFix } from './fixes/navigation.js';\nimport { applyTimingFix, fixMissingAwait, convertToWebFirstAssertion } from './fixes/timing.js';\nimport type { FailureClassification } from '../verify/classifier.js';\nimport type { VerifySummary } from '../verify/summary.js';\n\n/**\n * Healing loop options\n */\nexport interface HealingLoopOptions {\n  /** Journey ID */\n  journeyId: string;\n  /** Path to test file */\n  testFile: string;\n  /** Output directory for logs */\n  outputDir: string;\n  /** Healing configuration */\n  config?: HealingConfig;\n  /** Function to verify the test */\n  verifyFn: () => Promise<VerifySummary>;\n  /** Optional ARIA info for selector fixes */\n  ariaInfo?: Record<string, unknown>;\n}\n\n/**\n * Healing loop result\n */\nexport interface HealingLoopResult {\n  /** Whether healing succeeded */\n  success: boolean;\n  /** Final status */\n  status: 'healed' | 'failed' | 'exhausted' | 'not_healable';\n  /** Number of attempts made */\n  attempts: number;\n  /** Fix that worked (if any) */\n  appliedFix?: HealFixType;\n  /** Path to heal log */\n  logPath: string;\n  /** Recommendation if not healed */\n  recommendation?: string;\n  /** Modified code (if any changes) */\n  modifiedCode?: string;\n}\n\n/**\n * Apply a specific fix to code\n */\nfunction applyFix(\n  code: string,\n  fixType: HealFixType,\n  context: {\n    lineNumber: number;\n    errorMessage: string;\n    classification: FailureClassification;\n    ariaInfo?: Record<string, unknown>;\n  }\n): { applied: boolean; code: string; description: string } {\n  const { lineNumber, errorMessage, ariaInfo } = context;\n\n  switch (fixType) {\n    case 'selector-refine':\n      return applySelectorFix({\n        code,\n        lineNumber,\n        selector: '', // Will be extracted from code\n        errorMessage,\n        ariaInfo: ariaInfo as never,\n      });\n\n    case 'add-exact':\n      return addExactToLocator(code);\n\n    case 'missing-await':\n      return fixMissingAwait(code);\n\n    case 'navigation-wait':\n      return applyNavigationFix({\n        code,\n        lineNumber,\n        errorMessage,\n      });\n\n    case 'web-first-assertion':\n      return convertToWebFirstAssertion(code);\n\n    case 'timeout-increase':\n      return applyTimingFix({\n        code,\n        lineNumber,\n        errorMessage,\n      });\n\n    default:\n      return {\n        applied: false,\n        code,\n        description: `Unknown fix type: ${fixType}`,\n      };\n  }\n}\n\n/**\n * Extract line number from verification summary\n */\nfunction extractLineNumber(summary: VerifySummary): number {\n  // Try to extract from first failure test name or error message\n  const firstTest = summary.failures.tests[0];\n  if (firstTest) {\n    // Try to extract line number from error message patterns like:\n    // \"at /path/to/file.ts:42:10\"\n    // \"Error: ... at line 42\"\n    const lineMatch = firstTest.match(/:(\\d+)(?::\\d+)?(?:\\)|$)/);\n    if (lineMatch) {\n      return parseInt(lineMatch[1]!, 10);\n    }\n\n    // Try \"at line N\" pattern\n    const atLineMatch = firstTest.match(/at line (\\d+)/i);\n    if (atLineMatch) {\n      return parseInt(atLineMatch[1]!, 10);\n    }\n  }\n\n  // Check classifications for error messages\n  for (const [, classification] of Object.entries(summary.failures.classifications)) {\n    if (classification && typeof classification === 'object' && 'explanation' in classification) {\n      const explanation = (classification as { explanation: string }).explanation;\n      const lineMatch = explanation.match(/:(\\d+)(?::\\d+)?/);\n      if (lineMatch) {\n        return parseInt(lineMatch[1]!, 10);\n      }\n    }\n  }\n\n  // Default to line 1 if we can't determine\n  return 1;\n}\n\n/**\n * Extract failure classification from verification summary\n */\nfunction extractClassification(summary: VerifySummary): FailureClassification | null {\n  const classifications = summary.failures.classifications;\n  const firstKey = Object.keys(classifications)[0];\n\n  if (firstKey && classifications[firstKey]) {\n    return classifications[firstKey] as FailureClassification;\n  }\n\n  return null;\n}\n\n/**\n * Run the bounded healing loop\n */\nexport async function runHealingLoop(options: HealingLoopOptions): Promise<HealingLoopResult> {\n  const {\n    journeyId,\n    testFile,\n    outputDir,\n    config = DEFAULT_HEALING_CONFIG,\n    verifyFn,\n    ariaInfo,\n  } = options;\n\n  // Initialize logger\n  const logger = new HealingLogger(journeyId, outputDir, config.maxAttempts);\n  const attemptedFixes: HealFixType[] = [];\n\n  // Read original code\n  if (!existsSync(testFile)) {\n    logger.markFailed('Test file not found');\n    return {\n      success: false,\n      status: 'failed',\n      attempts: 0,\n      logPath: logger.getOutputPath(),\n      recommendation: 'Test file not found',\n    };\n  }\n\n  let currentCode = readFileSync(testFile, 'utf-8');\n  let lastSummary: VerifySummary | null = null;\n\n  // Initial verification to get failure info\n  try {\n    lastSummary = await verifyFn();\n    if (lastSummary.status === 'passed') {\n      logger.markHealed();\n      return {\n        success: true,\n        status: 'healed',\n        attempts: 0,\n        logPath: logger.getOutputPath(),\n      };\n    }\n  } catch (error) {\n    logger.markFailed(`Initial verification failed: ${error}`);\n    return {\n      success: false,\n      status: 'failed',\n      attempts: 0,\n      logPath: logger.getOutputPath(),\n      recommendation: 'Initial verification failed',\n    };\n  }\n\n  // Get classification from initial failure\n  const classification = extractClassification(lastSummary);\n  if (!classification) {\n    logger.markFailed('Unable to classify failure');\n    return {\n      success: false,\n      status: 'failed',\n      attempts: 0,\n      logPath: logger.getOutputPath(),\n      recommendation: 'Unable to classify failure for healing',\n    };\n  }\n\n  // Check if healable\n  const evaluation = evaluateHealing(classification, config);\n  if (!evaluation.canHeal) {\n    logger.markFailed(evaluation.reason);\n    return {\n      success: false,\n      status: 'not_healable',\n      attempts: 0,\n      logPath: logger.getOutputPath(),\n      recommendation: evaluation.reason,\n    };\n  }\n\n  // Healing loop\n  while (!logger.isMaxAttemptsReached()) {\n    const attemptNumber = logger.getAttemptCount() + 1;\n    const startTime = Date.now();\n\n    // Get next fix to try\n    const nextFix = getNextFix(classification, attemptedFixes, config);\n    if (!nextFix) {\n      logger.markExhausted(getPostHealingRecommendation(classification, attemptNumber));\n      return {\n        success: false,\n        status: 'exhausted',\n        attempts: attemptNumber - 1,\n        logPath: logger.getOutputPath(),\n        recommendation: getPostHealingRecommendation(classification, attemptNumber),\n      };\n    }\n\n    attemptedFixes.push(nextFix);\n\n    // Apply the fix\n    const fixResult = applyFix(currentCode, nextFix, {\n      lineNumber: extractLineNumber(lastSummary),\n      errorMessage: lastSummary.failures.tests[0] || '',\n      classification,\n      ariaInfo,\n    });\n\n    if (!fixResult.applied) {\n      // Log skipped attempt\n      logger.logAttempt({\n        attempt: attemptNumber,\n        failureType: classification.category,\n        fixType: nextFix,\n        file: testFile,\n        change: fixResult.description,\n        evidence: [],\n        result: 'fail',\n        errorMessage: 'Fix not applied',\n        duration: Date.now() - startTime,\n      });\n      continue;\n    }\n\n    // Write fixed code\n    writeFileSync(testFile, fixResult.code, 'utf-8');\n    currentCode = fixResult.code;\n\n    // Verify the fix\n    try {\n      lastSummary = await verifyFn();\n\n      const attempt: Omit<HealingAttempt, 'timestamp'> = {\n        attempt: attemptNumber,\n        failureType: classification.category,\n        fixType: nextFix,\n        file: testFile,\n        change: fixResult.description,\n        evidence: lastSummary.reportPath ? [lastSummary.reportPath] : [],\n        result: lastSummary.status === 'passed' ? 'pass' : 'fail',\n        duration: Date.now() - startTime,\n      };\n\n      if (lastSummary.status !== 'passed') {\n        attempt.errorMessage = lastSummary.failures.tests[0] || 'Unknown error';\n\n        // Re-classify after failed attempt - failure category may have changed\n        const newClassification = extractClassification(lastSummary);\n        if (newClassification && newClassification.category !== classification.category) {\n          // Update classification for next iteration\n          Object.assign(classification, newClassification);\n        }\n      }\n\n      logger.logAttempt(attempt);\n\n      if (lastSummary.status === 'passed') {\n        logger.markHealed();\n        return {\n          success: true,\n          status: 'healed',\n          attempts: attemptNumber,\n          appliedFix: nextFix,\n          logPath: logger.getOutputPath(),\n          modifiedCode: currentCode,\n        };\n      }\n    } catch (error) {\n      logger.logAttempt({\n        attempt: attemptNumber,\n        failureType: classification.category,\n        fixType: nextFix,\n        file: testFile,\n        change: fixResult.description,\n        evidence: [],\n        result: 'error',\n        errorMessage: String(error),\n        duration: Date.now() - startTime,\n      });\n    }\n  }\n\n  // Max attempts reached\n  logger.markExhausted(getPostHealingRecommendation(classification, config.maxAttempts));\n  return {\n    success: false,\n    status: 'exhausted',\n    attempts: config.maxAttempts,\n    logPath: logger.getOutputPath(),\n    recommendation: getPostHealingRecommendation(classification, config.maxAttempts),\n  };\n}\n\n/**\n * Dry run healing to preview fixes without applying\n */\nexport function previewHealingFixes(\n  code: string,\n  classification: FailureClassification,\n  config: HealingConfig = DEFAULT_HEALING_CONFIG\n): Array<{ fixType: HealFixType; preview: string; confidence: number }> {\n  const previews: Array<{ fixType: HealFixType; preview: string; confidence: number }> = [];\n  const evaluation = evaluateHealing(classification, config);\n\n  if (!evaluation.canHeal) {\n    return previews;\n  }\n\n  for (const fixType of evaluation.applicableFixes) {\n    const result = applyFix(code, fixType, {\n      lineNumber: 1,\n      errorMessage: '',\n      classification,\n    });\n\n    if (result.applied) {\n      previews.push({\n        fixType,\n        preview: result.description,\n        confidence: 0.5, // Could be enhanced with actual confidence scores\n      });\n    }\n  }\n\n  return previews;\n}\n\n/**\n * Check if a specific fix type would apply to code\n */\nexport function wouldFixApply(\n  code: string,\n  fixType: HealFixType,\n  classification: FailureClassification\n): boolean {\n  const result = applyFix(code, fixType, {\n    lineNumber: 1,\n    errorMessage: '',\n    classification,\n  });\n  return result.applied;\n}\n","/**\n * Data Isolation Fix - Namespace test data with runId\n * @see T065 - Implement data isolation fix (runId namespace)\n */\nimport { randomBytes } from 'node:crypto';\n\n/**\n * Data fix context\n */\nexport interface DataFixContext {\n  /** Original code */\n  code: string;\n  /** Test file path */\n  testFile: string;\n  /** Journey ID */\n  journeyId: string;\n}\n\n/**\n * Data fix result\n */\nexport interface DataFixResult {\n  /** Whether a fix was applied */\n  applied: boolean;\n  /** The modified code */\n  code: string;\n  /** Description of the fix */\n  description: string;\n  /** Confidence in the fix (0-1) */\n  confidence: number;\n}\n\n/**\n * Generate unique run ID\n */\nexport function generateRunId(): string {\n  const timestamp = Date.now().toString(36);\n  const random = randomBytes(4).toString('hex');\n  return `${timestamp}-${random}`;\n}\n\n// Note: Patterns defined for reference, may be used in future enhancements\n\n/**\n * Check if code has data isolation\n */\nexport function hasDataIsolation(code: string): boolean {\n  // Check for runId pattern\n  if (/\\brunId\\b/i.test(code)) {\n    return true;\n  }\n\n  // Check for testInfo.testId usage\n  if (/testInfo\\.testId/i.test(code)) {\n    return true;\n  }\n\n  // Check for dynamic data generation\n  if (/Date\\.now\\(\\)|Math\\.random\\(\\)|crypto|uuid/i.test(code)) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Add runId variable to test\n */\nexport function addRunIdVariable(code: string): DataFixResult {\n  // Check if runId already exists\n  if (/\\bconst\\s+runId\\b/.test(code)) {\n    return {\n      applied: false,\n      code,\n      description: 'runId already defined',\n      confidence: 0,\n    };\n  }\n\n  // Find the test function start\n  const testMatch = code.match(/test\\s*\\(\\s*['\"`][^'\"`]+['\"`]\\s*,\\s*async\\s*\\(\\s*\\{[^}]*\\}\\s*\\)\\s*=>\\s*\\{/);\n  if (!testMatch) {\n    return {\n      applied: false,\n      code,\n      description: 'Unable to find test function',\n      confidence: 0,\n    };\n  }\n\n  // Insert runId after the test function opening brace\n  const insertIndex = testMatch.index! + testMatch[0].length;\n  const indentation = '    ';\n  const runIdDeclaration = `\\n${indentation}const runId = \\`\\${Date.now()}-\\${Math.random().toString(36).slice(2, 8)}\\`;`;\n\n  const modifiedCode = code.slice(0, insertIndex) + runIdDeclaration + code.slice(insertIndex);\n\n  return {\n    applied: true,\n    code: modifiedCode,\n    description: 'Added runId variable for data isolation',\n    confidence: 0.8,\n  };\n}\n\n/**\n * Namespace email with runId\n */\nexport function namespaceEmail(email: string, runId: string): string {\n  const [local, domain] = email.split('@');\n  if (!domain) return `${email}-${runId}`;\n  return `${local}+${runId}@${domain}`;\n}\n\n/**\n * Namespace name with runId\n */\nexport function namespaceName(name: string, runId: string): string {\n  return `${name} ${runId}`;\n}\n\n/**\n * Replace hardcoded email with namespaced version\n */\nexport function replaceHardcodedEmail(code: string): DataFixResult {\n  const emailPattern = /(['\"`])([\\w.+-]+@[\\w.-]+\\.[\\w]{2,})(['\"`])/g;\n\n  let applied = false;\n  const modifiedCode = code.replace(emailPattern, (match, _q1, email, _q2) => {\n    // Don't replace if already using template literals with runId\n    if (code.includes('`') && code.includes('${runId}')) {\n      return match;\n    }\n\n    // Check if this is in a fill() or similar\n    const before = code.slice(Math.max(0, code.indexOf(match) - 50), code.indexOf(match));\n    if (/\\.fill\\s*\\([^,]*$/.test(before)) {\n      applied = true;\n      const [local, domain] = email.split('@');\n      return `\\`${local}+\\${runId}@${domain}\\``;\n    }\n\n    return match;\n  });\n\n  return {\n    applied,\n    code: modifiedCode,\n    description: applied ? 'Namespaced email with runId' : 'No hardcoded email to namespace',\n    confidence: applied ? 0.7 : 0,\n  };\n}\n\n/**\n * Replace hardcoded test data with namespaced version\n */\nexport function replaceHardcodedTestData(code: string): DataFixResult {\n  let modifiedCode = code;\n  let applied = false;\n\n  // Replace test names\n  modifiedCode = modifiedCode.replace(\n    /(['\"`])(Test\\s*(?:User|Name|Account|Client|Customer))\\s*(['\"`])/gi,\n    (_match, _q1, name, _q2) => {\n      applied = true;\n      return `\\`${name} \\${runId}\\``;\n    }\n  );\n\n  // Replace test- prefixed strings in fill operations\n  modifiedCode = modifiedCode.replace(\n    /\\.fill\\s*\\([^,]+,\\s*['\"`](test[-_]?\\w+)['\"`]\\s*\\)/gi,\n    (match, value) => {\n      applied = true;\n      return match.replace(`'${value}'`, `\\`${value}-\\${runId}\\``).replace(`\"${value}\"`, `\\`${value}-\\${runId}\\``);\n    }\n  );\n\n  return {\n    applied,\n    code: modifiedCode,\n    description: applied ? 'Namespaced test data with runId' : 'No hardcoded test data found',\n    confidence: applied ? 0.6 : 0,\n  };\n}\n\n/**\n * Apply data isolation fix\n */\nexport function applyDataFix(context: DataFixContext): DataFixResult {\n  const { code } = context;\n\n  // Check if already has isolation\n  if (hasDataIsolation(code)) {\n    return {\n      applied: false,\n      code,\n      description: 'Data isolation already present',\n      confidence: 0,\n    };\n  }\n\n  // First, add runId variable\n  let result = addRunIdVariable(code);\n  if (!result.applied) {\n    return result;\n  }\n\n  let modifiedCode = result.code;\n  let fixCount = 1;\n\n  // Then namespace emails\n  const emailResult = replaceHardcodedEmail(modifiedCode);\n  if (emailResult.applied) {\n    modifiedCode = emailResult.code;\n    fixCount++;\n  }\n\n  // Then namespace test data\n  const dataResult = replaceHardcodedTestData(modifiedCode);\n  if (dataResult.applied) {\n    modifiedCode = dataResult.code;\n    fixCount++;\n  }\n\n  return {\n    applied: true,\n    code: modifiedCode,\n    description: `Applied ${fixCount} data isolation fix(es)`,\n    confidence: 0.7,\n  };\n}\n\n/**\n * Add cleanup hook for test data\n */\nexport function addCleanupHook(code: string, cleanupCode: string): DataFixResult {\n  // Check if afterEach already exists\n  if (/test\\.afterEach\\s*\\(/.test(code)) {\n    return {\n      applied: false,\n      code,\n      description: 'afterEach hook already exists',\n      confidence: 0,\n    };\n  }\n\n  // Find test.describe or test block\n  const describeMatch = code.match(/test\\.describe\\s*\\(\\s*['\"`][^'\"`]+['\"`]\\s*,\\s*\\(\\s*\\)\\s*=>\\s*\\{/);\n\n  if (describeMatch) {\n    // Add after describe opening\n    const insertIndex = describeMatch.index! + describeMatch[0].length;\n    const indentation = '  ';\n    const hookCode = `\\n${indentation}test.afterEach(async () => {\\n${indentation}  ${cleanupCode}\\n${indentation}});\\n`;\n\n    const modifiedCode = code.slice(0, insertIndex) + hookCode + code.slice(insertIndex);\n\n    return {\n      applied: true,\n      code: modifiedCode,\n      description: 'Added afterEach cleanup hook',\n      confidence: 0.7,\n    };\n  }\n\n  return {\n    applied: false,\n    code,\n    description: 'Unable to find suitable location for cleanup hook',\n    confidence: 0,\n  };\n}\n\n/**\n * Extract test data patterns from code\n */\nexport function extractTestDataPatterns(code: string): string[] {\n  const patterns: string[] = [];\n\n  // Find fill operations\n  const fillMatches = code.matchAll(/\\.fill\\s*\\([^,]+,\\s*['\"`]([^'\"`]+)['\"`]\\s*\\)/g);\n  for (const match of fillMatches) {\n    patterns.push(match[1]!);\n  }\n\n  // Find email patterns\n  const emailMatches = code.matchAll(/['\"`]([\\w.+-]+@[\\w.-]+\\.[\\w]{2,})['\"`]/g);\n  for (const match of emailMatches) {\n    patterns.push(match[1]!);\n  }\n\n  return patterns;\n}\n"]}
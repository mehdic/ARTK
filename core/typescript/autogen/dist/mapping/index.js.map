{"version":3,"sources":["../../src/mapping/telemetry.ts","../../src/llkb/patternExtension.ts","../../src/mapping/patterns.ts","../../src/mapping/glossary.ts","../../src/journey/hintPatterns.ts","../../src/journey/parseHints.ts","../../src/mapping/stepMapper.ts","../../src/mapping/patternDistance.ts","../../src/mapping/blockedStepAnalysis.ts","../../src/mapping/index.ts"],"names":["existsSync","readFileSync","join","dirname","mkdirSync","z","parseYaml","coreMapping"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Telemetry for blocked steps - Records blocked steps for pattern analysis\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md Phase 3\n */\nimport { existsSync, readFileSync, appendFileSync, mkdirSync } from 'node:fs';\nimport { join, dirname } from 'node:path';\n\n/**\n * Record for a blocked step\n */\nexport interface BlockedStepRecord {\n  /** ISO timestamp when the step was blocked */\n  timestamp: string;\n  /** Journey ID where this step was found */\n  journeyId: string;\n  /** Original step text that was blocked */\n  stepText: string;\n  /** Normalized text (lowercase, trimmed) */\n  normalizedText: string;\n  /** Category of the step */\n  category: 'navigation' | 'interaction' | 'assertion' | 'wait' | 'unknown';\n  /** Reason the step was blocked */\n  reason: string;\n  /** Suggested fix from the system */\n  suggestedFix?: string;\n  /** User's manual fix (if captured) */\n  userFix?: string;\n  /** Nearest pattern that almost matched */\n  nearestPattern?: string;\n  /** Distance to nearest pattern */\n  nearestDistance?: number;\n}\n\n/**\n * Pattern gap identified from telemetry analysis\n */\nexport interface PatternGap {\n  /** Example text that represents this gap */\n  exampleText: string;\n  /** Normalized form of the text */\n  normalizedText: string;\n  /** Number of times this gap was encountered */\n  count: number;\n  /** Category of the gap */\n  category: string;\n  /** All unique step texts that fall into this gap */\n  variants: string[];\n  /** Suggested regex pattern to add */\n  suggestedPattern?: string;\n  /** First occurrence timestamp */\n  firstSeen: string;\n  /** Last occurrence timestamp */\n  lastSeen: string;\n}\n\n/**\n * Telemetry statistics\n */\nexport interface TelemetryStats {\n  /** Total number of blocked steps recorded */\n  totalRecords: number;\n  /** Unique patterns identified */\n  uniquePatterns: number;\n  /** Records by category */\n  byCategory: Record<string, number>;\n  /** Date range of records */\n  dateRange: {\n    earliest: string;\n    latest: string;\n  };\n}\n\n/**\n * Default telemetry file location\n */\nconst DEFAULT_TELEMETRY_DIR = '.artk';\nconst TELEMETRY_FILE = 'blocked-steps-telemetry.jsonl';\n\n/**\n * Get the telemetry file path\n */\nexport function getTelemetryPath(baseDir?: string): string {\n  const dir = baseDir || process.cwd();\n  return join(dir, DEFAULT_TELEMETRY_DIR, TELEMETRY_FILE);\n}\n\n/**\n * Ensure the telemetry directory exists\n */\nfunction ensureTelemetryDir(telemetryPath: string): void {\n  const dir = dirname(telemetryPath);\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n}\n\n/**\n * Normalize step text for telemetry comparison\n * (Simpler normalization than glossary - for deduplication purposes)\n */\nexport function normalizeStepTextForTelemetry(text: string): string {\n  return text\n    .toLowerCase()\n    .trim()\n    // Remove common articles\n    .replace(/\\b(the|a|an)\\b/g, '')\n    // Remove extra whitespace\n    .replace(/\\s+/g, ' ')\n    // Remove quoted values but keep structure\n    .replace(/\"[^\"]*\"/g, '\"\"')\n    .replace(/'[^']*'/g, \"''\")\n    .trim();\n}\n\n/**\n * Categorize a step based on its text\n */\nexport function categorizeStepText(text: string): BlockedStepRecord['category'] {\n  const lower = text.toLowerCase();\n\n  if (\n    lower.includes('navigate') ||\n    lower.includes('go to') ||\n    lower.includes('open') ||\n    lower.includes('visit')\n  ) {\n    return 'navigation';\n  }\n\n  if (\n    lower.includes('click') ||\n    lower.includes('fill') ||\n    lower.includes('enter') ||\n    lower.includes('type') ||\n    lower.includes('select') ||\n    lower.includes('check') ||\n    lower.includes('press') ||\n    lower.includes('submit') ||\n    lower.includes('input')\n  ) {\n    return 'interaction';\n  }\n\n  if (\n    lower.includes('see') ||\n    lower.includes('visible') ||\n    lower.includes('verify') ||\n    lower.includes('assert') ||\n    lower.includes('confirm') ||\n    lower.includes('should') ||\n    lower.includes('ensure') ||\n    lower.includes('expect') ||\n    lower.includes('display')\n  ) {\n    return 'assertion';\n  }\n\n  if (lower.includes('wait') || lower.includes('load') || lower.includes('until')) {\n    return 'wait';\n  }\n\n  return 'unknown';\n}\n\n/**\n * Record a blocked step to the telemetry file\n */\nexport function recordBlockedStep(\n  record: Omit<BlockedStepRecord, 'timestamp' | 'normalizedText' | 'category'> & {\n    category?: BlockedStepRecord['category'];\n  },\n  options: { baseDir?: string } = {}\n): void {\n  const telemetryPath = getTelemetryPath(options.baseDir);\n  ensureTelemetryDir(telemetryPath);\n\n  const fullRecord: BlockedStepRecord = {\n    ...record,\n    timestamp: new Date().toISOString(),\n    normalizedText: normalizeStepTextForTelemetry(record.stepText),\n    category: record.category || categorizeStepText(record.stepText),\n  };\n\n  appendFileSync(telemetryPath, JSON.stringify(fullRecord) + '\\n');\n}\n\n/**\n * Read all blocked step records from the telemetry file\n */\nexport function readBlockedStepRecords(options: { baseDir?: string } = {}): BlockedStepRecord[] {\n  const telemetryPath = getTelemetryPath(options.baseDir);\n\n  if (!existsSync(telemetryPath)) {\n    return [];\n  }\n\n  try {\n    const content = readFileSync(telemetryPath, 'utf-8');\n    return content\n      .split('\\n')\n      .filter(Boolean)\n      .map((line) => {\n        try {\n          return JSON.parse(line) as BlockedStepRecord;\n        } catch {\n          return null;\n        }\n      })\n      .filter((record): record is BlockedStepRecord => record !== null);\n  } catch {\n    return [];\n  }\n}\n\n/**\n * Calculate similarity between two normalized texts\n * Uses simple token-based Jaccard similarity\n */\nfunction calculateTokenSimilarity(a: string, b: string): number {\n  const tokensA = new Set(a.split(' ').filter(Boolean));\n  const tokensB = new Set(b.split(' ').filter(Boolean));\n\n  if (tokensA.size === 0 && tokensB.size === 0) return 1;\n  if (tokensA.size === 0 || tokensB.size === 0) return 0;\n\n  const intersection = new Set([...tokensA].filter((x) => tokensB.has(x)));\n  const union = new Set([...tokensA, ...tokensB]);\n\n  return intersection.size / union.size;\n}\n\n/**\n * Group blocked step records by similarity\n */\nfunction groupBySimilarity(\n  records: BlockedStepRecord[],\n  threshold: number = 0.7\n): Map<string, BlockedStepRecord[]> {\n  const groups = new Map<string, BlockedStepRecord[]>();\n  const processed = new Set<number>();\n\n  for (let i = 0; i < records.length; i++) {\n    if (processed.has(i)) continue;\n\n    const record = records[i]!;\n    const normalized = record.normalizedText;\n    const group: BlockedStepRecord[] = [record];\n    processed.add(i);\n\n    // Find similar records\n    for (let j = i + 1; j < records.length; j++) {\n      if (processed.has(j)) continue;\n\n      const other = records[j]!;\n      const similarity = calculateTokenSimilarity(normalized, other.normalizedText);\n\n      if (similarity >= threshold) {\n        group.push(other);\n        processed.add(j);\n      }\n    }\n\n    groups.set(normalized, group);\n  }\n\n  return groups;\n}\n\n/**\n * Analyze blocked steps to find top pattern gaps\n */\nexport function analyzeBlockedPatterns(options: { baseDir?: string; limit?: number } = {}): PatternGap[] {\n  const records = readBlockedStepRecords(options);\n\n  if (records.length === 0) {\n    return [];\n  }\n\n  const groups = groupBySimilarity(records);\n  const gaps: PatternGap[] = [];\n\n  for (const [normalizedText, groupRecords] of groups) {\n    const timestamps = groupRecords.map((r) => r.timestamp).sort();\n    const variants = [...new Set(groupRecords.map((r) => r.stepText))];\n\n    gaps.push({\n      exampleText: groupRecords[0]!.stepText,\n      normalizedText,\n      count: groupRecords.length,\n      category: groupRecords[0]!.category,\n      variants,\n      suggestedPattern: generateSuggestedPattern(variants),\n      firstSeen: timestamps[0]!,\n      lastSeen: timestamps[timestamps.length - 1]!,\n    });\n  }\n\n  // Sort by count (most frequent first)\n  gaps.sort((a, b) => b.count - a.count);\n\n  return options.limit ? gaps.slice(0, options.limit) : gaps;\n}\n\n/**\n * Generate a suggested regex pattern from examples\n */\nfunction generateSuggestedPattern(variants: string[]): string | undefined {\n  if (variants.length === 0) return undefined;\n\n  // Find common prefix and suffix\n  const example = variants[0]!.toLowerCase();\n\n  // Extract quoted values and replace with placeholders\n  const pattern = example\n    .replace(/\"[^\"]+\"/g, '\"([^\"]+)\"')\n    .replace(/'[^']+'/g, \"'([^']+)'\")\n    // Escape special regex chars (except those we use)\n    .replace(/[.*+?^${}()|[\\]\\\\]/g, (char) => {\n      if (char === '(' || char === ')' || char === '[' || char === ']' || char === '+') {\n        return char;\n      }\n      return '\\\\' + char;\n    });\n\n  return `^(?:user\\\\s+)?${pattern}$`;\n}\n\n/**\n * Get telemetry statistics\n */\nexport function getTelemetryStats(options: { baseDir?: string } = {}): TelemetryStats {\n  const records = readBlockedStepRecords(options);\n\n  if (records.length === 0) {\n    return {\n      totalRecords: 0,\n      uniquePatterns: 0,\n      byCategory: {},\n      dateRange: {\n        earliest: '',\n        latest: '',\n      },\n    };\n  }\n\n  const byCategory: Record<string, number> = {};\n  const normalizedSet = new Set<string>();\n  const timestamps = records.map((r) => r.timestamp).sort();\n\n  for (const record of records) {\n    byCategory[record.category] = (byCategory[record.category] || 0) + 1;\n    normalizedSet.add(record.normalizedText);\n  }\n\n  return {\n    totalRecords: records.length,\n    uniquePatterns: normalizedSet.size,\n    byCategory,\n    dateRange: {\n      earliest: timestamps[0]!,\n      latest: timestamps[timestamps.length - 1]!,\n    },\n  };\n}\n\n/**\n * Record a user fix for a previously blocked step\n */\nexport function recordUserFix(\n  originalStepText: string,\n  userFixedText: string,\n  options: { baseDir?: string } = {}\n): void {\n  const records = readBlockedStepRecords(options);\n  const normalizedOriginal = normalizeStepTextForTelemetry(originalStepText);\n\n  // Find matching record and update it (append new record with fix)\n  const matchingRecord = records.find((r) => r.normalizedText === normalizedOriginal && !r.userFix);\n\n  if (matchingRecord) {\n    // Record the user fix - timestamp and normalizedText will be set by recordBlockedStep\n    const { timestamp: _t, normalizedText: _n, ...recordWithoutTimestamp } = matchingRecord;\n    recordBlockedStep(\n      {\n        ...recordWithoutTimestamp,\n        userFix: userFixedText,\n      },\n      options\n    );\n  }\n}\n\n/**\n * Clear telemetry data (for testing or reset)\n */\nexport function clearTelemetry(options: { baseDir?: string } = {}): void {\n  const telemetryPath = getTelemetryPath(options.baseDir);\n  if (existsSync(telemetryPath)) {\n    const { unlinkSync } = require('node:fs');\n    unlinkSync(telemetryPath);\n  }\n}\n","/**\n * LLKB Pattern Extension - Learning and promotion of patterns from LLKB\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md Phase 4\n */\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { join, dirname } from 'node:path';\nimport type { IRPrimitive } from '../ir/types.js';\nimport { normalizeStepTextForTelemetry as normalizeStepText } from '../mapping/telemetry.js';\n\n/**\n * A pattern learned from successful step mappings\n */\nexport interface LearnedPattern {\n  /** Unique identifier */\n  id: string;\n  /** Original step text that was learned from */\n  originalText: string;\n  /** Normalized form for matching */\n  normalizedText: string;\n  /** The IR primitive this text maps to */\n  mappedPrimitive: IRPrimitive;\n  /** Confidence score (0-1) */\n  confidence: number;\n  /** Journey IDs where this pattern was used */\n  sourceJourneys: string[];\n  /** Number of successful uses */\n  successCount: number;\n  /** Number of failed uses */\n  failCount: number;\n  /** Timestamp of last use */\n  lastUsed: string;\n  /** Timestamp when created */\n  createdAt: string;\n  /** Whether this pattern has been promoted to core */\n  promotedToCore: boolean;\n  /** Promotion timestamp if promoted */\n  promotedAt?: string;\n}\n\n/**\n * Pattern ready for promotion to core\n */\nexport interface PromotedPattern {\n  /** The learned pattern being promoted */\n  pattern: LearnedPattern;\n  /** Generated regex string for the pattern */\n  generatedRegex: string;\n  /** Priority score for ordering */\n  priority: number;\n}\n\n/**\n * LLKB pattern match result\n */\nexport interface LlkbPatternMatch {\n  /** Pattern ID that matched */\n  patternId: string;\n  /** The IR primitive */\n  primitive: IRPrimitive;\n  /** Confidence of the match */\n  confidence: number;\n}\n\n/**\n * Options for pruning patterns\n */\nexport interface PruneOptions {\n  /** Minimum confidence to keep */\n  minConfidence?: number;\n  /** Minimum success count to keep */\n  minSuccess?: number;\n  /** Maximum age in days to keep */\n  maxAgeDays?: number;\n}\n\n/**\n * Storage file for learned patterns\n */\nconst PATTERNS_FILE = 'learned-patterns.json';\nconst DEFAULT_LLKB_ROOT = '.artk/llkb';\n\n/**\n * Get the path to the patterns file\n */\nexport function getPatternsFilePath(llkbRoot?: string): string {\n  const root = llkbRoot || join(process.cwd(), DEFAULT_LLKB_ROOT);\n  return join(root, PATTERNS_FILE);\n}\n\n/**\n * Generate a unique pattern ID\n */\nexport function generatePatternId(): string {\n  return `LP${Date.now().toString(36)}${Math.random().toString(36).slice(2, 6)}`.toUpperCase();\n}\n\n/**\n * Load learned patterns from storage\n */\nexport function loadLearnedPatterns(options: { llkbRoot?: string } = {}): LearnedPattern[] {\n  const filePath = getPatternsFilePath(options.llkbRoot);\n\n  if (!existsSync(filePath)) {\n    return [];\n  }\n\n  try {\n    const content = readFileSync(filePath, 'utf-8');\n    const data = JSON.parse(content);\n    return Array.isArray(data.patterns) ? data.patterns : [];\n  } catch {\n    return [];\n  }\n}\n\n/**\n * Save learned patterns to storage\n */\nexport function saveLearnedPatterns(\n  patterns: LearnedPattern[],\n  options: { llkbRoot?: string } = {}\n): void {\n  const filePath = getPatternsFilePath(options.llkbRoot);\n  const dir = dirname(filePath);\n\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n\n  const data = {\n    version: '1.0.0',\n    lastUpdated: new Date().toISOString(),\n    patterns,\n  };\n\n  writeFileSync(filePath, JSON.stringify(data, null, 2), 'utf-8');\n}\n\n/**\n * Calculate confidence from success/fail counts\n * Uses Wilson score interval for small sample sizes\n */\nexport function calculateConfidence(successCount: number, failCount: number): number {\n  const total = successCount + failCount;\n  if (total === 0) return 0.5;\n\n  const p = successCount / total;\n  const z = 1.96; // 95% confidence\n  const n = total;\n\n  // Wilson score lower bound\n  const denominator = 1 + (z * z) / n;\n  const center = p + (z * z) / (2 * n);\n  const spread = z * Math.sqrt((p * (1 - p) + (z * z) / (4 * n)) / n);\n\n  return Math.max(0, Math.min(1, (center - spread) / denominator));\n}\n\n/**\n * Record a successful pattern transformation\n */\nexport function recordPatternSuccess(\n  originalText: string,\n  primitive: IRPrimitive,\n  journeyId: string,\n  options: { llkbRoot?: string } = {}\n): LearnedPattern {\n  const patterns = loadLearnedPatterns(options);\n  const normalizedText = normalizeStepText(originalText);\n\n  // Find existing pattern\n  let pattern = patterns.find((p) => p.normalizedText === normalizedText);\n\n  if (pattern) {\n    // Update existing\n    pattern.successCount++;\n    pattern.confidence = calculateConfidence(pattern.successCount, pattern.failCount);\n    pattern.lastUsed = new Date().toISOString();\n    if (!pattern.sourceJourneys.includes(journeyId)) {\n      pattern.sourceJourneys.push(journeyId);\n    }\n  } else {\n    // Create new\n    pattern = {\n      id: generatePatternId(),\n      originalText,\n      normalizedText,\n      mappedPrimitive: primitive,\n      confidence: 0.5, // Initial confidence\n      sourceJourneys: [journeyId],\n      successCount: 1,\n      failCount: 0,\n      lastUsed: new Date().toISOString(),\n      createdAt: new Date().toISOString(),\n      promotedToCore: false,\n    };\n    patterns.push(pattern);\n  }\n\n  saveLearnedPatterns(patterns, options);\n  return pattern;\n}\n\n/**\n * Record a failed pattern use\n */\nexport function recordPatternFailure(\n  originalText: string,\n  journeyId: string,\n  options: { llkbRoot?: string } = {}\n): LearnedPattern | null {\n  const patterns = loadLearnedPatterns(options);\n  const normalizedText = normalizeStepText(originalText);\n\n  const pattern = patterns.find((p) => p.normalizedText === normalizedText);\n\n  if (pattern) {\n    pattern.failCount++;\n    pattern.confidence = calculateConfidence(pattern.successCount, pattern.failCount);\n    pattern.lastUsed = new Date().toISOString();\n    saveLearnedPatterns(patterns, options);\n    return pattern;\n  }\n\n  return null;\n}\n\n/**\n * Match text against learned LLKB patterns\n */\nexport function matchLlkbPattern(\n  text: string,\n  options: { llkbRoot?: string; minConfidence?: number } = {}\n): LlkbPatternMatch | null {\n  const patterns = loadLearnedPatterns(options);\n  const normalizedText = normalizeStepText(text);\n  const minConfidence = options.minConfidence ?? 0.7;\n\n  // Find exact normalized match with sufficient confidence\n  const match = patterns.find(\n    (p) => p.normalizedText === normalizedText && p.confidence >= minConfidence && !p.promotedToCore\n  );\n\n  if (match) {\n    return {\n      patternId: match.id,\n      primitive: match.mappedPrimitive,\n      confidence: match.confidence,\n    };\n  }\n\n  return null;\n}\n\n/**\n * Generate a regex pattern from a learned text pattern\n * This is a heuristic approach - complex patterns may need manual refinement\n */\nexport function generateRegexFromText(text: string): string {\n  let pattern = text\n    .toLowerCase()\n    // Escape special regex chars\n    .replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n    // Replace quoted values with capture groups\n    .replace(/\"[^\"]+\"/g, '\"([^\"]+)\"')\n    .replace(/'[^']+'/g, \"'([^']+)'\")\n    // Make articles optional\n    .replace(/\\b(the|a|an)\\b/g, '(?:$1\\\\s+)?')\n    // Make \"user\" prefix optional\n    .replace(/^user\\s+/, '(?:user\\\\s+)?')\n    // Handle common verbs\n    .replace(/\\bclicks?\\b/g, 'clicks?')\n    .replace(/\\bfills?\\b/g, 'fills?')\n    .replace(/\\bselects?\\b/g, 'selects?')\n    .replace(/\\btypes?\\b/g, 'types?')\n    .replace(/\\bsees?\\b/g, 'sees?')\n    .replace(/\\bwaits?\\b/g, 'waits?');\n\n  return `^${pattern}$`;\n}\n\n/**\n * Get patterns ready for promotion to core\n */\nexport function getPromotablePatterns(options: { llkbRoot?: string } = {}): PromotedPattern[] {\n  const patterns = loadLearnedPatterns(options);\n\n  const promotable = patterns.filter(\n    (p) =>\n      p.confidence >= 0.9 &&\n      p.successCount >= 5 &&\n      p.sourceJourneys.length >= 2 &&\n      !p.promotedToCore\n  );\n\n  return promotable.map((pattern) => ({\n    pattern,\n    generatedRegex: generateRegexFromText(pattern.originalText),\n    priority: pattern.successCount * pattern.confidence,\n  }));\n}\n\n/**\n * Mark patterns as promoted\n */\nexport function markPatternsPromoted(\n  patternIds: string[],\n  options: { llkbRoot?: string } = {}\n): void {\n  const patterns = loadLearnedPatterns(options);\n  const now = new Date().toISOString();\n\n  for (const pattern of patterns) {\n    if (patternIds.includes(pattern.id)) {\n      pattern.promotedToCore = true;\n      pattern.promotedAt = now;\n    }\n  }\n\n  saveLearnedPatterns(patterns, options);\n}\n\n/**\n * Prune low-quality patterns\n */\nexport function prunePatterns(options: PruneOptions & { llkbRoot?: string } = {}): {\n  removed: number;\n  remaining: number;\n} {\n  const patterns = loadLearnedPatterns(options);\n  const now = Date.now();\n  const maxAge = (options.maxAgeDays ?? 90) * 24 * 60 * 60 * 1000;\n  const minConfidence = options.minConfidence ?? 0.3;\n  const minSuccess = options.minSuccess ?? 1;\n\n  const filtered = patterns.filter((p) => {\n    // Keep if already promoted\n    if (p.promotedToCore) return true;\n\n    // Remove if below minimum confidence\n    if (p.confidence < minConfidence) return false;\n\n    // Remove if no successes and required\n    if (minSuccess > 0 && p.successCount < minSuccess) return false;\n\n    // Remove if too old and never successful\n    const age = now - new Date(p.createdAt).getTime();\n    if (age > maxAge && p.successCount === 0) return false;\n\n    return true;\n  });\n\n  const removed = patterns.length - filtered.length;\n\n  if (removed > 0) {\n    saveLearnedPatterns(filtered, options);\n  }\n\n  return {\n    removed,\n    remaining: filtered.length,\n  };\n}\n\n/**\n * Get pattern statistics\n */\nexport function getPatternStats(options: { llkbRoot?: string } = {}): {\n  total: number;\n  promoted: number;\n  highConfidence: number;\n  lowConfidence: number;\n  avgConfidence: number;\n  totalSuccesses: number;\n  totalFailures: number;\n} {\n  const patterns = loadLearnedPatterns(options);\n\n  if (patterns.length === 0) {\n    return {\n      total: 0,\n      promoted: 0,\n      highConfidence: 0,\n      lowConfidence: 0,\n      avgConfidence: 0,\n      totalSuccesses: 0,\n      totalFailures: 0,\n    };\n  }\n\n  const promoted = patterns.filter((p) => p.promotedToCore).length;\n  const highConfidence = patterns.filter((p) => p.confidence >= 0.7).length;\n  const lowConfidence = patterns.filter((p) => p.confidence < 0.3).length;\n  const totalConfidence = patterns.reduce((sum, p) => sum + p.confidence, 0);\n  const totalSuccesses = patterns.reduce((sum, p) => sum + p.successCount, 0);\n  const totalFailures = patterns.reduce((sum, p) => sum + p.failCount, 0);\n\n  return {\n    total: patterns.length,\n    promoted,\n    highConfidence,\n    lowConfidence,\n    avgConfidence: totalConfidence / patterns.length,\n    totalSuccesses,\n    totalFailures,\n  };\n}\n\n/**\n * Export learned patterns to LLKB config format\n */\nexport function exportPatternsToConfig(options: {\n  llkbRoot?: string;\n  outputPath?: string;\n  minConfidence?: number;\n}): { exported: number; path: string } {\n  const patterns = loadLearnedPatterns(options);\n  const minConfidence = options.minConfidence ?? 0.7;\n\n  const exportable = patterns.filter((p) => p.confidence >= minConfidence && !p.promotedToCore);\n\n  const config = {\n    version: '1.0.0',\n    exportedAt: new Date().toISOString(),\n    patterns: exportable.map((p) => ({\n      id: p.id,\n      trigger: generateRegexFromText(p.originalText),\n      primitive: p.mappedPrimitive,\n      confidence: p.confidence,\n      sourceCount: p.sourceJourneys.length,\n    })),\n  };\n\n  const outputPath =\n    options.outputPath || join(dirname(getPatternsFilePath(options.llkbRoot)), 'autogen-patterns.json');\n\n  writeFileSync(outputPath, JSON.stringify(config, null, 2), 'utf-8');\n\n  return {\n    exported: exportable.length,\n    path: outputPath,\n  };\n}\n\n/**\n * Clear all learned patterns (for testing)\n */\nexport function clearLearnedPatterns(options: { llkbRoot?: string } = {}): void {\n  const filePath = getPatternsFilePath(options.llkbRoot);\n  if (existsSync(filePath)) {\n    const { unlinkSync } = require('node:fs');\n    unlinkSync(filePath);\n  }\n}\n","/**\n * Step Mapping Patterns - Regex patterns for parsing step text into IR primitives\n * @see research/2026-01-02_autogen-refined-plan.md Section 10\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md Phase 3\n */\nimport type { IRPrimitive, LocatorSpec, ValueSpec, LocatorStrategy } from '../ir/types.js';\n\n/**\n * Pattern version - increment when patterns change\n * Format: MAJOR.MINOR.PATCH\n * - MAJOR: Breaking changes to pattern behavior\n * - MINOR: New patterns added\n * - PATCH: Bug fixes to existing patterns\n */\nexport const PATTERN_VERSION = '1.1.0';\n\n/**\n * Pattern metadata for tracking\n */\nexport interface PatternMetadata {\n  name: string;\n  version: string;\n  addedDate: string;\n  source: 'core' | 'llkb' | 'telemetry';\n  category: string;\n}\n\n/**\n * Pattern result with match groups\n */\nexport interface PatternMatch {\n  type: IRPrimitive['type'];\n  groups: Record<string, string>;\n}\n\n/**\n * Pattern definition\n */\nexport interface StepPattern {\n  /** Pattern name for debugging */\n  name: string;\n  /** Regex pattern with named groups */\n  regex: RegExp;\n  /** IR primitive type this pattern produces */\n  primitiveType: IRPrimitive['type'];\n  /** Extract IR primitive from match (prefix with _ if unused) */\n  extract: (_match: RegExpMatchArray) => IRPrimitive | null;\n}\n\n/**\n * Create a locator spec from pattern match\n */\nexport function createLocatorFromMatch(\n  strategy: LocatorStrategy,\n  value: string,\n  name?: string\n): LocatorSpec {\n  const locator: LocatorSpec = { strategy, value };\n  if (name) {\n    locator.options = { name };\n  }\n  return locator;\n}\n\n/**\n * Create a value spec from text\n */\nexport function createValueFromText(text: string): ValueSpec {\n  // Actor reference: {{email}}, {{password}}, etc.\n  if (/^\\{\\{.+\\}\\}$/.test(text)) {\n    const path = text.slice(2, -2).trim();\n    return { type: 'actor', value: path };\n  }\n\n  // Test data reference: $user.email, $testData.field\n  if (/^\\$.+/.test(text)) {\n    return { type: 'testData', value: text.slice(1) };\n  }\n\n  // Generated value: ${runId}, ${timestamp}\n  if (/\\$\\{.+\\}/.test(text)) {\n    return { type: 'generated', value: text };\n  }\n\n  // Literal value\n  return { type: 'literal', value: text };\n}\n\n/**\n * Navigation patterns\n */\nexport const navigationPatterns: StepPattern[] = [\n  {\n    name: 'navigate-to-url',\n    regex: /^(?:user\\s+)?(?:navigates?|go(?:es)?|opens?)\\s+(?:to\\s+)?(?:the\\s+)?[\"']?([^\"'\\s]+)[\"']?$/i,\n    primitiveType: 'goto',\n    extract: (match) => ({\n      type: 'goto',\n      url: match[1]!,\n      waitForLoad: true,\n    }),\n  },\n  {\n    name: 'navigate-to-page',\n    regex: /^(?:user\\s+)?(?:navigates?|go(?:es)?|opens?)\\s+(?:to\\s+)?(?:the\\s+)?(.+?)\\s+page$/i,\n    primitiveType: 'goto',\n    extract: (match) => ({\n      type: 'goto',\n      url: `/${match[1]!.toLowerCase().replace(/\\s+/g, '-')}`,\n      waitForLoad: true,\n    }),\n  },\n];\n\n/**\n * Click patterns\n */\nexport const clickPatterns: StepPattern[] = [\n  {\n    name: 'click-button-quoted',\n    regex: /^(?:user\\s+)?(?:clicks?|presses?|taps?)\\s+(?:on\\s+)?(?:the\\s+)?[\"']([^\"']+)[\"']\\s+button$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('role', 'button', match[1]!),\n    }),\n  },\n  {\n    name: 'click-link-quoted',\n    regex: /^(?:user\\s+)?(?:clicks?|presses?|taps?)\\s+(?:on\\s+)?(?:the\\s+)?[\"']([^\"']+)[\"']\\s+link$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('role', 'link', match[1]!),\n    }),\n  },\n  {\n    name: 'click-element-quoted',\n    regex: /^(?:user\\s+)?(?:clicks?|presses?|taps?)\\s+(?:on\\s+)?(?:the\\s+)?[\"']([^\"']+)[\"']$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'click-element-generic',\n    regex: /^(?:user\\s+)?(?:clicks?|presses?|taps?)\\s+(?:on\\s+)?(?:the\\s+)?(.+?)\\s+(?:button|link|icon|menu|tab)$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n];\n\n/**\n * Fill/Input patterns\n */\nexport const fillPatterns: StepPattern[] = [\n  {\n    name: 'fill-field-quoted-value',\n    regex: /^(?:user\\s+)?(?:enters?|types?|fills?\\s+in?|inputs?)\\s+[\"']([^\"']+)[\"']\\s+(?:in|into)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']\\s*(?:field|input)?$/i,\n    primitiveType: 'fill',\n    extract: (match) => ({\n      type: 'fill',\n      locator: createLocatorFromMatch('label', match[2]!),\n      value: createValueFromText(match[1]!),\n    }),\n  },\n  {\n    name: 'fill-field-actor-value',\n    regex: /^(?:user\\s+)?(?:enters?|types?|fills?\\s+in?|inputs?)\\s+(\\{\\{[^}]+\\}\\})\\s+(?:in|into)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']\\s*(?:field|input)?$/i,\n    primitiveType: 'fill',\n    extract: (match) => ({\n      type: 'fill',\n      locator: createLocatorFromMatch('label', match[2]!),\n      value: createValueFromText(match[1]!),\n    }),\n  },\n  {\n    name: 'fill-field-generic',\n    regex: /^(?:user\\s+)?(?:enters?|types?|fills?\\s+in?|inputs?)\\s+(.+?)\\s+(?:in|into)\\s+(?:the\\s+)?(.+?)\\s*(?:field|input)?$/i,\n    primitiveType: 'fill',\n    extract: (match) => ({\n      type: 'fill',\n      locator: createLocatorFromMatch('label', match[2]!.replace(/[\"']/g, '')),\n      value: createValueFromText(match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n];\n\n/**\n * Select patterns\n */\nexport const selectPatterns: StepPattern[] = [\n  {\n    name: 'select-option',\n    regex: /^(?:user\\s+)?(?:selects?|chooses?)\\s+[\"']([^\"']+)[\"']\\s+(?:from|in)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']\\s*(?:dropdown|select|menu)?$/i,\n    primitiveType: 'select',\n    extract: (match) => ({\n      type: 'select',\n      locator: createLocatorFromMatch('label', match[2]!),\n      option: match[1]!,\n    }),\n  },\n];\n\n/**\n * Check/Uncheck patterns\n */\nexport const checkPatterns: StepPattern[] = [\n  {\n    name: 'check-checkbox',\n    regex: /^(?:user\\s+)?(?:checks?|enables?|ticks?)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']\\s*(?:checkbox|option)?$/i,\n    primitiveType: 'check',\n    extract: (match) => ({\n      type: 'check',\n      locator: createLocatorFromMatch('label', match[1]!),\n    }),\n  },\n  {\n    name: 'uncheck-checkbox',\n    regex: /^(?:user\\s+)?(?:unchecks?|disables?|unticks?)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']\\s*(?:checkbox|option)?$/i,\n    primitiveType: 'uncheck',\n    extract: (match) => ({\n      type: 'uncheck',\n      locator: createLocatorFromMatch('label', match[1]!),\n    }),\n  },\n];\n\n/**\n * Visibility assertion patterns\n */\nexport const visibilityPatterns: StepPattern[] = [\n  {\n    name: 'should-see-text',\n    regex: /^(?:user\\s+)?(?:should\\s+)?(?:sees?|views?)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'is-visible',\n    regex: /^[\"']?([^\"']+)[\"']?\\s+(?:is\\s+)?(?:visible|displayed|shown)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'should-see-element',\n    regex: /^(?:user\\s+)?(?:should\\s+)?(?:sees?|views?)\\s+(?:the\\s+)?(.+?)\\s+(?:heading|button|link|form|page|element)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'page-displayed',\n    regex: /^(?:the\\s+)?(.+?)\\s+(?:page|screen|view)\\s+(?:is\\s+)?(?:displayed|shown|visible)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n];\n\n/**\n * Toast/notification patterns\n */\nexport const toastPatterns: StepPattern[] = [\n  {\n    name: 'success-toast-message',\n    regex: /^(?:a\\s+)?success\\s+toast\\s+(?:with\\s+)?[\"']([^\"']+)[\"']\\s*(?:message\\s+)?(?:appears?|is\\s+shown|displays?)$/i,\n    primitiveType: 'expectToast',\n    extract: (match) => ({\n      type: 'expectToast',\n      toastType: 'success',\n      message: match[1]!,\n    }),\n  },\n  {\n    name: 'error-toast-message',\n    regex: /^(?:an?\\s+)?error\\s+toast\\s+(?:with\\s+)?[\"']([^\"']+)[\"']\\s*(?:message\\s+)?(?:appears?|is\\s+shown|displays?)$/i,\n    primitiveType: 'expectToast',\n    extract: (match) => ({\n      type: 'expectToast',\n      toastType: 'error',\n      message: match[1]!,\n    }),\n  },\n  {\n    name: 'toast-appears',\n    regex: /^(?:a\\s+)?(success|error|info|warning)\\s+toast\\s+(?:appears?|is\\s+shown|displays?)$/i,\n    primitiveType: 'expectToast',\n    extract: (match) => ({\n      type: 'expectToast',\n      toastType: match[1]!.toLowerCase() as 'success' | 'error' | 'info' | 'warning',\n    }),\n  },\n  {\n    name: 'toast-with-text',\n    regex: /^(?:toast|notification)\\s+(?:with\\s+)?[\"']([^\"']+)[\"']\\s+(?:appears?|is\\s+shown|displays?)$/i,\n    primitiveType: 'expectToast',\n    extract: (match) => ({\n      type: 'expectToast',\n      toastType: 'info',\n      message: match[1]!,\n    }),\n  },\n];\n\n/**\n * URL assertion patterns\n */\nexport const urlPatterns: StepPattern[] = [\n  {\n    name: 'url-contains',\n    regex: /^(?:the\\s+)?url\\s+(?:should\\s+)?(?:contains?|includes?)\\s+[\"']?([^\"'\\s]+)[\"']?$/i,\n    primitiveType: 'expectURL',\n    extract: (match) => ({\n      type: 'expectURL',\n      pattern: match[1]!,\n    }),\n  },\n  {\n    name: 'url-is',\n    regex: /^(?:the\\s+)?url\\s+(?:should\\s+)?(?:is|equals?|be)\\s+[\"']?([^\"'\\s]+)[\"']?$/i,\n    primitiveType: 'expectURL',\n    extract: (match) => ({\n      type: 'expectURL',\n      pattern: match[1]!,\n    }),\n  },\n  {\n    name: 'redirected-to',\n    regex: /^(?:user\\s+)?(?:is\\s+)?redirected\\s+to\\s+[\"']?([^\"'\\s]+)[\"']?$/i,\n    primitiveType: 'expectURL',\n    extract: (match) => ({\n      type: 'expectURL',\n      pattern: match[1]!,\n    }),\n  },\n];\n\n/**\n * Module call patterns (authentication)\n */\nexport const authPatterns: StepPattern[] = [\n  {\n    name: 'user-login',\n    regex: /^(?:user\\s+)?(?:logs?\\s*in|login\\s+is\\s+performed|authenticates?)$/i,\n    primitiveType: 'callModule',\n    extract: (_match) => ({\n      type: 'callModule',\n      module: 'auth',\n      method: 'login',\n    }),\n  },\n  {\n    name: 'user-logout',\n    regex: /^(?:user\\s+)?(?:logs?\\s*out|logout\\s+is\\s+performed|signs?\\s*out)$/i,\n    primitiveType: 'callModule',\n    extract: (_match) => ({\n      type: 'callModule',\n      module: 'auth',\n      method: 'logout',\n    }),\n  },\n  {\n    name: 'login-as-role',\n    regex: /^(?:user\\s+)?logs?\\s*in\\s+as\\s+(?:an?\\s+)?(.+?)(?:\\s+user)?$/i,\n    primitiveType: 'callModule',\n    extract: (match) => ({\n      type: 'callModule',\n      module: 'auth',\n      method: 'loginAs',\n      args: [match[1]!.toLowerCase()],\n    }),\n  },\n];\n\n/**\n * Wait patterns\n */\nexport const waitPatterns: StepPattern[] = [\n  {\n    name: 'wait-for-navigation',\n    regex: /^(?:user\\s+)?(?:waits?\\s+)?(?:for\\s+)?navigation\\s+to\\s+[\"']?([^\"'\\s]+)[\"']?$/i,\n    primitiveType: 'waitForURL',\n    extract: (match) => ({\n      type: 'waitForURL',\n      pattern: match[1]!,\n    }),\n  },\n  {\n    name: 'wait-for-page',\n    regex: /^(?:user\\s+)?(?:waits?\\s+)?(?:for\\s+)?(?:the\\s+)?(.+?)\\s+(?:page|screen)\\s+to\\s+load$/i,\n    primitiveType: 'waitForLoadingComplete',\n    extract: (_match) => ({\n      type: 'waitForLoadingComplete',\n    }),\n  },\n];\n\n/**\n * Helper function to convert natural language selectors to Playwright locator strategies\n */\nexport function parseSelectorToLocator(selector: string): { strategy: LocatorStrategy; value: string; name?: string } {\n  // Remove leading \"the\" if present\n  let cleanSelector = selector.replace(/^the\\s+/i, '').trim();\n\n  // Match button patterns\n  if (/button$/i.test(cleanSelector)) {\n    const buttonName = cleanSelector.replace(/\\s*button$/i, '').trim();\n    return { strategy: 'role', value: 'button', name: buttonName };\n  }\n\n  // Match link patterns\n  if (/link$/i.test(cleanSelector)) {\n    const linkName = cleanSelector.replace(/\\s*link$/i, '').trim();\n    return { strategy: 'role', value: 'link', name: linkName };\n  }\n\n  // Match input/field patterns\n  if (/(?:input|field)$/i.test(cleanSelector)) {\n    const labelName = cleanSelector.replace(/\\s*(?:input|field)$/i, '').trim();\n    return { strategy: 'label', value: labelName };\n  }\n\n  // Default to text locator\n  return { strategy: 'text', value: cleanSelector };\n}\n\n/**\n * Structured step patterns for Journey markdown format\n * Matches patterns like:\n * - **Action**: Click the login button\n * - **Wait for**: Dashboard to load\n * - **Assert**: User name is visible\n */\nexport const structuredPatterns: StepPattern[] = [\n  // Action patterns\n  {\n    name: 'structured-action-click',\n    regex: /^\\*\\*Action\\*\\*:\\s*[Cc]lick\\s+(?:the\\s+)?['\"]?(.+?)['\"]?\\s*(?:button|link)?$/i,\n    primitiveType: 'click',\n    extract: (match) => {\n      const target = match[1]!;\n      const locatorInfo = parseSelectorToLocator(target + ' button');\n      return {\n        type: 'click',\n        locator: locatorInfo.name\n          ? createLocatorFromMatch(locatorInfo.strategy, locatorInfo.value, locatorInfo.name)\n          : { strategy: locatorInfo.strategy, value: locatorInfo.value },\n      };\n    },\n  },\n  {\n    name: 'structured-action-fill',\n    regex: /^\\*\\*Action\\*\\*:\\s*[Ff]ill\\s+(?:in\\s+)?['\"]?(.+?)['\"]?\\s+with\\s+['\"]?(.+?)['\"]?$/i,\n    primitiveType: 'fill',\n    extract: (match) => {\n      const target = match[1]!;\n      const value = match[2]!;\n      const locatorInfo = parseSelectorToLocator(target);\n      return {\n        type: 'fill',\n        locator: locatorInfo.name\n          ? createLocatorFromMatch(locatorInfo.strategy, locatorInfo.value, locatorInfo.name)\n          : { strategy: locatorInfo.strategy, value: locatorInfo.value },\n        value: createValueFromText(value),\n      };\n    },\n  },\n  {\n    name: 'structured-action-navigate',\n    regex: /^\\*\\*Action\\*\\*:\\s*[Nn]avigate\\s+to\\s+['\"]?(.+?)['\"]?$/i,\n    primitiveType: 'goto',\n    extract: (match) => ({\n      type: 'goto',\n      url: match[1]!,\n      waitForLoad: true,\n    }),\n  },\n\n  // Wait patterns\n  {\n    name: 'structured-wait-for-visible',\n    regex: /^\\*\\*Wait for\\*\\*:\\s*(.+?)\\s+(?:to\\s+)?(?:be\\s+)?(?:visible|appear|load)/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => {\n      const target = match[1]!;\n      const locatorInfo = parseSelectorToLocator(target);\n      return {\n        type: 'expectVisible',\n        locator: locatorInfo.name\n          ? createLocatorFromMatch(locatorInfo.strategy, locatorInfo.value, locatorInfo.name)\n          : { strategy: locatorInfo.strategy, value: locatorInfo.value },\n      };\n    },\n  },\n\n  // Assert patterns\n  {\n    name: 'structured-assert-visible',\n    regex: /^\\*\\*Assert\\*\\*:\\s*(.+?)\\s+(?:is\\s+)?visible$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => {\n      const target = match[1]!;\n      const locatorInfo = parseSelectorToLocator(target);\n      return {\n        type: 'expectVisible',\n        locator: locatorInfo.name\n          ? createLocatorFromMatch(locatorInfo.strategy, locatorInfo.value, locatorInfo.name)\n          : { strategy: locatorInfo.strategy, value: locatorInfo.value },\n      };\n    },\n  },\n  {\n    name: 'structured-assert-text',\n    regex: /^\\*\\*Assert\\*\\*:\\s*(.+?)\\s+(?:contains|has text)\\s+['\"]?(.+?)['\"]?$/i,\n    primitiveType: 'expectText',\n    extract: (match) => {\n      const target = match[1]!;\n      const text = match[2]!;\n      const locatorInfo = parseSelectorToLocator(target);\n      return {\n        type: 'expectText',\n        locator: locatorInfo.name\n          ? createLocatorFromMatch(locatorInfo.strategy, locatorInfo.value, locatorInfo.name)\n          : { strategy: locatorInfo.strategy, value: locatorInfo.value },\n        text,\n      };\n    },\n  },\n];\n\n/**\n * Extended click patterns - Common variations missed by core patterns\n * Added in v1.1.0 based on telemetry analysis\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md Phase 3\n */\nexport const extendedClickPatterns: StepPattern[] = [\n  {\n    name: 'click-on-element',\n    // \"Click on Submit\" or \"Click on the Submit button\"\n    regex: /^(?:user\\s+)?clicks?\\s+on\\s+(?:the\\s+)?(.+?)(?:\\s+button|\\s+link)?$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('text', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n  {\n    name: 'press-enter-key',\n    // \"Press Enter\" or \"Press the Enter key\" or \"Hit Enter\"\n    regex: /^(?:user\\s+)?(?:press(?:es)?|hits?)\\s+(?:the\\s+)?(?:enter|return)(?:\\s+key)?$/i,\n    primitiveType: 'press',\n    extract: () => ({\n      type: 'press',\n      key: 'Enter',\n    }),\n  },\n  {\n    name: 'press-tab-key',\n    // \"Press Tab\" or \"Press the Tab key\"\n    regex: /^(?:user\\s+)?(?:press(?:es)?|hits?)\\s+(?:the\\s+)?tab(?:\\s+key)?$/i,\n    primitiveType: 'press',\n    extract: () => ({\n      type: 'press',\n      key: 'Tab',\n    }),\n  },\n  {\n    name: 'press-escape-key',\n    // \"Press Escape\" or \"Press Esc\"\n    regex: /^(?:user\\s+)?(?:press(?:es)?|hits?)\\s+(?:the\\s+)?(?:escape|esc)(?:\\s+key)?$/i,\n    primitiveType: 'press',\n    extract: () => ({\n      type: 'press',\n      key: 'Escape',\n    }),\n  },\n  {\n    name: 'double-click',\n    // \"Double click on\" or \"Double-click the\"\n    regex: /^(?:user\\s+)?double[-\\s]?clicks?\\s+(?:on\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?$/i,\n    primitiveType: 'dblclick',\n    extract: (match) => ({\n      type: 'dblclick',\n      locator: createLocatorFromMatch('text', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n  {\n    name: 'right-click',\n    // \"Right click on\" or \"Right-click the\"\n    regex: /^(?:user\\s+)?right[-\\s]?clicks?\\s+(?:on\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?$/i,\n    primitiveType: 'rightClick',\n    extract: (match) => ({\n      type: 'rightClick',\n      locator: createLocatorFromMatch('text', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n  {\n    name: 'submit-form',\n    // \"Submit the form\" or \"Submits form\"\n    regex: /^(?:user\\s+)?submits?\\s+(?:the\\s+)?form$/i,\n    primitiveType: 'click',\n    extract: () => ({\n      type: 'click',\n      locator: createLocatorFromMatch('role', 'button', 'Submit'),\n    }),\n  },\n];\n\n/**\n * Extended fill patterns - Common variations missed by core patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const extendedFillPatterns: StepPattern[] = [\n  {\n    name: 'type-into-field',\n    // \"Type 'password' into the Password field\"\n    regex: /^(?:user\\s+)?types?\\s+['\"](.+?)['\"]\\s+into\\s+(?:the\\s+)?[\"']?(.+?)[\"']?\\s*(?:field|input)?$/i,\n    primitiveType: 'fill',\n    extract: (match) => ({\n      type: 'fill',\n      locator: createLocatorFromMatch('label', match[2]!),\n      value: createValueFromText(match[1]!),\n    }),\n  },\n  {\n    name: 'fill-in-field-no-value',\n    // \"Fill in the email address\" (without explicit value - uses actor data)\n    regex: /^(?:user\\s+)?fills?\\s+in\\s+(?:the\\s+)?[\"']?(.+?)[\"']?\\s*(?:field|input)?$/i,\n    primitiveType: 'fill',\n    extract: (match) => {\n      const fieldName = match[1]!.replace(/[\"']/g, '');\n      return {\n        type: 'fill',\n        locator: createLocatorFromMatch('label', fieldName),\n        value: { type: 'actor', value: fieldName.toLowerCase().replace(/\\s+/g, '_') },\n      };\n    },\n  },\n  {\n    name: 'clear-field',\n    // \"Clear the email field\" or \"Clears the input\"\n    regex: /^(?:user\\s+)?clears?\\s+(?:the\\s+)?[\"']?(.+?)[\"']?\\s*(?:field|input)?$/i,\n    primitiveType: 'clear',\n    extract: (match) => ({\n      type: 'clear',\n      locator: createLocatorFromMatch('label', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n  {\n    name: 'set-value',\n    // \"Set the value to 'test'\" or \"Sets field to 'value'\"\n    regex: /^(?:user\\s+)?sets?\\s+(?:the\\s+)?(?:value\\s+)?(?:of\\s+)?[\"']?(.+?)[\"']?\\s+to\\s+['\"](.+?)['\"]$/i,\n    primitiveType: 'fill',\n    extract: (match) => ({\n      type: 'fill',\n      locator: createLocatorFromMatch('label', match[1]!),\n      value: createValueFromText(match[2]!),\n    }),\n  },\n];\n\n/**\n * Extended assertion patterns - Common variations missed by core patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const extendedAssertionPatterns: StepPattern[] = [\n  {\n    name: 'verify-element-showing',\n    // \"Verify the dashboard is showing/displayed\"\n    regex: /^(?:verify|confirm|ensure)\\s+(?:that\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:is\\s+)?(?:showing|displayed|visible)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'page-should-show',\n    // \"The page should show 'Welcome'\" or \"Page should display 'text'\"\n    regex: /^(?:the\\s+)?page\\s+should\\s+(?:show|display|contain)\\s+['\"](.+?)['\"]$/i,\n    primitiveType: 'expectText',\n    extract: (match) => ({\n      type: 'expectText',\n      locator: { strategy: 'role', value: 'main' },\n      text: match[1]!,\n    }),\n  },\n  {\n    name: 'make-sure-assertion',\n    // \"Make sure the button is visible\" or \"Make sure user sees 'text'\"\n    regex: /^make\\s+sure\\s+(?:that\\s+)?(?:the\\s+)?(.+?)\\s+(?:is\\s+)?(?:visible|displayed|shown)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'confirm-that-assertion',\n    // \"Confirm that the message appears\" or \"Confirm the error is shown\"\n    regex: /^confirm\\s+(?:that\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:appears?|is\\s+shown|displays?)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'check-element-exists',\n    // \"Check that the element exists\" or \"Check the button is present\"\n    regex: /^check\\s+(?:that\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:exists?|is\\s+present)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'element-should-not-be-visible',\n    // \"The error should not be visible\" or \"Error message is not displayed\"\n    regex: /^(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:should\\s+)?(?:not\\s+be|is\\s+not)\\s+(?:visible|displayed|shown)$/i,\n    primitiveType: 'expectHidden',\n    extract: (match) => ({\n      type: 'expectHidden',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'element-contains-text',\n    // \"The header contains 'Welcome'\" or \"Element should contain 'text'\"\n    regex: /^(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:should\\s+)?contains?\\s+['\"](.+?)['\"]$/i,\n    primitiveType: 'expectText',\n    extract: (match) => ({\n      type: 'expectText',\n      locator: createLocatorFromMatch('text', match[1]!),\n      text: match[2]!,\n    }),\n  },\n];\n\n/**\n * Extended wait patterns - Common variations missed by core patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const extendedWaitPatterns: StepPattern[] = [\n  {\n    name: 'wait-for-element-visible',\n    // \"Wait for the loading spinner to disappear\"\n    regex: /^(?:user\\s+)?waits?\\s+(?:for\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+to\\s+(?:disappear|be\\s+hidden)$/i,\n    primitiveType: 'waitForHidden',\n    extract: (match) => ({\n      type: 'waitForHidden',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'wait-for-element-appear',\n    // \"Wait for the modal to appear\" or \"Wait for dialog to show\"\n    regex: /^(?:user\\s+)?waits?\\s+(?:for\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+to\\s+(?:appear|show|be\\s+visible)$/i,\n    primitiveType: 'waitForVisible',\n    extract: (match) => ({\n      type: 'waitForVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'wait-until-loaded',\n    // \"Wait until the page is loaded\" or \"Wait until content loads\"\n    regex: /^(?:user\\s+)?waits?\\s+until\\s+(?:the\\s+)?(?:page|content|data)\\s+(?:is\\s+)?loaded$/i,\n    primitiveType: 'waitForLoadingComplete',\n    extract: () => ({\n      type: 'waitForLoadingComplete',\n    }),\n  },\n  {\n    name: 'wait-seconds',\n    // \"Wait for 2 seconds\" or \"Wait 3 seconds\"\n    regex: /^(?:user\\s+)?waits?\\s+(?:for\\s+)?(\\d+)\\s+seconds?$/i,\n    primitiveType: 'waitForTimeout',\n    extract: (match) => ({\n      type: 'waitForTimeout',\n      ms: parseInt(match[1]!, 10) * 1000,\n    }),\n  },\n  {\n    name: 'wait-for-network',\n    // \"Wait for network to be idle\" or \"Wait for network idle\"\n    regex: /^(?:user\\s+)?waits?\\s+(?:for\\s+)?(?:the\\s+)?network\\s+(?:to\\s+be\\s+)?idle$/i,\n    primitiveType: 'waitForNetworkIdle',\n    extract: () => ({\n      type: 'waitForNetworkIdle',\n    }),\n  },\n];\n\n/**\n * Extended navigation patterns - Common variations missed by core patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const extendedNavigationPatterns: StepPattern[] = [\n  {\n    name: 'refresh-page',\n    // \"Refresh the page\" or \"Reload the page\"\n    regex: /^(?:user\\s+)?(?:refresh(?:es)?|reloads?)\\s+(?:the\\s+)?page$/i,\n    primitiveType: 'reload',\n    extract: () => ({\n      type: 'reload',\n    }),\n  },\n  {\n    name: 'go-back',\n    // \"Go back\" or \"Navigate back\" or \"User goes back\"\n    regex: /^(?:user\\s+)?(?:go(?:es)?|navigates?)\\s+back$/i,\n    primitiveType: 'goBack',\n    extract: () => ({\n      type: 'goBack',\n    }),\n  },\n  {\n    name: 'go-forward',\n    // \"Go forward\" or \"Navigate forward\"\n    regex: /^(?:user\\s+)?(?:go(?:es)?|navigates?)\\s+forward$/i,\n    primitiveType: 'goForward',\n    extract: () => ({\n      type: 'goForward',\n    }),\n  },\n];\n\n/**\n * Extended select/dropdown patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const extendedSelectPatterns: StepPattern[] = [\n  {\n    name: 'select-from-dropdown',\n    // \"Select 'Option' from dropdown\" or \"Choose 'Value' from the dropdown\"\n    regex: /^(?:user\\s+)?(?:selects?|chooses?)\\s+['\"](.+?)['\"]\\s+from\\s+(?:the\\s+)?dropdown$/i,\n    primitiveType: 'select',\n    extract: (match) => ({\n      type: 'select',\n      locator: { strategy: 'role', value: 'combobox' },\n      option: match[1]!,\n    }),\n  },\n  {\n    name: 'select-option-named',\n    // \"Select option 'Value'\" or \"Choose the 'Option' option\"\n    regex: /^(?:user\\s+)?(?:selects?|chooses?)\\s+(?:the\\s+)?(?:option\\s+)?['\"](.+?)['\"](?:\\s+option)?$/i,\n    primitiveType: 'select',\n    extract: (match) => ({\n      type: 'select',\n      locator: { strategy: 'role', value: 'combobox' },\n      option: match[1]!,\n    }),\n  },\n];\n\n/**\n * Hover patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const hoverPatterns: StepPattern[] = [\n  {\n    name: 'hover-over-element',\n    // \"Hover over the menu\" or \"User hovers on button\"\n    regex: /^(?:user\\s+)?hovers?\\s+(?:over|on)\\s+(?:the\\s+)?[\"']?(.+?)[\"']?$/i,\n    primitiveType: 'hover',\n    extract: (match) => ({\n      type: 'hover',\n      locator: createLocatorFromMatch('text', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n  {\n    name: 'mouse-over',\n    // \"Mouse over the element\" or \"Mouseover the button\"\n    regex: /^(?:user\\s+)?mouse\\s*over\\s+(?:the\\s+)?[\"']?(.+?)[\"']?$/i,\n    primitiveType: 'hover',\n    extract: (match) => ({\n      type: 'hover',\n      locator: createLocatorFromMatch('text', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n];\n\n/**\n * Focus patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const focusPatterns: StepPattern[] = [\n  {\n    name: 'focus-on-element',\n    // \"Focus on the input\" or \"User focuses the field\"\n    regex: /^(?:user\\s+)?focus(?:es)?\\s+(?:on\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?$/i,\n    primitiveType: 'focus',\n    extract: (match) => ({\n      type: 'focus',\n      locator: createLocatorFromMatch('label', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n];\n\n/**\n * All patterns in priority order (more specific patterns first)\n * Structured patterns come first to prioritize the Journey markdown format\n */\nexport const allPatterns: StepPattern[] = [\n  ...structuredPatterns,\n  ...authPatterns,\n  ...toastPatterns,\n  // Extended patterns come BEFORE base patterns to match more specific cases first\n  ...extendedNavigationPatterns, // Must be before navigationPatterns (e.g., \"Go back\" vs \"Go to\")\n  ...navigationPatterns,\n  ...extendedClickPatterns, // Must be before clickPatterns (e.g., \"Click on\" vs \"Click\")\n  ...clickPatterns,\n  ...extendedFillPatterns,\n  ...fillPatterns,\n  ...extendedSelectPatterns,\n  ...selectPatterns,\n  ...checkPatterns,\n  ...extendedAssertionPatterns, // Must be before visibilityPatterns (e.g., \"not be visible\")\n  ...visibilityPatterns,\n  ...urlPatterns,\n  ...extendedWaitPatterns,\n  ...waitPatterns,\n  ...hoverPatterns,\n  ...focusPatterns,\n];\n\n/**\n * Match text against all patterns and return the first matching primitive\n */\nexport function matchPattern(text: string): IRPrimitive | null {\n  const trimmedText = text.trim();\n\n  for (const pattern of allPatterns) {\n    const match = trimmedText.match(pattern.regex);\n    if (match) {\n      const primitive = pattern.extract(match);\n      if (primitive) {\n        return primitive;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Get all pattern matches for debugging\n */\nexport function getPatternMatches(text: string): Array<{ pattern: string; match: IRPrimitive }> {\n  const trimmedText = text.trim();\n  const matches: Array<{ pattern: string; match: IRPrimitive }> = [];\n\n  for (const pattern of allPatterns) {\n    const match = trimmedText.match(pattern.regex);\n    if (match) {\n      const primitive = pattern.extract(match);\n      if (primitive) {\n        matches.push({ pattern: pattern.name, match: primitive });\n      }\n    }\n  }\n\n  return matches;\n}\n\n/**\n * Get all pattern names for CLI listing\n */\nexport function getAllPatternNames(): string[] {\n  return allPatterns.map((p) => p.name);\n}\n\n/**\n * Get pattern count by category\n */\nexport function getPatternCountByCategory(): Record<string, number> {\n  const counts: Record<string, number> = {};\n\n  for (const pattern of allPatterns) {\n    const category = pattern.name.split('-')[0] || 'other';\n    counts[category] = (counts[category] || 0) + 1;\n  }\n\n  return counts;\n}\n\n/**\n * Get pattern metadata for a specific pattern\n */\nexport function getPatternMetadata(patternName: string): PatternMetadata | null {\n  const pattern = allPatterns.find((p) => p.name === patternName);\n  if (!pattern) return null;\n\n  // Determine version based on pattern name prefix\n  const isExtended =\n    patternName.includes('extended') ||\n    patternName.startsWith('hover') ||\n    patternName.startsWith('focus') ||\n    patternName.startsWith('press-') ||\n    patternName.startsWith('double-') ||\n    patternName.startsWith('right-');\n\n  return {\n    name: pattern.name,\n    version: isExtended ? '1.1.0' : '1.0.0',\n    addedDate: isExtended ? '2026-01-27' : '2026-01-02',\n    source: 'core',\n    category: pattern.name.split('-')[0] || 'other',\n  };\n}\n\n/**\n * Find patterns that match a given text (for debugging)\n */\nexport function findMatchingPatterns(text: string): string[] {\n  const trimmedText = text.trim();\n  const matchingNames: string[] = [];\n\n  for (const pattern of allPatterns) {\n    if (pattern.regex.test(trimmedText)) {\n      matchingNames.push(pattern.name);\n    }\n  }\n\n  return matchingNames;\n}\n","/**\n * Glossary Loader - Load and resolve synonyms for step text normalization\n * @see research/2026-01-02_autogen-refined-plan.md Section 10\n * @see research/2026-01-23_llkb-autogen-integration-specification.md (LLKB integration)\n */\nimport { readFileSync, existsSync } from 'node:fs';\nimport { resolve } from 'node:path';\nimport { pathToFileURL } from 'node:url';\nimport { parse as parseYaml } from 'yaml';\nimport { z } from 'zod';\nimport type { IRPrimitive } from '../ir/types.js';\n\n/**\n * Glossary entry schema\n */\nconst GlossaryEntrySchema = z.object({\n  canonical: z.string(),\n  synonyms: z.array(z.string()),\n});\n\n/**\n * Label alias entry schema (maps display labels to testids/selectors)\n * @see T082 - Extend glossary schema for labelAliases\n */\nconst LabelAliasSchema = z.object({\n  label: z.string(),\n  testid: z.string().optional(),\n  role: z.string().optional(),\n  selector: z.string().optional(),\n});\n\n/**\n * Module method mapping schema (maps phrases to module.method calls)\n * @see T082 - Module method resolution\n */\nconst ModuleMethodMappingSchema = z.object({\n  phrase: z.string(),\n  module: z.string(),\n  method: z.string(),\n  params: z.record(z.string()).optional(),\n});\n\n/**\n * Glossary file schema\n */\nconst GlossarySchema = z.object({\n  version: z.number().default(1),\n  entries: z.array(GlossaryEntrySchema),\n  labelAliases: z.array(LabelAliasSchema).default([]),\n  moduleMethods: z.array(ModuleMethodMappingSchema).default([]),\n});\n\nexport type LabelAlias = z.infer<typeof LabelAliasSchema>;\nexport type ModuleMethodMapping = z.infer<typeof ModuleMethodMappingSchema>;\n\nexport type GlossaryEntry = z.infer<typeof GlossaryEntrySchema>;\nexport type Glossary = z.infer<typeof GlossarySchema>;\n\n/**\n * Default glossary entries for common terms\n */\nexport const defaultGlossary: Glossary = {\n  version: 1,\n  labelAliases: [\n    // Common label-to-selector mappings\n    { label: 'email', testid: 'email-input', role: 'textbox' },\n    { label: 'password', testid: 'password-input', role: 'textbox' },\n    { label: 'username', testid: 'username-input', role: 'textbox' },\n    { label: 'search', testid: 'search-input', role: 'searchbox' },\n    { label: 'submit', testid: 'submit-button', role: 'button' },\n    { label: 'cancel', testid: 'cancel-button', role: 'button' },\n    { label: 'close', testid: 'close-button', role: 'button' },\n  ],\n  moduleMethods: [\n    // Common phrase-to-module mappings\n    { phrase: 'log in', module: 'auth', method: 'login' },\n    { phrase: 'login', module: 'auth', method: 'login' },\n    { phrase: 'sign in', module: 'auth', method: 'login' },\n    { phrase: 'log out', module: 'auth', method: 'logout' },\n    { phrase: 'logout', module: 'auth', method: 'logout' },\n    { phrase: 'sign out', module: 'auth', method: 'logout' },\n    { phrase: 'navigate to', module: 'navigation', method: 'goToPath' },\n    { phrase: 'go to', module: 'navigation', method: 'goToPath' },\n    { phrase: 'open', module: 'navigation', method: 'goToPath' },\n    { phrase: 'fill form', module: 'forms', method: 'fillForm' },\n    { phrase: 'submit form', module: 'forms', method: 'submitForm' },\n    { phrase: 'wait for', module: 'waits', method: 'waitForSignal' },\n  ],\n  entries: [\n    {\n      canonical: 'click',\n      synonyms: ['press', 'tap', 'select', 'hit'],\n    },\n    {\n      canonical: 'enter',\n      synonyms: ['type', 'fill', 'input', 'write'],\n    },\n    {\n      canonical: 'navigate',\n      synonyms: ['go', 'open', 'visit', 'browse'],\n    },\n    {\n      canonical: 'see',\n      synonyms: ['view', 'observe', 'notice', 'find'],\n    },\n    {\n      canonical: 'visible',\n      synonyms: ['displayed', 'shown', 'present'],\n    },\n    {\n      canonical: 'button',\n      synonyms: ['btn', 'action', 'cta'],\n    },\n    {\n      canonical: 'field',\n      synonyms: ['input', 'textbox', 'text field', 'text input'],\n    },\n    {\n      canonical: 'dropdown',\n      synonyms: ['select', 'combo', 'combobox', 'selector', 'picker'],\n    },\n    {\n      canonical: 'checkbox',\n      synonyms: ['check', 'tick', 'toggle'],\n    },\n    {\n      canonical: 'login',\n      synonyms: ['log in', 'sign in', 'authenticate'],\n    },\n    {\n      canonical: 'logout',\n      synonyms: ['log out', 'sign out', 'exit'],\n    },\n    {\n      canonical: 'submit',\n      synonyms: ['send', 'save', 'confirm', 'ok'],\n    },\n    {\n      canonical: 'cancel',\n      synonyms: ['close', 'dismiss', 'abort', 'back'],\n    },\n    {\n      canonical: 'success',\n      synonyms: ['passed', 'completed', 'done', 'finished'],\n    },\n    {\n      canonical: 'error',\n      synonyms: ['failure', 'failed', 'problem', 'issue'],\n    },\n    {\n      canonical: 'toast',\n      synonyms: ['notification', 'message', 'alert', 'snackbar'],\n    },\n    {\n      canonical: 'modal',\n      synonyms: ['dialog', 'popup', 'overlay', 'lightbox'],\n    },\n    {\n      canonical: 'user',\n      synonyms: ['customer', 'visitor', 'member', 'client'],\n    },\n    {\n      canonical: 'page',\n      synonyms: ['screen', 'view', 'section'],\n    },\n    {\n      canonical: 'form',\n      synonyms: ['questionnaire', 'survey', 'wizard'],\n    },\n  ],\n};\n\n/**\n * Loaded glossary cache\n */\nlet glossaryCache: Glossary | null = null;\nlet synonymMap: Map<string, string> | null = null;\n\n/**\n * Build a synonym lookup map from glossary\n */\nfunction buildSynonymMap(glossary: Glossary): Map<string, string> {\n  const map = new Map<string, string>();\n\n  for (const entry of glossary.entries) {\n    // Map canonical to itself\n    map.set(entry.canonical.toLowerCase(), entry.canonical);\n\n    // Map all synonyms to canonical\n    for (const synonym of entry.synonyms) {\n      map.set(synonym.toLowerCase(), entry.canonical);\n    }\n  }\n\n  return map;\n}\n\n/**\n * Load glossary from file\n * @param glossaryPath - Path to glossary YAML file\n */\nexport function loadGlossary(glossaryPath: string): Glossary {\n  const resolvedPath = resolve(glossaryPath);\n\n  if (!existsSync(resolvedPath)) {\n    console.warn(`Glossary file not found at ${resolvedPath}, using defaults`);\n    return defaultGlossary;\n  }\n\n  try {\n    const content = readFileSync(resolvedPath, 'utf-8');\n    const parsed = parseYaml(content);\n    const result = GlossarySchema.safeParse(parsed);\n\n    if (!result.success) {\n      console.warn(`Invalid glossary file at ${resolvedPath}, using defaults`);\n      return defaultGlossary;\n    }\n\n    // Merge with defaults\n    return mergeGlossaries(defaultGlossary, result.data);\n  } catch {\n    console.warn(`Failed to load glossary from ${resolvedPath}, using defaults`);\n    return defaultGlossary;\n  }\n}\n\n/**\n * Merge two glossaries (user glossary extends defaults)\n */\nexport function mergeGlossaries(base: Glossary, extension: Glossary): Glossary {\n  const merged: Glossary = {\n    version: Math.max(base.version, extension.version),\n    entries: [...base.entries],\n    labelAliases: [...(base.labelAliases ?? [])],\n    moduleMethods: [...(base.moduleMethods ?? [])],\n  };\n\n  // Add or extend entries from extension\n  for (const extEntry of extension.entries) {\n    const existing = merged.entries.find(\n      (e) => e.canonical.toLowerCase() === extEntry.canonical.toLowerCase()\n    );\n\n    if (existing) {\n      // Merge synonyms\n      const allSynonyms = new Set([...existing.synonyms, ...extEntry.synonyms]);\n      existing.synonyms = Array.from(allSynonyms);\n    } else {\n      // Add new entry\n      merged.entries.push(extEntry);\n    }\n  }\n\n  // Add or extend label aliases from extension\n  for (const extAlias of extension.labelAliases ?? []) {\n    const existing = merged.labelAliases.find(\n      (a) => a.label.toLowerCase() === extAlias.label.toLowerCase()\n    );\n\n    if (!existing) {\n      merged.labelAliases.push(extAlias);\n    } else {\n      // Override with extension values\n      Object.assign(existing, extAlias);\n    }\n  }\n\n  // Add or extend module methods from extension\n  for (const extMethod of extension.moduleMethods ?? []) {\n    const existing = merged.moduleMethods.find(\n      (m) => m.phrase.toLowerCase() === extMethod.phrase.toLowerCase()\n    );\n\n    if (!existing) {\n      merged.moduleMethods.push(extMethod);\n    } else {\n      // Override with extension values\n      Object.assign(existing, extMethod);\n    }\n  }\n\n  return merged;\n}\n\n/**\n * Initialize the glossary (call once at startup)\n * @param glossaryPath - Optional path to custom glossary\n */\nexport function initGlossary(glossaryPath?: string): void {\n  if (glossaryPath) {\n    glossaryCache = loadGlossary(glossaryPath);\n  } else {\n    glossaryCache = defaultGlossary;\n  }\n  synonymMap = buildSynonymMap(glossaryCache);\n}\n\n/**\n * Get the current glossary\n */\nexport function getGlossary(): Glossary {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n  return glossaryCache!;\n}\n\n/**\n * Resolve a term to its canonical form\n * @param term - Term to resolve\n * @returns Canonical form or original term if not found\n */\nexport function resolveCanonical(term: string): string {\n  if (!synonymMap) {\n    initGlossary();\n  }\n  return synonymMap!.get(term.toLowerCase()) ?? term;\n}\n\n/**\n * Normalize step text by replacing synonyms with canonical terms\n * @param text - Step text to normalize\n * @returns Normalized text\n */\nexport function normalizeStepText(text: string): string {\n  if (!synonymMap) {\n    initGlossary();\n  }\n\n  // Split into words, preserving quoted strings\n  const parts: string[] = [];\n  const regex = /(['\"][^'\"]+['\"])|(\\S+)/g;\n  let match;\n\n  while ((match = regex.exec(text)) !== null) {\n    const part = match[0];\n\n    // Don't normalize quoted strings\n    if (part.startsWith('\"') || part.startsWith(\"'\")) {\n      parts.push(part);\n    } else {\n      // Check if this word has a canonical form\n      const canonical = synonymMap!.get(part.toLowerCase());\n      parts.push(canonical ?? part);\n    }\n  }\n\n  return parts.join(' ');\n}\n\n/**\n * Get all synonyms for a canonical term\n */\nexport function getSynonyms(canonical: string): string[] {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n\n  const entry = glossaryCache!.entries.find(\n    (e) => e.canonical.toLowerCase() === canonical.toLowerCase()\n  );\n\n  return entry?.synonyms ?? [];\n}\n\n/**\n * Check if a term is a synonym of a canonical term\n */\nexport function isSynonymOf(term: string, canonical: string): boolean {\n  const resolved = resolveCanonical(term);\n  return resolved.toLowerCase() === canonical.toLowerCase();\n}\n\n/**\n * Reset the glossary cache (for testing)\n */\nexport function resetGlossaryCache(): void {\n  glossaryCache = null;\n  synonymMap = null;\n}\n\n/**\n * Find a label alias by label text\n * @see T082 - Label alias matching\n */\nexport function findLabelAlias(label: string): LabelAlias | null {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n\n  const normalizedLabel = label.toLowerCase().trim();\n\n  return (\n    glossaryCache!.labelAliases?.find(\n      (alias) => alias.label.toLowerCase() === normalizedLabel\n    ) ?? null\n  );\n}\n\n/**\n * Get locator info from label alias\n */\nexport function getLocatorFromLabel(label: string): { strategy: string; value: string } | null {\n  const alias = findLabelAlias(label);\n  if (!alias) return null;\n\n  // Priority: testid > role > selector\n  if (alias.testid) {\n    return { strategy: 'testid', value: alias.testid };\n  }\n  if (alias.role) {\n    return { strategy: 'role', value: alias.role };\n  }\n  if (alias.selector) {\n    return { strategy: 'css', value: alias.selector };\n  }\n\n  return null;\n}\n\n/**\n * Find a module method mapping by phrase\n * @see T083 - Module method resolution in step mapper\n */\nexport function findModuleMethod(text: string): ModuleMethodMapping | null {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n\n  const normalizedText = text.toLowerCase().trim();\n\n  // Find the best matching phrase (longest match wins)\n  let bestMatch: ModuleMethodMapping | null = null;\n  let bestMatchLength = 0;\n\n  for (const mapping of glossaryCache!.moduleMethods ?? []) {\n    const phrase = mapping.phrase.toLowerCase();\n    if (normalizedText.includes(phrase) && phrase.length > bestMatchLength) {\n      bestMatch = mapping;\n      bestMatchLength = phrase.length;\n    }\n  }\n\n  return bestMatch;\n}\n\n/**\n * Resolve a step to a module method call if it matches\n */\nexport function resolveModuleMethod(\n  text: string\n): { module: string; method: string; params?: Record<string, string> } | null {\n  const mapping = findModuleMethod(text);\n  if (!mapping) return null;\n\n  return {\n    module: mapping.module,\n    method: mapping.method,\n    params: mapping.params,\n  };\n}\n\n/**\n * Get all label aliases\n */\nexport function getLabelAliases(): LabelAlias[] {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n  return glossaryCache!.labelAliases ?? [];\n}\n\n/**\n * Get all module method mappings\n */\nexport function getModuleMethods(): ModuleMethodMapping[] {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n  return glossaryCache!.moduleMethods ?? [];\n}\n\n// ============================================================================\n// LLKB Extended Glossary Support\n// @see research/2026-01-23_llkb-autogen-integration-specification.md\n// ============================================================================\n\n/**\n * Extended glossary metadata from LLKB export\n */\nexport interface ExtendedGlossaryMeta {\n  exportedAt: string;\n  entryCount: number;\n  minConfidence?: number;\n  sourceComponents?: string[];\n  sourceLessons?: string[];\n}\n\n/**\n * Extended glossary loaded from LLKB export\n */\nlet extendedGlossary: Map<string, IRPrimitive> | null = null;\nlet extendedGlossaryMeta: ExtendedGlossaryMeta | null = null;\n\n/**\n * Load extended glossary from LLKB export file\n * @param glossaryPath - Path to the LLKB-generated glossary TypeScript file\n * @returns Loading result with entry count and metadata\n */\nexport async function loadExtendedGlossary(glossaryPath: string): Promise<{\n  loaded: boolean;\n  entryCount: number;\n  exportedAt: string | null;\n  error?: string;\n}> {\n  try {\n    const resolvedPath = resolve(glossaryPath);\n\n    if (!existsSync(resolvedPath)) {\n      return {\n        loaded: false,\n        entryCount: 0,\n        exportedAt: null,\n        error: `Glossary file not found: ${resolvedPath}`,\n      };\n    }\n\n    // Dynamic import of the generated glossary file\n    // Use file:// URL for Windows compatibility\n    const fileUrl = pathToFileURL(resolvedPath).href;\n    const module = await import(fileUrl);\n\n    if (module.llkbGlossary instanceof Map) {\n      const glossaryMap: Map<string, IRPrimitive> = module.llkbGlossary;\n      extendedGlossary = glossaryMap;\n      extendedGlossaryMeta = module.llkbGlossaryMeta ?? null;\n\n      return {\n        loaded: true,\n        entryCount: glossaryMap.size,\n        exportedAt: extendedGlossaryMeta?.exportedAt ?? null,\n      };\n    }\n\n    // If llkbGlossary is a plain object, convert to Map\n    if (module.llkbGlossary && typeof module.llkbGlossary === 'object') {\n      const glossaryMap = new Map<string, IRPrimitive>(\n        Object.entries(module.llkbGlossary) as [string, IRPrimitive][]\n      );\n      extendedGlossary = glossaryMap;\n      extendedGlossaryMeta = module.llkbGlossaryMeta ?? null;\n\n      return {\n        loaded: true,\n        entryCount: glossaryMap.size,\n        exportedAt: extendedGlossaryMeta?.exportedAt ?? null,\n      };\n    }\n\n    return {\n      loaded: false,\n      entryCount: 0,\n      exportedAt: null,\n      error: 'Invalid glossary format: llkbGlossary not found or not a Map/object',\n    };\n  } catch (err) {\n    return {\n      loaded: false,\n      entryCount: 0,\n      exportedAt: null,\n      error: `Failed to load glossary: ${err instanceof Error ? err.message : String(err)}`,\n    };\n  }\n}\n\n/**\n * Clear extended glossary (for testing)\n */\nexport function clearExtendedGlossary(): void {\n  extendedGlossary = null;\n  extendedGlossaryMeta = null;\n}\n\n/**\n * Check if a term exactly matches a core glossary phrase\n * (not just a partial/substring match)\n */\nfunction isExactCoreMatch(term: string): boolean {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n\n  const normalizedTerm = term.toLowerCase().trim();\n\n  // Check if any module method phrase exactly matches the term\n  for (const mapping of glossaryCache!.moduleMethods ?? []) {\n    if (mapping.phrase.toLowerCase() === normalizedTerm) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Lookup a term in both core glossary and extended LLKB glossary\n * Core glossary takes precedence for exact matches (LLKB only extends, never overrides)\n * @param term - Term to look up\n * @returns IR primitive if found, undefined otherwise\n */\nexport function lookupGlossary(term: string): IRPrimitive | undefined {\n  const normalizedTerm = term.toLowerCase().trim();\n\n  // First check if core glossary has an EXACT match for this term\n  // Core always wins for exact matches (LLKB never overrides core)\n  if (isExactCoreMatch(normalizedTerm)) {\n    const coreMapping = findModuleMethod(normalizedTerm);\n    if (coreMapping) {\n      return {\n        type: 'callModule',\n        module: coreMapping.module,\n        method: coreMapping.method,\n        args: coreMapping.params ? [coreMapping.params] : undefined,\n      };\n    }\n  }\n\n  // Then check extended glossary for exact match\n  // LLKB extends core glossary with new terms\n  if (extendedGlossary) {\n    const extendedMatch = extendedGlossary.get(normalizedTerm);\n    if (extendedMatch) {\n      return extendedMatch;\n    }\n  }\n\n  // Finally, check core glossary for partial/substring matches\n  // This allows core patterns like \"wait for\" to match \"wait for something\"\n  const coreMapping = findModuleMethod(normalizedTerm);\n  if (coreMapping) {\n    return {\n      type: 'callModule',\n      module: coreMapping.module,\n      method: coreMapping.method,\n      args: coreMapping.params ? [coreMapping.params] : undefined,\n    };\n  }\n\n  return undefined;\n}\n\n/**\n * Lookup a term in core glossary only (for priority enforcement)\n * Used when LLKB should NOT override core mappings\n * @param term - Term to look up\n * @returns IR primitive if found, undefined otherwise\n */\nexport function lookupCoreGlossary(term: string): IRPrimitive | undefined {\n  const normalizedTerm = term.toLowerCase().trim();\n\n  const coreMapping = findModuleMethod(normalizedTerm);\n  if (coreMapping) {\n    return {\n      type: 'callModule',\n      module: coreMapping.module,\n      method: coreMapping.method,\n      args: coreMapping.params ? [coreMapping.params] : undefined,\n    };\n  }\n\n  return undefined;\n}\n\n/**\n * Get glossary statistics\n */\nexport function getGlossaryStats(): {\n  coreEntries: number;\n  extendedEntries: number;\n  extendedExportedAt: string | null;\n  extendedMeta: ExtendedGlossaryMeta | null;\n} {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n\n  return {\n    coreEntries: glossaryCache!.moduleMethods?.length ?? 0,\n    extendedEntries: extendedGlossary?.size ?? 0,\n    extendedExportedAt: extendedGlossaryMeta?.exportedAt ?? null,\n    extendedMeta: extendedGlossaryMeta,\n  };\n}\n\n/**\n * Check if extended glossary is loaded\n */\nexport function hasExtendedGlossary(): boolean {\n  return extendedGlossary !== null && extendedGlossary.size > 0;\n}\n","/**\n * Machine Hint Syntax Patterns - Define regex patterns for parsing hints\n * @see T071 - Define machine hint syntax regex patterns\n */\n\n/**\n * Machine hint types\n */\nexport type HintType =\n  | 'role'       // ARIA role hint: (role=button)\n  | 'testid'     // Test ID hint: (testid=submit-btn)\n  | 'label'      // Label hint: (label=\"Email Address\")\n  | 'text'       // Text hint: (text=\"Submit\")\n  | 'exact'      // Exact matching: (exact=true)\n  | 'level'      // Heading level: (level=2)\n  | 'signal'     // Signal hint: (signal=loading-done)\n  | 'module'     // Module method hint: (module=auth.login)\n  | 'wait'       // Wait strategy: (wait=networkidle)\n  | 'timeout';   // Timeout hint: (timeout=5000)\n\n/**\n * Parsed machine hint\n */\nexport interface MachineHint {\n  /** Hint type */\n  type: HintType;\n  /** Hint value */\n  value: string;\n  /** Raw hint string */\n  raw: string;\n}\n\n/**\n * Pattern for detecting hint blocks: (key=value) or (key=\"value with spaces\")\n */\nexport const HINT_BLOCK_PATTERN = /\\(([a-z]+)=(?:\"([^\"]+)\"|'([^']+)'|([^,)\\s]+))\\)/gi;\n\n/**\n * Pattern for a complete hints section: (...hints...)\n */\nexport const HINTS_SECTION_PATTERN = /\\((?:[a-z]+=(?:\"[^\"]+\"|'[^']+'|[^,)\\s]+)(?:,\\s*)?)+\\)/gi;\n\n/**\n * Individual hint patterns for validation\n */\nexport const HINT_PATTERNS: Record<HintType, RegExp> = {\n  role: /role=(?:\"([^\"]+)\"|'([^']+)'|([a-z]+))/i,\n  testid: /testid=(?:\"([^\"]+)\"|'([^']+)'|([a-z0-9_-]+))/i,\n  label: /label=(?:\"([^\"]+)\"|'([^']+)')/i,\n  text: /text=(?:\"([^\"]+)\"|'([^']+)')/i,\n  exact: /exact=(true|false)/i,\n  level: /level=([1-6])/i,\n  signal: /signal=(?:\"([^\"]+)\"|'([^']+)'|([a-z0-9_-]+))/i,\n  module: /module=(?:\"([^\"]+)\"|'([^']+)'|([a-z0-9_.]+))/i,\n  wait: /wait=(networkidle|domcontentloaded|load|commit)/i,\n  timeout: /timeout=(\\d+)/i,\n};\n\n/**\n * Valid ARIA roles for validation\n */\nexport const VALID_ROLES = [\n  'alert',\n  'alertdialog',\n  'application',\n  'article',\n  'banner',\n  'button',\n  'cell',\n  'checkbox',\n  'columnheader',\n  'combobox',\n  'complementary',\n  'contentinfo',\n  'definition',\n  'dialog',\n  'directory',\n  'document',\n  'feed',\n  'figure',\n  'form',\n  'grid',\n  'gridcell',\n  'group',\n  'heading',\n  'img',\n  'link',\n  'list',\n  'listbox',\n  'listitem',\n  'log',\n  'main',\n  'marquee',\n  'math',\n  'menu',\n  'menubar',\n  'menuitem',\n  'menuitemcheckbox',\n  'menuitemradio',\n  'navigation',\n  'none',\n  'note',\n  'option',\n  'presentation',\n  'progressbar',\n  'radio',\n  'radiogroup',\n  'region',\n  'row',\n  'rowgroup',\n  'rowheader',\n  'scrollbar',\n  'search',\n  'searchbox',\n  'separator',\n  'slider',\n  'spinbutton',\n  'status',\n  'switch',\n  'tab',\n  'table',\n  'tablist',\n  'tabpanel',\n  'term',\n  'textbox',\n  'timer',\n  'toolbar',\n  'tooltip',\n  'tree',\n  'treegrid',\n  'treeitem',\n];\n\n/**\n * Check if a role is valid\n */\nexport function isValidRole(role: string): boolean {\n  return VALID_ROLES.includes(role.toLowerCase());\n}\n\n/**\n * Extract hint value from a match (handles quoted and unquoted values)\n */\nexport function extractHintValue(match: RegExpMatchArray): string | null {\n  // Try quoted values first, then unquoted\n  for (let i = 1; i < match.length; i++) {\n    if (match[i] !== undefined) {\n      return match[i] ?? null;\n    }\n  }\n  return null;\n}\n\n/**\n * Check if text contains machine hints\n */\nexport function containsHints(text: string): boolean {\n  // Reset lastIndex for global regex\n  HINTS_SECTION_PATTERN.lastIndex = 0;\n  return HINTS_SECTION_PATTERN.test(text);\n}\n\n/**\n * Remove hints section from step text\n */\nexport function removeHints(text: string): string {\n  return text.replace(HINTS_SECTION_PATTERN, '').trim();\n}\n","/**\n * Machine Hint Parser - Extract hints from Journey step text\n * @see T072 - Implement machine hint parser\n */\nimport {\n  type HintType,\n  type MachineHint,\n  HINT_BLOCK_PATTERN,\n  HINT_PATTERNS,\n  isValidRole,\n  containsHints,\n  removeHints,\n} from './hintPatterns.js';\n\n/**\n * Parsed hints result\n */\nexport interface ParsedHints {\n  /** All parsed hints */\n  hints: MachineHint[];\n  /** Step text with hints removed */\n  cleanText: string;\n  /** Original text */\n  originalText: string;\n  /** Validation warnings */\n  warnings: string[];\n}\n\n/**\n * Locator hints extracted for code generation\n */\nexport interface LocatorHints {\n  /** ARIA role */\n  role?: string;\n  /** Test ID */\n  testid?: string;\n  /** Label text */\n  label?: string;\n  /** Text content */\n  text?: string;\n  /** Exact matching */\n  exact?: boolean;\n  /** Heading level (for role=heading) */\n  level?: number;\n}\n\n/**\n * Behavioral hints extracted for code generation\n */\nexport interface BehaviorHints {\n  /** Signal to wait for */\n  signal?: string;\n  /** Module method to call */\n  module?: string;\n  /** Wait strategy */\n  wait?: 'networkidle' | 'domcontentloaded' | 'load' | 'commit';\n  /** Timeout in ms */\n  timeout?: number;\n}\n\n/**\n * Complete hint extraction result\n */\nexport interface ExtractedHints {\n  /** Locator-related hints */\n  locator: LocatorHints;\n  /** Behavior-related hints */\n  behavior: BehaviorHints;\n  /** Whether any hints were found */\n  hasHints: boolean;\n  /** Clean step text */\n  cleanText: string;\n  /** Warnings */\n  warnings: string[];\n}\n\n/**\n * Parse machine hints from step text\n */\nexport function parseHints(text: string): ParsedHints {\n  const hints: MachineHint[] = [];\n  const warnings: string[] = [];\n\n  if (!containsHints(text)) {\n    return {\n      hints: [],\n      cleanText: text,\n      originalText: text,\n      warnings: [],\n    };\n  }\n\n  // Extract all hint blocks\n  HINT_BLOCK_PATTERN.lastIndex = 0;\n  let match;\n\n  while ((match = HINT_BLOCK_PATTERN.exec(text)) !== null) {\n    const key = match[1]!.toLowerCase() as HintType;\n    const value = match[2] || match[3] || match[4];\n\n    if (!value) {\n      warnings.push(`Empty value for hint: ${key}`);\n      continue;\n    }\n\n    // Validate the hint type\n    if (!(key in HINT_PATTERNS)) {\n      warnings.push(`Unknown hint type: ${key}`);\n      continue;\n    }\n\n    // Validate role values\n    if (key === 'role' && !isValidRole(value)) {\n      warnings.push(`Invalid ARIA role: ${value}`);\n    }\n\n    hints.push({\n      type: key,\n      value,\n      raw: match[0],\n    });\n  }\n\n  return {\n    hints,\n    cleanText: removeHints(text),\n    originalText: text,\n    warnings,\n  };\n}\n\n/**\n * Extract structured hints for code generation\n */\nexport function extractHints(text: string): ExtractedHints {\n  const parsed = parseHints(text);\n\n  const locator: LocatorHints = {};\n  const behavior: BehaviorHints = {};\n\n  for (const hint of parsed.hints) {\n    switch (hint.type) {\n      case 'role':\n        locator.role = hint.value;\n        break;\n      case 'testid':\n        locator.testid = hint.value;\n        break;\n      case 'label':\n        locator.label = hint.value;\n        break;\n      case 'text':\n        locator.text = hint.value;\n        break;\n      case 'exact':\n        locator.exact = hint.value.toLowerCase() === 'true';\n        break;\n      case 'level':\n        locator.level = parseInt(hint.value, 10);\n        break;\n      case 'signal':\n        behavior.signal = hint.value;\n        break;\n      case 'module':\n        behavior.module = hint.value;\n        break;\n      case 'wait':\n        behavior.wait = hint.value as BehaviorHints['wait'];\n        break;\n      case 'timeout':\n        behavior.timeout = parseInt(hint.value, 10);\n        break;\n    }\n  }\n\n  return {\n    locator,\n    behavior,\n    hasHints: parsed.hints.length > 0,\n    cleanText: parsed.cleanText,\n    warnings: parsed.warnings,\n  };\n}\n\n/**\n * Check if hints specify a locator strategy\n */\nexport function hasLocatorHints(hints: ExtractedHints): boolean {\n  const { locator } = hints;\n  return !!(locator.role || locator.testid || locator.label || locator.text);\n}\n\n/**\n * Check if hints specify behavioral modifications\n */\nexport function hasBehaviorHints(hints: ExtractedHints): boolean {\n  const { behavior } = hints;\n  return !!(behavior.signal || behavior.module || behavior.wait || behavior.timeout);\n}\n\n/**\n * Generate locator code from hints\n */\nexport function generateLocatorFromHints(hints: LocatorHints): string | null {\n  // Priority: testid > role > label > text\n  if (hints.testid) {\n    return `page.getByTestId('${hints.testid}')`;\n  }\n\n  if (hints.role) {\n    const options: string[] = [];\n    if (hints.label) {\n      options.push(`name: '${hints.label}'`);\n    }\n    if (hints.exact) {\n      options.push('exact: true');\n    }\n    if (hints.level && hints.role === 'heading') {\n      options.push(`level: ${hints.level}`);\n    }\n\n    if (options.length > 0) {\n      return `page.getByRole('${hints.role}', { ${options.join(', ')} })`;\n    }\n    return `page.getByRole('${hints.role}')`;\n  }\n\n  if (hints.label) {\n    if (hints.exact) {\n      return `page.getByLabel('${hints.label}', { exact: true })`;\n    }\n    return `page.getByLabel('${hints.label}')`;\n  }\n\n  if (hints.text) {\n    if (hints.exact) {\n      return `page.getByText('${hints.text}', { exact: true })`;\n    }\n    return `page.getByText('${hints.text}')`;\n  }\n\n  return null;\n}\n\n/**\n * Parse module hint into module name and method\n */\nexport function parseModuleHint(moduleHint: string): { module: string; method: string } | null {\n  const parts = moduleHint.split('.');\n  if (parts.length !== 2) {\n    return null;\n  }\n  return {\n    module: parts[0]!,\n    method: parts[1]!,\n  };\n}\n\n/**\n * Validate hints for consistency\n */\nexport function validateHints(hints: ExtractedHints): string[] {\n  const errors: string[] = [];\n\n  // Check for conflicting locator hints\n  const locatorCount = [\n    hints.locator.testid,\n    hints.locator.role,\n    hints.locator.label && !hints.locator.role, // label with role is fine\n    hints.locator.text,\n  ].filter(Boolean).length;\n\n  if (locatorCount > 1) {\n    errors.push('Multiple conflicting locator hints specified');\n  }\n\n  // Check for level without heading role\n  if (hints.locator.level && hints.locator.role !== 'heading') {\n    errors.push('level hint only applies to role=heading');\n  }\n\n  // Check for module hint format\n  if (hints.behavior.module) {\n    const parsed = parseModuleHint(hints.behavior.module);\n    if (!parsed) {\n      errors.push('module hint must be in format: moduleName.methodName');\n    }\n  }\n\n  return errors;\n}\n\n/**\n * Merge hints with inferred locator (hints take priority)\n */\nexport function mergeWithInferred(\n  hints: LocatorHints,\n  inferred: { strategy: string; value: string }\n): { strategy: string; value: string; options?: Record<string, unknown> } {\n  // If hints specify a locator, use it\n  if (hints.testid) {\n    return { strategy: 'testid', value: hints.testid };\n  }\n\n  if (hints.role) {\n    const options: Record<string, unknown> = {};\n    if (hints.label) {\n      options.name = hints.label;\n    }\n    if (hints.exact) {\n      options.exact = true;\n    }\n    if (hints.level) {\n      options.level = hints.level;\n    }\n    return { strategy: 'role', value: hints.role, options };\n  }\n\n  if (hints.label) {\n    const options: Record<string, unknown> = {};\n    if (hints.exact) {\n      options.exact = true;\n    }\n    return { strategy: 'label', value: hints.label, options };\n  }\n\n  if (hints.text) {\n    const options: Record<string, unknown> = {};\n    if (hints.exact) {\n      options.exact = true;\n    }\n    return { strategy: 'text', value: hints.text, options };\n  }\n\n  // Add exact option to inferred if specified\n  if (hints.exact) {\n    return { ...inferred, options: { exact: true } };\n  }\n\n  // Fall back to inferred\n  return inferred;\n}\n","/**\n * Step Mapper - Convert step text to IR primitives\n * @see research/2026-01-02_autogen-refined-plan.md Section 10\n * @see T073 - Update step mapper to prioritize explicit hints over inference\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md Phase 4 - LLKB integration\n */\nimport type {\n  IRPrimitive,\n  IRStep,\n  LocatorSpec,\n} from '../ir/types.js';\nimport type { AcceptanceCriterion, ProceduralStep } from '../journey/parseJourney.js';\nimport { matchPattern } from './patterns.js';\nimport { normalizeStepText } from './glossary.js';\nimport {\n  extractHints,\n  hasLocatorHints,\n  hasBehaviorHints,\n  parseModuleHint,\n  type ExtractedHints,\n} from '../journey/parseHints.js';\n\n// LLKB integration types - imported dynamically to avoid hard dependency\ntype LlkbPatternMatch = {\n  patternId: string;\n  primitive: IRPrimitive;\n  confidence: number;\n};\n\n// LLKB module reference - loaded lazily\nlet llkbModule: {\n  matchLlkbPattern: (text: string, options?: { llkbRoot?: string; minConfidence?: number }) => LlkbPatternMatch | null;\n  recordPatternSuccess: (text: string, primitive: IRPrimitive, journeyId: string, options?: { llkbRoot?: string }) => void;\n} | null = null;\n\n// Track if we've attempted to load LLKB\nlet llkbLoadAttempted = false;\n\n/**\n * Lazily load LLKB module (graceful degradation if not available)\n */\nasync function loadLlkbModule(): Promise<typeof llkbModule> {\n  if (llkbLoadAttempted) return llkbModule;\n  llkbLoadAttempted = true;\n\n  try {\n    const mod = await import('../llkb/patternExtension.js');\n    llkbModule = {\n      matchLlkbPattern: mod.matchLlkbPattern,\n      recordPatternSuccess: mod.recordPatternSuccess,\n    };\n  } catch {\n    // LLKB not available - this is fine, graceful degradation\n    llkbModule = null;\n  }\n\n  return llkbModule;\n}\n\n/**\n * Synchronously check LLKB (for non-async contexts)\n * Uses previously loaded module if available\n */\nfunction tryLlkbMatch(text: string, options?: { llkbRoot?: string; minConfidence?: number }): LlkbPatternMatch | null {\n  if (!llkbModule) return null;\n  return llkbModule.matchLlkbPattern(text, options);\n}\n\n/**\n * Options for step mapping\n */\nexport interface StepMapperOptions {\n  /** Whether to normalize text before matching */\n  normalizeText?: boolean;\n  /** Whether to include blocked steps for unmatched text */\n  includeBlocked?: boolean;\n  /** Default timeout for assertions */\n  defaultTimeout?: number;\n  /** Whether to use LLKB patterns as fallback (default: true) */\n  useLlkb?: boolean;\n  /** LLKB root directory (default: .artk/llkb) */\n  llkbRoot?: string;\n  /** Minimum confidence for LLKB pattern matches (default: 0.7) */\n  llkbMinConfidence?: number;\n  /** Journey ID for LLKB recording (optional) */\n  journeyId?: string;\n}\n\n/**\n * Result of mapping a single step\n */\nexport interface StepMappingResult {\n  /** The parsed primitive, or null if not matched */\n  primitive: IRPrimitive | null;\n  /** Original text that was mapped */\n  sourceText: string;\n  /** Whether this is an assertion (expect*) or action */\n  isAssertion: boolean;\n  /** Warning or error message if any */\n  message?: string;\n  /** Source of the match */\n  matchSource?: 'pattern' | 'llkb' | 'hints' | 'none';\n  /** LLKB pattern ID if matched via LLKB */\n  llkbPatternId?: string;\n  /** LLKB match confidence if matched via LLKB */\n  llkbConfidence?: number;\n}\n\n/**\n * Result of mapping an acceptance criterion\n */\nexport interface ACMappingResult {\n  /** The mapped IR step */\n  step: IRStep;\n  /** Individual step mapping results */\n  mappings: StepMappingResult[];\n  /** Number of successfully mapped steps */\n  mappedCount: number;\n  /** Number of blocked/unmatched steps */\n  blockedCount: number;\n}\n\n/**\n * Check if a primitive is an assertion\n */\nfunction isAssertion(primitive: IRPrimitive): boolean {\n  return primitive.type.startsWith('expect');\n}\n\n/**\n * Map a single text step to an IR primitive\n */\nexport function mapStepText(\n  text: string,\n  options: StepMapperOptions = {}\n): StepMappingResult {\n  const {\n    normalizeText = true,\n    useLlkb = true,\n    llkbRoot,\n    llkbMinConfidence = 0.7,\n  } = options;\n\n  // Extract machine hints first (T073 - hints take priority)\n  const hints = extractHints(text);\n  const cleanText = hints.hasHints ? hints.cleanText : text;\n\n  // Normalize text if enabled\n  const processedText = normalizeText ? normalizeStepText(cleanText) : cleanText;\n\n  // Try to match against core patterns first\n  let primitive = matchPattern(processedText);\n  let matchSource: 'pattern' | 'llkb' | 'hints' | 'none' = primitive ? 'pattern' : 'none';\n\n  // If we have hints, enhance or override the primitive\n  if (primitive && hints.hasHints) {\n    primitive = applyHintsToPrimitive(primitive, hints);\n  }\n\n  // If no core pattern match, try LLKB patterns (Phase 4 integration)\n  let llkbPatternId: string | undefined;\n  let llkbConfidence: number | undefined;\n\n  if (!primitive && useLlkb) {\n    const llkbMatch = tryLlkbMatch(processedText, {\n      llkbRoot,\n      minConfidence: llkbMinConfidence,\n    });\n\n    if (llkbMatch) {\n      primitive = llkbMatch.primitive;\n      matchSource = 'llkb';\n      llkbPatternId = llkbMatch.patternId;\n      llkbConfidence = llkbMatch.confidence;\n\n      // Apply hints to LLKB-matched primitive if available\n      if (hints.hasHints) {\n        primitive = applyHintsToPrimitive(primitive, hints);\n      }\n    }\n  }\n\n  // If still no match but we have locator hints, try to create primitive from hints\n  if (!primitive && hasLocatorHints(hints)) {\n    primitive = createPrimitiveFromHints(processedText, hints);\n    if (primitive) {\n      matchSource = 'hints';\n    }\n  }\n\n  if (primitive) {\n    return {\n      primitive,\n      sourceText: text,\n      isAssertion: isAssertion(primitive),\n      matchSource,\n      llkbPatternId,\n      llkbConfidence,\n    };\n  }\n\n  // No match - return blocked\n  return {\n    primitive: null,\n    sourceText: text,\n    isAssertion: false,\n    message: `Could not map step: \"${text}\"`,\n    matchSource: 'none',\n  };\n}\n\n/**\n * Apply hints to an existing primitive (override inferred values)\n */\nfunction applyHintsToPrimitive(primitive: IRPrimitive, hints: ExtractedHints): IRPrimitive {\n  // Clone the primitive to avoid mutation\n  const enhanced = { ...primitive };\n\n  // Apply locator hints if present\n  if (hasLocatorHints(hints)) {\n    const locatorSpec = buildLocatorFromHints(hints);\n    if (locatorSpec && 'locator' in enhanced) {\n      (enhanced as { locator: LocatorSpec }).locator = locatorSpec;\n    }\n  }\n\n  // Apply behavior hints\n  if (hasBehaviorHints(hints)) {\n    if (hints.behavior.timeout !== undefined && 'timeout' in enhanced) {\n      (enhanced as { timeout: number }).timeout = hints.behavior.timeout;\n    }\n    if (hints.behavior.signal && 'signal' in enhanced) {\n      (enhanced as { signal: string }).signal = hints.behavior.signal;\n    }\n    if (hints.behavior.module) {\n      const parsed = parseModuleHint(hints.behavior.module);\n      if (parsed) {\n        (enhanced as { module?: string; method?: string }).module = parsed.module;\n        (enhanced as { module?: string; method?: string }).method = parsed.method;\n      }\n    }\n  }\n\n  return enhanced;\n}\n\n/**\n * Build LocatorSpec from hints\n */\nfunction buildLocatorFromHints(hints: ExtractedHints): LocatorSpec | null {\n  const { locator } = hints;\n\n  if (locator.testid) {\n    return { strategy: 'testid', value: locator.testid };\n  }\n\n  if (locator.role) {\n    const options: Record<string, unknown> = {};\n    if (locator.label) options.name = locator.label;\n    if (locator.exact) options.exact = true;\n    if (locator.level) options.level = locator.level;\n    return {\n      strategy: 'role',\n      value: locator.role,\n      options: Object.keys(options).length > 0 ? options : undefined,\n    };\n  }\n\n  if (locator.label) {\n    return {\n      strategy: 'label',\n      value: locator.label,\n      options: locator.exact ? { exact: true } : undefined,\n    };\n  }\n\n  if (locator.text) {\n    return {\n      strategy: 'text',\n      value: locator.text,\n      options: locator.exact ? { exact: true } : undefined,\n    };\n  }\n\n  return null;\n}\n\n/**\n * Create a primitive from hints when no pattern matched\n */\nfunction createPrimitiveFromHints(text: string, hints: ExtractedHints): IRPrimitive | null {\n  const locator = buildLocatorFromHints(hints);\n  if (!locator) return null;\n\n  const lowerText = text.toLowerCase();\n\n  // Infer action type from text\n  if (lowerText.includes('click') || lowerText.includes('press')) {\n    return { type: 'click', locator };\n  }\n\n  if (lowerText.includes('enter') || lowerText.includes('type') || lowerText.includes('fill')) {\n    // Try to extract value from text\n    const valueMatch = text.match(/['\"]([^'\"]+)['\"]/);\n    return {\n      type: 'fill',\n      locator,\n      value: { type: 'literal', value: valueMatch ? valueMatch[1]! : '' },\n    };\n  }\n\n  if (lowerText.includes('see') || lowerText.includes('visible') || lowerText.includes('display')) {\n    return { type: 'expectVisible', locator };\n  }\n\n  if (lowerText.includes('check') || lowerText.includes('select')) {\n    return { type: 'check', locator };\n  }\n\n  // Default to click if we have a locator but can't determine action\n  return { type: 'click', locator };\n}\n\n/**\n * Map an acceptance criterion to an IR step\n */\nexport function mapAcceptanceCriterion(\n  ac: AcceptanceCriterion,\n  proceduralSteps: ProceduralStep[],\n  options: StepMapperOptions = {}\n): ACMappingResult {\n  const { includeBlocked = true } = options;\n\n  const actions: IRPrimitive[] = [];\n  const assertions: IRPrimitive[] = [];\n  const mappings: StepMappingResult[] = [];\n  const notes: string[] = [];\n\n  // Find procedural steps linked to this AC\n  const linkedProcedural = proceduralSteps.filter((ps) => ps.linkedAC === ac.id);\n\n  // Map all bullet points from the AC\n  for (const stepText of ac.steps) {\n    const result = mapStepText(stepText, options);\n    mappings.push(result);\n\n    if (result.primitive) {\n      if (result.isAssertion) {\n        assertions.push(result.primitive);\n      } else {\n        actions.push(result.primitive);\n      }\n    } else if (includeBlocked) {\n      actions.push({\n        type: 'blocked',\n        reason: result.message || 'Could not map step',\n        sourceText: stepText,\n      });\n    }\n  }\n\n  // Also map linked procedural steps\n  for (const ps of linkedProcedural) {\n    const result = mapStepText(ps.text, options);\n    // Don't duplicate in mappings, but add to actions if different from AC steps\n    if (result.primitive && !ac.steps.includes(ps.text)) {\n      if (result.isAssertion) {\n        assertions.push(result.primitive);\n      } else {\n        actions.push(result.primitive);\n      }\n    }\n  }\n\n  // Add note if no assertions\n  if (assertions.length === 0 && ac.title) {\n    notes.push(`TODO: Add assertion for: ${ac.title}`);\n  }\n\n  const step: IRStep = {\n    id: ac.id,\n    description: ac.title || `Step ${ac.id}`,\n    actions,\n    assertions,\n    sourceText: ac.rawContent,\n    notes: notes.length > 0 ? notes : undefined,\n  };\n\n  return {\n    step,\n    mappings,\n    mappedCount: mappings.filter((m) => m.primitive !== null).length,\n    blockedCount: mappings.filter((m) => m.primitive === null).length,\n  };\n}\n\n/**\n * Map a procedural step to an IR step\n */\nexport function mapProceduralStep(\n  ps: ProceduralStep,\n  options: StepMapperOptions = {}\n): ACMappingResult {\n  const { includeBlocked = true } = options;\n\n  const result = mapStepText(ps.text, options);\n  const actions: IRPrimitive[] = [];\n  const assertions: IRPrimitive[] = [];\n\n  if (result.primitive) {\n    if (result.isAssertion) {\n      assertions.push(result.primitive);\n    } else {\n      actions.push(result.primitive);\n    }\n  } else if (includeBlocked) {\n    actions.push({\n      type: 'blocked',\n      reason: result.message || 'Could not map procedural step',\n      sourceText: ps.text,\n    });\n  }\n\n  const step: IRStep = {\n    id: `PS-${ps.number}`,\n    description: ps.text,\n    actions,\n    assertions,\n  };\n\n  return {\n    step,\n    mappings: [result],\n    mappedCount: result.primitive ? 1 : 0,\n    blockedCount: result.primitive ? 0 : 1,\n  };\n}\n\n/**\n * Batch map multiple steps\n */\nexport function mapSteps(\n  steps: string[],\n  options: StepMapperOptions = {}\n): StepMappingResult[] {\n  return steps.map((step) => mapStepText(step, options));\n}\n\n/**\n * Get mapping statistics (enhanced with LLKB stats)\n */\nexport function getMappingStats(mappings: StepMappingResult[]): {\n  total: number;\n  mapped: number;\n  blocked: number;\n  actions: number;\n  assertions: number;\n  mappingRate: number;\n  /** Steps matched by core patterns */\n  patternMatches: number;\n  /** Steps matched by LLKB patterns */\n  llkbMatches: number;\n  /** Steps matched by hints */\n  hintMatches: number;\n} {\n  const mapped = mappings.filter((m) => m.primitive !== null);\n  const blocked = mappings.filter((m) => m.primitive === null);\n  const actions = mapped.filter((m) => !m.isAssertion);\n  const assertions = mapped.filter((m) => m.isAssertion);\n\n  const patternMatches = mappings.filter((m) => m.matchSource === 'pattern').length;\n  const llkbMatches = mappings.filter((m) => m.matchSource === 'llkb').length;\n  const hintMatches = mappings.filter((m) => m.matchSource === 'hints').length;\n\n  return {\n    total: mappings.length,\n    mapped: mapped.length,\n    blocked: blocked.length,\n    actions: actions.length,\n    assertions: assertions.length,\n    mappingRate: mappings.length > 0 ? mapped.length / mappings.length : 0,\n    patternMatches,\n    llkbMatches,\n    hintMatches,\n  };\n}\n\n/**\n * Initialize LLKB module for use with step mapping\n * Call this once at the start of generation to enable LLKB patterns\n */\nexport async function initializeLlkb(): Promise<boolean> {\n  const mod = await loadLlkbModule();\n  return mod !== null;\n}\n\n/**\n * Check if LLKB is available for use\n */\nexport function isLlkbAvailable(): boolean {\n  return llkbModule !== null;\n}\n\n/**\n * Suggest improvements for blocked steps\n */\nexport function suggestImprovements(blockedSteps: StepMappingResult[]): string[] {\n  const suggestions: string[] = [];\n\n  for (const step of blockedSteps) {\n    const text = step.sourceText.toLowerCase();\n\n    // Navigation suggestions\n    if (text.includes('go') || text.includes('open') || text.includes('navigate')) {\n      suggestions.push(\n        `\"${step.sourceText}\" - Try: \"User navigates to /path\" or \"User opens /path\"`\n      );\n    }\n    // Click suggestions\n    else if (text.includes('click') || text.includes('press') || text.includes('button')) {\n      suggestions.push(\n        `\"${step.sourceText}\" - Try: \"User clicks 'Button Name' button\" or \"Click the 'Label' button\"`\n      );\n    }\n    // Fill suggestions\n    else if (text.includes('enter') || text.includes('type') || text.includes('field')) {\n      suggestions.push(\n        `\"${step.sourceText}\" - Try: \"User enters 'value' in 'Field Label' field\"`\n      );\n    }\n    // Visibility suggestions\n    else if (text.includes('see') || text.includes('visible') || text.includes('display')) {\n      suggestions.push(\n        `\"${step.sourceText}\" - Try: \"User should see 'Text'\" or \"'Element' is visible\"`\n      );\n    }\n    // Generic suggestion\n    else {\n      suggestions.push(\n        `\"${step.sourceText}\" - Could not determine intent. Check the patterns documentation.`\n      );\n    }\n  }\n\n  return suggestions;\n}\n","/**\n * Pattern distance calculation for finding nearest matching patterns\n */\n\nimport type { StepPattern } from './patterns.js';\n\n/**\n * Extended pattern definition with examples for distance calculation\n */\nexport interface PatternDefinition extends StepPattern {\n  examples?: string[];\n  requiredKeywords?: string[];\n}\n\nexport interface NearestPatternResult {\n  name: string;\n  distance: number;\n  exampleMatch: string;\n  mismatchReason: string;\n}\n\n/**\n * Calculate Levenshtein distance between two strings\n */\nexport function levenshteinDistance(a: string, b: string): number {\n  const matrix: number[][] = [];\n\n  for (let i = 0; i <= b.length; i++) {\n    matrix[i] = [i];\n  }\n\n  for (let j = 0; j <= a.length; j++) {\n    matrix[0]![j] = j;\n  }\n\n  for (let i = 1; i <= b.length; i++) {\n    for (let j = 1; j <= a.length; j++) {\n      if (b.charAt(i - 1) === a.charAt(j - 1)) {\n        matrix[i]![j] = matrix[i - 1]![j - 1]!;\n      } else {\n        matrix[i]![j] = Math.min(\n          matrix[i - 1]![j - 1]! + 1, // substitution\n          matrix[i]![j - 1]! + 1,     // insertion\n          matrix[i - 1]![j]! + 1      // deletion\n        );\n      }\n    }\n  }\n\n  return matrix[b.length]![a.length]!;\n}\n\n/**\n * Calculate normalized similarity between two strings (0-1)\n */\nexport function calculateSimilarity(a: string, b: string): number {\n  const distance = levenshteinDistance(a.toLowerCase(), b.toLowerCase());\n  const maxLength = Math.max(a.length, b.length);\n  if (maxLength === 0) return 1;\n  return 1 - distance / maxLength;\n}\n\n/**\n * Extract example text from a regex pattern\n * This is a heuristic - it tries to create a plausible example from the regex\n */\nfunction generateExampleFromRegex(regex: RegExp, patternName: string): string {\n  // Reserved for future regex-based example generation\n  void regex.source;\n\n  // Navigation patterns\n  if (patternName.includes('navigate')) {\n    return 'User navigates to /path';\n  }\n\n  // Click patterns\n  if (patternName.includes('click')) {\n    return 'User clicks \"Button\" button';\n  }\n\n  // Fill patterns\n  if (patternName.includes('fill') || patternName.includes('enter') || patternName.includes('type')) {\n    return 'User enters \"value\" in \"Field\" field';\n  }\n\n  // Assertion patterns\n  if (patternName.includes('see') || patternName.includes('visible') || patternName.includes('expect')) {\n    return 'User should see \"Content\"';\n  }\n\n  // Wait patterns\n  if (patternName.includes('wait')) {\n    return 'Wait for network idle';\n  }\n\n  // Generic fallback\n  return `Step matching ${patternName}`;\n}\n\n/**\n * Find the nearest pattern for a given step text\n */\nexport function findNearestPattern(\n  text: string,\n  patterns: Map<string, PatternDefinition> | StepPattern[]\n): NearestPatternResult | null {\n  let nearest: NearestPatternResult | null = null;\n  let minDistance = Infinity;\n\n  const normalizedText = text.toLowerCase().trim();\n\n  // Convert to array if it's a Map\n  const patternArray: Array<[string, PatternDefinition | StepPattern]> =\n    patterns instanceof Map\n      ? Array.from(patterns.entries())\n      : patterns.map(p => [p.name, p] as [string, PatternDefinition | StepPattern]);\n\n  for (const [name, pattern] of patternArray) {\n    // Get examples - either from PatternDefinition or generate from regex\n    const examples = 'examples' in pattern && pattern.examples\n      ? pattern.examples\n      : [generateExampleFromRegex(pattern.regex, pattern.name)];\n\n    // Compare against pattern examples\n    for (const example of examples) {\n      const distance = levenshteinDistance(normalizedText, example.toLowerCase());\n      if (distance < minDistance) {\n        minDistance = distance;\n        nearest = {\n          name,\n          distance,\n          exampleMatch: example,\n          mismatchReason: explainMismatch(text, pattern),\n        };\n      }\n    }\n  }\n\n  // Only return if similarity is above threshold (> 50%)\n  if (nearest && nearest.exampleMatch) {\n    const similarity = calculateSimilarity(text, nearest.exampleMatch);\n    if (similarity > 0.5) {\n      return nearest;\n    }\n  }\n\n  return nearest;\n}\n\n/**\n * Explain why a pattern didn't match\n */\nexport function explainMismatch(text: string, pattern: StepPattern | PatternDefinition): string {\n  const reasons: string[] = [];\n  const lowerText = text.toLowerCase();\n\n  // Check for missing keywords based on pattern type\n  const requiredKeywords = 'requiredKeywords' in pattern\n    ? pattern.requiredKeywords\n    : inferRequiredKeywords(pattern);\n\n  if (requiredKeywords) {\n    const missing = requiredKeywords.filter(\n      kw => !lowerText.includes(kw.toLowerCase())\n    );\n    if (missing.length > 0) {\n      reasons.push(`Missing keywords: ${missing.join(', ')}`);\n    }\n  }\n\n  // Check for missing locator hints\n  if (!text.includes('(') && !text.includes('testid=') && !text.includes('role=')) {\n    reasons.push('Missing locator hint (e.g., testid=..., role=button)');\n  }\n\n  // Check for ambiguous target based on pattern type\n  if (pattern.primitiveType === 'click' && !text.match(/['\"].+?['\"]/)) {\n    reasons.push('Target element name not quoted');\n  }\n\n  return reasons.length > 0 ? reasons.join('; ') : 'Pattern format mismatch';\n}\n\n/**\n * Infer required keywords from a pattern\n */\nfunction inferRequiredKeywords(pattern: StepPattern): string[] | undefined {\n  const name = pattern.name.toLowerCase();\n\n  if (name.includes('navigate')) {\n    return ['navigate', 'go', 'open'];\n  }\n\n  if (name.includes('click')) {\n    return ['click', 'press', 'tap'];\n  }\n\n  if (name.includes('fill') || name.includes('enter')) {\n    return ['enter', 'type', 'fill', 'input'];\n  }\n\n  if (name.includes('see') || name.includes('visible')) {\n    return ['see', 'visible', 'shown'];\n  }\n\n  if (name.includes('wait')) {\n    return ['wait'];\n  }\n\n  return undefined;\n}\n","/**\n * Enhanced analysis of blocked steps for AI-assisted fixing\n */\n\nimport { findNearestPattern, type NearestPatternResult, type PatternDefinition } from './patternDistance.js';\nimport type { StepPattern } from './patterns.js';\n\nexport type StepCategory = 'navigation' | 'interaction' | 'assertion' | 'wait' | 'unknown';\n\nexport interface StepSuggestion {\n  priority: number;\n  text: string;\n  explanation: string;\n  confidence: number;\n}\n\nexport interface BlockedStepAnalysis {\n  step: string;\n  reason: string;\n  suggestions: StepSuggestion[];\n  nearestPattern?: NearestPatternResult;\n  machineHintSuggestion?: string;\n  category: StepCategory;\n}\n\n/**\n * Categorize a step based on its text\n */\nexport function categorizeStep(text: string): StepCategory {\n  const lowerText = text.toLowerCase();\n\n  if (lowerText.includes('navigate') || lowerText.includes('go to') ||\n      lowerText.includes('open') || lowerText.includes('visit')) {\n    return 'navigation';\n  }\n\n  if (lowerText.includes('click') || lowerText.includes('fill') ||\n      lowerText.includes('enter') || lowerText.includes('type') ||\n      lowerText.includes('select') || lowerText.includes('check') ||\n      lowerText.includes('press')) {\n    return 'interaction';\n  }\n\n  if (lowerText.includes('see') || lowerText.includes('visible') ||\n      lowerText.includes('verify') || lowerText.includes('assert') ||\n      lowerText.includes('confirm') || lowerText.includes('should') ||\n      lowerText.includes('expect')) {\n    return 'assertion';\n  }\n\n  if (lowerText.includes('wait') || lowerText.includes('load') ||\n      lowerText.includes('until') || lowerText.includes('appear')) {\n    return 'wait';\n  }\n\n  return 'unknown';\n}\n\n/**\n * Infer a machine hint from step text\n */\nexport function inferMachineHint(text: string): string | undefined {\n  const lowerText = text.toLowerCase();\n\n  // Extract element name from quotes\n  const quotedMatch = text.match(/['\"]([^'\"]+)['\"]/);\n  const elementName = quotedMatch?.[1];\n\n  if (!elementName) return undefined;\n\n  // Suggest hint based on context (check more specific terms first)\n  if (lowerText.includes('link')) {\n    return `(role=link, name=${elementName})`;\n  }\n\n  if (lowerText.includes('button') || lowerText.includes('click')) {\n    return `(role=button, name=${elementName})`;\n  }\n\n  if (lowerText.includes('field') || lowerText.includes('input') ||\n      lowerText.includes('enter') || lowerText.includes('type')) {\n    return `(role=textbox, name=${elementName})`;\n  }\n\n  if (lowerText.includes('heading')) {\n    return `(role=heading, name=${elementName})`;\n  }\n\n  if (lowerText.includes('checkbox')) {\n    return `(role=checkbox, name=${elementName})`;\n  }\n\n  return `(text=${elementName})`;\n}\n\n/**\n * Get suggestions for navigation steps\n */\nexport function getNavigationSuggestions(text: string): StepSuggestion[] {\n  const suggestions: StepSuggestion[] = [];\n  const urlMatch = text.match(/\\/[a-zA-Z0-9/_-]+/);\n\n  if (urlMatch) {\n    suggestions.push({\n      priority: 1,\n      text: `User navigates to ${urlMatch[0]}`,\n      explanation: 'Standard navigation pattern',\n      confidence: 0.9,\n    });\n  } else {\n    suggestions.push({\n      priority: 1,\n      text: 'User navigates to /[path]',\n      explanation: 'Add explicit URL path',\n      confidence: 0.5,\n    });\n  }\n\n  return suggestions;\n}\n\n/**\n * Get suggestions for interaction steps\n */\nexport function getInteractionSuggestions(text: string): StepSuggestion[] {\n  const suggestions: StepSuggestion[] = [];\n  const quotedMatch = text.match(/['\"]([^'\"]+)['\"]/);\n  const elementName = quotedMatch?.[1] || '[element]';\n  const lowerText = text.toLowerCase();\n\n  if (lowerText.includes('click')) {\n    suggestions.push({\n      priority: 1,\n      text: `User clicks '${elementName}' button \\`(role=button, name=${elementName})\\``,\n      explanation: 'Add role=button locator hint',\n      confidence: 0.85,\n    });\n  }\n\n  if (lowerText.includes('fill') || lowerText.includes('enter') ||\n      lowerText.includes('type')) {\n    // Try to extract value being entered\n    const valueMatch = text.match(/['\"]([^'\"]+)['\"]/);\n    const value = valueMatch?.[1] || 'value';\n    suggestions.push({\n      priority: 1,\n      text: `User enters '${value}' in '${elementName}' field \\`(role=textbox, name=${elementName})\\``,\n      explanation: 'Add role=textbox locator hint',\n      confidence: 0.85,\n    });\n  }\n\n  return suggestions;\n}\n\n/**\n * Get suggestions for assertion steps\n */\nexport function getAssertionSuggestions(text: string): StepSuggestion[] {\n  const suggestions: StepSuggestion[] = [];\n  const quotedMatch = text.match(/['\"]([^'\"]+)['\"]/);\n  const content = quotedMatch?.[1] || '[content]';\n\n  suggestions.push({\n    priority: 1,\n    text: `User should see '${content}' \\`(text=${content})\\``,\n    explanation: 'Standard visibility assertion',\n    confidence: 0.8,\n  });\n\n  suggestions.push({\n    priority: 2,\n    text: `**Assert**: '${content}' is visible \\`(role=heading, name=${content})\\``,\n    explanation: 'Structured assertion format with heading role',\n    confidence: 0.7,\n  });\n\n  return suggestions;\n}\n\n/**\n * Get suggestions for wait steps\n */\nexport function getWaitSuggestions(_text: string): StepSuggestion[] {\n  const suggestions: StepSuggestion[] = [];\n\n  suggestions.push({\n    priority: 1,\n    text: 'Wait for network idle `(signal=networkidle)`',\n    explanation: 'Standard network wait pattern',\n    confidence: 0.8,\n  });\n\n  suggestions.push({\n    priority: 2,\n    text: 'Wait for page to load `(signal=load)`',\n    explanation: 'Wait for load event',\n    confidence: 0.7,\n  });\n\n  return suggestions;\n}\n\n/**\n * Get generic suggestions for unknown step categories\n */\nexport function getGenericSuggestions(text: string): StepSuggestion[] {\n  return [{\n    priority: 1,\n    text: `**Action**: ${text}`,\n    explanation: 'Use structured format with Action prefix',\n    confidence: 0.5,\n  }];\n}\n\n/**\n * Analyze a blocked step and generate suggestions\n */\nexport function analyzeBlockedStep(\n  step: string,\n  reason: string,\n  patterns?: Map<string, PatternDefinition> | StepPattern[]\n): BlockedStepAnalysis {\n  const category = categorizeStep(step);\n\n  const analysis: BlockedStepAnalysis = {\n    step,\n    reason,\n    suggestions: [],\n    category,\n  };\n\n  // Find nearest pattern if patterns provided\n  if (patterns) {\n    const nearest = findNearestPattern(step, patterns);\n    if (nearest) {\n      analysis.nearestPattern = nearest;\n    }\n  }\n\n  // Generate category-specific suggestions\n  switch (category) {\n    case 'navigation':\n      analysis.suggestions = getNavigationSuggestions(step);\n      break;\n    case 'interaction':\n      analysis.suggestions = getInteractionSuggestions(step);\n      analysis.machineHintSuggestion = inferMachineHint(step);\n      break;\n    case 'assertion':\n      analysis.suggestions = getAssertionSuggestions(step);\n      break;\n    case 'wait':\n      analysis.suggestions = getWaitSuggestions(step);\n      break;\n    default:\n      analysis.suggestions = getGenericSuggestions(step);\n  }\n\n  return analysis;\n}\n\n/**\n * Format a blocked step analysis for console output\n */\nexport function formatBlockedStepAnalysis(analysis: BlockedStepAnalysis): string {\n  const lines: string[] = [];\n\n  lines.push(`\\n  Step: \"${analysis.step}\"`);\n  lines.push(`  Category: ${analysis.category}`);\n  lines.push(`  Reason: ${analysis.reason}`);\n\n  if (analysis.nearestPattern) {\n    lines.push(`  Nearest pattern: ${analysis.nearestPattern.name}`);\n    lines.push(`  Example that works: \"${analysis.nearestPattern.exampleMatch}\"`);\n    lines.push(`  Why it didn't match: ${analysis.nearestPattern.mismatchReason}`);\n  }\n\n  lines.push('  Suggestions:');\n  for (const suggestion of analysis.suggestions) {\n    lines.push(`    ${suggestion.priority}. ${suggestion.text}`);\n    lines.push(`       (${suggestion.explanation}, confidence: ${(suggestion.confidence * 100).toFixed(0)}%)`);\n  }\n\n  if (analysis.machineHintSuggestion) {\n    lines.push(`  Suggested hint: ${analysis.machineHintSuggestion}`);\n  }\n\n  return lines.join('\\n');\n}\n","/**\n * Mapping module exports\n */\nexport * from './patterns.js';\nexport * from './glossary.js';\nexport * from './stepMapper.js';\nexport * from './patternDistance.js';\nexport * from './blockedStepAnalysis.js';\nexport * from './telemetry.js';\n"]}
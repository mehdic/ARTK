{"version":3,"sources":["../../src/mapping/patterns.ts","../../src/mapping/glossary.ts","../../src/journey/hintPatterns.ts","../../src/journey/parseHints.ts","../../src/mapping/stepMapper.ts"],"names":["parseYaml"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Step Mapping Patterns - Regex patterns for parsing step text into IR primitives\n * @see research/2026-01-02_autogen-refined-plan.md Section 10\n */\nimport type { IRPrimitive, LocatorSpec, ValueSpec, LocatorStrategy } from '../ir/types.js';\n\n/**\n * Pattern result with match groups\n */\nexport interface PatternMatch {\n  type: IRPrimitive['type'];\n  groups: Record<string, string>;\n}\n\n/**\n * Pattern definition\n */\nexport interface StepPattern {\n  /** Pattern name for debugging */\n  name: string;\n  /** Regex pattern with named groups */\n  regex: RegExp;\n  /** IR primitive type this pattern produces */\n  primitiveType: IRPrimitive['type'];\n  /** Extract IR primitive from match (prefix with _ if unused) */\n  extract: (_match: RegExpMatchArray) => IRPrimitive | null;\n}\n\n/**\n * Create a locator spec from pattern match\n */\nexport function createLocatorFromMatch(\n  strategy: LocatorStrategy,\n  value: string,\n  name?: string\n): LocatorSpec {\n  const locator: LocatorSpec = { strategy, value };\n  if (name) {\n    locator.options = { name };\n  }\n  return locator;\n}\n\n/**\n * Create a value spec from text\n */\nexport function createValueFromText(text: string): ValueSpec {\n  // Actor reference: {{email}}, {{password}}, etc.\n  if (/^\\{\\{.+\\}\\}$/.test(text)) {\n    const path = text.slice(2, -2).trim();\n    return { type: 'actor', value: path };\n  }\n\n  // Test data reference: $user.email, $testData.field\n  if (/^\\$.+/.test(text)) {\n    return { type: 'testData', value: text.slice(1) };\n  }\n\n  // Generated value: ${runId}, ${timestamp}\n  if (/\\$\\{.+\\}/.test(text)) {\n    return { type: 'generated', value: text };\n  }\n\n  // Literal value\n  return { type: 'literal', value: text };\n}\n\n/**\n * Navigation patterns\n */\nexport const navigationPatterns: StepPattern[] = [\n  {\n    name: 'navigate-to-url',\n    regex: /^(?:user\\s+)?(?:navigates?|go(?:es)?|opens?)\\s+(?:to\\s+)?(?:the\\s+)?[\"']?([^\"'\\s]+)[\"']?$/i,\n    primitiveType: 'goto',\n    extract: (match) => ({\n      type: 'goto',\n      url: match[1]!,\n      waitForLoad: true,\n    }),\n  },\n  {\n    name: 'navigate-to-page',\n    regex: /^(?:user\\s+)?(?:navigates?|go(?:es)?|opens?)\\s+(?:to\\s+)?(?:the\\s+)?(.+?)\\s+page$/i,\n    primitiveType: 'goto',\n    extract: (match) => ({\n      type: 'goto',\n      url: `/${match[1]!.toLowerCase().replace(/\\s+/g, '-')}`,\n      waitForLoad: true,\n    }),\n  },\n];\n\n/**\n * Click patterns\n */\nexport const clickPatterns: StepPattern[] = [\n  {\n    name: 'click-button-quoted',\n    regex: /^(?:user\\s+)?(?:clicks?|presses?|taps?)\\s+(?:on\\s+)?(?:the\\s+)?[\"']([^\"']+)[\"']\\s+button$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('role', 'button', match[1]!),\n    }),\n  },\n  {\n    name: 'click-link-quoted',\n    regex: /^(?:user\\s+)?(?:clicks?|presses?|taps?)\\s+(?:on\\s+)?(?:the\\s+)?[\"']([^\"']+)[\"']\\s+link$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('role', 'link', match[1]!),\n    }),\n  },\n  {\n    name: 'click-element-quoted',\n    regex: /^(?:user\\s+)?(?:clicks?|presses?|taps?)\\s+(?:on\\s+)?(?:the\\s+)?[\"']([^\"']+)[\"']$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'click-element-generic',\n    regex: /^(?:user\\s+)?(?:clicks?|presses?|taps?)\\s+(?:on\\s+)?(?:the\\s+)?(.+?)\\s+(?:button|link|icon|menu|tab)$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n];\n\n/**\n * Fill/Input patterns\n */\nexport const fillPatterns: StepPattern[] = [\n  {\n    name: 'fill-field-quoted-value',\n    regex: /^(?:user\\s+)?(?:enters?|types?|fills?\\s+in?|inputs?)\\s+[\"']([^\"']+)[\"']\\s+(?:in|into)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']\\s*(?:field|input)?$/i,\n    primitiveType: 'fill',\n    extract: (match) => ({\n      type: 'fill',\n      locator: createLocatorFromMatch('label', match[2]!),\n      value: createValueFromText(match[1]!),\n    }),\n  },\n  {\n    name: 'fill-field-actor-value',\n    regex: /^(?:user\\s+)?(?:enters?|types?|fills?\\s+in?|inputs?)\\s+(\\{\\{[^}]+\\}\\})\\s+(?:in|into)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']\\s*(?:field|input)?$/i,\n    primitiveType: 'fill',\n    extract: (match) => ({\n      type: 'fill',\n      locator: createLocatorFromMatch('label', match[2]!),\n      value: createValueFromText(match[1]!),\n    }),\n  },\n  {\n    name: 'fill-field-generic',\n    regex: /^(?:user\\s+)?(?:enters?|types?|fills?\\s+in?|inputs?)\\s+(.+?)\\s+(?:in|into)\\s+(?:the\\s+)?(.+?)\\s*(?:field|input)?$/i,\n    primitiveType: 'fill',\n    extract: (match) => ({\n      type: 'fill',\n      locator: createLocatorFromMatch('label', match[2]!.replace(/[\"']/g, '')),\n      value: createValueFromText(match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n];\n\n/**\n * Select patterns\n */\nexport const selectPatterns: StepPattern[] = [\n  {\n    name: 'select-option',\n    regex: /^(?:user\\s+)?(?:selects?|chooses?)\\s+[\"']([^\"']+)[\"']\\s+(?:from|in)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']\\s*(?:dropdown|select|menu)?$/i,\n    primitiveType: 'select',\n    extract: (match) => ({\n      type: 'select',\n      locator: createLocatorFromMatch('label', match[2]!),\n      option: match[1]!,\n    }),\n  },\n];\n\n/**\n * Check/Uncheck patterns\n */\nexport const checkPatterns: StepPattern[] = [\n  {\n    name: 'check-checkbox',\n    regex: /^(?:user\\s+)?(?:checks?|enables?|ticks?)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']\\s*(?:checkbox|option)?$/i,\n    primitiveType: 'check',\n    extract: (match) => ({\n      type: 'check',\n      locator: createLocatorFromMatch('label', match[1]!),\n    }),\n  },\n  {\n    name: 'uncheck-checkbox',\n    regex: /^(?:user\\s+)?(?:unchecks?|disables?|unticks?)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']\\s*(?:checkbox|option)?$/i,\n    primitiveType: 'uncheck',\n    extract: (match) => ({\n      type: 'uncheck',\n      locator: createLocatorFromMatch('label', match[1]!),\n    }),\n  },\n];\n\n/**\n * Visibility assertion patterns\n */\nexport const visibilityPatterns: StepPattern[] = [\n  {\n    name: 'should-see-text',\n    regex: /^(?:user\\s+)?(?:should\\s+)?(?:sees?|views?)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'is-visible',\n    regex: /^[\"']?([^\"']+)[\"']?\\s+(?:is\\s+)?(?:visible|displayed|shown)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'should-see-element',\n    regex: /^(?:user\\s+)?(?:should\\s+)?(?:sees?|views?)\\s+(?:the\\s+)?(.+?)\\s+(?:heading|button|link|form|page|element)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'page-displayed',\n    regex: /^(?:the\\s+)?(.+?)\\s+(?:page|screen|view)\\s+(?:is\\s+)?(?:displayed|shown|visible)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n];\n\n/**\n * Toast/notification patterns\n */\nexport const toastPatterns: StepPattern[] = [\n  {\n    name: 'success-toast-message',\n    regex: /^(?:a\\s+)?success\\s+toast\\s+(?:with\\s+)?[\"']([^\"']+)[\"']\\s*(?:message\\s+)?(?:appears?|is\\s+shown|displays?)$/i,\n    primitiveType: 'expectToast',\n    extract: (match) => ({\n      type: 'expectToast',\n      toastType: 'success',\n      message: match[1]!,\n    }),\n  },\n  {\n    name: 'error-toast-message',\n    regex: /^(?:an?\\s+)?error\\s+toast\\s+(?:with\\s+)?[\"']([^\"']+)[\"']\\s*(?:message\\s+)?(?:appears?|is\\s+shown|displays?)$/i,\n    primitiveType: 'expectToast',\n    extract: (match) => ({\n      type: 'expectToast',\n      toastType: 'error',\n      message: match[1]!,\n    }),\n  },\n  {\n    name: 'toast-appears',\n    regex: /^(?:a\\s+)?(success|error|info|warning)\\s+toast\\s+(?:appears?|is\\s+shown|displays?)$/i,\n    primitiveType: 'expectToast',\n    extract: (match) => ({\n      type: 'expectToast',\n      toastType: match[1]!.toLowerCase() as 'success' | 'error' | 'info' | 'warning',\n    }),\n  },\n  {\n    name: 'toast-with-text',\n    regex: /^(?:toast|notification)\\s+(?:with\\s+)?[\"']([^\"']+)[\"']\\s+(?:appears?|is\\s+shown|displays?)$/i,\n    primitiveType: 'expectToast',\n    extract: (match) => ({\n      type: 'expectToast',\n      toastType: 'info',\n      message: match[1]!,\n    }),\n  },\n];\n\n/**\n * URL assertion patterns\n */\nexport const urlPatterns: StepPattern[] = [\n  {\n    name: 'url-contains',\n    regex: /^(?:the\\s+)?url\\s+(?:should\\s+)?(?:contains?|includes?)\\s+[\"']?([^\"'\\s]+)[\"']?$/i,\n    primitiveType: 'expectURL',\n    extract: (match) => ({\n      type: 'expectURL',\n      pattern: match[1]!,\n    }),\n  },\n  {\n    name: 'url-is',\n    regex: /^(?:the\\s+)?url\\s+(?:should\\s+)?(?:is|equals?|be)\\s+[\"']?([^\"'\\s]+)[\"']?$/i,\n    primitiveType: 'expectURL',\n    extract: (match) => ({\n      type: 'expectURL',\n      pattern: match[1]!,\n    }),\n  },\n  {\n    name: 'redirected-to',\n    regex: /^(?:user\\s+)?(?:is\\s+)?redirected\\s+to\\s+[\"']?([^\"'\\s]+)[\"']?$/i,\n    primitiveType: 'expectURL',\n    extract: (match) => ({\n      type: 'expectURL',\n      pattern: match[1]!,\n    }),\n  },\n];\n\n/**\n * Module call patterns (authentication)\n */\nexport const authPatterns: StepPattern[] = [\n  {\n    name: 'user-login',\n    regex: /^(?:user\\s+)?(?:logs?\\s*in|login\\s+is\\s+performed|authenticates?)$/i,\n    primitiveType: 'callModule',\n    extract: (_match) => ({\n      type: 'callModule',\n      module: 'auth',\n      method: 'login',\n    }),\n  },\n  {\n    name: 'user-logout',\n    regex: /^(?:user\\s+)?(?:logs?\\s*out|logout\\s+is\\s+performed|signs?\\s*out)$/i,\n    primitiveType: 'callModule',\n    extract: (_match) => ({\n      type: 'callModule',\n      module: 'auth',\n      method: 'logout',\n    }),\n  },\n  {\n    name: 'login-as-role',\n    regex: /^(?:user\\s+)?logs?\\s*in\\s+as\\s+(?:an?\\s+)?(.+?)(?:\\s+user)?$/i,\n    primitiveType: 'callModule',\n    extract: (match) => ({\n      type: 'callModule',\n      module: 'auth',\n      method: 'loginAs',\n      args: [match[1]!.toLowerCase()],\n    }),\n  },\n];\n\n/**\n * Wait patterns\n */\nexport const waitPatterns: StepPattern[] = [\n  {\n    name: 'wait-for-navigation',\n    regex: /^(?:user\\s+)?(?:waits?\\s+)?(?:for\\s+)?navigation\\s+to\\s+[\"']?([^\"'\\s]+)[\"']?$/i,\n    primitiveType: 'waitForURL',\n    extract: (match) => ({\n      type: 'waitForURL',\n      pattern: match[1]!,\n    }),\n  },\n  {\n    name: 'wait-for-page',\n    regex: /^(?:user\\s+)?(?:waits?\\s+)?(?:for\\s+)?(?:the\\s+)?(.+?)\\s+(?:page|screen)\\s+to\\s+load$/i,\n    primitiveType: 'waitForLoadingComplete',\n    extract: (_match) => ({\n      type: 'waitForLoadingComplete',\n    }),\n  },\n];\n\n/**\n * Helper function to convert natural language selectors to Playwright locator strategies\n */\nexport function parseSelectorToLocator(selector: string): { strategy: LocatorStrategy; value: string; name?: string } {\n  // Remove leading \"the\" if present\n  let cleanSelector = selector.replace(/^the\\s+/i, '').trim();\n\n  // Match button patterns\n  if (/button$/i.test(cleanSelector)) {\n    const buttonName = cleanSelector.replace(/\\s*button$/i, '').trim();\n    return { strategy: 'role', value: 'button', name: buttonName };\n  }\n\n  // Match link patterns\n  if (/link$/i.test(cleanSelector)) {\n    const linkName = cleanSelector.replace(/\\s*link$/i, '').trim();\n    return { strategy: 'role', value: 'link', name: linkName };\n  }\n\n  // Match input/field patterns\n  if (/(?:input|field)$/i.test(cleanSelector)) {\n    const labelName = cleanSelector.replace(/\\s*(?:input|field)$/i, '').trim();\n    return { strategy: 'label', value: labelName };\n  }\n\n  // Default to text locator\n  return { strategy: 'text', value: cleanSelector };\n}\n\n/**\n * Structured step patterns for Journey markdown format\n * Matches patterns like:\n * - **Action**: Click the login button\n * - **Wait for**: Dashboard to load\n * - **Assert**: User name is visible\n */\nexport const structuredPatterns: StepPattern[] = [\n  // Action patterns\n  {\n    name: 'structured-action-click',\n    regex: /^\\*\\*Action\\*\\*:\\s*[Cc]lick\\s+(?:the\\s+)?['\"]?(.+?)['\"]?\\s*(?:button|link)?$/i,\n    primitiveType: 'click',\n    extract: (match) => {\n      const target = match[1]!;\n      const locatorInfo = parseSelectorToLocator(target + ' button');\n      return {\n        type: 'click',\n        locator: locatorInfo.name\n          ? createLocatorFromMatch(locatorInfo.strategy, locatorInfo.value, locatorInfo.name)\n          : { strategy: locatorInfo.strategy, value: locatorInfo.value },\n      };\n    },\n  },\n  {\n    name: 'structured-action-fill',\n    regex: /^\\*\\*Action\\*\\*:\\s*[Ff]ill\\s+(?:in\\s+)?['\"]?(.+?)['\"]?\\s+with\\s+['\"]?(.+?)['\"]?$/i,\n    primitiveType: 'fill',\n    extract: (match) => {\n      const target = match[1]!;\n      const value = match[2]!;\n      const locatorInfo = parseSelectorToLocator(target);\n      return {\n        type: 'fill',\n        locator: locatorInfo.name\n          ? createLocatorFromMatch(locatorInfo.strategy, locatorInfo.value, locatorInfo.name)\n          : { strategy: locatorInfo.strategy, value: locatorInfo.value },\n        value: createValueFromText(value),\n      };\n    },\n  },\n  {\n    name: 'structured-action-navigate',\n    regex: /^\\*\\*Action\\*\\*:\\s*[Nn]avigate\\s+to\\s+['\"]?(.+?)['\"]?$/i,\n    primitiveType: 'goto',\n    extract: (match) => ({\n      type: 'goto',\n      url: match[1]!,\n      waitForLoad: true,\n    }),\n  },\n\n  // Wait patterns\n  {\n    name: 'structured-wait-for-visible',\n    regex: /^\\*\\*Wait for\\*\\*:\\s*(.+?)\\s+(?:to\\s+)?(?:be\\s+)?(?:visible|appear|load)/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => {\n      const target = match[1]!;\n      const locatorInfo = parseSelectorToLocator(target);\n      return {\n        type: 'expectVisible',\n        locator: locatorInfo.name\n          ? createLocatorFromMatch(locatorInfo.strategy, locatorInfo.value, locatorInfo.name)\n          : { strategy: locatorInfo.strategy, value: locatorInfo.value },\n      };\n    },\n  },\n\n  // Assert patterns\n  {\n    name: 'structured-assert-visible',\n    regex: /^\\*\\*Assert\\*\\*:\\s*(.+?)\\s+(?:is\\s+)?visible$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => {\n      const target = match[1]!;\n      const locatorInfo = parseSelectorToLocator(target);\n      return {\n        type: 'expectVisible',\n        locator: locatorInfo.name\n          ? createLocatorFromMatch(locatorInfo.strategy, locatorInfo.value, locatorInfo.name)\n          : { strategy: locatorInfo.strategy, value: locatorInfo.value },\n      };\n    },\n  },\n  {\n    name: 'structured-assert-text',\n    regex: /^\\*\\*Assert\\*\\*:\\s*(.+?)\\s+(?:contains|has text)\\s+['\"]?(.+?)['\"]?$/i,\n    primitiveType: 'expectText',\n    extract: (match) => {\n      const target = match[1]!;\n      const text = match[2]!;\n      const locatorInfo = parseSelectorToLocator(target);\n      return {\n        type: 'expectText',\n        locator: locatorInfo.name\n          ? createLocatorFromMatch(locatorInfo.strategy, locatorInfo.value, locatorInfo.name)\n          : { strategy: locatorInfo.strategy, value: locatorInfo.value },\n        text,\n      };\n    },\n  },\n];\n\n/**\n * All patterns in priority order (more specific patterns first)\n * Structured patterns come first to prioritize the Journey markdown format\n */\nexport const allPatterns: StepPattern[] = [\n  ...structuredPatterns,\n  ...authPatterns,\n  ...toastPatterns,\n  ...navigationPatterns,\n  ...clickPatterns,\n  ...fillPatterns,\n  ...selectPatterns,\n  ...checkPatterns,\n  ...visibilityPatterns,\n  ...urlPatterns,\n  ...waitPatterns,\n];\n\n/**\n * Match text against all patterns and return the first matching primitive\n */\nexport function matchPattern(text: string): IRPrimitive | null {\n  const trimmedText = text.trim();\n\n  for (const pattern of allPatterns) {\n    const match = trimmedText.match(pattern.regex);\n    if (match) {\n      const primitive = pattern.extract(match);\n      if (primitive) {\n        return primitive;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Get all pattern matches for debugging\n */\nexport function getPatternMatches(text: string): Array<{ pattern: string; match: IRPrimitive }> {\n  const trimmedText = text.trim();\n  const matches: Array<{ pattern: string; match: IRPrimitive }> = [];\n\n  for (const pattern of allPatterns) {\n    const match = trimmedText.match(pattern.regex);\n    if (match) {\n      const primitive = pattern.extract(match);\n      if (primitive) {\n        matches.push({ pattern: pattern.name, match: primitive });\n      }\n    }\n  }\n\n  return matches;\n}\n","/**\n * Glossary Loader - Load and resolve synonyms for step text normalization\n * @see research/2026-01-02_autogen-refined-plan.md Section 10\n */\nimport { readFileSync, existsSync } from 'node:fs';\nimport { resolve } from 'node:path';\nimport { parse as parseYaml } from 'yaml';\nimport { z } from 'zod';\n\n/**\n * Glossary entry schema\n */\nconst GlossaryEntrySchema = z.object({\n  canonical: z.string(),\n  synonyms: z.array(z.string()),\n});\n\n/**\n * Label alias entry schema (maps display labels to testids/selectors)\n * @see T082 - Extend glossary schema for labelAliases\n */\nconst LabelAliasSchema = z.object({\n  label: z.string(),\n  testid: z.string().optional(),\n  role: z.string().optional(),\n  selector: z.string().optional(),\n});\n\n/**\n * Module method mapping schema (maps phrases to module.method calls)\n * @see T082 - Module method resolution\n */\nconst ModuleMethodMappingSchema = z.object({\n  phrase: z.string(),\n  module: z.string(),\n  method: z.string(),\n  params: z.record(z.string()).optional(),\n});\n\n/**\n * Glossary file schema\n */\nconst GlossarySchema = z.object({\n  version: z.number().default(1),\n  entries: z.array(GlossaryEntrySchema),\n  labelAliases: z.array(LabelAliasSchema).default([]),\n  moduleMethods: z.array(ModuleMethodMappingSchema).default([]),\n});\n\nexport type LabelAlias = z.infer<typeof LabelAliasSchema>;\nexport type ModuleMethodMapping = z.infer<typeof ModuleMethodMappingSchema>;\n\nexport type GlossaryEntry = z.infer<typeof GlossaryEntrySchema>;\nexport type Glossary = z.infer<typeof GlossarySchema>;\n\n/**\n * Default glossary entries for common terms\n */\nexport const defaultGlossary: Glossary = {\n  version: 1,\n  labelAliases: [\n    // Common label-to-selector mappings\n    { label: 'email', testid: 'email-input', role: 'textbox' },\n    { label: 'password', testid: 'password-input', role: 'textbox' },\n    { label: 'username', testid: 'username-input', role: 'textbox' },\n    { label: 'search', testid: 'search-input', role: 'searchbox' },\n    { label: 'submit', testid: 'submit-button', role: 'button' },\n    { label: 'cancel', testid: 'cancel-button', role: 'button' },\n    { label: 'close', testid: 'close-button', role: 'button' },\n  ],\n  moduleMethods: [\n    // Common phrase-to-module mappings\n    { phrase: 'log in', module: 'auth', method: 'login' },\n    { phrase: 'login', module: 'auth', method: 'login' },\n    { phrase: 'sign in', module: 'auth', method: 'login' },\n    { phrase: 'log out', module: 'auth', method: 'logout' },\n    { phrase: 'logout', module: 'auth', method: 'logout' },\n    { phrase: 'sign out', module: 'auth', method: 'logout' },\n    { phrase: 'navigate to', module: 'navigation', method: 'goToPath' },\n    { phrase: 'go to', module: 'navigation', method: 'goToPath' },\n    { phrase: 'open', module: 'navigation', method: 'goToPath' },\n    { phrase: 'fill form', module: 'forms', method: 'fillForm' },\n    { phrase: 'submit form', module: 'forms', method: 'submitForm' },\n    { phrase: 'wait for', module: 'waits', method: 'waitForSignal' },\n  ],\n  entries: [\n    {\n      canonical: 'click',\n      synonyms: ['press', 'tap', 'select', 'hit'],\n    },\n    {\n      canonical: 'enter',\n      synonyms: ['type', 'fill', 'input', 'write'],\n    },\n    {\n      canonical: 'navigate',\n      synonyms: ['go', 'open', 'visit', 'browse'],\n    },\n    {\n      canonical: 'see',\n      synonyms: ['view', 'observe', 'notice', 'find'],\n    },\n    {\n      canonical: 'visible',\n      synonyms: ['displayed', 'shown', 'present'],\n    },\n    {\n      canonical: 'button',\n      synonyms: ['btn', 'action', 'cta'],\n    },\n    {\n      canonical: 'field',\n      synonyms: ['input', 'textbox', 'text field', 'text input'],\n    },\n    {\n      canonical: 'dropdown',\n      synonyms: ['select', 'combo', 'combobox', 'selector', 'picker'],\n    },\n    {\n      canonical: 'checkbox',\n      synonyms: ['check', 'tick', 'toggle'],\n    },\n    {\n      canonical: 'login',\n      synonyms: ['log in', 'sign in', 'authenticate'],\n    },\n    {\n      canonical: 'logout',\n      synonyms: ['log out', 'sign out', 'exit'],\n    },\n    {\n      canonical: 'submit',\n      synonyms: ['send', 'save', 'confirm', 'ok'],\n    },\n    {\n      canonical: 'cancel',\n      synonyms: ['close', 'dismiss', 'abort', 'back'],\n    },\n    {\n      canonical: 'success',\n      synonyms: ['passed', 'completed', 'done', 'finished'],\n    },\n    {\n      canonical: 'error',\n      synonyms: ['failure', 'failed', 'problem', 'issue'],\n    },\n    {\n      canonical: 'toast',\n      synonyms: ['notification', 'message', 'alert', 'snackbar'],\n    },\n    {\n      canonical: 'modal',\n      synonyms: ['dialog', 'popup', 'overlay', 'lightbox'],\n    },\n    {\n      canonical: 'user',\n      synonyms: ['customer', 'visitor', 'member', 'client'],\n    },\n    {\n      canonical: 'page',\n      synonyms: ['screen', 'view', 'section'],\n    },\n    {\n      canonical: 'form',\n      synonyms: ['questionnaire', 'survey', 'wizard'],\n    },\n  ],\n};\n\n/**\n * Loaded glossary cache\n */\nlet glossaryCache: Glossary | null = null;\nlet synonymMap: Map<string, string> | null = null;\n\n/**\n * Build a synonym lookup map from glossary\n */\nfunction buildSynonymMap(glossary: Glossary): Map<string, string> {\n  const map = new Map<string, string>();\n\n  for (const entry of glossary.entries) {\n    // Map canonical to itself\n    map.set(entry.canonical.toLowerCase(), entry.canonical);\n\n    // Map all synonyms to canonical\n    for (const synonym of entry.synonyms) {\n      map.set(synonym.toLowerCase(), entry.canonical);\n    }\n  }\n\n  return map;\n}\n\n/**\n * Load glossary from file\n * @param glossaryPath - Path to glossary YAML file\n */\nexport function loadGlossary(glossaryPath: string): Glossary {\n  const resolvedPath = resolve(glossaryPath);\n\n  if (!existsSync(resolvedPath)) {\n    console.warn(`Glossary file not found at ${resolvedPath}, using defaults`);\n    return defaultGlossary;\n  }\n\n  try {\n    const content = readFileSync(resolvedPath, 'utf-8');\n    const parsed = parseYaml(content);\n    const result = GlossarySchema.safeParse(parsed);\n\n    if (!result.success) {\n      console.warn(`Invalid glossary file at ${resolvedPath}, using defaults`);\n      return defaultGlossary;\n    }\n\n    // Merge with defaults\n    return mergeGlossaries(defaultGlossary, result.data);\n  } catch (err) {\n    console.warn(`Failed to load glossary from ${resolvedPath}, using defaults`);\n    return defaultGlossary;\n  }\n}\n\n/**\n * Merge two glossaries (user glossary extends defaults)\n */\nexport function mergeGlossaries(base: Glossary, extension: Glossary): Glossary {\n  const merged: Glossary = {\n    version: Math.max(base.version, extension.version),\n    entries: [...base.entries],\n    labelAliases: [...(base.labelAliases ?? [])],\n    moduleMethods: [...(base.moduleMethods ?? [])],\n  };\n\n  // Add or extend entries from extension\n  for (const extEntry of extension.entries) {\n    const existing = merged.entries.find(\n      (e) => e.canonical.toLowerCase() === extEntry.canonical.toLowerCase()\n    );\n\n    if (existing) {\n      // Merge synonyms\n      const allSynonyms = new Set([...existing.synonyms, ...extEntry.synonyms]);\n      existing.synonyms = Array.from(allSynonyms);\n    } else {\n      // Add new entry\n      merged.entries.push(extEntry);\n    }\n  }\n\n  // Add or extend label aliases from extension\n  for (const extAlias of extension.labelAliases ?? []) {\n    const existing = merged.labelAliases.find(\n      (a) => a.label.toLowerCase() === extAlias.label.toLowerCase()\n    );\n\n    if (!existing) {\n      merged.labelAliases.push(extAlias);\n    } else {\n      // Override with extension values\n      Object.assign(existing, extAlias);\n    }\n  }\n\n  // Add or extend module methods from extension\n  for (const extMethod of extension.moduleMethods ?? []) {\n    const existing = merged.moduleMethods.find(\n      (m) => m.phrase.toLowerCase() === extMethod.phrase.toLowerCase()\n    );\n\n    if (!existing) {\n      merged.moduleMethods.push(extMethod);\n    } else {\n      // Override with extension values\n      Object.assign(existing, extMethod);\n    }\n  }\n\n  return merged;\n}\n\n/**\n * Initialize the glossary (call once at startup)\n * @param glossaryPath - Optional path to custom glossary\n */\nexport function initGlossary(glossaryPath?: string): void {\n  if (glossaryPath) {\n    glossaryCache = loadGlossary(glossaryPath);\n  } else {\n    glossaryCache = defaultGlossary;\n  }\n  synonymMap = buildSynonymMap(glossaryCache);\n}\n\n/**\n * Get the current glossary\n */\nexport function getGlossary(): Glossary {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n  return glossaryCache!;\n}\n\n/**\n * Resolve a term to its canonical form\n * @param term - Term to resolve\n * @returns Canonical form or original term if not found\n */\nexport function resolveCanonical(term: string): string {\n  if (!synonymMap) {\n    initGlossary();\n  }\n  return synonymMap!.get(term.toLowerCase()) ?? term;\n}\n\n/**\n * Normalize step text by replacing synonyms with canonical terms\n * @param text - Step text to normalize\n * @returns Normalized text\n */\nexport function normalizeStepText(text: string): string {\n  if (!synonymMap) {\n    initGlossary();\n  }\n\n  // Split into words, preserving quoted strings\n  const parts: string[] = [];\n  const regex = /(['\"][^'\"]+['\"])|(\\S+)/g;\n  let match;\n\n  while ((match = regex.exec(text)) !== null) {\n    const part = match[0];\n\n    // Don't normalize quoted strings\n    if (part.startsWith('\"') || part.startsWith(\"'\")) {\n      parts.push(part);\n    } else {\n      // Check if this word has a canonical form\n      const canonical = synonymMap!.get(part.toLowerCase());\n      parts.push(canonical ?? part);\n    }\n  }\n\n  return parts.join(' ');\n}\n\n/**\n * Get all synonyms for a canonical term\n */\nexport function getSynonyms(canonical: string): string[] {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n\n  const entry = glossaryCache!.entries.find(\n    (e) => e.canonical.toLowerCase() === canonical.toLowerCase()\n  );\n\n  return entry?.synonyms ?? [];\n}\n\n/**\n * Check if a term is a synonym of a canonical term\n */\nexport function isSynonymOf(term: string, canonical: string): boolean {\n  const resolved = resolveCanonical(term);\n  return resolved.toLowerCase() === canonical.toLowerCase();\n}\n\n/**\n * Reset the glossary cache (for testing)\n */\nexport function resetGlossaryCache(): void {\n  glossaryCache = null;\n  synonymMap = null;\n}\n\n/**\n * Find a label alias by label text\n * @see T082 - Label alias matching\n */\nexport function findLabelAlias(label: string): LabelAlias | null {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n\n  const normalizedLabel = label.toLowerCase().trim();\n\n  return (\n    glossaryCache!.labelAliases?.find(\n      (alias) => alias.label.toLowerCase() === normalizedLabel\n    ) ?? null\n  );\n}\n\n/**\n * Get locator info from label alias\n */\nexport function getLocatorFromLabel(label: string): { strategy: string; value: string } | null {\n  const alias = findLabelAlias(label);\n  if (!alias) return null;\n\n  // Priority: testid > role > selector\n  if (alias.testid) {\n    return { strategy: 'testid', value: alias.testid };\n  }\n  if (alias.role) {\n    return { strategy: 'role', value: alias.role };\n  }\n  if (alias.selector) {\n    return { strategy: 'css', value: alias.selector };\n  }\n\n  return null;\n}\n\n/**\n * Find a module method mapping by phrase\n * @see T083 - Module method resolution in step mapper\n */\nexport function findModuleMethod(text: string): ModuleMethodMapping | null {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n\n  const normalizedText = text.toLowerCase().trim();\n\n  // Find the best matching phrase (longest match wins)\n  let bestMatch: ModuleMethodMapping | null = null;\n  let bestMatchLength = 0;\n\n  for (const mapping of glossaryCache!.moduleMethods ?? []) {\n    const phrase = mapping.phrase.toLowerCase();\n    if (normalizedText.includes(phrase) && phrase.length > bestMatchLength) {\n      bestMatch = mapping;\n      bestMatchLength = phrase.length;\n    }\n  }\n\n  return bestMatch;\n}\n\n/**\n * Resolve a step to a module method call if it matches\n */\nexport function resolveModuleMethod(\n  text: string\n): { module: string; method: string; params?: Record<string, string> } | null {\n  const mapping = findModuleMethod(text);\n  if (!mapping) return null;\n\n  return {\n    module: mapping.module,\n    method: mapping.method,\n    params: mapping.params,\n  };\n}\n\n/**\n * Get all label aliases\n */\nexport function getLabelAliases(): LabelAlias[] {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n  return glossaryCache!.labelAliases ?? [];\n}\n\n/**\n * Get all module method mappings\n */\nexport function getModuleMethods(): ModuleMethodMapping[] {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n  return glossaryCache!.moduleMethods ?? [];\n}\n","/**\n * Machine Hint Syntax Patterns - Define regex patterns for parsing hints\n * @see T071 - Define machine hint syntax regex patterns\n */\n\n/**\n * Machine hint types\n */\nexport type HintType =\n  | 'role'       // ARIA role hint: (role=button)\n  | 'testid'     // Test ID hint: (testid=submit-btn)\n  | 'label'      // Label hint: (label=\"Email Address\")\n  | 'text'       // Text hint: (text=\"Submit\")\n  | 'exact'      // Exact matching: (exact=true)\n  | 'level'      // Heading level: (level=2)\n  | 'signal'     // Signal hint: (signal=loading-done)\n  | 'module'     // Module method hint: (module=auth.login)\n  | 'wait'       // Wait strategy: (wait=networkidle)\n  | 'timeout';   // Timeout hint: (timeout=5000)\n\n/**\n * Parsed machine hint\n */\nexport interface MachineHint {\n  /** Hint type */\n  type: HintType;\n  /** Hint value */\n  value: string;\n  /** Raw hint string */\n  raw: string;\n}\n\n/**\n * Pattern for detecting hint blocks: (key=value) or (key=\"value with spaces\")\n */\nexport const HINT_BLOCK_PATTERN = /\\(([a-z]+)=(?:\"([^\"]+)\"|'([^']+)'|([^,)\\s]+))\\)/gi;\n\n/**\n * Pattern for a complete hints section: (...hints...)\n */\nexport const HINTS_SECTION_PATTERN = /\\((?:[a-z]+=(?:\"[^\"]+\"|'[^']+'|[^,)\\s]+)(?:,\\s*)?)+\\)/gi;\n\n/**\n * Individual hint patterns for validation\n */\nexport const HINT_PATTERNS: Record<HintType, RegExp> = {\n  role: /role=(?:\"([^\"]+)\"|'([^']+)'|([a-z]+))/i,\n  testid: /testid=(?:\"([^\"]+)\"|'([^']+)'|([a-z0-9_-]+))/i,\n  label: /label=(?:\"([^\"]+)\"|'([^']+)')/i,\n  text: /text=(?:\"([^\"]+)\"|'([^']+)')/i,\n  exact: /exact=(true|false)/i,\n  level: /level=([1-6])/i,\n  signal: /signal=(?:\"([^\"]+)\"|'([^']+)'|([a-z0-9_-]+))/i,\n  module: /module=(?:\"([^\"]+)\"|'([^']+)'|([a-z0-9_.]+))/i,\n  wait: /wait=(networkidle|domcontentloaded|load|commit)/i,\n  timeout: /timeout=(\\d+)/i,\n};\n\n/**\n * Valid ARIA roles for validation\n */\nexport const VALID_ROLES = [\n  'alert',\n  'alertdialog',\n  'application',\n  'article',\n  'banner',\n  'button',\n  'cell',\n  'checkbox',\n  'columnheader',\n  'combobox',\n  'complementary',\n  'contentinfo',\n  'definition',\n  'dialog',\n  'directory',\n  'document',\n  'feed',\n  'figure',\n  'form',\n  'grid',\n  'gridcell',\n  'group',\n  'heading',\n  'img',\n  'link',\n  'list',\n  'listbox',\n  'listitem',\n  'log',\n  'main',\n  'marquee',\n  'math',\n  'menu',\n  'menubar',\n  'menuitem',\n  'menuitemcheckbox',\n  'menuitemradio',\n  'navigation',\n  'none',\n  'note',\n  'option',\n  'presentation',\n  'progressbar',\n  'radio',\n  'radiogroup',\n  'region',\n  'row',\n  'rowgroup',\n  'rowheader',\n  'scrollbar',\n  'search',\n  'searchbox',\n  'separator',\n  'slider',\n  'spinbutton',\n  'status',\n  'switch',\n  'tab',\n  'table',\n  'tablist',\n  'tabpanel',\n  'term',\n  'textbox',\n  'timer',\n  'toolbar',\n  'tooltip',\n  'tree',\n  'treegrid',\n  'treeitem',\n];\n\n/**\n * Check if a role is valid\n */\nexport function isValidRole(role: string): boolean {\n  return VALID_ROLES.includes(role.toLowerCase());\n}\n\n/**\n * Extract hint value from a match (handles quoted and unquoted values)\n */\nexport function extractHintValue(match: RegExpMatchArray): string | null {\n  // Try quoted values first, then unquoted\n  for (let i = 1; i < match.length; i++) {\n    if (match[i] !== undefined) {\n      return match[i] ?? null;\n    }\n  }\n  return null;\n}\n\n/**\n * Check if text contains machine hints\n */\nexport function containsHints(text: string): boolean {\n  // Reset lastIndex for global regex\n  HINTS_SECTION_PATTERN.lastIndex = 0;\n  return HINTS_SECTION_PATTERN.test(text);\n}\n\n/**\n * Remove hints section from step text\n */\nexport function removeHints(text: string): string {\n  return text.replace(HINTS_SECTION_PATTERN, '').trim();\n}\n","/**\n * Machine Hint Parser - Extract hints from Journey step text\n * @see T072 - Implement machine hint parser\n */\nimport {\n  type HintType,\n  type MachineHint,\n  HINT_BLOCK_PATTERN,\n  HINT_PATTERNS,\n  isValidRole,\n  containsHints,\n  removeHints,\n} from './hintPatterns.js';\n\n/**\n * Parsed hints result\n */\nexport interface ParsedHints {\n  /** All parsed hints */\n  hints: MachineHint[];\n  /** Step text with hints removed */\n  cleanText: string;\n  /** Original text */\n  originalText: string;\n  /** Validation warnings */\n  warnings: string[];\n}\n\n/**\n * Locator hints extracted for code generation\n */\nexport interface LocatorHints {\n  /** ARIA role */\n  role?: string;\n  /** Test ID */\n  testid?: string;\n  /** Label text */\n  label?: string;\n  /** Text content */\n  text?: string;\n  /** Exact matching */\n  exact?: boolean;\n  /** Heading level (for role=heading) */\n  level?: number;\n}\n\n/**\n * Behavioral hints extracted for code generation\n */\nexport interface BehaviorHints {\n  /** Signal to wait for */\n  signal?: string;\n  /** Module method to call */\n  module?: string;\n  /** Wait strategy */\n  wait?: 'networkidle' | 'domcontentloaded' | 'load' | 'commit';\n  /** Timeout in ms */\n  timeout?: number;\n}\n\n/**\n * Complete hint extraction result\n */\nexport interface ExtractedHints {\n  /** Locator-related hints */\n  locator: LocatorHints;\n  /** Behavior-related hints */\n  behavior: BehaviorHints;\n  /** Whether any hints were found */\n  hasHints: boolean;\n  /** Clean step text */\n  cleanText: string;\n  /** Warnings */\n  warnings: string[];\n}\n\n/**\n * Parse machine hints from step text\n */\nexport function parseHints(text: string): ParsedHints {\n  const hints: MachineHint[] = [];\n  const warnings: string[] = [];\n\n  if (!containsHints(text)) {\n    return {\n      hints: [],\n      cleanText: text,\n      originalText: text,\n      warnings: [],\n    };\n  }\n\n  // Extract all hint blocks\n  HINT_BLOCK_PATTERN.lastIndex = 0;\n  let match;\n\n  while ((match = HINT_BLOCK_PATTERN.exec(text)) !== null) {\n    const key = match[1]!.toLowerCase() as HintType;\n    const value = match[2] || match[3] || match[4];\n\n    if (!value) {\n      warnings.push(`Empty value for hint: ${key}`);\n      continue;\n    }\n\n    // Validate the hint type\n    if (!(key in HINT_PATTERNS)) {\n      warnings.push(`Unknown hint type: ${key}`);\n      continue;\n    }\n\n    // Validate role values\n    if (key === 'role' && !isValidRole(value)) {\n      warnings.push(`Invalid ARIA role: ${value}`);\n    }\n\n    hints.push({\n      type: key,\n      value,\n      raw: match[0],\n    });\n  }\n\n  return {\n    hints,\n    cleanText: removeHints(text),\n    originalText: text,\n    warnings,\n  };\n}\n\n/**\n * Extract structured hints for code generation\n */\nexport function extractHints(text: string): ExtractedHints {\n  const parsed = parseHints(text);\n\n  const locator: LocatorHints = {};\n  const behavior: BehaviorHints = {};\n\n  for (const hint of parsed.hints) {\n    switch (hint.type) {\n      case 'role':\n        locator.role = hint.value;\n        break;\n      case 'testid':\n        locator.testid = hint.value;\n        break;\n      case 'label':\n        locator.label = hint.value;\n        break;\n      case 'text':\n        locator.text = hint.value;\n        break;\n      case 'exact':\n        locator.exact = hint.value.toLowerCase() === 'true';\n        break;\n      case 'level':\n        locator.level = parseInt(hint.value, 10);\n        break;\n      case 'signal':\n        behavior.signal = hint.value;\n        break;\n      case 'module':\n        behavior.module = hint.value;\n        break;\n      case 'wait':\n        behavior.wait = hint.value as BehaviorHints['wait'];\n        break;\n      case 'timeout':\n        behavior.timeout = parseInt(hint.value, 10);\n        break;\n    }\n  }\n\n  return {\n    locator,\n    behavior,\n    hasHints: parsed.hints.length > 0,\n    cleanText: parsed.cleanText,\n    warnings: parsed.warnings,\n  };\n}\n\n/**\n * Check if hints specify a locator strategy\n */\nexport function hasLocatorHints(hints: ExtractedHints): boolean {\n  const { locator } = hints;\n  return !!(locator.role || locator.testid || locator.label || locator.text);\n}\n\n/**\n * Check if hints specify behavioral modifications\n */\nexport function hasBehaviorHints(hints: ExtractedHints): boolean {\n  const { behavior } = hints;\n  return !!(behavior.signal || behavior.module || behavior.wait || behavior.timeout);\n}\n\n/**\n * Generate locator code from hints\n */\nexport function generateLocatorFromHints(hints: LocatorHints): string | null {\n  // Priority: testid > role > label > text\n  if (hints.testid) {\n    return `page.getByTestId('${hints.testid}')`;\n  }\n\n  if (hints.role) {\n    const options: string[] = [];\n    if (hints.label) {\n      options.push(`name: '${hints.label}'`);\n    }\n    if (hints.exact) {\n      options.push('exact: true');\n    }\n    if (hints.level && hints.role === 'heading') {\n      options.push(`level: ${hints.level}`);\n    }\n\n    if (options.length > 0) {\n      return `page.getByRole('${hints.role}', { ${options.join(', ')} })`;\n    }\n    return `page.getByRole('${hints.role}')`;\n  }\n\n  if (hints.label) {\n    if (hints.exact) {\n      return `page.getByLabel('${hints.label}', { exact: true })`;\n    }\n    return `page.getByLabel('${hints.label}')`;\n  }\n\n  if (hints.text) {\n    if (hints.exact) {\n      return `page.getByText('${hints.text}', { exact: true })`;\n    }\n    return `page.getByText('${hints.text}')`;\n  }\n\n  return null;\n}\n\n/**\n * Parse module hint into module name and method\n */\nexport function parseModuleHint(moduleHint: string): { module: string; method: string } | null {\n  const parts = moduleHint.split('.');\n  if (parts.length !== 2) {\n    return null;\n  }\n  return {\n    module: parts[0]!,\n    method: parts[1]!,\n  };\n}\n\n/**\n * Validate hints for consistency\n */\nexport function validateHints(hints: ExtractedHints): string[] {\n  const errors: string[] = [];\n\n  // Check for conflicting locator hints\n  const locatorCount = [\n    hints.locator.testid,\n    hints.locator.role,\n    hints.locator.label && !hints.locator.role, // label with role is fine\n    hints.locator.text,\n  ].filter(Boolean).length;\n\n  if (locatorCount > 1) {\n    errors.push('Multiple conflicting locator hints specified');\n  }\n\n  // Check for level without heading role\n  if (hints.locator.level && hints.locator.role !== 'heading') {\n    errors.push('level hint only applies to role=heading');\n  }\n\n  // Check for module hint format\n  if (hints.behavior.module) {\n    const parsed = parseModuleHint(hints.behavior.module);\n    if (!parsed) {\n      errors.push('module hint must be in format: moduleName.methodName');\n    }\n  }\n\n  return errors;\n}\n\n/**\n * Merge hints with inferred locator (hints take priority)\n */\nexport function mergeWithInferred(\n  hints: LocatorHints,\n  inferred: { strategy: string; value: string }\n): { strategy: string; value: string; options?: Record<string, unknown> } {\n  // If hints specify a locator, use it\n  if (hints.testid) {\n    return { strategy: 'testid', value: hints.testid };\n  }\n\n  if (hints.role) {\n    const options: Record<string, unknown> = {};\n    if (hints.label) {\n      options.name = hints.label;\n    }\n    if (hints.exact) {\n      options.exact = true;\n    }\n    if (hints.level) {\n      options.level = hints.level;\n    }\n    return { strategy: 'role', value: hints.role, options };\n  }\n\n  if (hints.label) {\n    const options: Record<string, unknown> = {};\n    if (hints.exact) {\n      options.exact = true;\n    }\n    return { strategy: 'label', value: hints.label, options };\n  }\n\n  if (hints.text) {\n    const options: Record<string, unknown> = {};\n    if (hints.exact) {\n      options.exact = true;\n    }\n    return { strategy: 'text', value: hints.text, options };\n  }\n\n  // Add exact option to inferred if specified\n  if (hints.exact) {\n    return { ...inferred, options: { exact: true } };\n  }\n\n  // Fall back to inferred\n  return inferred;\n}\n","/**\n * Step Mapper - Convert step text to IR primitives\n * @see research/2026-01-02_autogen-refined-plan.md Section 10\n * @see T073 - Update step mapper to prioritize explicit hints over inference\n */\nimport type {\n  IRPrimitive,\n  IRStep,\n  LocatorSpec,\n} from '../ir/types.js';\nimport type { AcceptanceCriterion, ProceduralStep } from '../journey/parseJourney.js';\nimport { matchPattern } from './patterns.js';\nimport { normalizeStepText } from './glossary.js';\nimport {\n  extractHints,\n  hasLocatorHints,\n  hasBehaviorHints,\n  parseModuleHint,\n  type ExtractedHints,\n} from '../journey/parseHints.js';\n\n/**\n * Options for step mapping\n */\nexport interface StepMapperOptions {\n  /** Whether to normalize text before matching */\n  normalizeText?: boolean;\n  /** Whether to include blocked steps for unmatched text */\n  includeBlocked?: boolean;\n  /** Default timeout for assertions */\n  defaultTimeout?: number;\n}\n\n/**\n * Result of mapping a single step\n */\nexport interface StepMappingResult {\n  /** The parsed primitive, or null if not matched */\n  primitive: IRPrimitive | null;\n  /** Original text that was mapped */\n  sourceText: string;\n  /** Whether this is an assertion (expect*) or action */\n  isAssertion: boolean;\n  /** Warning or error message if any */\n  message?: string;\n}\n\n/**\n * Result of mapping an acceptance criterion\n */\nexport interface ACMappingResult {\n  /** The mapped IR step */\n  step: IRStep;\n  /** Individual step mapping results */\n  mappings: StepMappingResult[];\n  /** Number of successfully mapped steps */\n  mappedCount: number;\n  /** Number of blocked/unmatched steps */\n  blockedCount: number;\n}\n\n/**\n * Check if a primitive is an assertion\n */\nfunction isAssertion(primitive: IRPrimitive): boolean {\n  return primitive.type.startsWith('expect');\n}\n\n/**\n * Map a single text step to an IR primitive\n */\nexport function mapStepText(\n  text: string,\n  options: StepMapperOptions = {}\n): StepMappingResult {\n  const { normalizeText = true } = options;\n\n  // Extract machine hints first (T073 - hints take priority)\n  const hints = extractHints(text);\n  const cleanText = hints.hasHints ? hints.cleanText : text;\n\n  // Normalize text if enabled\n  const processedText = normalizeText ? normalizeStepText(cleanText) : cleanText;\n\n  // Try to match against patterns\n  let primitive = matchPattern(processedText);\n\n  // If we have hints, enhance or override the primitive\n  if (primitive && hints.hasHints) {\n    primitive = applyHintsToPrimitive(primitive, hints);\n  } else if (!primitive && hasLocatorHints(hints)) {\n    // If no pattern match but we have locator hints, try to create primitive from hints\n    primitive = createPrimitiveFromHints(processedText, hints);\n  }\n\n  if (primitive) {\n    return {\n      primitive,\n      sourceText: text,\n      isAssertion: isAssertion(primitive),\n    };\n  }\n\n  // No match - return blocked\n  return {\n    primitive: null,\n    sourceText: text,\n    isAssertion: false,\n    message: `Could not map step: \"${text}\"`,\n  };\n}\n\n/**\n * Apply hints to an existing primitive (override inferred values)\n */\nfunction applyHintsToPrimitive(primitive: IRPrimitive, hints: ExtractedHints): IRPrimitive {\n  // Clone the primitive to avoid mutation\n  const enhanced = { ...primitive };\n\n  // Apply locator hints if present\n  if (hasLocatorHints(hints)) {\n    const locatorSpec = buildLocatorFromHints(hints);\n    if (locatorSpec && 'locator' in enhanced) {\n      (enhanced as { locator: LocatorSpec }).locator = locatorSpec;\n    }\n  }\n\n  // Apply behavior hints\n  if (hasBehaviorHints(hints)) {\n    if (hints.behavior.timeout !== undefined && 'timeout' in enhanced) {\n      (enhanced as { timeout: number }).timeout = hints.behavior.timeout;\n    }\n    if (hints.behavior.signal && 'signal' in enhanced) {\n      (enhanced as { signal: string }).signal = hints.behavior.signal;\n    }\n    if (hints.behavior.module) {\n      const parsed = parseModuleHint(hints.behavior.module);\n      if (parsed) {\n        (enhanced as { module?: string; method?: string }).module = parsed.module;\n        (enhanced as { module?: string; method?: string }).method = parsed.method;\n      }\n    }\n  }\n\n  return enhanced;\n}\n\n/**\n * Build LocatorSpec from hints\n */\nfunction buildLocatorFromHints(hints: ExtractedHints): LocatorSpec | null {\n  const { locator } = hints;\n\n  if (locator.testid) {\n    return { strategy: 'testid', value: locator.testid };\n  }\n\n  if (locator.role) {\n    const options: Record<string, unknown> = {};\n    if (locator.label) options.name = locator.label;\n    if (locator.exact) options.exact = true;\n    if (locator.level) options.level = locator.level;\n    return {\n      strategy: 'role',\n      value: locator.role,\n      options: Object.keys(options).length > 0 ? options : undefined,\n    };\n  }\n\n  if (locator.label) {\n    return {\n      strategy: 'label',\n      value: locator.label,\n      options: locator.exact ? { exact: true } : undefined,\n    };\n  }\n\n  if (locator.text) {\n    return {\n      strategy: 'text',\n      value: locator.text,\n      options: locator.exact ? { exact: true } : undefined,\n    };\n  }\n\n  return null;\n}\n\n/**\n * Create a primitive from hints when no pattern matched\n */\nfunction createPrimitiveFromHints(text: string, hints: ExtractedHints): IRPrimitive | null {\n  const locator = buildLocatorFromHints(hints);\n  if (!locator) return null;\n\n  const lowerText = text.toLowerCase();\n\n  // Infer action type from text\n  if (lowerText.includes('click') || lowerText.includes('press')) {\n    return { type: 'click', locator };\n  }\n\n  if (lowerText.includes('enter') || lowerText.includes('type') || lowerText.includes('fill')) {\n    // Try to extract value from text\n    const valueMatch = text.match(/['\"]([^'\"]+)['\"]/);\n    return {\n      type: 'fill',\n      locator,\n      value: { type: 'literal', value: valueMatch ? valueMatch[1]! : '' },\n    };\n  }\n\n  if (lowerText.includes('see') || lowerText.includes('visible') || lowerText.includes('display')) {\n    return { type: 'expectVisible', locator };\n  }\n\n  if (lowerText.includes('check') || lowerText.includes('select')) {\n    return { type: 'check', locator };\n  }\n\n  // Default to click if we have a locator but can't determine action\n  return { type: 'click', locator };\n}\n\n/**\n * Map an acceptance criterion to an IR step\n */\nexport function mapAcceptanceCriterion(\n  ac: AcceptanceCriterion,\n  proceduralSteps: ProceduralStep[],\n  options: StepMapperOptions = {}\n): ACMappingResult {\n  const { includeBlocked = true } = options;\n\n  const actions: IRPrimitive[] = [];\n  const assertions: IRPrimitive[] = [];\n  const mappings: StepMappingResult[] = [];\n  const notes: string[] = [];\n\n  // Find procedural steps linked to this AC\n  const linkedProcedural = proceduralSteps.filter((ps) => ps.linkedAC === ac.id);\n\n  // Map all bullet points from the AC\n  for (const stepText of ac.steps) {\n    const result = mapStepText(stepText, options);\n    mappings.push(result);\n\n    if (result.primitive) {\n      if (result.isAssertion) {\n        assertions.push(result.primitive);\n      } else {\n        actions.push(result.primitive);\n      }\n    } else if (includeBlocked) {\n      actions.push({\n        type: 'blocked',\n        reason: result.message || 'Could not map step',\n        sourceText: stepText,\n      });\n    }\n  }\n\n  // Also map linked procedural steps\n  for (const ps of linkedProcedural) {\n    const result = mapStepText(ps.text, options);\n    // Don't duplicate in mappings, but add to actions if different from AC steps\n    if (result.primitive && !ac.steps.includes(ps.text)) {\n      if (result.isAssertion) {\n        assertions.push(result.primitive);\n      } else {\n        actions.push(result.primitive);\n      }\n    }\n  }\n\n  // Add note if no assertions\n  if (assertions.length === 0 && ac.title) {\n    notes.push(`TODO: Add assertion for: ${ac.title}`);\n  }\n\n  const step: IRStep = {\n    id: ac.id,\n    description: ac.title || `Step ${ac.id}`,\n    actions,\n    assertions,\n    sourceText: ac.rawContent,\n    notes: notes.length > 0 ? notes : undefined,\n  };\n\n  return {\n    step,\n    mappings,\n    mappedCount: mappings.filter((m) => m.primitive !== null).length,\n    blockedCount: mappings.filter((m) => m.primitive === null).length,\n  };\n}\n\n/**\n * Map a procedural step to an IR step\n */\nexport function mapProceduralStep(\n  ps: ProceduralStep,\n  options: StepMapperOptions = {}\n): ACMappingResult {\n  const { includeBlocked = true } = options;\n\n  const result = mapStepText(ps.text, options);\n  const actions: IRPrimitive[] = [];\n  const assertions: IRPrimitive[] = [];\n\n  if (result.primitive) {\n    if (result.isAssertion) {\n      assertions.push(result.primitive);\n    } else {\n      actions.push(result.primitive);\n    }\n  } else if (includeBlocked) {\n    actions.push({\n      type: 'blocked',\n      reason: result.message || 'Could not map procedural step',\n      sourceText: ps.text,\n    });\n  }\n\n  const step: IRStep = {\n    id: `PS-${ps.number}`,\n    description: ps.text,\n    actions,\n    assertions,\n  };\n\n  return {\n    step,\n    mappings: [result],\n    mappedCount: result.primitive ? 1 : 0,\n    blockedCount: result.primitive ? 0 : 1,\n  };\n}\n\n/**\n * Batch map multiple steps\n */\nexport function mapSteps(\n  steps: string[],\n  options: StepMapperOptions = {}\n): StepMappingResult[] {\n  return steps.map((step) => mapStepText(step, options));\n}\n\n/**\n * Get mapping statistics\n */\nexport function getMappingStats(mappings: StepMappingResult[]): {\n  total: number;\n  mapped: number;\n  blocked: number;\n  actions: number;\n  assertions: number;\n  mappingRate: number;\n} {\n  const mapped = mappings.filter((m) => m.primitive !== null);\n  const blocked = mappings.filter((m) => m.primitive === null);\n  const actions = mapped.filter((m) => !m.isAssertion);\n  const assertions = mapped.filter((m) => m.isAssertion);\n\n  return {\n    total: mappings.length,\n    mapped: mapped.length,\n    blocked: blocked.length,\n    actions: actions.length,\n    assertions: assertions.length,\n    mappingRate: mappings.length > 0 ? mapped.length / mappings.length : 0,\n  };\n}\n\n/**\n * Suggest improvements for blocked steps\n */\nexport function suggestImprovements(blockedSteps: StepMappingResult[]): string[] {\n  const suggestions: string[] = [];\n\n  for (const step of blockedSteps) {\n    const text = step.sourceText.toLowerCase();\n\n    // Navigation suggestions\n    if (text.includes('go') || text.includes('open') || text.includes('navigate')) {\n      suggestions.push(\n        `\"${step.sourceText}\" - Try: \"User navigates to /path\" or \"User opens /path\"`\n      );\n    }\n    // Click suggestions\n    else if (text.includes('click') || text.includes('press') || text.includes('button')) {\n      suggestions.push(\n        `\"${step.sourceText}\" - Try: \"User clicks 'Button Name' button\" or \"Click the 'Label' button\"`\n      );\n    }\n    // Fill suggestions\n    else if (text.includes('enter') || text.includes('type') || text.includes('field')) {\n      suggestions.push(\n        `\"${step.sourceText}\" - Try: \"User enters 'value' in 'Field Label' field\"`\n      );\n    }\n    // Visibility suggestions\n    else if (text.includes('see') || text.includes('visible') || text.includes('display')) {\n      suggestions.push(\n        `\"${step.sourceText}\" - Try: \"User should see 'Text'\" or \"'Element' is visible\"`\n      );\n    }\n    // Generic suggestion\n    else {\n      suggestions.push(\n        `\"${step.sourceText}\" - Could not determine intent. Check the patterns documentation.`\n      );\n    }\n  }\n\n  return suggestions;\n}\n"]}
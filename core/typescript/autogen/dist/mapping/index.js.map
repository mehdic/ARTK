{"version":3,"sources":["../../src/mapping/glossary.ts","../../src/utils/paths.ts","../../src/mapping/patternDistance.ts","../../src/llkb/patternExtension.ts","../../src/mapping/patterns.ts","../../src/mapping/index.ts","../../src/mapping/stepMapper.ts","../../src/journey/hintPatterns.ts","../../src/journey/parseHints.ts","../../src/mapping/blockedStepAnalysis.ts","../../src/mapping/telemetry.ts","../../src/mapping/unifiedMatcher.ts","../../src/mapping/fuzzyMatcher.ts","../../src/mapping/normalize.ts","../../src/mapping/plannedActionAdapter.ts","../../src/mapping/llmFallback.ts"],"names":["parseYaml","coreMapping","existsSync","join","readFileSync","dirname","z","mkdirSync","unlinkSync","result"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Glossary Loader - Load and resolve synonyms for step text normalization\n * @see research/2026-01-02_autogen-refined-plan.md Section 10\n * @see research/2026-01-23_llkb-autogen-integration-specification.md (LLKB integration)\n */\nimport { readFileSync, existsSync } from 'node:fs';\nimport { resolve } from 'node:path';\nimport { pathToFileURL } from 'node:url';\nimport { parse as parseYaml } from 'yaml';\nimport { z } from 'zod';\nimport type { IRPrimitive } from '../ir/types.js';\n\n/**\n * Glossary entry schema\n */\nconst GlossaryEntrySchema = z.object({\n  canonical: z.string(),\n  synonyms: z.array(z.string()),\n});\n\n/**\n * Label alias entry schema (maps display labels to testids/selectors)\n * @see T082 - Extend glossary schema for labelAliases\n */\nconst LabelAliasSchema = z.object({\n  label: z.string(),\n  testid: z.string().optional(),\n  role: z.string().optional(),\n  selector: z.string().optional(),\n});\n\n/**\n * Module method mapping schema (maps phrases to module.method calls)\n * @see T082 - Module method resolution\n */\nconst ModuleMethodMappingSchema = z.object({\n  phrase: z.string(),\n  module: z.string(),\n  method: z.string(),\n  params: z.record(z.string()).optional(),\n});\n\n/**\n * Glossary file schema\n */\nconst GlossarySchema = z.object({\n  version: z.number().default(1),\n  entries: z.array(GlossaryEntrySchema),\n  labelAliases: z.array(LabelAliasSchema).default([]),\n  moduleMethods: z.array(ModuleMethodMappingSchema).default([]),\n});\n\nexport type LabelAlias = z.infer<typeof LabelAliasSchema>;\nexport type ModuleMethodMapping = z.infer<typeof ModuleMethodMappingSchema>;\n\nexport type GlossaryEntry = z.infer<typeof GlossaryEntrySchema>;\nexport type Glossary = z.infer<typeof GlossarySchema>;\n\n/**\n * Default glossary entries for common terms\n */\nexport const defaultGlossary: Glossary = {\n  version: 1,\n  labelAliases: [\n    // Common label-to-selector mappings\n    { label: 'email', testid: 'email-input', role: 'textbox' },\n    { label: 'password', testid: 'password-input', role: 'textbox' },\n    { label: 'username', testid: 'username-input', role: 'textbox' },\n    { label: 'search', testid: 'search-input', role: 'searchbox' },\n    { label: 'submit', testid: 'submit-button', role: 'button' },\n    { label: 'cancel', testid: 'cancel-button', role: 'button' },\n    { label: 'close', testid: 'close-button', role: 'button' },\n  ],\n  moduleMethods: [\n    // Common phrase-to-module mappings\n    { phrase: 'log in', module: 'auth', method: 'login' },\n    { phrase: 'login', module: 'auth', method: 'login' },\n    { phrase: 'sign in', module: 'auth', method: 'login' },\n    { phrase: 'log out', module: 'auth', method: 'logout' },\n    { phrase: 'logout', module: 'auth', method: 'logout' },\n    { phrase: 'sign out', module: 'auth', method: 'logout' },\n    { phrase: 'navigate to', module: 'navigation', method: 'goToPath' },\n    { phrase: 'go to', module: 'navigation', method: 'goToPath' },\n    { phrase: 'open', module: 'navigation', method: 'goToPath' },\n    { phrase: 'fill form', module: 'forms', method: 'fillForm' },\n    { phrase: 'submit form', module: 'forms', method: 'submitForm' },\n    { phrase: 'wait for', module: 'waits', method: 'waitForSignal' },\n  ],\n  entries: [\n    {\n      canonical: 'click',\n      synonyms: ['press', 'tap', 'select', 'hit'],\n    },\n    {\n      canonical: 'enter',\n      synonyms: ['type', 'fill', 'input', 'write'],\n    },\n    {\n      canonical: 'navigate',\n      synonyms: ['go', 'open', 'visit', 'browse'],\n    },\n    {\n      canonical: 'see',\n      synonyms: ['view', 'observe', 'notice', 'find'],\n    },\n    {\n      canonical: 'visible',\n      synonyms: ['displayed', 'shown', 'present'],\n    },\n    {\n      canonical: 'button',\n      synonyms: ['btn', 'action', 'cta'],\n    },\n    {\n      canonical: 'field',\n      synonyms: ['input', 'textbox', 'text field', 'text input'],\n    },\n    {\n      canonical: 'dropdown',\n      synonyms: ['select', 'combo', 'combobox', 'selector', 'picker'],\n    },\n    {\n      canonical: 'checkbox',\n      synonyms: ['check', 'tick', 'toggle'],\n    },\n    {\n      canonical: 'login',\n      synonyms: ['log in', 'sign in', 'authenticate'],\n    },\n    {\n      canonical: 'logout',\n      synonyms: ['log out', 'sign out', 'exit'],\n    },\n    {\n      canonical: 'submit',\n      synonyms: ['send', 'save', 'confirm', 'ok'],\n    },\n    {\n      canonical: 'cancel',\n      synonyms: ['close', 'dismiss', 'abort', 'back'],\n    },\n    {\n      canonical: 'success',\n      synonyms: ['passed', 'completed', 'done', 'finished'],\n    },\n    {\n      canonical: 'error',\n      synonyms: ['failure', 'failed', 'problem', 'issue'],\n    },\n    {\n      canonical: 'toast',\n      synonyms: ['notification', 'message', 'alert', 'snackbar'],\n    },\n    {\n      canonical: 'modal',\n      synonyms: ['dialog', 'popup', 'overlay', 'lightbox'],\n    },\n    {\n      canonical: 'user',\n      synonyms: ['customer', 'visitor', 'member', 'client'],\n    },\n    {\n      canonical: 'page',\n      synonyms: ['screen', 'view', 'section'],\n    },\n    {\n      canonical: 'form',\n      synonyms: ['questionnaire', 'survey', 'wizard'],\n    },\n  ],\n};\n\n/**\n * Loaded glossary cache\n */\nlet glossaryCache: Glossary | null = null;\nlet synonymMap: Map<string, string> | null = null;\n\n/**\n * Build a synonym lookup map from glossary\n */\nfunction buildSynonymMap(glossary: Glossary): Map<string, string> {\n  const map = new Map<string, string>();\n\n  for (const entry of glossary.entries) {\n    // Map canonical to itself\n    map.set(entry.canonical.toLowerCase(), entry.canonical);\n\n    // Map all synonyms to canonical\n    for (const synonym of entry.synonyms) {\n      map.set(synonym.toLowerCase(), entry.canonical);\n    }\n  }\n\n  return map;\n}\n\n/**\n * Load glossary from file\n * @param glossaryPath - Path to glossary YAML file\n */\nexport function loadGlossary(glossaryPath: string): Glossary {\n  const resolvedPath = resolve(glossaryPath);\n\n  if (!existsSync(resolvedPath)) {\n    console.warn(`Glossary file not found at ${resolvedPath}, using defaults`);\n    return defaultGlossary;\n  }\n\n  try {\n    const content = readFileSync(resolvedPath, 'utf-8');\n    const parsed = parseYaml(content);\n    const result = GlossarySchema.safeParse(parsed);\n\n    if (!result.success) {\n      console.warn(`Invalid glossary file at ${resolvedPath}, using defaults`);\n      return defaultGlossary;\n    }\n\n    // Merge with defaults\n    return mergeGlossaries(defaultGlossary, result.data);\n  } catch {\n    console.warn(`Failed to load glossary from ${resolvedPath}, using defaults`);\n    return defaultGlossary;\n  }\n}\n\n/**\n * Merge two glossaries (user glossary extends defaults)\n */\nexport function mergeGlossaries(base: Glossary, extension: Glossary): Glossary {\n  const merged: Glossary = {\n    version: Math.max(base.version, extension.version),\n    entries: [...base.entries],\n    labelAliases: [...(base.labelAliases ?? [])],\n    moduleMethods: [...(base.moduleMethods ?? [])],\n  };\n\n  // Add or extend entries from extension\n  for (const extEntry of extension.entries) {\n    const existing = merged.entries.find(\n      (e) => e.canonical.toLowerCase() === extEntry.canonical.toLowerCase()\n    );\n\n    if (existing) {\n      // Merge synonyms\n      const allSynonyms = new Set([...existing.synonyms, ...extEntry.synonyms]);\n      existing.synonyms = Array.from(allSynonyms);\n    } else {\n      // Add new entry\n      merged.entries.push(extEntry);\n    }\n  }\n\n  // Add or extend label aliases from extension\n  for (const extAlias of extension.labelAliases ?? []) {\n    const existing = merged.labelAliases.find(\n      (a) => a.label.toLowerCase() === extAlias.label.toLowerCase()\n    );\n\n    if (!existing) {\n      merged.labelAliases.push(extAlias);\n    } else {\n      // Override with extension values\n      Object.assign(existing, extAlias);\n    }\n  }\n\n  // Add or extend module methods from extension\n  for (const extMethod of extension.moduleMethods ?? []) {\n    const existing = merged.moduleMethods.find(\n      (m) => m.phrase.toLowerCase() === extMethod.phrase.toLowerCase()\n    );\n\n    if (!existing) {\n      merged.moduleMethods.push(extMethod);\n    } else {\n      // Override with extension values\n      Object.assign(existing, extMethod);\n    }\n  }\n\n  return merged;\n}\n\n/**\n * Initialize the glossary (call once at startup)\n * @param glossaryPath - Optional path to custom glossary\n */\nexport function initGlossary(glossaryPath?: string): void {\n  if (glossaryPath) {\n    glossaryCache = loadGlossary(glossaryPath);\n  } else {\n    glossaryCache = defaultGlossary;\n  }\n  synonymMap = buildSynonymMap(glossaryCache);\n}\n\n/**\n * Get the current glossary\n */\nexport function getGlossary(): Glossary {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n  return glossaryCache!;\n}\n\n/**\n * Resolve a term to its canonical form\n * @param term - Term to resolve\n * @returns Canonical form or original term if not found\n */\nexport function resolveCanonical(term: string): string {\n  if (!synonymMap) {\n    initGlossary();\n  }\n  return synonymMap!.get(term.toLowerCase()) ?? term;\n}\n\n/**\n * Normalize step text by replacing synonyms with canonical terms\n * @param text - Step text to normalize\n * @returns Normalized text\n */\nexport function normalizeStepText(text: string): string {\n  if (!synonymMap) {\n    initGlossary();\n  }\n\n  // Split into words, preserving quoted strings\n  const parts: string[] = [];\n  const regex = /(['\"][^'\"]+['\"])|(\\S+)/g;\n  let match;\n\n  while ((match = regex.exec(text)) !== null) {\n    const part = match[0];\n\n    // Don't normalize quoted strings\n    if (part.startsWith('\"') || part.startsWith(\"'\")) {\n      parts.push(part);\n    } else {\n      // Check if this word has a canonical form\n      // Lowercase for consistent matching (LLKB pattern matching requires this)\n      const lowerPart = part.toLowerCase();\n      const canonical = synonymMap!.get(lowerPart);\n      parts.push(canonical ?? lowerPart);\n    }\n  }\n\n  return parts.join(' ');\n}\n\n/**\n * Get all synonyms for a canonical term\n */\nexport function getSynonyms(canonical: string): string[] {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n\n  const entry = glossaryCache!.entries.find(\n    (e) => e.canonical.toLowerCase() === canonical.toLowerCase()\n  );\n\n  return entry?.synonyms ?? [];\n}\n\n/**\n * Check if a term is a synonym of a canonical term\n */\nexport function isSynonymOf(term: string, canonical: string): boolean {\n  const resolved = resolveCanonical(term);\n  return resolved.toLowerCase() === canonical.toLowerCase();\n}\n\n/**\n * Reset the glossary cache (for testing)\n */\nexport function resetGlossaryCache(): void {\n  glossaryCache = null;\n  synonymMap = null;\n}\n\n/**\n * Find a label alias by label text\n * @see T082 - Label alias matching\n */\nexport function findLabelAlias(label: string): LabelAlias | null {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n\n  const normalizedLabel = label.toLowerCase().trim();\n\n  return (\n    glossaryCache!.labelAliases?.find(\n      (alias) => alias.label.toLowerCase() === normalizedLabel\n    ) ?? null\n  );\n}\n\n/**\n * Get locator info from label alias\n */\nexport function getLocatorFromLabel(label: string): { strategy: string; value: string } | null {\n  const alias = findLabelAlias(label);\n  if (!alias) return null;\n\n  // Priority: testid > role > selector\n  if (alias.testid) {\n    return { strategy: 'testid', value: alias.testid };\n  }\n  if (alias.role) {\n    return { strategy: 'role', value: alias.role };\n  }\n  if (alias.selector) {\n    return { strategy: 'css', value: alias.selector };\n  }\n\n  return null;\n}\n\n/**\n * Find a module method mapping by phrase\n * @see T083 - Module method resolution in step mapper\n */\nexport function findModuleMethod(text: string): ModuleMethodMapping | null {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n\n  const normalizedText = text.toLowerCase().trim();\n\n  // Find the best matching phrase (longest match wins)\n  let bestMatch: ModuleMethodMapping | null = null;\n  let bestMatchLength = 0;\n\n  for (const mapping of glossaryCache!.moduleMethods ?? []) {\n    const phrase = mapping.phrase.toLowerCase();\n    if (normalizedText.includes(phrase) && phrase.length > bestMatchLength) {\n      bestMatch = mapping;\n      bestMatchLength = phrase.length;\n    }\n  }\n\n  return bestMatch;\n}\n\n/**\n * Resolve a step to a module method call if it matches\n */\nexport function resolveModuleMethod(\n  text: string\n): { module: string; method: string; params?: Record<string, string> } | null {\n  const mapping = findModuleMethod(text);\n  if (!mapping) return null;\n\n  return {\n    module: mapping.module,\n    method: mapping.method,\n    params: mapping.params,\n  };\n}\n\n/**\n * Get all label aliases\n */\nexport function getLabelAliases(): LabelAlias[] {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n  return glossaryCache!.labelAliases ?? [];\n}\n\n/**\n * Get all module method mappings\n */\nexport function getModuleMethods(): ModuleMethodMapping[] {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n  return glossaryCache!.moduleMethods ?? [];\n}\n\n// ============================================================================\n// LLKB Extended Glossary Support\n// @see research/2026-01-23_llkb-autogen-integration-specification.md\n// ============================================================================\n\n/**\n * Extended glossary metadata from LLKB export\n */\nexport interface ExtendedGlossaryMeta {\n  exportedAt: string;\n  entryCount: number;\n  minConfidence?: number;\n  sourceComponents?: string[];\n  sourceLessons?: string[];\n}\n\n/**\n * Extended glossary loaded from LLKB export\n */\nlet extendedGlossary: Map<string, IRPrimitive> | null = null;\nlet extendedGlossaryMeta: ExtendedGlossaryMeta | null = null;\n\n/**\n * Load extended glossary from LLKB export file\n * @param glossaryPath - Path to the LLKB-generated glossary TypeScript file\n * @returns Loading result with entry count and metadata\n */\nexport async function loadExtendedGlossary(glossaryPath: string): Promise<{\n  loaded: boolean;\n  entryCount: number;\n  exportedAt: string | null;\n  error?: string;\n}> {\n  try {\n    const resolvedPath = resolve(glossaryPath);\n\n    if (!existsSync(resolvedPath)) {\n      return {\n        loaded: false,\n        entryCount: 0,\n        exportedAt: null,\n        error: `Glossary file not found: ${resolvedPath}`,\n      };\n    }\n\n    // Dynamic import of the generated glossary file\n    // Use file:// URL for Windows compatibility\n    const fileUrl = pathToFileURL(resolvedPath).href;\n    const module = await import(fileUrl);\n\n    if (module.llkbGlossary instanceof Map) {\n      const glossaryMap: Map<string, IRPrimitive> = module.llkbGlossary;\n      extendedGlossary = glossaryMap;\n      extendedGlossaryMeta = module.llkbGlossaryMeta ?? null;\n\n      return {\n        loaded: true,\n        entryCount: glossaryMap.size,\n        exportedAt: extendedGlossaryMeta?.exportedAt ?? null,\n      };\n    }\n\n    // If llkbGlossary is a plain object, convert to Map\n    if (module.llkbGlossary && typeof module.llkbGlossary === 'object') {\n      const glossaryMap = new Map<string, IRPrimitive>(\n        Object.entries(module.llkbGlossary) as [string, IRPrimitive][]\n      );\n      extendedGlossary = glossaryMap;\n      extendedGlossaryMeta = module.llkbGlossaryMeta ?? null;\n\n      return {\n        loaded: true,\n        entryCount: glossaryMap.size,\n        exportedAt: extendedGlossaryMeta?.exportedAt ?? null,\n      };\n    }\n\n    return {\n      loaded: false,\n      entryCount: 0,\n      exportedAt: null,\n      error: 'Invalid glossary format: llkbGlossary not found or not a Map/object',\n    };\n  } catch (err) {\n    return {\n      loaded: false,\n      entryCount: 0,\n      exportedAt: null,\n      error: `Failed to load glossary: ${err instanceof Error ? err.message : String(err)}`,\n    };\n  }\n}\n\n/**\n * Clear extended glossary (for testing)\n */\nexport function clearExtendedGlossary(): void {\n  extendedGlossary = null;\n  extendedGlossaryMeta = null;\n}\n\n/**\n * Check if a term exactly matches a core glossary phrase\n * (not just a partial/substring match)\n */\nfunction isExactCoreMatch(term: string): boolean {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n\n  const normalizedTerm = term.toLowerCase().trim();\n\n  // Check if any module method phrase exactly matches the term\n  for (const mapping of glossaryCache!.moduleMethods ?? []) {\n    if (mapping.phrase.toLowerCase() === normalizedTerm) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Lookup a term in both core glossary and extended LLKB glossary\n * Core glossary takes precedence for exact matches (LLKB only extends, never overrides)\n * @param term - Term to look up\n * @returns IR primitive if found, undefined otherwise\n */\nexport function lookupGlossary(term: string): IRPrimitive | undefined {\n  const normalizedTerm = term.toLowerCase().trim();\n\n  // First check if core glossary has an EXACT match for this term\n  // Core always wins for exact matches (LLKB never overrides core)\n  if (isExactCoreMatch(normalizedTerm)) {\n    const coreMapping = findModuleMethod(normalizedTerm);\n    if (coreMapping) {\n      return {\n        type: 'callModule',\n        module: coreMapping.module,\n        method: coreMapping.method,\n        args: coreMapping.params ? [coreMapping.params] : undefined,\n      };\n    }\n  }\n\n  // Then check extended glossary for exact match\n  // LLKB extends core glossary with new terms\n  if (extendedGlossary) {\n    const extendedMatch = extendedGlossary.get(normalizedTerm);\n    if (extendedMatch) {\n      return extendedMatch;\n    }\n  }\n\n  // Finally, check core glossary for partial/substring matches\n  // This allows core patterns like \"wait for\" to match \"wait for something\"\n  const coreMapping = findModuleMethod(normalizedTerm);\n  if (coreMapping) {\n    return {\n      type: 'callModule',\n      module: coreMapping.module,\n      method: coreMapping.method,\n      args: coreMapping.params ? [coreMapping.params] : undefined,\n    };\n  }\n\n  return undefined;\n}\n\n/**\n * Lookup a term in core glossary only (for priority enforcement)\n * Used when LLKB should NOT override core mappings\n * @param term - Term to look up\n * @returns IR primitive if found, undefined otherwise\n */\nexport function lookupCoreGlossary(term: string): IRPrimitive | undefined {\n  const normalizedTerm = term.toLowerCase().trim();\n\n  const coreMapping = findModuleMethod(normalizedTerm);\n  if (coreMapping) {\n    return {\n      type: 'callModule',\n      module: coreMapping.module,\n      method: coreMapping.method,\n      args: coreMapping.params ? [coreMapping.params] : undefined,\n    };\n  }\n\n  return undefined;\n}\n\n/**\n * Get glossary statistics\n */\nexport function getGlossaryStats(): {\n  coreEntries: number;\n  extendedEntries: number;\n  extendedExportedAt: string | null;\n  extendedMeta: ExtendedGlossaryMeta | null;\n} {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n\n  return {\n    coreEntries: glossaryCache!.moduleMethods?.length ?? 0,\n    extendedEntries: extendedGlossary?.size ?? 0,\n    extendedExportedAt: extendedGlossaryMeta?.exportedAt ?? null,\n    extendedMeta: extendedGlossaryMeta,\n  };\n}\n\n/**\n * Check if extended glossary is loaded\n */\nexport function hasExtendedGlossary(): boolean {\n  return extendedGlossary !== null && extendedGlossary.size > 0;\n}\n","/**\n * Cross-module-system path utilities\n *\n * Provides directory resolution that works in both ESM and CJS environments.\n *\n * IMPORTANT: This module uses a dual-strategy approach:\n * - In CJS: Uses __dirname (injected by Node.js module wrapper)\n * - In ESM: Uses import.meta.url (only available in ESM)\n *\n * The TypeScript source uses import.meta.url, which works for ESM builds.\n * For CJS builds, we detect that __dirname is available and use it instead.\n */\nimport { join, dirname, resolve, relative, isAbsolute } from 'node:path';\nimport { readFileSync, existsSync, realpathSync } from 'node:fs';\nimport { fileURLToPath } from 'node:url';\n\n// CJS-specific globals - these are injected by Node.js module wrapper in CJS context\n// They will be undefined in ESM context\ndeclare const __dirname: string | undefined;\n \ndeclare const require: ((_id: string) => any) & { resolve: (_id: string) => string } | undefined;\n\n/**\n * Cached package root to avoid repeated lookups\n */\nlet cachedPackageRoot: string | undefined;\n\n/**\n * Cached module directory\n */\nlet cachedModuleDir: string | undefined;\n\n/**\n * Get the directory where this module file is located.\n * Works in both ESM and CJS environments.\n */\nfunction getModuleDir(): string {\n  if (cachedModuleDir) {\n    return cachedModuleDir;\n  }\n\n  // In CJS, __dirname is injected by Node.js module wrapper\n  // It will be undefined in ESM context\n  if (typeof __dirname === 'string' && __dirname.length > 0) {\n    cachedModuleDir = __dirname;\n    return cachedModuleDir;\n  }\n\n  // In ESM, use import.meta.url directly\n  // For CJS builds, this block is removed by post-build script (not needed since __dirname works)\n  // __ESM_ONLY_START__\n  try {\n    // @ts-ignore - Valid in ESM, removed from CJS by post-build\n    const metaUrl: string | undefined = import.meta.url;\n    if (metaUrl) {\n      cachedModuleDir = dirname(fileURLToPath(metaUrl));\n      return cachedModuleDir;\n    }\n  } catch {\n    // import.meta not available\n  }\n  // __ESM_ONLY_END__\n\n  // Fallback: try to find via require.resolve (CJS only)\n  try {\n    if (typeof require !== 'undefined' && require?.resolve) {\n      const resolved = require.resolve('@artk/core-autogen/package.json');\n      cachedModuleDir = dirname(resolved);\n      return cachedModuleDir;\n    }\n  } catch {\n    // Package not found via require.resolve\n  }\n\n  // Last resort: use process.cwd()\n  // This is unreliable but better than crashing\n  cachedModuleDir = process.cwd();\n  return cachedModuleDir;\n}\n\n/**\n * Get the package root directory.\n *\n * Strategy:\n * 1. Check ARTK_AUTOGEN_ROOT env var (for testing/override)\n * 2. Use module location to find package root\n * 3. Fallback to cwd-based search\n */\nexport function getPackageRoot(): string {\n  if (cachedPackageRoot) {\n    return cachedPackageRoot;\n  }\n\n  // 1. Check environment variable override\n  const envRoot = process.env['ARTK_AUTOGEN_ROOT'];\n  if (envRoot && existsSync(join(envRoot, 'package.json'))) {\n    cachedPackageRoot = envRoot;\n    return cachedPackageRoot;\n  }\n\n  // 2. Find package root from module location\n  // This file is at: <package-root>/dist[-variant]/utils/paths.js\n  // So we go up 2 levels to find package root\n  const moduleDir = getModuleDir();\n  const possibleRoots = [\n    join(moduleDir, '..', '..'),     // from dist/utils/ or dist-cjs/utils/\n    join(moduleDir, '..'),           // from dist/ directly\n    moduleDir,                        // if already at root\n  ];\n\n  for (const root of possibleRoots) {\n    const pkgPath = join(root, 'package.json');\n    if (existsSync(pkgPath)) {\n      try {\n        const pkg = JSON.parse(readFileSync(pkgPath, 'utf-8'));\n        if (pkg.name === '@artk/core-autogen') {\n          cachedPackageRoot = root;\n          return cachedPackageRoot;\n        }\n      } catch {\n        // Continue searching\n      }\n    }\n  }\n\n  // 3. Fallback to cwd-based search (for vendored installations)\n  const cwdPaths = [\n    join(process.cwd(), 'node_modules', '@artk', 'core-autogen'),\n    join(process.cwd(), 'artk-e2e', 'vendor', 'artk-core-autogen'),\n    process.cwd(),\n  ];\n\n  for (const searchPath of cwdPaths) {\n    const pkgPath = join(searchPath, 'package.json');\n    if (existsSync(pkgPath)) {\n      try {\n        const pkg = JSON.parse(readFileSync(pkgPath, 'utf-8'));\n        if (pkg.name === '@artk/core-autogen') {\n          cachedPackageRoot = searchPath;\n          return cachedPackageRoot;\n        }\n      } catch {\n        // Continue searching\n      }\n    }\n  }\n\n  // Final fallback - use module directory's parent\n  cachedPackageRoot = join(moduleDir, '..', '..');\n  return cachedPackageRoot;\n}\n\n/**\n * Get the templates directory path.\n *\n * Templates are copied to dist/codegen/templates/ during build.\n * When installed, only one dist variant exists.\n */\nexport function getTemplatesDir(): string {\n  const root = getPackageRoot();\n  const moduleDir = getModuleDir();\n\n  // First, try relative to the module itself (most reliable)\n  // Module is at dist[-variant]/utils/paths.js\n  // Templates are at dist[-variant]/codegen/templates/\n  const relativeToModule = join(moduleDir, '..', 'codegen', 'templates');\n  if (existsSync(relativeToModule)) {\n    return relativeToModule;\n  }\n\n  // Fallback: check standard locations from package root\n  const possiblePaths = [\n    join(root, 'dist', 'codegen', 'templates'),\n    join(root, 'dist-cjs', 'codegen', 'templates'),\n    join(root, 'dist-legacy-16', 'codegen', 'templates'),\n    join(root, 'dist-legacy-14', 'codegen', 'templates'),\n  ];\n\n  for (const templatesPath of possiblePaths) {\n    if (existsSync(templatesPath)) {\n      return templatesPath;\n    }\n  }\n\n  // Final fallback\n  return possiblePaths[0] ?? join(root, 'dist', 'codegen', 'templates');\n}\n\n/**\n * Get the path to a specific template file.\n */\nexport function getTemplatePath(templateName: string): string {\n  return join(getTemplatesDir(), templateName);\n}\n\n/**\n * Clear cached paths (for testing)\n */\nexport function clearPathCache(): void {\n  cachedPackageRoot = undefined;\n  cachedModuleDir = undefined;\n  cachedHarnessRoot = undefined;\n}\n\n/**\n * Cached harness root to avoid repeated lookups\n */\nlet cachedHarnessRoot: string | undefined;\n\n/**\n * Get the ARTK harness root directory (artk-e2e/).\n *\n * This function infers the correct harness root by checking:\n * 1. ARTK_HARNESS_ROOT environment variable (explicit override)\n * 2. artk-e2e/ subdirectory from cwd (standard installation)\n * 3. Current directory if it contains artk.config.yml (inside harness)\n * 4. Fallback to cwd (backwards compatibility)\n *\n * @returns Path to the harness root directory\n */\nexport function getHarnessRoot(): string {\n  if (cachedHarnessRoot) {\n    return cachedHarnessRoot;\n  }\n\n  // 1. Check environment variable override\n  const envRoot = process.env['ARTK_HARNESS_ROOT'];\n  if (envRoot && existsSync(envRoot)) {\n    cachedHarnessRoot = envRoot;\n    return cachedHarnessRoot;\n  }\n\n  // 2. Check for artk-e2e/ in cwd (standard installation)\n  const artkE2eFromCwd = join(process.cwd(), 'artk-e2e');\n  if (existsSync(artkE2eFromCwd)) {\n    cachedHarnessRoot = artkE2eFromCwd;\n    return cachedHarnessRoot;\n  }\n\n  // 3. Check if we're already inside artk-e2e (cwd has artk.config.yml)\n  const configInCwd = join(process.cwd(), 'artk.config.yml');\n  if (existsSync(configInCwd)) {\n    cachedHarnessRoot = process.cwd();\n    return cachedHarnessRoot;\n  }\n\n  // 4. Walk up from cwd looking for artk-e2e/ or artk.config.yml\n  let searchDir = process.cwd();\n  const root = dirname(searchDir);\n  while (searchDir !== root) {\n    // Check if this is artk-e2e (has artk.config.yml)\n    if (existsSync(join(searchDir, 'artk.config.yml'))) {\n      cachedHarnessRoot = searchDir;\n      return cachedHarnessRoot;\n    }\n    // Check if artk-e2e is a sibling\n    const sibling = join(searchDir, 'artk-e2e');\n    if (existsSync(sibling)) {\n      cachedHarnessRoot = sibling;\n      return cachedHarnessRoot;\n    }\n    searchDir = dirname(searchDir);\n  }\n\n  // 5. Fallback to cwd (backwards compatibility)\n  cachedHarnessRoot = process.cwd();\n  return cachedHarnessRoot;\n}\n\n/**\n * Get the LLKB root directory (.artk/llkb inside harness root).\n *\n * @param explicitRoot - Optional explicit path override\n * @returns Path to the LLKB root directory\n */\nexport function getLlkbRoot(explicitRoot?: string): string {\n  if (explicitRoot) {\n    return explicitRoot;\n  }\n  return join(getHarnessRoot(), '.artk', 'llkb');\n}\n\n/**\n * Get the .artk directory inside harness root.\n *\n * @param explicitBaseDir - Optional explicit path override\n * @returns Path to the .artk directory\n */\nexport function getArtkDir(explicitBaseDir?: string): string {\n  if (explicitBaseDir) {\n    return join(explicitBaseDir, '.artk');\n  }\n  return join(getHarnessRoot(), '.artk');\n}\n\n// \n// AUTOGEN ARTIFACT PATHS\n// \n\n/**\n * Autogen artifact types\n */\nexport type AutogenArtifact =\n  | 'analysis'      // analysis.json - Journey analysis results\n  | 'plan'          // plan.json - Test generation plan\n  | 'state'         // pipeline-state.json - Pipeline execution state\n  | 'results'       // results.json - Test execution results\n  | 'samples'       // samples/ directory - Multi-sample outputs\n  | 'agreement'     // samples/agreement.json - Sample agreement analysis\n  | 'telemetry';    // telemetry.json - Session telemetry\n\n/**\n * Get the autogen artifacts directory (.artk/autogen inside harness root).\n *\n * @param explicitBaseDir - Optional explicit path override\n * @returns Path to the autogen directory\n */\nexport function getAutogenDir(explicitBaseDir?: string): string {\n  return join(getArtkDir(explicitBaseDir), 'autogen');\n}\n\n/**\n * Get the path to a specific autogen artifact.\n *\n * @param artifact - The artifact type to get path for\n * @param explicitBaseDir - Optional explicit path override\n * @returns Path to the artifact\n */\nexport function getAutogenArtifact(artifact: AutogenArtifact, explicitBaseDir?: string): string {\n  const dir = getAutogenDir(explicitBaseDir);\n  switch (artifact) {\n    case 'analysis':\n      return join(dir, 'analysis.json');\n    case 'plan':\n      return join(dir, 'plan.json');\n    case 'state':\n      return join(dir, 'pipeline-state.json');\n    case 'results':\n      return join(dir, 'results.json');\n    case 'samples':\n      return join(dir, 'samples');\n    case 'agreement':\n      return join(dir, 'samples', 'agreement.json');\n    case 'telemetry':\n      return join(dir, 'telemetry.json');\n  }\n}\n\n/**\n * Ensure the autogen directory structure exists.\n *\n * Creates:\n * - <harnessRoot>/.artk/autogen/\n * - <harnessRoot>/.artk/autogen/samples/\n *\n * @param explicitBaseDir - Optional explicit path override\n */\nexport async function ensureAutogenDir(explicitBaseDir?: string): Promise<void> {\n  const { mkdir } = await import('node:fs/promises');\n  const dir = getAutogenDir(explicitBaseDir);\n  await mkdir(dir, { recursive: true });\n  await mkdir(join(dir, 'samples'), { recursive: true });\n}\n\n/**\n * Clean all autogen artifacts for a fresh start.\n *\n * Removes and recreates the autogen directory.\n *\n * @param explicitBaseDir - Optional explicit path override\n */\nexport async function cleanAutogenArtifacts(explicitBaseDir?: string): Promise<void> {\n  const { rm } = await import('node:fs/promises');\n  const dir = getAutogenDir(explicitBaseDir);\n  if (existsSync(dir)) {\n    await rm(dir, { recursive: true });\n  }\n  await ensureAutogenDir(explicitBaseDir);\n}\n\n/**\n * Check if autogen artifacts exist.\n *\n * @param explicitBaseDir - Optional explicit path override\n * @returns true if the autogen directory exists and contains artifacts\n */\nexport function hasAutogenArtifacts(explicitBaseDir?: string): boolean {\n  const dir = getAutogenDir(explicitBaseDir);\n  if (!existsSync(dir)) {\n    return false;\n  }\n  // Check for at least one artifact\n  const artifactTypes: AutogenArtifact[] = ['analysis', 'plan', 'state', 'results'];\n  return artifactTypes.some(artifact => existsSync(getAutogenArtifact(artifact, explicitBaseDir)));\n}\n\n// \n// PATH VALIDATION\n// \n\n/**\n * Custom error for path traversal attempts.\n */\nexport class PathTraversalError extends Error {\n  public readonly resolvedPath: string;\n\n  constructor(\n    public readonly userPath: string,\n    public readonly allowedRoot: string,\n    resolvedPath: string\n  ) {\n    super(`Path traversal detected: \"${userPath}\" resolves outside allowed root \"${allowedRoot}\"`);\n    this.name = 'PathTraversalError';\n    this.resolvedPath = resolvedPath;\n  }\n}\n\n/**\n * Validate that a user-provided path stays within an allowed root directory.\n *\n * Security: This function prevents path traversal attacks by:\n * 1. Resolving the path to an absolute path\n * 2. Resolving symlinks to their real targets\n * 3. Checking that the resolved path is within the allowed root\n *\n * @param userPath - The user-provided path (relative or absolute)\n * @param allowedRoot - The root directory that the path must stay within\n * @returns The resolved absolute path (safe to use)\n * @throws PathTraversalError if the path would escape the allowed root\n *\n * @example\n * // Valid paths\n * validatePath('tests/login.spec.ts', '/project') // => '/project/tests/login.spec.ts'\n * validatePath('./src/index.ts', '/project') // => '/project/src/index.ts'\n *\n * // Invalid paths (throw PathTraversalError)\n * validatePath('../../../etc/passwd', '/project') // throws\n * validatePath('/etc/passwd', '/project') // throws (absolute path outside root)\n */\nexport function validatePath(userPath: string, allowedRoot: string): string {\n  // Handle empty path\n  if (!userPath || userPath.trim() === '') {\n    throw new PathTraversalError(userPath, allowedRoot, '');\n  }\n\n  // Security: Check for dangerous characters that could bypass validation\n  // Null bytes can truncate strings in some file system APIs\n  // Newlines can be used for log injection or command splitting\n  if (userPath.includes('\\0') || userPath.includes('\\n') || userPath.includes('\\r')) {\n    throw new PathTraversalError(userPath, allowedRoot, 'invalid-characters');\n  }\n\n  // Windows-specific security checks\n  if (process.platform === 'win32') {\n    // Block Alternate Data Streams (ADS) - e.g., file.txt:Zone.Identifier\n    // ADS format: filename:streamname or filename::$DATA\n    // Only allow : as second character (drive letter like C:)\n    const colonIndex = userPath.indexOf(':');\n    if (colonIndex !== -1 && colonIndex !== 1) {\n      throw new PathTraversalError(userPath, allowedRoot, 'alternate-data-stream');\n    }\n\n    // Block UNC paths - \\\\server\\share or //server/share\n    if (userPath.startsWith('\\\\\\\\') || userPath.startsWith('//')) {\n      throw new PathTraversalError(userPath, allowedRoot, 'unc-path');\n    }\n\n    // Block Windows reserved device names (CON, PRN, AUX, NUL, COM1-9, LPT1-9)\n    // These can cause unexpected behavior or be used for attacks\n    // Check the base name of the path (without extension)\n    const pathParts = userPath.split(/[/\\\\]/);\n    const baseName = pathParts[pathParts.length - 1] || '';\n    const nameWithoutExt = baseName.split('.')[0] || '';\n    const upperName = nameWithoutExt.toUpperCase();\n    const reservedNames = ['CON', 'PRN', 'AUX', 'NUL'];\n    const reservedPrefixes = ['COM', 'LPT'];\n\n    if (reservedNames.includes(upperName)) {\n      throw new PathTraversalError(userPath, allowedRoot, 'reserved-device-name');\n    }\n    for (const prefix of reservedPrefixes) {\n      if (upperName.startsWith(prefix) && /^(COM|LPT)[1-9]$/.test(upperName)) {\n        throw new PathTraversalError(userPath, allowedRoot, 'reserved-device-name');\n      }\n    }\n  }\n\n  // Resolve the user path relative to the allowed root\n  const resolved = resolve(allowedRoot, userPath);\n\n  // Try to resolve symlinks - if the file doesn't exist yet, just use the resolved path\n  let realResolved: string;\n  let realRoot: string;\n\n  try {\n    realRoot = realpathSync(allowedRoot);\n  } catch {\n    // If allowed root doesn't exist, use the resolved version\n    realRoot = resolve(allowedRoot);\n  }\n\n  try {\n    realResolved = realpathSync(resolved);\n  } catch {\n    // File doesn't exist yet - try to resolve the parent directory chain\n    // to ensure we get a consistent path (handles /var -> /private/var on macOS)\n    let current = resolved;\n    let parentResolved = resolved;\n    while (current !== dirname(current)) {\n      const parent = dirname(current);\n      try {\n        // Find the deepest existing directory and resolve from there\n        const realParent = realpathSync(parent);\n        const relativePart = relative(parent, resolved);\n        parentResolved = join(realParent, relativePart);\n        break;\n      } catch {\n        current = parent;\n      }\n    }\n    realResolved = parentResolved;\n  }\n\n  // Calculate relative path from root to resolved\n  const rel = relative(realRoot, realResolved);\n\n  // Check for traversal:\n  // - Path starts with '..' (escapes upward)\n  // - Path is absolute and different from root (e.g., /etc/passwd resolved)\n  if (rel.startsWith('..') || (isAbsolute(rel) && !rel.startsWith(realRoot))) {\n    throw new PathTraversalError(userPath, allowedRoot, realResolved);\n  }\n\n  return realResolved;\n}\n\n/**\n * Validate multiple paths and return only the valid ones.\n *\n * @param paths - Array of user-provided paths\n * @param allowedRoot - The root directory that paths must stay within\n * @param onInvalid - Optional callback for invalid paths (for logging/reporting)\n * @returns Array of validated absolute paths (invalid paths are filtered out)\n */\nexport function validatePaths(\n  paths: string[],\n  allowedRoot: string,\n  onInvalid?: (_invalidPath: string) => void\n): string[] {\n  const validPaths: string[] = [];\n\n  for (const userPath of paths) {\n    try {\n      const validated = validatePath(userPath, allowedRoot);\n      validPaths.push(validated);\n    } catch (e) {\n      if (e instanceof PathTraversalError && onInvalid) {\n        onInvalid(userPath);\n      }\n      // Skip invalid paths\n    }\n  }\n\n  return validPaths;\n}\n","/**\n * Pattern distance calculation for finding nearest matching patterns\n */\n\nimport type { StepPattern } from './patterns.js';\n\n/**\n * Extended pattern definition with examples for distance calculation\n */\nexport interface PatternDefinition extends StepPattern {\n  examples?: string[];\n  requiredKeywords?: string[];\n}\n\nexport interface NearestPatternResult {\n  name: string;\n  distance: number;\n  exampleMatch: string;\n  mismatchReason: string;\n}\n\n/**\n * Calculate Levenshtein distance between two strings\n */\nexport function levenshteinDistance(a: string, b: string): number {\n  const matrix: number[][] = [];\n\n  for (let i = 0; i <= b.length; i++) {\n    matrix[i] = [i];\n  }\n\n  for (let j = 0; j <= a.length; j++) {\n    matrix[0]![j] = j;\n  }\n\n  for (let i = 1; i <= b.length; i++) {\n    for (let j = 1; j <= a.length; j++) {\n      if (b.charAt(i - 1) === a.charAt(j - 1)) {\n        matrix[i]![j] = matrix[i - 1]![j - 1]!;\n      } else {\n        matrix[i]![j] = Math.min(\n          matrix[i - 1]![j - 1]! + 1, // substitution\n          matrix[i]![j - 1]! + 1,     // insertion\n          matrix[i - 1]![j]! + 1      // deletion\n        );\n      }\n    }\n  }\n\n  return matrix[b.length]![a.length]!;\n}\n\n/**\n * Calculate normalized similarity between two strings (0-1)\n */\nexport function calculateSimilarity(a: string, b: string): number {\n  const distance = levenshteinDistance(a.toLowerCase(), b.toLowerCase());\n  const maxLength = Math.max(a.length, b.length);\n  if (maxLength === 0) return 1;\n  return 1 - distance / maxLength;\n}\n\n/**\n * Extract example text from a regex pattern\n * This is a heuristic - it tries to create a plausible example from the regex\n */\nfunction generateExampleFromRegex(regex: RegExp, patternName: string): string {\n  // Reserved for future regex-based example generation\n  void regex.source;\n\n  // Navigation patterns\n  if (patternName.includes('navigate')) {\n    return 'User navigates to /path';\n  }\n\n  // Click patterns\n  if (patternName.includes('click')) {\n    return 'User clicks \"Button\" button';\n  }\n\n  // Fill patterns\n  if (patternName.includes('fill') || patternName.includes('enter') || patternName.includes('type')) {\n    return 'User enters \"value\" in \"Field\" field';\n  }\n\n  // Assertion patterns\n  if (patternName.includes('see') || patternName.includes('visible') || patternName.includes('expect')) {\n    return 'User should see \"Content\"';\n  }\n\n  // Wait patterns\n  if (patternName.includes('wait')) {\n    return 'Wait for network idle';\n  }\n\n  // Generic fallback\n  return `Step matching ${patternName}`;\n}\n\n/**\n * Find the nearest pattern for a given step text\n */\nexport function findNearestPattern(\n  text: string,\n  patterns: Map<string, PatternDefinition> | StepPattern[]\n): NearestPatternResult | null {\n  let nearest: NearestPatternResult | null = null;\n  let minDistance = Infinity;\n\n  const normalizedText = text.toLowerCase().trim();\n\n  // Convert to array if it's a Map\n  const patternArray: Array<[string, PatternDefinition | StepPattern]> =\n    patterns instanceof Map\n      ? Array.from(patterns.entries())\n      : patterns.map(p => [p.name, p] as [string, PatternDefinition | StepPattern]);\n\n  for (const [name, pattern] of patternArray) {\n    // Get examples - either from PatternDefinition or generate from regex\n    const examples = 'examples' in pattern && pattern.examples\n      ? pattern.examples\n      : [generateExampleFromRegex(pattern.regex, pattern.name)];\n\n    // Compare against pattern examples\n    for (const example of examples) {\n      const distance = levenshteinDistance(normalizedText, example.toLowerCase());\n      if (distance < minDistance) {\n        minDistance = distance;\n        nearest = {\n          name,\n          distance,\n          exampleMatch: example,\n          mismatchReason: explainMismatch(text, pattern),\n        };\n      }\n    }\n  }\n\n  // Only return if similarity is above threshold (> 50%)\n  if (nearest && nearest.exampleMatch) {\n    const similarity = calculateSimilarity(text, nearest.exampleMatch);\n    if (similarity > 0.5) {\n      return nearest;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Explain why a pattern didn't match\n */\nexport function explainMismatch(text: string, pattern: StepPattern | PatternDefinition): string {\n  const reasons: string[] = [];\n  const lowerText = text.toLowerCase();\n\n  // Check for missing keywords based on pattern type\n  const requiredKeywords = 'requiredKeywords' in pattern\n    ? pattern.requiredKeywords\n    : inferRequiredKeywords(pattern);\n\n  if (requiredKeywords) {\n    const missing = requiredKeywords.filter(\n      kw => !lowerText.includes(kw.toLowerCase())\n    );\n    if (missing.length > 0) {\n      reasons.push(`Missing keywords: ${missing.join(', ')}`);\n    }\n  }\n\n  // Check for missing locator hints\n  if (!text.includes('(') && !text.includes('testid=') && !text.includes('role=')) {\n    reasons.push('Missing locator hint (e.g., testid=..., role=button)');\n  }\n\n  // Check for ambiguous target based on pattern type\n  if (pattern.primitiveType === 'click' && !text.match(/['\"].+?['\"]/)) {\n    reasons.push('Target element name not quoted');\n  }\n\n  return reasons.length > 0 ? reasons.join('; ') : 'Pattern format mismatch';\n}\n\n/**\n * Infer required keywords from a pattern\n */\nfunction inferRequiredKeywords(pattern: StepPattern): string[] | undefined {\n  const name = pattern.name.toLowerCase();\n\n  if (name.includes('navigate')) {\n    return ['navigate', 'go', 'open'];\n  }\n\n  if (name.includes('click')) {\n    return ['click', 'press', 'tap'];\n  }\n\n  if (name.includes('fill') || name.includes('enter')) {\n    return ['enter', 'type', 'fill', 'input'];\n  }\n\n  if (name.includes('see') || name.includes('visible')) {\n    return ['see', 'visible', 'shown'];\n  }\n\n  if (name.includes('wait')) {\n    return ['wait'];\n  }\n\n  return undefined;\n}\n","/**\n * LLKB Pattern Extension - Learning and promotion of patterns from LLKB\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md Phase 4\n * @see Task 2 - Fuzzy matching support added 2026-02-04\n */\nimport { existsSync, readFileSync, writeFileSync, mkdirSync, unlinkSync } from 'node:fs';\nimport { join, dirname } from 'node:path';\nimport type { IRPrimitive } from '../ir/types.js';\n// Use the same normalizer as stepMapper for consistent pattern matching\n// This ensures patterns learned during recording match during lookup\nimport { normalizeStepText } from '../mapping/glossary.js';\nimport { getLlkbRoot as getInferredLlkbRoot } from '../utils/paths.js';\nimport { calculateSimilarity } from '../mapping/patternDistance.js';\n\n/**\n * A pattern learned from successful step mappings\n */\nexport interface LearnedPattern {\n  /** Unique identifier */\n  id: string;\n  /** Original step text that was learned from */\n  originalText: string;\n  /** Normalized form for matching */\n  normalizedText: string;\n  /** The IR primitive this text maps to */\n  mappedPrimitive: IRPrimitive;\n  /** Confidence score (0-1) */\n  confidence: number;\n  /** Journey IDs where this pattern was used */\n  sourceJourneys: string[];\n  /** Number of successful uses */\n  successCount: number;\n  /** Number of failed uses */\n  failCount: number;\n  /** Timestamp of last use */\n  lastUsed: string;\n  /** Timestamp when created */\n  createdAt: string;\n  /** Whether this pattern has been promoted to core */\n  promotedToCore: boolean;\n  /** Promotion timestamp if promoted */\n  promotedAt?: string;\n}\n\n/**\n * Pattern ready for promotion to core\n */\nexport interface PromotedPattern {\n  /** The learned pattern being promoted */\n  pattern: LearnedPattern;\n  /** Generated regex string for the pattern */\n  generatedRegex: string;\n  /** Priority score for ordering */\n  priority: number;\n}\n\n/**\n * LLKB pattern match result\n */\nexport interface LlkbPatternMatch {\n  /** Pattern ID that matched */\n  patternId: string;\n  /** The IR primitive */\n  primitive: IRPrimitive;\n  /** Confidence of the match */\n  confidence: number;\n}\n\n/**\n * Options for pruning patterns\n */\nexport interface PruneOptions {\n  /** Minimum confidence to keep */\n  minConfidence?: number;\n  /** Minimum success count to keep */\n  minSuccess?: number;\n  /** Maximum age in days to keep */\n  maxAgeDays?: number;\n}\n\n/**\n * Storage file for learned patterns\n */\nconst PATTERNS_FILE = 'learned-patterns.json';\n\n/**\n * Pattern cache for performance optimization\n * Avoids repeated file reads during step mapping\n */\ninterface PatternCache {\n  patterns: LearnedPattern[];\n  llkbRoot: string;\n  loadedAt: number;\n}\n\nlet patternCache: PatternCache | null = null;\nconst CACHE_TTL_MS = 5000; // 5 second cache TTL\n\n/**\n * Invalidate the pattern cache\n * Call this after any write operation\n */\nexport function invalidatePatternCache(): void {\n  patternCache = null;\n}\n\n/**\n * Get the path to the patterns file.\n *\n * Automatically infers the correct LLKB directory location by:\n * 1. Using explicit llkbRoot if provided\n * 2. Finding artk-e2e/.artk/llkb from project root\n * 3. Finding .artk/llkb in current directory if inside harness\n *\n * @param llkbRoot - Optional explicit LLKB root directory override\n * @returns Path to the patterns file\n */\nexport function getPatternsFilePath(llkbRoot?: string): string {\n  const root = getInferredLlkbRoot(llkbRoot);\n  return join(root, PATTERNS_FILE);\n}\n\n/**\n * Generate a unique pattern ID\n */\nexport function generatePatternId(): string {\n  return `LP${Date.now().toString(36)}${Math.random().toString(36).slice(2, 6)}`.toUpperCase();\n}\n\n/**\n * Load learned patterns from storage (with caching for performance)\n */\nexport function loadLearnedPatterns(options: { llkbRoot?: string; bypassCache?: boolean } = {}): LearnedPattern[] {\n  const llkbRoot = getInferredLlkbRoot(options.llkbRoot);\n  const now = Date.now();\n\n  // Check cache validity (same llkbRoot and not expired)\n  if (\n    !options.bypassCache &&\n    patternCache &&\n    patternCache.llkbRoot === llkbRoot &&\n    now - patternCache.loadedAt < CACHE_TTL_MS\n  ) {\n    return patternCache.patterns;\n  }\n\n  const filePath = getPatternsFilePath(options.llkbRoot);\n\n  if (!existsSync(filePath)) {\n    // Cache empty result\n    patternCache = { patterns: [], llkbRoot, loadedAt: now };\n    return [];\n  }\n\n  try {\n    const content = readFileSync(filePath, 'utf-8');\n    const data = JSON.parse(content);\n    const patterns = Array.isArray(data.patterns) ? data.patterns : [];\n\n    // Update cache\n    patternCache = { patterns, llkbRoot, loadedAt: now };\n    return patterns;\n  } catch {\n    // Cache empty result on error\n    patternCache = { patterns: [], llkbRoot, loadedAt: now };\n    return [];\n  }\n}\n\n/**\n * Save learned patterns to storage\n */\nexport function saveLearnedPatterns(\n  patterns: LearnedPattern[],\n  options: { llkbRoot?: string } = {}\n): void {\n  const filePath = getPatternsFilePath(options.llkbRoot);\n  const dir = dirname(filePath);\n\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n\n  const data = {\n    version: '1.0.0',\n    lastUpdated: new Date().toISOString(),\n    patterns,\n  };\n\n  writeFileSync(filePath, JSON.stringify(data, null, 2), 'utf-8');\n\n  // Invalidate cache after write\n  invalidatePatternCache();\n}\n\n/**\n * Calculate confidence from success/fail counts\n * Uses Wilson score interval for small sample sizes\n */\nexport function calculateConfidence(successCount: number, failCount: number): number {\n  const total = successCount + failCount;\n  if (total === 0) return 0.5;\n\n  const p = successCount / total;\n  const z = 1.96; // 95% confidence\n  const n = total;\n\n  // Wilson score lower bound\n  const denominator = 1 + (z * z) / n;\n  const center = p + (z * z) / (2 * n);\n  const spread = z * Math.sqrt((p * (1 - p) + (z * z) / (4 * n)) / n);\n\n  return Math.max(0, Math.min(1, (center - spread) / denominator));\n}\n\n/**\n * Record a successful pattern transformation\n */\nexport function recordPatternSuccess(\n  originalText: string,\n  primitive: IRPrimitive,\n  journeyId: string,\n  options: { llkbRoot?: string } = {}\n): LearnedPattern {\n  const patterns = loadLearnedPatterns(options);\n  const normalizedText = normalizeStepText(originalText);\n\n  // Find existing pattern\n  let pattern = patterns.find((p) => p.normalizedText === normalizedText);\n\n  if (pattern) {\n    // Update existing\n    pattern.successCount++;\n    pattern.confidence = calculateConfidence(pattern.successCount, pattern.failCount);\n    pattern.lastUsed = new Date().toISOString();\n    if (!pattern.sourceJourneys.includes(journeyId)) {\n      pattern.sourceJourneys.push(journeyId);\n    }\n  } else {\n    // Create new\n    pattern = {\n      id: generatePatternId(),\n      originalText,\n      normalizedText,\n      mappedPrimitive: primitive,\n      confidence: 0.5, // Initial confidence\n      sourceJourneys: [journeyId],\n      successCount: 1,\n      failCount: 0,\n      lastUsed: new Date().toISOString(),\n      createdAt: new Date().toISOString(),\n      promotedToCore: false,\n    };\n    patterns.push(pattern);\n  }\n\n  saveLearnedPatterns(patterns, options);\n  return pattern;\n}\n\n/**\n * Record a failed pattern use\n */\nexport function recordPatternFailure(\n  originalText: string,\n  _journeyId: string,\n  options: { llkbRoot?: string } = {}\n): LearnedPattern | null {\n  const patterns = loadLearnedPatterns(options);\n  const normalizedText = normalizeStepText(originalText);\n\n  const pattern = patterns.find((p) => p.normalizedText === normalizedText);\n\n  if (pattern) {\n    pattern.failCount++;\n    pattern.confidence = calculateConfidence(pattern.successCount, pattern.failCount);\n    pattern.lastUsed = new Date().toISOString();\n    saveLearnedPatterns(patterns, options);\n    return pattern;\n  }\n\n  return null;\n}\n\n/**\n * Options for LLKB pattern matching\n */\nexport interface LlkbMatchOptions {\n  /** LLKB root directory */\n  llkbRoot?: string;\n  /** Minimum pattern confidence to consider (default: 0.5) */\n  minConfidence?: number;\n  /** Minimum text similarity for fuzzy match (default: 0.7) */\n  minSimilarity?: number;\n  /** Whether to use fuzzy matching (default: true) */\n  useFuzzyMatch?: boolean;\n}\n\n/**\n * Match text against learned LLKB patterns\n *\n * Uses a two-phase approach:\n * 1. Try exact normalized text match (fast path)\n * 2. If no exact match, use fuzzy similarity matching\n *\n * Fuzzy matching compares the input text against all learned patterns\n * and returns the best match above the similarity threshold.\n */\nexport function matchLlkbPattern(\n  text: string,\n  options: LlkbMatchOptions = {}\n): LlkbPatternMatch | null {\n  const patterns = loadLearnedPatterns(options);\n  const normalizedText = normalizeStepText(text);\n  const minConfidence = options.minConfidence ?? 0.5;\n  const minSimilarity = options.minSimilarity ?? 0.7;\n  const useFuzzyMatch = options.useFuzzyMatch ?? true;\n\n  // Phase 1: Try exact normalized match (fast path)\n  const exactMatch = patterns.find(\n    (p) => p.normalizedText === normalizedText && p.confidence >= minConfidence && !p.promotedToCore\n  );\n\n  if (exactMatch) {\n    return {\n      patternId: exactMatch.id,\n      primitive: exactMatch.mappedPrimitive,\n      confidence: exactMatch.confidence,\n    };\n  }\n\n  // Phase 2: Fuzzy matching using text similarity\n  if (useFuzzyMatch) {\n    let bestMatch: LearnedPattern | null = null;\n    let bestSimilarity = 0;\n\n    for (const pattern of patterns) {\n      // Skip promoted or low-confidence patterns\n      if (pattern.promotedToCore || pattern.confidence < minConfidence) {\n        continue;\n      }\n\n      // Calculate similarity between normalized texts\n      const similarity = calculateSimilarity(normalizedText, pattern.normalizedText);\n\n      // Track best match above threshold\n      if (similarity >= minSimilarity && similarity > bestSimilarity) {\n        bestSimilarity = similarity;\n        bestMatch = pattern;\n      }\n    }\n\n    if (bestMatch) {\n      // Adjust confidence based on similarity (fuzzy matches are less confident)\n      const adjustedConfidence = bestMatch.confidence * bestSimilarity;\n\n      return {\n        patternId: bestMatch.id,\n        primitive: bestMatch.mappedPrimitive,\n        confidence: adjustedConfidence,\n      };\n    }\n  }\n\n  return null;\n}\n\n/**\n * Generate a regex pattern from a learned text pattern\n * This is a heuristic approach - complex patterns may need manual refinement\n */\nexport function generateRegexFromText(text: string): string {\n  const pattern = text\n    .toLowerCase()\n    // Escape special regex chars\n    .replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n    // Replace quoted values with capture groups\n    .replace(/\"[^\"]+\"/g, '\"([^\"]+)\"')\n    .replace(/'[^']+'/g, \"'([^']+)'\")\n    // Make articles optional\n    .replace(/\\b(the|a|an)\\b/g, '(?:$1\\\\s+)?')\n    // Make \"user\" prefix optional\n    .replace(/^user\\s+/, '(?:user\\\\s+)?')\n    // Handle common verbs\n    .replace(/\\bclicks?\\b/g, 'clicks?')\n    .replace(/\\bfills?\\b/g, 'fills?')\n    .replace(/\\bselects?\\b/g, 'selects?')\n    .replace(/\\btypes?\\b/g, 'types?')\n    .replace(/\\bsees?\\b/g, 'sees?')\n    .replace(/\\bwaits?\\b/g, 'waits?');\n\n  return `^${pattern}$`;\n}\n\n/**\n * Get patterns ready for promotion to core\n */\nexport function getPromotablePatterns(options: { llkbRoot?: string } = {}): PromotedPattern[] {\n  const patterns = loadLearnedPatterns(options);\n\n  const promotable = patterns.filter(\n    (p) =>\n      p.confidence >= 0.9 &&\n      p.successCount >= 5 &&\n      p.sourceJourneys.length >= 2 &&\n      !p.promotedToCore\n  );\n\n  return promotable.map((pattern) => ({\n    pattern,\n    generatedRegex: generateRegexFromText(pattern.originalText),\n    priority: pattern.successCount * pattern.confidence,\n  }));\n}\n\n/**\n * Mark patterns as promoted\n */\nexport function markPatternsPromoted(\n  patternIds: string[],\n  options: { llkbRoot?: string } = {}\n): void {\n  const patterns = loadLearnedPatterns(options);\n  const now = new Date().toISOString();\n\n  for (const pattern of patterns) {\n    if (patternIds.includes(pattern.id)) {\n      pattern.promotedToCore = true;\n      pattern.promotedAt = now;\n    }\n  }\n\n  saveLearnedPatterns(patterns, options);\n}\n\n/**\n * Prune low-quality patterns\n */\nexport function prunePatterns(options: PruneOptions & { llkbRoot?: string } = {}): {\n  removed: number;\n  remaining: number;\n} {\n  const patterns = loadLearnedPatterns(options);\n  const now = Date.now();\n  const maxAge = (options.maxAgeDays ?? 90) * 24 * 60 * 60 * 1000;\n  const minConfidence = options.minConfidence ?? 0.3;\n  const minSuccess = options.minSuccess ?? 1;\n\n  const filtered = patterns.filter((p) => {\n    // Keep if already promoted\n    if (p.promotedToCore) return true;\n\n    // Remove if below minimum confidence\n    if (p.confidence < minConfidence) return false;\n\n    // Remove if no successes and required\n    if (minSuccess > 0 && p.successCount < minSuccess) return false;\n\n    // Remove if too old and never successful\n    const age = now - new Date(p.createdAt).getTime();\n    if (age > maxAge && p.successCount === 0) return false;\n\n    return true;\n  });\n\n  const removed = patterns.length - filtered.length;\n\n  if (removed > 0) {\n    saveLearnedPatterns(filtered, options);\n  }\n\n  return {\n    removed,\n    remaining: filtered.length,\n  };\n}\n\n/**\n * Get pattern statistics\n */\nexport function getPatternStats(options: { llkbRoot?: string } = {}): {\n  total: number;\n  promoted: number;\n  highConfidence: number;\n  lowConfidence: number;\n  avgConfidence: number;\n  totalSuccesses: number;\n  totalFailures: number;\n} {\n  const patterns = loadLearnedPatterns(options);\n\n  if (patterns.length === 0) {\n    return {\n      total: 0,\n      promoted: 0,\n      highConfidence: 0,\n      lowConfidence: 0,\n      avgConfidence: 0,\n      totalSuccesses: 0,\n      totalFailures: 0,\n    };\n  }\n\n  const promoted = patterns.filter((p) => p.promotedToCore).length;\n  const highConfidence = patterns.filter((p) => p.confidence >= 0.7).length;\n  const lowConfidence = patterns.filter((p) => p.confidence < 0.3).length;\n  const totalConfidence = patterns.reduce((sum, p) => sum + p.confidence, 0);\n  const totalSuccesses = patterns.reduce((sum, p) => sum + p.successCount, 0);\n  const totalFailures = patterns.reduce((sum, p) => sum + p.failCount, 0);\n\n  return {\n    total: patterns.length,\n    promoted,\n    highConfidence,\n    lowConfidence,\n    avgConfidence: totalConfidence / patterns.length,\n    totalSuccesses,\n    totalFailures,\n  };\n}\n\n/**\n * Export learned patterns to LLKB config format\n */\nexport function exportPatternsToConfig(options: {\n  llkbRoot?: string;\n  outputPath?: string;\n  minConfidence?: number;\n}): { exported: number; path: string } {\n  const patterns = loadLearnedPatterns(options);\n  const minConfidence = options.minConfidence ?? 0.7;\n\n  const exportable = patterns.filter((p) => p.confidence >= minConfidence && !p.promotedToCore);\n\n  const config = {\n    version: '1.0.0',\n    exportedAt: new Date().toISOString(),\n    patterns: exportable.map((p) => ({\n      id: p.id,\n      trigger: generateRegexFromText(p.originalText),\n      primitive: p.mappedPrimitive,\n      confidence: p.confidence,\n      sourceCount: p.sourceJourneys.length,\n    })),\n  };\n\n  const outputPath =\n    options.outputPath || join(dirname(getPatternsFilePath(options.llkbRoot)), 'autogen-patterns.json');\n\n  writeFileSync(outputPath, JSON.stringify(config, null, 2), 'utf-8');\n\n  return {\n    exported: exportable.length,\n    path: outputPath,\n  };\n}\n\n/**\n * Clear all learned patterns (for testing)\n */\nexport function clearLearnedPatterns(options: { llkbRoot?: string } = {}): void {\n  const filePath = getPatternsFilePath(options.llkbRoot);\n  if (existsSync(filePath)) {\n    unlinkSync(filePath);\n  }\n  // Invalidate cache when clearing patterns\n  invalidatePatternCache();\n}\n","/**\n * Step Mapping Patterns - Regex patterns for parsing step text into IR primitives\n * @see research/2026-01-02_autogen-refined-plan.md Section 10\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md Phase 3\n */\nimport type { IRPrimitive, LocatorSpec, ValueSpec, LocatorStrategy } from '../ir/types.js';\n\n/**\n * Pattern version - increment when patterns change\n * Format: MAJOR.MINOR.PATCH\n * - MAJOR: Breaking changes to pattern behavior\n * - MINOR: New patterns added\n * - PATCH: Bug fixes to existing patterns\n */\nexport const PATTERN_VERSION = '1.1.0';\n\n/**\n * Pattern metadata for tracking\n */\nexport interface PatternMetadata {\n  name: string;\n  version: string;\n  addedDate: string;\n  source: 'core' | 'llkb' | 'telemetry';\n  category: string;\n}\n\n/**\n * Pattern result with match groups\n */\nexport interface PatternMatch {\n  type: IRPrimitive['type'];\n  groups: Record<string, string>;\n}\n\n/**\n * Pattern definition\n */\nexport interface StepPattern {\n  /** Pattern name for debugging */\n  name: string;\n  /** Regex pattern with named groups */\n  regex: RegExp;\n  /** IR primitive type this pattern produces */\n  primitiveType: IRPrimitive['type'];\n  /** Extract IR primitive from match (prefix with _ if unused) */\n  extract: (_match: RegExpMatchArray) => IRPrimitive | null;\n}\n\n/**\n * Create a locator spec from pattern match\n */\nexport function createLocatorFromMatch(\n  strategy: LocatorStrategy,\n  value: string,\n  name?: string\n): LocatorSpec {\n  const locator: LocatorSpec = { strategy, value };\n  if (name) {\n    locator.options = { name };\n  }\n  return locator;\n}\n\n/**\n * Create a value spec from text\n */\nexport function createValueFromText(text: string): ValueSpec {\n  // Actor reference: {{email}}, {{password}}, etc.\n  if (/^\\{\\{.+\\}\\}$/.test(text)) {\n    const path = text.slice(2, -2).trim();\n    return { type: 'actor', value: path };\n  }\n\n  // Test data reference: $user.email, $testData.field\n  if (/^\\$.+/.test(text)) {\n    return { type: 'testData', value: text.slice(1) };\n  }\n\n  // Generated value: ${runId}, ${timestamp}\n  if (/\\$\\{.+\\}/.test(text)) {\n    return { type: 'generated', value: text };\n  }\n\n  // Literal value\n  return { type: 'literal', value: text };\n}\n\n/**\n * Navigation patterns\n */\nexport const navigationPatterns: StepPattern[] = [\n  {\n    name: 'navigate-to-url',\n    regex: /^(?:user\\s+)?(?:navigates?|go(?:es)?|opens?)\\s+(?:to\\s+)?(?:the\\s+)?[\"']?([^\"'\\s]+)[\"']?$/i,\n    primitiveType: 'goto',\n    extract: (match) => ({\n      type: 'goto',\n      url: match[1]!,\n      waitForLoad: true,\n    }),\n  },\n  {\n    name: 'navigate-to-page',\n    regex: /^(?:user\\s+)?(?:navigates?|go(?:es)?|opens?)\\s+(?:to\\s+)?(?:the\\s+)?(.+?)\\s+page$/i,\n    primitiveType: 'goto',\n    extract: (match) => ({\n      type: 'goto',\n      url: `/${match[1]!.toLowerCase().replace(/\\s+/g, '-')}`,\n      waitForLoad: true,\n    }),\n  },\n  {\n    name: 'wait-for-url-change',\n    // \"Wait for URL to change to '/dashboard'\" or \"Wait until URL contains '/settings'\"\n    regex: /^(?:user\\s+)?waits?\\s+(?:for\\s+)?(?:the\\s+)?url\\s+(?:to\\s+)?(?:change\\s+to|contain|include)\\s+[\"']?([^\"']+)[\"']?$/i,\n    primitiveType: 'waitForURL',\n    extract: (match) => ({\n      type: 'waitForURL',\n      pattern: match[1]!,\n    }),\n  },\n];\n\n/**\n * Click patterns\n */\nexport const clickPatterns: StepPattern[] = [\n  {\n    name: 'click-button-quoted',\n    regex: /^(?:user\\s+)?(?:clicks?|presses?|taps?)\\s+(?:on\\s+)?(?:the\\s+)?[\"']([^\"']+)[\"']\\s+button$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('role', 'button', match[1]!),\n    }),\n  },\n  {\n    name: 'click-link-quoted',\n    regex: /^(?:user\\s+)?(?:clicks?|presses?|taps?)\\s+(?:on\\s+)?(?:the\\s+)?[\"']([^\"']+)[\"']\\s+link$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('role', 'link', match[1]!),\n    }),\n  },\n  {\n    name: 'click-menuitem-quoted',\n    // \"Click the 'Settings' menu item\" or \"Click on 'Edit' menuitem\"\n    regex: /^(?:user\\s+)?(?:clicks?|selects?)\\s+(?:on\\s+)?(?:the\\s+)?[\"']([^\"']+)[\"']\\s+menu\\s*item$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('role', 'menuitem', match[1]!),\n    }),\n  },\n  {\n    name: 'click-tab-quoted',\n    // \"Click the 'Details' tab\" or \"Select the 'Overview' tab\"\n    regex: /^(?:user\\s+)?(?:clicks?|selects?)\\s+(?:on\\s+)?(?:the\\s+)?[\"']([^\"']+)[\"']\\s+tab$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('role', 'tab', match[1]!),\n    }),\n  },\n  {\n    name: 'click-element-quoted',\n    regex: /^(?:user\\s+)?(?:clicks?|presses?|taps?)\\s+(?:on\\s+)?(?:the\\s+)?[\"']([^\"']+)[\"']$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'click-element-generic',\n    regex: /^(?:user\\s+)?(?:clicks?|presses?|taps?)\\s+(?:on\\s+)?(?:the\\s+)?(.+?)\\s+(?:button|link|icon|menu|tab)$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n];\n\n/**\n * Fill/Input patterns\n */\nexport const fillPatterns: StepPattern[] = [\n  {\n    name: 'fill-field-quoted-value',\n    regex: /^(?:user\\s+)?(?:enters?|types?|fills?\\s+in?|inputs?)\\s+[\"']([^\"']+)[\"']\\s+(?:in|into)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']\\s*(?:field|input)?$/i,\n    primitiveType: 'fill',\n    extract: (match) => ({\n      type: 'fill',\n      locator: createLocatorFromMatch('label', match[2]!),\n      value: createValueFromText(match[1]!),\n    }),\n  },\n  {\n    name: 'fill-field-actor-value',\n    regex: /^(?:user\\s+)?(?:enters?|types?|fills?\\s+in?|inputs?)\\s+(\\{\\{[^}]+\\}\\})\\s+(?:in|into)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']\\s*(?:field|input)?$/i,\n    primitiveType: 'fill',\n    extract: (match) => ({\n      type: 'fill',\n      locator: createLocatorFromMatch('label', match[2]!),\n      value: createValueFromText(match[1]!),\n    }),\n  },\n  {\n    name: 'fill-placeholder-field',\n    // \"Fill 'test@example.com' in the field with placeholder 'Enter email'\"\n    // or \"Type 'value' into input with placeholder 'Search'\"\n    regex: /^(?:user\\s+)?(?:enters?|types?|fills?)\\s+[\"']([^\"']+)[\"']\\s+(?:in|into)\\s+(?:the\\s+)?(?:field|input)\\s+with\\s+placeholder\\s+[\"']([^\"']+)[\"']$/i,\n    primitiveType: 'fill',\n    extract: (match) => ({\n      type: 'fill',\n      locator: createLocatorFromMatch('placeholder', match[2]!),\n      value: createValueFromText(match[1]!),\n    }),\n  },\n  {\n    name: 'fill-field-generic',\n    regex: /^(?:user\\s+)?(?:enters?|types?|fills?\\s+in?|inputs?)\\s+(.+?)\\s+(?:in|into)\\s+(?:the\\s+)?(.+?)\\s*(?:field|input)?$/i,\n    primitiveType: 'fill',\n    extract: (match) => ({\n      type: 'fill',\n      locator: createLocatorFromMatch('label', match[2]!.replace(/[\"']/g, '')),\n      value: createValueFromText(match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n];\n\n/**\n * Select patterns\n */\nexport const selectPatterns: StepPattern[] = [\n  {\n    name: 'select-option',\n    regex: /^(?:user\\s+)?(?:selects?|chooses?)\\s+[\"']([^\"']+)[\"']\\s+(?:from|in)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']\\s*(?:dropdown|select|menu)?$/i,\n    primitiveType: 'select',\n    extract: (match) => ({\n      type: 'select',\n      locator: createLocatorFromMatch('label', match[2]!),\n      option: match[1]!,\n    }),\n  },\n];\n\n/**\n * Check/Uncheck patterns\n */\nexport const checkPatterns: StepPattern[] = [\n  {\n    name: 'check-checkbox',\n    regex: /^(?:user\\s+)?(?:checks?|enables?|ticks?)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']\\s*(?:checkbox|option)?$/i,\n    primitiveType: 'check',\n    extract: (match) => ({\n      type: 'check',\n      locator: createLocatorFromMatch('label', match[1]!),\n    }),\n  },\n  {\n    // \"Check the terms checkbox\" - unquoted checkbox name\n    name: 'check-checkbox-unquoted',\n    regex: /^(?:user\\s+)?(?:checks?|enables?|ticks?)\\s+(?:the\\s+)?(\\w+(?:\\s+\\w+)*)\\s+checkbox$/i,\n    primitiveType: 'check',\n    extract: (match) => ({\n      type: 'check',\n      locator: createLocatorFromMatch('label', match[1]!),\n    }),\n  },\n  {\n    name: 'uncheck-checkbox',\n    regex: /^(?:user\\s+)?(?:unchecks?|disables?|unticks?)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']\\s*(?:checkbox|option)?$/i,\n    primitiveType: 'uncheck',\n    extract: (match) => ({\n      type: 'uncheck',\n      locator: createLocatorFromMatch('label', match[1]!),\n    }),\n  },\n  {\n    // \"Uncheck the newsletter checkbox\" - unquoted checkbox name\n    name: 'uncheck-checkbox-unquoted',\n    regex: /^(?:user\\s+)?(?:unchecks?|disables?|unticks?)\\s+(?:the\\s+)?(\\w+(?:\\s+\\w+)*)\\s+checkbox$/i,\n    primitiveType: 'uncheck',\n    extract: (match) => ({\n      type: 'uncheck',\n      locator: createLocatorFromMatch('label', match[1]!),\n    }),\n  },\n];\n\n/**\n * Visibility assertion patterns\n */\nexport const visibilityPatterns: StepPattern[] = [\n  {\n    name: 'should-see-text',\n    regex: /^(?:user\\s+)?(?:should\\s+)?(?:sees?|views?)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'is-visible',\n    regex: /^[\"']?([^\"']+)[\"']?\\s+(?:is\\s+)?(?:visible|displayed|shown)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'should-see-element',\n    regex: /^(?:user\\s+)?(?:should\\s+)?(?:sees?|views?)\\s+(?:the\\s+)?(.+?)\\s+(?:heading|button|link|form|page|element)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'page-displayed',\n    regex: /^(?:the\\s+)?(.+?)\\s+(?:page|screen|view)\\s+(?:is\\s+)?(?:displayed|shown|visible)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n];\n\n/**\n * Toast/notification patterns\n */\nexport const toastPatterns: StepPattern[] = [\n  {\n    name: 'success-toast-message',\n    regex: /^(?:a\\s+)?success\\s+toast\\s+(?:with\\s+)?[\"']([^\"']+)[\"']\\s*(?:message\\s+)?(?:appears?|is\\s+shown|displays?)$/i,\n    primitiveType: 'expectToast',\n    extract: (match) => ({\n      type: 'expectToast',\n      toastType: 'success',\n      message: match[1]!,\n    }),\n  },\n  {\n    name: 'error-toast-message',\n    regex: /^(?:an?\\s+)?error\\s+toast\\s+(?:with\\s+)?[\"']([^\"']+)[\"']\\s*(?:message\\s+)?(?:appears?|is\\s+shown|displays?)$/i,\n    primitiveType: 'expectToast',\n    extract: (match) => ({\n      type: 'expectToast',\n      toastType: 'error',\n      message: match[1]!,\n    }),\n  },\n  {\n    name: 'toast-appears',\n    regex: /^(?:a\\s+)?(success|error|info|warning)\\s+toast\\s+(?:appears?|is\\s+shown|displays?)$/i,\n    primitiveType: 'expectToast',\n    extract: (match) => ({\n      type: 'expectToast',\n      toastType: match[1]!.toLowerCase() as 'success' | 'error' | 'info' | 'warning',\n    }),\n  },\n  {\n    name: 'toast-with-text',\n    regex: /^(?:toast|notification)\\s+(?:with\\s+)?[\"']([^\"']+)[\"']\\s+(?:appears?|is\\s+shown|displays?)$/i,\n    primitiveType: 'expectToast',\n    extract: (match) => ({\n      type: 'expectToast',\n      toastType: 'info',\n      message: match[1]!,\n    }),\n  },\n  {\n    name: 'status-message-visible',\n    // \"A status message 'Processing...' is visible\" or \"The status shows 'Loading'\"\n    regex: /^(?:a\\s+)?status\\s+(?:message\\s+)?[\"']([^\"']+)[\"']\\s+(?:is\\s+)?(?:visible|shown|displayed)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('role', 'status', match[1]!),\n    }),\n  },\n  {\n    name: 'verify-status-message',\n    // \"Verify the status message shows 'Complete'\"\n    regex: /^(?:verify|check)\\s+(?:that\\s+)?(?:the\\s+)?status\\s+(?:message\\s+)?(?:shows?|displays?|contains?)\\s+[\"']([^\"']+)[\"']$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('role', 'status', match[1]!),\n    }),\n  },\n];\n\n/**\n * URL assertion patterns\n */\nexport const urlPatterns: StepPattern[] = [\n  {\n    name: 'url-contains',\n    regex: /^(?:the\\s+)?url\\s+(?:should\\s+)?(?:contains?|includes?)\\s+[\"']?([^\"'\\s]+)[\"']?$/i,\n    primitiveType: 'expectURL',\n    extract: (match) => ({\n      type: 'expectURL',\n      pattern: match[1]!,\n    }),\n  },\n  {\n    name: 'url-is',\n    regex: /^(?:the\\s+)?url\\s+(?:should\\s+)?(?:is|equals?|be)\\s+[\"']?([^\"'\\s]+)[\"']?$/i,\n    primitiveType: 'expectURL',\n    extract: (match) => ({\n      type: 'expectURL',\n      pattern: match[1]!,\n    }),\n  },\n  {\n    name: 'redirected-to',\n    regex: /^(?:user\\s+)?(?:is\\s+)?redirected\\s+to\\s+[\"']?([^\"'\\s]+)[\"']?$/i,\n    primitiveType: 'expectURL',\n    extract: (match) => ({\n      type: 'expectURL',\n      pattern: match[1]!,\n    }),\n  },\n];\n\n/**\n * Module call patterns (authentication)\n */\nexport const authPatterns: StepPattern[] = [\n  {\n    name: 'user-login',\n    regex: /^(?:user\\s+)?(?:logs?\\s*in|login\\s+is\\s+performed|authenticates?)$/i,\n    primitiveType: 'callModule',\n    extract: (_match) => ({\n      type: 'callModule',\n      module: 'auth',\n      method: 'login',\n    }),\n  },\n  {\n    name: 'user-logout',\n    regex: /^(?:user\\s+)?(?:logs?\\s*out|logout\\s+is\\s+performed|signs?\\s*out)$/i,\n    primitiveType: 'callModule',\n    extract: (_match) => ({\n      type: 'callModule',\n      module: 'auth',\n      method: 'logout',\n    }),\n  },\n  {\n    name: 'login-as-role',\n    regex: /^(?:user\\s+)?logs?\\s*in\\s+as\\s+(?:an?\\s+)?(.+?)(?:\\s+user)?$/i,\n    primitiveType: 'callModule',\n    extract: (match) => ({\n      type: 'callModule',\n      module: 'auth',\n      method: 'loginAs',\n      args: [match[1]!.toLowerCase()],\n    }),\n  },\n];\n\n/**\n * Wait patterns\n */\nexport const waitPatterns: StepPattern[] = [\n  {\n    name: 'wait-for-navigation',\n    regex: /^(?:user\\s+)?(?:waits?\\s+)?(?:for\\s+)?navigation\\s+to\\s+[\"']?([^\"'\\s]+)[\"']?$/i,\n    primitiveType: 'waitForURL',\n    extract: (match) => ({\n      type: 'waitForURL',\n      pattern: match[1]!,\n    }),\n  },\n  {\n    name: 'wait-for-page',\n    regex: /^(?:user\\s+)?(?:waits?\\s+)?(?:for\\s+)?(?:the\\s+)?(.+?)\\s+(?:page|screen)\\s+to\\s+load$/i,\n    primitiveType: 'waitForLoadingComplete',\n    extract: (_match) => ({\n      type: 'waitForLoadingComplete',\n    }),\n  },\n];\n\n/**\n * Helper function to convert natural language selectors to Playwright locator strategies\n */\nexport function parseSelectorToLocator(selector: string): { strategy: LocatorStrategy; value: string; name?: string } {\n  // Remove leading \"the\" if present\n  const cleanSelector = selector.replace(/^the\\s+/i, '').trim();\n\n  // Match button patterns\n  if (/button$/i.test(cleanSelector)) {\n    const buttonName = cleanSelector.replace(/\\s*button$/i, '').trim();\n    return { strategy: 'role', value: 'button', name: buttonName };\n  }\n\n  // Match link patterns\n  if (/link$/i.test(cleanSelector)) {\n    const linkName = cleanSelector.replace(/\\s*link$/i, '').trim();\n    return { strategy: 'role', value: 'link', name: linkName };\n  }\n\n  // Match input/field patterns\n  if (/(?:input|field)$/i.test(cleanSelector)) {\n    const labelName = cleanSelector.replace(/\\s*(?:input|field)$/i, '').trim();\n    return { strategy: 'label', value: labelName };\n  }\n\n  // Default to text locator\n  return { strategy: 'text', value: cleanSelector };\n}\n\n/**\n * Structured step patterns for Journey markdown format\n * Matches patterns like:\n * - **Action**: Click the login button\n * - **Wait for**: Dashboard to load\n * - **Assert**: User name is visible\n */\nexport const structuredPatterns: StepPattern[] = [\n  // Action patterns\n  {\n    name: 'structured-action-click',\n    regex: /^\\*\\*Action\\*\\*:\\s*[Cc]lick\\s+(?:the\\s+)?['\"]?(.+?)['\"]?\\s*(?:button|link)?$/i,\n    primitiveType: 'click',\n    extract: (match) => {\n      const target = match[1]!;\n      const locatorInfo = parseSelectorToLocator(target + ' button');\n      return {\n        type: 'click',\n        locator: locatorInfo.name\n          ? createLocatorFromMatch(locatorInfo.strategy, locatorInfo.value, locatorInfo.name)\n          : { strategy: locatorInfo.strategy, value: locatorInfo.value },\n      };\n    },\n  },\n  {\n    name: 'structured-action-fill',\n    regex: /^\\*\\*Action\\*\\*:\\s*[Ff]ill\\s+(?:in\\s+)?['\"]?(.+?)['\"]?\\s+with\\s+['\"]?(.+?)['\"]?$/i,\n    primitiveType: 'fill',\n    extract: (match) => {\n      const target = match[1]!;\n      const value = match[2]!;\n      const locatorInfo = parseSelectorToLocator(target);\n      return {\n        type: 'fill',\n        locator: locatorInfo.name\n          ? createLocatorFromMatch(locatorInfo.strategy, locatorInfo.value, locatorInfo.name)\n          : { strategy: locatorInfo.strategy, value: locatorInfo.value },\n        value: createValueFromText(value),\n      };\n    },\n  },\n  {\n    name: 'structured-action-navigate',\n    regex: /^\\*\\*Action\\*\\*:\\s*[Nn]avigate\\s+to\\s+['\"]?(.+?)['\"]?$/i,\n    primitiveType: 'goto',\n    extract: (match) => ({\n      type: 'goto',\n      url: match[1]!,\n      waitForLoad: true,\n    }),\n  },\n\n  // Wait patterns\n  {\n    name: 'structured-wait-for-visible',\n    regex: /^\\*\\*Wait for\\*\\*:\\s*(.+?)\\s+(?:to\\s+)?(?:be\\s+)?(?:visible|appear|load)/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => {\n      const target = match[1]!;\n      const locatorInfo = parseSelectorToLocator(target);\n      return {\n        type: 'expectVisible',\n        locator: locatorInfo.name\n          ? createLocatorFromMatch(locatorInfo.strategy, locatorInfo.value, locatorInfo.name)\n          : { strategy: locatorInfo.strategy, value: locatorInfo.value },\n      };\n    },\n  },\n\n  // Assert patterns\n  {\n    name: 'structured-assert-visible',\n    regex: /^\\*\\*Assert\\*\\*:\\s*(.+?)\\s+(?:is\\s+)?visible$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => {\n      const target = match[1]!;\n      const locatorInfo = parseSelectorToLocator(target);\n      return {\n        type: 'expectVisible',\n        locator: locatorInfo.name\n          ? createLocatorFromMatch(locatorInfo.strategy, locatorInfo.value, locatorInfo.name)\n          : { strategy: locatorInfo.strategy, value: locatorInfo.value },\n      };\n    },\n  },\n  {\n    name: 'structured-assert-text',\n    regex: /^\\*\\*Assert\\*\\*:\\s*(.+?)\\s+(?:contains|has text)\\s+['\"]?(.+?)['\"]?$/i,\n    primitiveType: 'expectText',\n    extract: (match) => {\n      const target = match[1]!;\n      const text = match[2]!;\n      const locatorInfo = parseSelectorToLocator(target);\n      return {\n        type: 'expectText',\n        locator: locatorInfo.name\n          ? createLocatorFromMatch(locatorInfo.strategy, locatorInfo.value, locatorInfo.name)\n          : { strategy: locatorInfo.strategy, value: locatorInfo.value },\n        text,\n      };\n    },\n  },\n];\n\n/**\n * Extended click patterns - Common variations missed by core patterns\n * Added in v1.1.0 based on telemetry analysis\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md Phase 3\n */\nexport const extendedClickPatterns: StepPattern[] = [\n  {\n    name: 'click-on-element',\n    // \"Click on Submit\" or \"Click on the Submit button\"\n    regex: /^(?:user\\s+)?clicks?\\s+on\\s+(?:the\\s+)?(.+?)(?:\\s+button|\\s+link)?$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('text', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n  {\n    name: 'press-enter-key',\n    // \"Press Enter\" or \"Press the Enter key\" or \"Hit Enter\"\n    regex: /^(?:user\\s+)?(?:press(?:es)?|hits?)\\s+(?:the\\s+)?(?:enter|return)(?:\\s+key)?$/i,\n    primitiveType: 'press',\n    extract: () => ({\n      type: 'press',\n      key: 'Enter',\n    }),\n  },\n  {\n    name: 'press-tab-key',\n    // \"Press Tab\" or \"Press the Tab key\"\n    regex: /^(?:user\\s+)?(?:press(?:es)?|hits?)\\s+(?:the\\s+)?tab(?:\\s+key)?$/i,\n    primitiveType: 'press',\n    extract: () => ({\n      type: 'press',\n      key: 'Tab',\n    }),\n  },\n  {\n    name: 'press-escape-key',\n    // \"Press Escape\" or \"Press Esc\"\n    regex: /^(?:user\\s+)?(?:press(?:es)?|hits?)\\s+(?:the\\s+)?(?:escape|esc)(?:\\s+key)?$/i,\n    primitiveType: 'press',\n    extract: () => ({\n      type: 'press',\n      key: 'Escape',\n    }),\n  },\n  {\n    name: 'double-click',\n    // \"Double click on\" or \"Double-click the\"\n    regex: /^(?:user\\s+)?double[-\\s]?clicks?\\s+(?:on\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?$/i,\n    primitiveType: 'dblclick',\n    extract: (match) => ({\n      type: 'dblclick',\n      locator: createLocatorFromMatch('text', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n  {\n    name: 'right-click',\n    // \"Right click on\" or \"Right-click the\"\n    regex: /^(?:user\\s+)?right[-\\s]?clicks?\\s+(?:on\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?$/i,\n    primitiveType: 'rightClick',\n    extract: (match) => ({\n      type: 'rightClick',\n      locator: createLocatorFromMatch('text', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n  {\n    name: 'submit-form',\n    // \"Submit the form\" or \"Submits form\"\n    regex: /^(?:user\\s+)?submits?\\s+(?:the\\s+)?form$/i,\n    primitiveType: 'click',\n    extract: () => ({\n      type: 'click',\n      locator: createLocatorFromMatch('role', 'button', 'Submit'),\n    }),\n  },\n];\n\n/**\n * Extended fill patterns - Common variations missed by core patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const extendedFillPatterns: StepPattern[] = [\n  {\n    name: 'type-into-field',\n    // \"Type 'password' into the Password field\"\n    regex: /^(?:user\\s+)?types?\\s+['\"](.+?)['\"]\\s+into\\s+(?:the\\s+)?[\"']?(.+?)[\"']?\\s*(?:field|input)?$/i,\n    primitiveType: 'fill',\n    extract: (match) => ({\n      type: 'fill',\n      locator: createLocatorFromMatch('label', match[2]!),\n      value: createValueFromText(match[1]!),\n    }),\n  },\n  {\n    name: 'fill-in-field-no-value',\n    // \"Fill in the email address\" (without explicit value - uses actor data)\n    regex: /^(?:user\\s+)?fills?\\s+in\\s+(?:the\\s+)?[\"']?(.+?)[\"']?\\s*(?:field|input)?$/i,\n    primitiveType: 'fill',\n    extract: (match) => {\n      const fieldName = match[1]!.replace(/[\"']/g, '');\n      return {\n        type: 'fill',\n        locator: createLocatorFromMatch('label', fieldName),\n        value: { type: 'actor', value: fieldName.toLowerCase().replace(/\\s+/g, '_') },\n      };\n    },\n  },\n  {\n    name: 'clear-field',\n    // \"Clear the email field\" or \"Clears the input\"\n    regex: /^(?:user\\s+)?clears?\\s+(?:the\\s+)?[\"']?(.+?)[\"']?\\s*(?:field|input)?$/i,\n    primitiveType: 'clear',\n    extract: (match) => ({\n      type: 'clear',\n      locator: createLocatorFromMatch('label', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n  {\n    name: 'set-value',\n    // \"Set the value to 'test'\" or \"Sets field to 'value'\"\n    regex: /^(?:user\\s+)?sets?\\s+(?:the\\s+)?(?:value\\s+)?(?:of\\s+)?[\"']?(.+?)[\"']?\\s+to\\s+['\"](.+?)['\"]$/i,\n    primitiveType: 'fill',\n    extract: (match) => ({\n      type: 'fill',\n      locator: createLocatorFromMatch('label', match[1]!),\n      value: createValueFromText(match[2]!),\n    }),\n  },\n];\n\n/**\n * Extended assertion patterns - Common variations missed by core patterns\n * Added in v1.1.0 based on telemetry analysis\n *\n * IMPORTANT: Patterns are ordered by SPECIFICITY (most specific first)\n * - \"is not visible\" patterns must come before generic \"is visible\" patterns\n * - \"URL contains\" patterns must come before generic \"contains\" patterns\n * - Specific state assertions (enabled, disabled, checked) before generic visibility\n */\nexport const extendedAssertionPatterns: StepPattern[] = [\n  // \n  // MOST SPECIFIC: Negative assertions (must come before positive counterparts)\n  // \n  {\n    name: 'verify-not-visible',\n    // \"Verify the error container is not visible\"\n    regex: /^(?:verify|confirm|check)\\s+(?:that\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+is\\s+not\\s+visible$/i,\n    primitiveType: 'expectHidden',\n    extract: (match) => ({\n      type: 'expectHidden',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'element-should-not-be-visible',\n    // \"The error should not be visible\" or \"Error message is not displayed\"\n    regex: /^(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:should\\s+)?(?:not\\s+be|is\\s+not)\\s+(?:visible|displayed|shown)$/i,\n    primitiveType: 'expectHidden',\n    extract: (match) => ({\n      type: 'expectHidden',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n\n  // \n  // URL AND TITLE: Specific patterns that match \"URL\" or \"title\" keywords\n  // \n  {\n    name: 'verify-url-contains',\n    // \"Verify the URL contains '/dashboard'\"\n    regex: /^(?:verify|confirm|check)\\s+(?:that\\s+)?(?:the\\s+)?url\\s+contains?\\s+[\"']([^\"']+)[\"']$/i,\n    primitiveType: 'expectURL',\n    extract: (match) => ({\n      type: 'expectURL',\n      pattern: match[1]!,\n    }),\n  },\n  {\n    name: 'verify-title-is',\n    // \"Verify the page title is 'Settings'\"\n    regex: /^(?:verify|confirm|check)\\s+(?:that\\s+)?(?:the\\s+)?(?:page\\s+)?title\\s+(?:is|equals?)\\s+[\"']([^\"']+)[\"']$/i,\n    primitiveType: 'expectTitle',\n    extract: (match) => ({\n      type: 'expectTitle',\n      title: match[1]!,\n    }),\n  },\n\n  // \n  // SPECIFIC STATE ASSERTIONS: enabled, disabled, checked, value, count\n  // \n  {\n    name: 'verify-field-value',\n    // \"Verify the username field has value 'testuser'\"\n    regex: /^(?:verify|confirm|check)\\s+(?:that\\s+)?(?:the\\s+)?[\"']?(\\w+)[\"']?\\s+(?:field\\s+)?has\\s+value\\s+[\"']([^\"']+)[\"']$/i,\n    primitiveType: 'expectValue',\n    extract: (match) => ({\n      type: 'expectValue',\n      locator: createLocatorFromMatch('label', match[1]!),\n      value: match[2]!,\n    }),\n  },\n  {\n    name: 'verify-element-enabled',\n    // \"Verify the submit button is enabled\"\n    regex: /^(?:verify|confirm|check)\\s+(?:that\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:button\\s+)?is\\s+enabled$/i,\n    primitiveType: 'expectEnabled',\n    extract: (match) => ({\n      type: 'expectEnabled',\n      locator: createLocatorFromMatch('label', match[1]!),\n    }),\n  },\n  {\n    name: 'verify-element-disabled',\n    // \"Verify the disabled input is disabled\"\n    regex: /^(?:verify|confirm|check)\\s+(?:that\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:input\\s+)?is\\s+disabled$/i,\n    primitiveType: 'expectDisabled',\n    extract: (match) => ({\n      type: 'expectDisabled',\n      locator: createLocatorFromMatch('label', match[1]!),\n    }),\n  },\n  {\n    name: 'verify-checkbox-checked',\n    // \"Verify the checkbox is checked\"\n    regex: /^(?:verify|confirm|check)\\s+(?:that\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:checkbox\\s+)?is\\s+checked$/i,\n    primitiveType: 'expectChecked',\n    extract: (match) => ({\n      type: 'expectChecked',\n      locator: createLocatorFromMatch('label', match[1]!),\n    }),\n  },\n  {\n    name: 'verify-count',\n    // \"Verify 5 items are shown\" or \"Verify 3 elements exist\"\n    regex: /^(?:verify|confirm|check)\\s+(?:that\\s+)?(\\d+)\\s+(?:items?|elements?|rows?)\\s+(?:are\\s+)?(?:shown|displayed|exist|visible)$/i,\n    primitiveType: 'expectCount',\n    extract: (match) => ({\n      type: 'expectCount',\n      locator: { strategy: 'text', value: 'item' },\n      count: parseInt(match[1]!, 10),\n    }),\n  },\n\n  // \n  // GENERIC VISIBILITY: Catch-all patterns for \"is visible/displayed/showing\"\n  // These must come AFTER specific patterns to avoid over-matching\n  // \n  {\n    name: 'verify-element-showing',\n    // \"Verify the dashboard is showing/displayed\"\n    regex: /^(?:verify|confirm|ensure)\\s+(?:that\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:is\\s+)?(?:showing|displayed|visible)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'page-should-show',\n    // \"The page should show 'Welcome'\" or \"Page should display 'text'\"\n    regex: /^(?:the\\s+)?page\\s+should\\s+(?:show|display|contain)\\s+['\"](.+?)['\"]$/i,\n    primitiveType: 'expectText',\n    extract: (match) => ({\n      type: 'expectText',\n      locator: { strategy: 'role', value: 'main' },\n      text: match[1]!,\n    }),\n  },\n  {\n    name: 'make-sure-assertion',\n    // \"Make sure the button is visible\" or \"Make sure user sees 'text'\"\n    regex: /^make\\s+sure\\s+(?:that\\s+)?(?:the\\s+)?(.+?)\\s+(?:is\\s+)?(?:visible|displayed|shown)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'confirm-that-assertion',\n    // \"Confirm that the message appears\", \"Verify success message appears\", or \"Confirm the error is shown\"\n    regex: /^(?:verify|confirm)\\s+(?:that\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:appears?|is\\s+shown|displays?)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'check-element-exists',\n    // \"Check that the element exists\" or \"Check the button is present\"\n    regex: /^check\\s+(?:that\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:exists?|is\\s+present)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n\n  // \n  // GENERIC TEXT ASSERTIONS: \"contains\" patterns (must be last to avoid conflicts)\n  // \n  {\n    name: 'element-contains-text',\n    // \"The header contains 'Welcome'\" or \"Element should contain 'text'\"\n    regex: /^(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:should\\s+)?contains?\\s+['\"](.+?)['\"]$/i,\n    primitiveType: 'expectText',\n    extract: (match) => ({\n      type: 'expectText',\n      locator: createLocatorFromMatch('text', match[1]!),\n      text: match[2]!,\n    }),\n  },\n];\n\n/**\n * Extended wait patterns - Common variations missed by core patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const extendedWaitPatterns: StepPattern[] = [\n  {\n    name: 'wait-for-element-visible',\n    // \"Wait for the loading spinner to disappear\"\n    regex: /^(?:user\\s+)?waits?\\s+(?:for\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+to\\s+(?:disappear|be\\s+hidden)$/i,\n    primitiveType: 'waitForHidden',\n    extract: (match) => ({\n      type: 'waitForHidden',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'wait-for-element-appear',\n    // \"Wait for the modal to appear\" or \"Wait for dialog to show\"\n    regex: /^(?:user\\s+)?waits?\\s+(?:for\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+to\\s+(?:appear|show|be\\s+visible)$/i,\n    primitiveType: 'waitForVisible',\n    extract: (match) => ({\n      type: 'waitForVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'wait-until-loaded',\n    // \"Wait until the page is loaded\" or \"Wait until content loads\"\n    regex: /^(?:user\\s+)?waits?\\s+until\\s+(?:the\\s+)?(?:page|content|data)\\s+(?:is\\s+)?loaded$/i,\n    primitiveType: 'waitForLoadingComplete',\n    extract: () => ({\n      type: 'waitForLoadingComplete',\n    }),\n  },\n  {\n    name: 'wait-seconds',\n    // \"Wait for 2 seconds\" or \"Wait 3 seconds\"\n    regex: /^(?:user\\s+)?waits?\\s+(?:for\\s+)?(\\d+)\\s+seconds?$/i,\n    primitiveType: 'waitForTimeout',\n    extract: (match) => ({\n      type: 'waitForTimeout',\n      ms: parseInt(match[1]!, 10) * 1000,\n    }),\n  },\n  {\n    name: 'wait-for-network',\n    // \"Wait for network to be idle\" or \"Wait for network idle\"\n    regex: /^(?:user\\s+)?waits?\\s+(?:for\\s+)?(?:the\\s+)?network\\s+(?:to\\s+be\\s+)?idle$/i,\n    primitiveType: 'waitForNetworkIdle',\n    extract: () => ({\n      type: 'waitForNetworkIdle',\n    }),\n  },\n];\n\n/**\n * Extended navigation patterns - Common variations missed by core patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const extendedNavigationPatterns: StepPattern[] = [\n  {\n    name: 'refresh-page',\n    // \"Refresh the page\" or \"Reload the page\"\n    regex: /^(?:user\\s+)?(?:refresh(?:es)?|reloads?)\\s+(?:the\\s+)?page$/i,\n    primitiveType: 'reload',\n    extract: () => ({\n      type: 'reload',\n    }),\n  },\n  {\n    name: 'go-back',\n    // \"Go back\" or \"Navigate back\" or \"User goes back\"\n    regex: /^(?:user\\s+)?(?:go(?:es)?|navigates?)\\s+back$/i,\n    primitiveType: 'goBack',\n    extract: () => ({\n      type: 'goBack',\n    }),\n  },\n  {\n    name: 'go-forward',\n    // \"Go forward\" or \"Navigate forward\"\n    regex: /^(?:user\\s+)?(?:go(?:es)?|navigates?)\\s+forward$/i,\n    primitiveType: 'goForward',\n    extract: () => ({\n      type: 'goForward',\n    }),\n  },\n];\n\n/**\n * Extended select/dropdown patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const extendedSelectPatterns: StepPattern[] = [\n  {\n    name: 'select-from-dropdown',\n    // \"Select 'Option' from dropdown\" or \"Choose 'Value' from the dropdown\"\n    regex: /^(?:user\\s+)?(?:selects?|chooses?)\\s+['\"](.+?)['\"]\\s+from\\s+(?:the\\s+)?dropdown$/i,\n    primitiveType: 'select',\n    extract: (match) => ({\n      type: 'select',\n      locator: { strategy: 'role', value: 'combobox' },\n      option: match[1]!,\n    }),\n  },\n  {\n    name: 'select-option-named',\n    // \"Select option 'Value'\" or \"Choose the 'Option' option\"\n    regex: /^(?:user\\s+)?(?:selects?|chooses?)\\s+(?:the\\s+)?(?:option\\s+)?['\"](.+?)['\"](?:\\s+option)?$/i,\n    primitiveType: 'select',\n    extract: (match) => ({\n      type: 'select',\n      locator: { strategy: 'role', value: 'combobox' },\n      option: match[1]!,\n    }),\n  },\n];\n\n/**\n * Hover patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const hoverPatterns: StepPattern[] = [\n  {\n    name: 'hover-over-element',\n    // \"Hover over the menu\" or \"User hovers on button\"\n    regex: /^(?:user\\s+)?hovers?\\s+(?:over|on)\\s+(?:the\\s+)?[\"']?(.+?)[\"']?$/i,\n    primitiveType: 'hover',\n    extract: (match) => ({\n      type: 'hover',\n      locator: createLocatorFromMatch('text', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n  {\n    name: 'mouse-over',\n    // \"Mouse over the element\" or \"Mouseover the button\"\n    regex: /^(?:user\\s+)?mouse\\s*over\\s+(?:the\\s+)?[\"']?(.+?)[\"']?$/i,\n    primitiveType: 'hover',\n    extract: (match) => ({\n      type: 'hover',\n      locator: createLocatorFromMatch('text', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n];\n\n/**\n * Focus patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const focusPatterns: StepPattern[] = [\n  {\n    name: 'focus-on-element',\n    // \"Focus on the input\" or \"User focuses the field\"\n    regex: /^(?:user\\s+)?focus(?:es)?\\s+(?:on\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?$/i,\n    primitiveType: 'focus',\n    extract: (match) => ({\n      type: 'focus',\n      locator: createLocatorFromMatch('label', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n];\n\n/**\n * Modal and Alert patterns\n * Added in v1.1.0 for comprehensive E2E coverage\n */\nexport const modalAlertPatterns: StepPattern[] = [\n  {\n    name: 'dismiss-modal',\n    // \"Dismiss the modal\" or \"Close the modal dialog\"\n    regex: /^(?:dismiss|close)\\s+(?:the\\s+)?(?:modal|dialog)(?:\\s+dialog)?$/i,\n    primitiveType: 'dismissModal',\n    extract: () => ({\n      type: 'dismissModal',\n    }),\n  },\n  {\n    name: 'accept-alert',\n    // \"Accept the alert\" or \"Click OK on alert\"\n    regex: /^(?:accept|confirm|ok)\\s+(?:the\\s+)?alert$/i,\n    primitiveType: 'acceptAlert',\n    extract: () => ({\n      type: 'acceptAlert',\n    }),\n  },\n  {\n    name: 'dismiss-alert',\n    // \"Dismiss the alert\" or \"Cancel the alert\"\n    regex: /^(?:dismiss|cancel|close)\\s+(?:the\\s+)?alert$/i,\n    primitiveType: 'dismissAlert',\n    extract: () => ({\n      type: 'dismissAlert',\n    }),\n  },\n];\n\n/**\n * All patterns in priority order (more specific patterns first)\n * Structured patterns come first to prioritize the Journey markdown format\n */\nexport const allPatterns: StepPattern[] = [\n  ...structuredPatterns,\n  ...authPatterns,\n  ...toastPatterns,\n  ...modalAlertPatterns, // Modal/alert patterns for dialog handling\n  // Extended patterns come BEFORE base patterns to match more specific cases first\n  ...extendedNavigationPatterns, // Must be before navigationPatterns (e.g., \"Go back\" vs \"Go to\")\n  ...navigationPatterns,\n  ...extendedClickPatterns, // Must be before clickPatterns (e.g., \"Click on\" vs \"Click\")\n  ...clickPatterns,\n  ...extendedFillPatterns,\n  ...fillPatterns,\n  ...extendedSelectPatterns,\n  ...selectPatterns,\n  ...checkPatterns,\n  ...extendedAssertionPatterns, // Must be before visibilityPatterns (e.g., \"not be visible\")\n  ...visibilityPatterns,\n  ...urlPatterns,\n  ...extendedWaitPatterns,\n  ...waitPatterns,\n  ...hoverPatterns,\n  ...focusPatterns,\n];\n\n/**\n * Match text against all patterns and return the first matching primitive\n */\nexport function matchPattern(text: string): IRPrimitive | null {\n  const trimmedText = text.trim();\n\n  for (const pattern of allPatterns) {\n    const match = trimmedText.match(pattern.regex);\n    if (match) {\n      const primitive = pattern.extract(match);\n      if (primitive) {\n        return primitive;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Get all pattern matches for debugging\n */\nexport function getPatternMatches(text: string): Array<{ pattern: string; match: IRPrimitive }> {\n  const trimmedText = text.trim();\n  const matches: Array<{ pattern: string; match: IRPrimitive }> = [];\n\n  for (const pattern of allPatterns) {\n    const match = trimmedText.match(pattern.regex);\n    if (match) {\n      const primitive = pattern.extract(match);\n      if (primitive) {\n        matches.push({ pattern: pattern.name, match: primitive });\n      }\n    }\n  }\n\n  return matches;\n}\n\n/**\n * Get all pattern names for CLI listing\n */\nexport function getAllPatternNames(): string[] {\n  return allPatterns.map((p) => p.name);\n}\n\n/**\n * Get pattern count by category\n */\nexport function getPatternCountByCategory(): Record<string, number> {\n  const counts: Record<string, number> = {};\n\n  for (const pattern of allPatterns) {\n    const category = pattern.name.split('-')[0] || 'other';\n    counts[category] = (counts[category] || 0) + 1;\n  }\n\n  return counts;\n}\n\n/**\n * Get pattern metadata for a specific pattern\n */\nexport function getPatternMetadata(patternName: string): PatternMetadata | null {\n  const pattern = allPatterns.find((p) => p.name === patternName);\n  if (!pattern) return null;\n\n  // Determine version based on pattern name prefix\n  const isExtended =\n    patternName.includes('extended') ||\n    patternName.startsWith('hover') ||\n    patternName.startsWith('focus') ||\n    patternName.startsWith('press-') ||\n    patternName.startsWith('double-') ||\n    patternName.startsWith('right-');\n\n  return {\n    name: pattern.name,\n    version: isExtended ? '1.1.0' : '1.0.0',\n    addedDate: isExtended ? '2026-01-27' : '2026-01-02',\n    source: 'core',\n    category: pattern.name.split('-')[0] || 'other',\n  };\n}\n\n/**\n * Find patterns that match a given text (for debugging)\n */\nexport function findMatchingPatterns(text: string): string[] {\n  const trimmedText = text.trim();\n  const matchingNames: string[] = [];\n\n  for (const pattern of allPatterns) {\n    if (pattern.regex.test(trimmedText)) {\n      matchingNames.push(pattern.name);\n    }\n  }\n\n  return matchingNames;\n}\n","/**\n * Mapping module exports\n */\nexport * from './patterns.js';\nexport * from './glossary.js';\nexport * from './stepMapper.js';\nexport * from './patternDistance.js';\nexport * from './blockedStepAnalysis.js';\nexport * from './telemetry.js';\nexport * from './unifiedMatcher.js';\nexport * from './plannedActionAdapter.js';\nexport * from './fuzzyMatcher.js';\nexport * from './normalize.js';\nexport * from './llmFallback.js';\n\n// LLKB pattern learning exports\nexport * from '../llkb/patternExtension.js';\n","/**\n * Step Mapper - Convert step text to IR primitives\n * @see research/2026-01-02_autogen-refined-plan.md Section 10\n * @see T073 - Update step mapper to prioritize explicit hints over inference\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md Phase 4 - LLKB integration\n */\nimport type {\n  IRPrimitive,\n  IRStep,\n  LocatorSpec,\n} from '../ir/types.js';\nimport type { AcceptanceCriterion, ProceduralStep } from '../journey/parseJourney.js';\nimport { matchPattern } from './patterns.js';\nimport { normalizeStepText } from './glossary.js';\nimport {\n  extractHints,\n  hasLocatorHints,\n  hasBehaviorHints,\n  parseModuleHint,\n  type ExtractedHints,\n} from '../journey/parseHints.js';\n\n// LLKB integration types - imported dynamically to avoid hard dependency\ntype LlkbPatternMatch = {\n  patternId: string;\n  primitive: IRPrimitive;\n  confidence: number;\n};\n\n// LLKB module reference - loaded lazily\nlet llkbModule: {\n  matchLlkbPattern: (text: string, options?: { llkbRoot?: string; minConfidence?: number }) => LlkbPatternMatch | null;\n  recordPatternSuccess: (text: string, primitive: IRPrimitive, journeyId: string, options?: { llkbRoot?: string }) => void;\n} | null = null;\n\n// Track if we've attempted to load LLKB\nlet llkbLoadAttempted = false;\n\n/**\n * Lazily load LLKB module (graceful degradation if not available)\n */\nasync function loadLlkbModule(): Promise<typeof llkbModule> {\n  if (llkbLoadAttempted) return llkbModule;\n  llkbLoadAttempted = true;\n\n  try {\n    const mod = await import('../llkb/patternExtension.js');\n    llkbModule = {\n      matchLlkbPattern: mod.matchLlkbPattern,\n      recordPatternSuccess: mod.recordPatternSuccess,\n    };\n  } catch {\n    // LLKB not available - this is fine, graceful degradation\n    llkbModule = null;\n  }\n\n  return llkbModule;\n}\n\n/**\n * Synchronously check LLKB (for non-async contexts)\n * Uses previously loaded module if available.\n *\n * NOTE: initializeLlkb() should be called before using mapStepText with useLlkb=true.\n * If not initialized, LLKB matching will be skipped silently (graceful degradation).\n */\nfunction tryLlkbMatch(text: string, options?: { llkbRoot?: string; minConfidence?: number }): LlkbPatternMatch | null {\n  if (!llkbModule) {\n    // If module not loaded, attempt lazy initialization (non-blocking)\n    // This won't block, but will start loading for future calls\n    if (!llkbLoadAttempted) {\n      void loadLlkbModule();\n    }\n    return null;\n  }\n  return llkbModule.matchLlkbPattern(text, options);\n}\n\n/**\n * Options for step mapping\n */\nexport interface StepMapperOptions {\n  /** Whether to normalize text before matching */\n  normalizeText?: boolean;\n  /** Whether to include blocked steps for unmatched text */\n  includeBlocked?: boolean;\n  /** Default timeout for assertions */\n  defaultTimeout?: number;\n  /** Whether to use LLKB patterns as fallback (default: true) */\n  useLlkb?: boolean;\n  /** LLKB root directory (default: .artk/llkb) */\n  llkbRoot?: string;\n  /** Minimum confidence for LLKB pattern matches (default: 0.7) */\n  llkbMinConfidence?: number;\n  /** Journey ID for LLKB recording (optional) */\n  journeyId?: string;\n}\n\n/**\n * Result of mapping a single step\n */\nexport interface StepMappingResult {\n  /** The parsed primitive, or null if not matched */\n  primitive: IRPrimitive | null;\n  /** Original text that was mapped */\n  sourceText: string;\n  /** Whether this is an assertion (expect*) or action */\n  isAssertion: boolean;\n  /** Warning or error message if any */\n  message?: string;\n  /** Source of the match */\n  matchSource?: 'pattern' | 'llkb' | 'hints' | 'none';\n  /** LLKB pattern ID if matched via LLKB */\n  llkbPatternId?: string;\n  /** LLKB match confidence if matched via LLKB */\n  llkbConfidence?: number;\n}\n\n/**\n * Result of mapping an acceptance criterion\n */\nexport interface ACMappingResult {\n  /** The mapped IR step */\n  step: IRStep;\n  /** Individual step mapping results */\n  mappings: StepMappingResult[];\n  /** Number of successfully mapped steps */\n  mappedCount: number;\n  /** Number of blocked/unmatched steps */\n  blockedCount: number;\n}\n\n/**\n * Check if a primitive is an assertion\n */\nfunction isAssertion(primitive: IRPrimitive): boolean {\n  return primitive.type.startsWith('expect');\n}\n\n/**\n * Map a single text step to an IR primitive\n */\nexport function mapStepText(\n  text: string,\n  options: StepMapperOptions = {}\n): StepMappingResult {\n  const {\n    normalizeText = true,\n    useLlkb = true,\n    llkbRoot,\n    llkbMinConfidence = 0.7,\n  } = options;\n\n  // Extract machine hints first (T073 - hints take priority)\n  const hints = extractHints(text);\n  const cleanText = hints.hasHints ? hints.cleanText : text;\n\n  // Normalize text if enabled\n  const processedText = normalizeText ? normalizeStepText(cleanText) : cleanText;\n\n  // Try to match against core patterns first\n  let primitive = matchPattern(processedText);\n  let matchSource: 'pattern' | 'llkb' | 'hints' | 'none' = primitive ? 'pattern' : 'none';\n\n  // If we have hints, enhance or override the primitive\n  if (primitive && hints.hasHints) {\n    primitive = applyHintsToPrimitive(primitive, hints);\n  }\n\n  // If no core pattern match, try LLKB patterns (Phase 4 integration)\n  let llkbPatternId: string | undefined;\n  let llkbConfidence: number | undefined;\n\n  if (!primitive && useLlkb) {\n    const llkbMatch = tryLlkbMatch(processedText, {\n      llkbRoot,\n      minConfidence: llkbMinConfidence,\n    });\n\n    if (llkbMatch) {\n      primitive = llkbMatch.primitive;\n      matchSource = 'llkb';\n      llkbPatternId = llkbMatch.patternId;\n      llkbConfidence = llkbMatch.confidence;\n\n      // Record successful pattern match to close the learning loop\n      // This increases confidence for future matches\n      if (llkbModule && options.journeyId) {\n        try {\n          llkbModule.recordPatternSuccess(\n            text, // Original text, not processed\n            llkbMatch.primitive,\n            options.journeyId,\n            { llkbRoot }\n          );\n        } catch {\n          // Don't fail mapping if recording fails - graceful degradation\n        }\n      }\n\n      // Apply hints to LLKB-matched primitive if available\n      if (hints.hasHints) {\n        primitive = applyHintsToPrimitive(primitive, hints);\n      }\n    }\n  }\n\n  // If still no match but we have locator hints, try to create primitive from hints\n  if (!primitive && hasLocatorHints(hints)) {\n    primitive = createPrimitiveFromHints(processedText, hints);\n    if (primitive) {\n      matchSource = 'hints';\n    }\n  }\n\n  if (primitive) {\n    return {\n      primitive,\n      sourceText: text,\n      isAssertion: isAssertion(primitive),\n      matchSource,\n      llkbPatternId,\n      llkbConfidence,\n    };\n  }\n\n  // No match - return blocked\n  return {\n    primitive: null,\n    sourceText: text,\n    isAssertion: false,\n    message: `Could not map step: \"${text}\"`,\n    matchSource: 'none',\n  };\n}\n\n/**\n * Apply hints to an existing primitive (override inferred values)\n */\nfunction applyHintsToPrimitive(primitive: IRPrimitive, hints: ExtractedHints): IRPrimitive {\n  // Clone the primitive to avoid mutation\n  const enhanced = { ...primitive };\n\n  // Apply locator hints if present\n  if (hasLocatorHints(hints)) {\n    const locatorSpec = buildLocatorFromHints(hints);\n    if (locatorSpec && 'locator' in enhanced) {\n      (enhanced as { locator: LocatorSpec }).locator = locatorSpec;\n    }\n  }\n\n  // Apply behavior hints\n  if (hasBehaviorHints(hints)) {\n    if (hints.behavior.timeout !== undefined && 'timeout' in enhanced) {\n      (enhanced as { timeout: number }).timeout = hints.behavior.timeout;\n    }\n    if (hints.behavior.signal && 'signal' in enhanced) {\n      (enhanced as { signal: string }).signal = hints.behavior.signal;\n    }\n    if (hints.behavior.module) {\n      const parsed = parseModuleHint(hints.behavior.module);\n      if (parsed) {\n        (enhanced as { module?: string; method?: string }).module = parsed.module;\n        (enhanced as { module?: string; method?: string }).method = parsed.method;\n      }\n    }\n  }\n\n  return enhanced;\n}\n\n/**\n * Build LocatorSpec from hints\n */\nfunction buildLocatorFromHints(hints: ExtractedHints): LocatorSpec | null {\n  const { locator } = hints;\n\n  if (locator.testid) {\n    return { strategy: 'testid', value: locator.testid };\n  }\n\n  if (locator.role) {\n    const options: Record<string, unknown> = {};\n    if (locator.label) options.name = locator.label;\n    if (locator.exact) options.exact = true;\n    if (locator.level) options.level = locator.level;\n    return {\n      strategy: 'role',\n      value: locator.role,\n      options: Object.keys(options).length > 0 ? options : undefined,\n    };\n  }\n\n  if (locator.label) {\n    return {\n      strategy: 'label',\n      value: locator.label,\n      options: locator.exact ? { exact: true } : undefined,\n    };\n  }\n\n  if (locator.text) {\n    return {\n      strategy: 'text',\n      value: locator.text,\n      options: locator.exact ? { exact: true } : undefined,\n    };\n  }\n\n  return null;\n}\n\n/**\n * Create a primitive from hints when no pattern matched\n */\nfunction createPrimitiveFromHints(text: string, hints: ExtractedHints): IRPrimitive | null {\n  const locator = buildLocatorFromHints(hints);\n  if (!locator) return null;\n\n  const lowerText = text.toLowerCase();\n\n  // Infer action type from text\n  if (lowerText.includes('click') || lowerText.includes('press')) {\n    return { type: 'click', locator };\n  }\n\n  if (lowerText.includes('enter') || lowerText.includes('type') || lowerText.includes('fill')) {\n    // Try to extract value from text\n    const valueMatch = text.match(/['\"]([^'\"]+)['\"]/);\n    return {\n      type: 'fill',\n      locator,\n      value: { type: 'literal', value: valueMatch ? valueMatch[1]! : '' },\n    };\n  }\n\n  if (lowerText.includes('see') || lowerText.includes('visible') || lowerText.includes('display')) {\n    return { type: 'expectVisible', locator };\n  }\n\n  if (lowerText.includes('check') || lowerText.includes('select')) {\n    return { type: 'check', locator };\n  }\n\n  // Default to click if we have a locator but can't determine action\n  return { type: 'click', locator };\n}\n\n/**\n * Map an acceptance criterion to an IR step\n */\nexport function mapAcceptanceCriterion(\n  ac: AcceptanceCriterion,\n  proceduralSteps: ProceduralStep[],\n  options: StepMapperOptions = {}\n): ACMappingResult {\n  const { includeBlocked = true } = options;\n\n  const actions: IRPrimitive[] = [];\n  const assertions: IRPrimitive[] = [];\n  const mappings: StepMappingResult[] = [];\n  const notes: string[] = [];\n\n  // Find procedural steps linked to this AC\n  const linkedProcedural = proceduralSteps.filter((ps) => ps.linkedAC === ac.id);\n\n  // Map all bullet points from the AC\n  for (const stepText of ac.steps) {\n    const result = mapStepText(stepText, options);\n    mappings.push(result);\n\n    if (result.primitive) {\n      if (result.isAssertion) {\n        assertions.push(result.primitive);\n      } else {\n        actions.push(result.primitive);\n      }\n    } else if (includeBlocked) {\n      actions.push({\n        type: 'blocked',\n        reason: result.message || 'Could not map step',\n        sourceText: stepText,\n      });\n    }\n  }\n\n  // Also map linked procedural steps\n  for (const ps of linkedProcedural) {\n    const result = mapStepText(ps.text, options);\n    // Don't duplicate in mappings, but add to actions if different from AC steps\n    if (result.primitive && !ac.steps.includes(ps.text)) {\n      if (result.isAssertion) {\n        assertions.push(result.primitive);\n      } else {\n        actions.push(result.primitive);\n      }\n    }\n  }\n\n  // Add note if no assertions\n  if (assertions.length === 0 && ac.title) {\n    notes.push(`TODO: Add assertion for: ${ac.title}`);\n  }\n\n  const step: IRStep = {\n    id: ac.id,\n    description: ac.title || `Step ${ac.id}`,\n    actions,\n    assertions,\n    sourceText: ac.rawContent,\n    notes: notes.length > 0 ? notes : undefined,\n  };\n\n  return {\n    step,\n    mappings,\n    mappedCount: mappings.filter((m) => m.primitive !== null).length,\n    blockedCount: mappings.filter((m) => m.primitive === null).length,\n  };\n}\n\n/**\n * Map a procedural step to an IR step\n */\nexport function mapProceduralStep(\n  ps: ProceduralStep,\n  options: StepMapperOptions = {}\n): ACMappingResult {\n  const { includeBlocked = true } = options;\n\n  const result = mapStepText(ps.text, options);\n  const actions: IRPrimitive[] = [];\n  const assertions: IRPrimitive[] = [];\n\n  if (result.primitive) {\n    if (result.isAssertion) {\n      assertions.push(result.primitive);\n    } else {\n      actions.push(result.primitive);\n    }\n  } else if (includeBlocked) {\n    actions.push({\n      type: 'blocked',\n      reason: result.message || 'Could not map procedural step',\n      sourceText: ps.text,\n    });\n  }\n\n  const step: IRStep = {\n    id: `PS-${ps.number}`,\n    description: ps.text,\n    actions,\n    assertions,\n  };\n\n  return {\n    step,\n    mappings: [result],\n    mappedCount: result.primitive ? 1 : 0,\n    blockedCount: result.primitive ? 0 : 1,\n  };\n}\n\n/**\n * Batch map multiple steps\n */\nexport function mapSteps(\n  steps: string[],\n  options: StepMapperOptions = {}\n): StepMappingResult[] {\n  return steps.map((step) => mapStepText(step, options));\n}\n\n/**\n * Get mapping statistics (enhanced with LLKB stats)\n */\nexport function getMappingStats(mappings: StepMappingResult[]): {\n  total: number;\n  mapped: number;\n  blocked: number;\n  actions: number;\n  assertions: number;\n  mappingRate: number;\n  /** Steps matched by core patterns */\n  patternMatches: number;\n  /** Steps matched by LLKB patterns */\n  llkbMatches: number;\n  /** Steps matched by hints */\n  hintMatches: number;\n} {\n  const mapped = mappings.filter((m) => m.primitive !== null);\n  const blocked = mappings.filter((m) => m.primitive === null);\n  const actions = mapped.filter((m) => !m.isAssertion);\n  const assertions = mapped.filter((m) => m.isAssertion);\n\n  const patternMatches = mappings.filter((m) => m.matchSource === 'pattern').length;\n  const llkbMatches = mappings.filter((m) => m.matchSource === 'llkb').length;\n  const hintMatches = mappings.filter((m) => m.matchSource === 'hints').length;\n\n  return {\n    total: mappings.length,\n    mapped: mapped.length,\n    blocked: blocked.length,\n    actions: actions.length,\n    assertions: assertions.length,\n    mappingRate: mappings.length > 0 ? mapped.length / mappings.length : 0,\n    patternMatches,\n    llkbMatches,\n    hintMatches,\n  };\n}\n\n/**\n * Initialize LLKB module for use with step mapping\n * Call this once at the start of generation to enable LLKB patterns\n */\nexport async function initializeLlkb(): Promise<boolean> {\n  const mod = await loadLlkbModule();\n  return mod !== null;\n}\n\n/**\n * Check if LLKB is available for use\n */\nexport function isLlkbAvailable(): boolean {\n  return llkbModule !== null;\n}\n\n/**\n * Suggest improvements for blocked steps\n */\nexport function suggestImprovements(blockedSteps: StepMappingResult[]): string[] {\n  const suggestions: string[] = [];\n\n  for (const step of blockedSteps) {\n    const text = step.sourceText.toLowerCase();\n\n    // Navigation suggestions\n    if (text.includes('go') || text.includes('open') || text.includes('navigate')) {\n      suggestions.push(\n        `\"${step.sourceText}\" - Try: \"User navigates to /path\" or \"User opens /path\"`\n      );\n    }\n    // Click suggestions\n    else if (text.includes('click') || text.includes('press') || text.includes('button')) {\n      suggestions.push(\n        `\"${step.sourceText}\" - Try: \"User clicks 'Button Name' button\" or \"Click the 'Label' button\"`\n      );\n    }\n    // Fill suggestions\n    else if (text.includes('enter') || text.includes('type') || text.includes('field')) {\n      suggestions.push(\n        `\"${step.sourceText}\" - Try: \"User enters 'value' in 'Field Label' field\"`\n      );\n    }\n    // Visibility suggestions\n    else if (text.includes('see') || text.includes('visible') || text.includes('display')) {\n      suggestions.push(\n        `\"${step.sourceText}\" - Try: \"User should see 'Text'\" or \"'Element' is visible\"`\n      );\n    }\n    // Generic suggestion\n    else {\n      suggestions.push(\n        `\"${step.sourceText}\" - Could not determine intent. Check the patterns documentation.`\n      );\n    }\n  }\n\n  return suggestions;\n}\n","/**\n * Machine Hint Syntax Patterns - Define regex patterns for parsing hints\n * @see T071 - Define machine hint syntax regex patterns\n */\n\n/**\n * Machine hint types\n */\nexport type HintType =\n  | 'role'       // ARIA role hint: (role=button)\n  | 'testid'     // Test ID hint: (testid=submit-btn)\n  | 'label'      // Label hint: (label=\"Email Address\")\n  | 'text'       // Text hint: (text=\"Submit\")\n  | 'exact'      // Exact matching: (exact=true)\n  | 'level'      // Heading level: (level=2)\n  | 'signal'     // Signal hint: (signal=loading-done)\n  | 'module'     // Module method hint: (module=auth.login)\n  | 'wait'       // Wait strategy: (wait=networkidle)\n  | 'timeout';   // Timeout hint: (timeout=5000)\n\n/**\n * Parsed machine hint\n */\nexport interface MachineHint {\n  /** Hint type */\n  type: HintType;\n  /** Hint value */\n  value: string;\n  /** Raw hint string */\n  raw: string;\n}\n\n/**\n * Pattern for detecting hint blocks: (key=value) or (key=\"value with spaces\")\n */\nexport const HINT_BLOCK_PATTERN = /\\(([a-z]+)=(?:\"([^\"]+)\"|'([^']+)'|([^,)\\s]+))\\)/gi;\n\n/**\n * Pattern for a complete hints section: (...hints...)\n */\nexport const HINTS_SECTION_PATTERN = /\\((?:[a-z]+=(?:\"[^\"]+\"|'[^']+'|[^,)\\s]+)(?:,\\s*)?)+\\)/gi;\n\n/**\n * Individual hint patterns for validation\n */\nexport const HINT_PATTERNS: Record<HintType, RegExp> = {\n  role: /role=(?:\"([^\"]+)\"|'([^']+)'|([a-z]+))/i,\n  testid: /testid=(?:\"([^\"]+)\"|'([^']+)'|([a-z0-9_-]+))/i,\n  label: /label=(?:\"([^\"]+)\"|'([^']+)')/i,\n  text: /text=(?:\"([^\"]+)\"|'([^']+)')/i,\n  exact: /exact=(true|false)/i,\n  level: /level=([1-6])/i,\n  signal: /signal=(?:\"([^\"]+)\"|'([^']+)'|([a-z0-9_-]+))/i,\n  module: /module=(?:\"([^\"]+)\"|'([^']+)'|([a-z0-9_.]+))/i,\n  wait: /wait=(networkidle|domcontentloaded|load|commit)/i,\n  timeout: /timeout=(\\d+)/i,\n};\n\n/**\n * Valid ARIA roles for validation\n */\nexport const VALID_ROLES = [\n  'alert',\n  'alertdialog',\n  'application',\n  'article',\n  'banner',\n  'button',\n  'cell',\n  'checkbox',\n  'columnheader',\n  'combobox',\n  'complementary',\n  'contentinfo',\n  'definition',\n  'dialog',\n  'directory',\n  'document',\n  'feed',\n  'figure',\n  'form',\n  'grid',\n  'gridcell',\n  'group',\n  'heading',\n  'img',\n  'link',\n  'list',\n  'listbox',\n  'listitem',\n  'log',\n  'main',\n  'marquee',\n  'math',\n  'menu',\n  'menubar',\n  'menuitem',\n  'menuitemcheckbox',\n  'menuitemradio',\n  'navigation',\n  'none',\n  'note',\n  'option',\n  'presentation',\n  'progressbar',\n  'radio',\n  'radiogroup',\n  'region',\n  'row',\n  'rowgroup',\n  'rowheader',\n  'scrollbar',\n  'search',\n  'searchbox',\n  'separator',\n  'slider',\n  'spinbutton',\n  'status',\n  'switch',\n  'tab',\n  'table',\n  'tablist',\n  'tabpanel',\n  'term',\n  'textbox',\n  'timer',\n  'toolbar',\n  'tooltip',\n  'tree',\n  'treegrid',\n  'treeitem',\n];\n\n/**\n * Check if a role is valid\n */\nexport function isValidRole(role: string): boolean {\n  return VALID_ROLES.includes(role.toLowerCase());\n}\n\n/**\n * Extract hint value from a match (handles quoted and unquoted values)\n */\nexport function extractHintValue(match: RegExpMatchArray): string | null {\n  // Try quoted values first, then unquoted\n  for (let i = 1; i < match.length; i++) {\n    if (match[i] !== undefined) {\n      return match[i] ?? null;\n    }\n  }\n  return null;\n}\n\n/**\n * Check if text contains machine hints\n */\nexport function containsHints(text: string): boolean {\n  // Reset lastIndex for global regex\n  HINTS_SECTION_PATTERN.lastIndex = 0;\n  return HINTS_SECTION_PATTERN.test(text);\n}\n\n/**\n * Remove hints section from step text\n */\nexport function removeHints(text: string): string {\n  return text.replace(HINTS_SECTION_PATTERN, '').trim();\n}\n","/**\n * Machine Hint Parser - Extract hints from Journey step text\n * @see T072 - Implement machine hint parser\n */\nimport {\n  type HintType,\n  type MachineHint,\n  HINT_BLOCK_PATTERN,\n  HINT_PATTERNS,\n  isValidRole,\n  containsHints,\n  removeHints,\n} from './hintPatterns.js';\n\n/**\n * Parsed hints result\n */\nexport interface ParsedHints {\n  /** All parsed hints */\n  hints: MachineHint[];\n  /** Step text with hints removed */\n  cleanText: string;\n  /** Original text */\n  originalText: string;\n  /** Validation warnings */\n  warnings: string[];\n}\n\n/**\n * Locator hints extracted for code generation\n */\nexport interface LocatorHints {\n  /** ARIA role */\n  role?: string;\n  /** Test ID */\n  testid?: string;\n  /** Label text */\n  label?: string;\n  /** Text content */\n  text?: string;\n  /** Exact matching */\n  exact?: boolean;\n  /** Heading level (for role=heading) */\n  level?: number;\n}\n\n/**\n * Behavioral hints extracted for code generation\n */\nexport interface BehaviorHints {\n  /** Signal to wait for */\n  signal?: string;\n  /** Module method to call */\n  module?: string;\n  /** Wait strategy */\n  wait?: 'networkidle' | 'domcontentloaded' | 'load' | 'commit';\n  /** Timeout in ms */\n  timeout?: number;\n}\n\n/**\n * Complete hint extraction result\n */\nexport interface ExtractedHints {\n  /** Locator-related hints */\n  locator: LocatorHints;\n  /** Behavior-related hints */\n  behavior: BehaviorHints;\n  /** Whether any hints were found */\n  hasHints: boolean;\n  /** Clean step text */\n  cleanText: string;\n  /** Warnings */\n  warnings: string[];\n}\n\n/**\n * Parse machine hints from step text\n */\nexport function parseHints(text: string): ParsedHints {\n  const hints: MachineHint[] = [];\n  const warnings: string[] = [];\n\n  if (!containsHints(text)) {\n    return {\n      hints: [],\n      cleanText: text,\n      originalText: text,\n      warnings: [],\n    };\n  }\n\n  // Extract all hint blocks\n  HINT_BLOCK_PATTERN.lastIndex = 0;\n  let match;\n\n  while ((match = HINT_BLOCK_PATTERN.exec(text)) !== null) {\n    const key = match[1]!.toLowerCase() as HintType;\n    const value = match[2] || match[3] || match[4];\n\n    if (!value) {\n      warnings.push(`Empty value for hint: ${key}`);\n      continue;\n    }\n\n    // Validate the hint type\n    if (!(key in HINT_PATTERNS)) {\n      warnings.push(`Unknown hint type: ${key}`);\n      continue;\n    }\n\n    // Validate role values\n    if (key === 'role' && !isValidRole(value)) {\n      warnings.push(`Invalid ARIA role: ${value}`);\n    }\n\n    hints.push({\n      type: key,\n      value,\n      raw: match[0],\n    });\n  }\n\n  return {\n    hints,\n    cleanText: removeHints(text),\n    originalText: text,\n    warnings,\n  };\n}\n\n/**\n * Extract structured hints for code generation\n */\nexport function extractHints(text: string): ExtractedHints {\n  const parsed = parseHints(text);\n\n  const locator: LocatorHints = {};\n  const behavior: BehaviorHints = {};\n\n  for (const hint of parsed.hints) {\n    switch (hint.type) {\n      case 'role':\n        locator.role = hint.value;\n        break;\n      case 'testid':\n        locator.testid = hint.value;\n        break;\n      case 'label':\n        locator.label = hint.value;\n        break;\n      case 'text':\n        locator.text = hint.value;\n        break;\n      case 'exact':\n        locator.exact = hint.value.toLowerCase() === 'true';\n        break;\n      case 'level':\n        locator.level = parseInt(hint.value, 10);\n        break;\n      case 'signal':\n        behavior.signal = hint.value;\n        break;\n      case 'module':\n        behavior.module = hint.value;\n        break;\n      case 'wait':\n        behavior.wait = hint.value as BehaviorHints['wait'];\n        break;\n      case 'timeout':\n        behavior.timeout = parseInt(hint.value, 10);\n        break;\n    }\n  }\n\n  return {\n    locator,\n    behavior,\n    hasHints: parsed.hints.length > 0,\n    cleanText: parsed.cleanText,\n    warnings: parsed.warnings,\n  };\n}\n\n/**\n * Check if hints specify a locator strategy\n */\nexport function hasLocatorHints(hints: ExtractedHints): boolean {\n  const { locator } = hints;\n  return !!(locator.role || locator.testid || locator.label || locator.text);\n}\n\n/**\n * Check if hints specify behavioral modifications\n */\nexport function hasBehaviorHints(hints: ExtractedHints): boolean {\n  const { behavior } = hints;\n  return !!(behavior.signal || behavior.module || behavior.wait || behavior.timeout);\n}\n\n/**\n * Generate locator code from hints\n */\nexport function generateLocatorFromHints(hints: LocatorHints): string | null {\n  // Priority: testid > role > label > text\n  if (hints.testid) {\n    return `page.getByTestId('${hints.testid}')`;\n  }\n\n  if (hints.role) {\n    const options: string[] = [];\n    if (hints.label) {\n      options.push(`name: '${hints.label}'`);\n    }\n    if (hints.exact) {\n      options.push('exact: true');\n    }\n    if (hints.level && hints.role === 'heading') {\n      options.push(`level: ${hints.level}`);\n    }\n\n    if (options.length > 0) {\n      return `page.getByRole('${hints.role}', { ${options.join(', ')} })`;\n    }\n    return `page.getByRole('${hints.role}')`;\n  }\n\n  if (hints.label) {\n    if (hints.exact) {\n      return `page.getByLabel('${hints.label}', { exact: true })`;\n    }\n    return `page.getByLabel('${hints.label}')`;\n  }\n\n  if (hints.text) {\n    if (hints.exact) {\n      return `page.getByText('${hints.text}', { exact: true })`;\n    }\n    return `page.getByText('${hints.text}')`;\n  }\n\n  return null;\n}\n\n/**\n * Parse module hint into module name and method\n */\nexport function parseModuleHint(moduleHint: string): { module: string; method: string } | null {\n  const parts = moduleHint.split('.');\n  if (parts.length !== 2) {\n    return null;\n  }\n  return {\n    module: parts[0]!,\n    method: parts[1]!,\n  };\n}\n\n/**\n * Validate hints for consistency\n */\nexport function validateHints(hints: ExtractedHints): string[] {\n  const errors: string[] = [];\n\n  // Check for conflicting locator hints\n  const locatorCount = [\n    hints.locator.testid,\n    hints.locator.role,\n    hints.locator.label && !hints.locator.role, // label with role is fine\n    hints.locator.text,\n  ].filter(Boolean).length;\n\n  if (locatorCount > 1) {\n    errors.push('Multiple conflicting locator hints specified');\n  }\n\n  // Check for level without heading role\n  if (hints.locator.level && hints.locator.role !== 'heading') {\n    errors.push('level hint only applies to role=heading');\n  }\n\n  // Check for module hint format\n  if (hints.behavior.module) {\n    const parsed = parseModuleHint(hints.behavior.module);\n    if (!parsed) {\n      errors.push('module hint must be in format: moduleName.methodName');\n    }\n  }\n\n  return errors;\n}\n\n/**\n * Merge hints with inferred locator (hints take priority)\n */\nexport function mergeWithInferred(\n  hints: LocatorHints,\n  inferred: { strategy: string; value: string }\n): { strategy: string; value: string; options?: Record<string, unknown> } {\n  // If hints specify a locator, use it\n  if (hints.testid) {\n    return { strategy: 'testid', value: hints.testid };\n  }\n\n  if (hints.role) {\n    const options: Record<string, unknown> = {};\n    if (hints.label) {\n      options.name = hints.label;\n    }\n    if (hints.exact) {\n      options.exact = true;\n    }\n    if (hints.level) {\n      options.level = hints.level;\n    }\n    return { strategy: 'role', value: hints.role, options };\n  }\n\n  if (hints.label) {\n    const options: Record<string, unknown> = {};\n    if (hints.exact) {\n      options.exact = true;\n    }\n    return { strategy: 'label', value: hints.label, options };\n  }\n\n  if (hints.text) {\n    const options: Record<string, unknown> = {};\n    if (hints.exact) {\n      options.exact = true;\n    }\n    return { strategy: 'text', value: hints.text, options };\n  }\n\n  // Add exact option to inferred if specified\n  if (hints.exact) {\n    return { ...inferred, options: { exact: true } };\n  }\n\n  // Fall back to inferred\n  return inferred;\n}\n","/**\n * Enhanced analysis of blocked steps for AI-assisted fixing\n */\n\nimport { findNearestPattern, type NearestPatternResult, type PatternDefinition } from './patternDistance.js';\nimport type { StepPattern } from './patterns.js';\n\nexport type StepCategory = 'navigation' | 'interaction' | 'assertion' | 'wait' | 'unknown';\n\nexport interface StepSuggestion {\n  priority: number;\n  text: string;\n  explanation: string;\n  confidence: number;\n}\n\nexport interface BlockedStepAnalysis {\n  step: string;\n  reason: string;\n  suggestions: StepSuggestion[];\n  nearestPattern?: NearestPatternResult;\n  machineHintSuggestion?: string;\n  category: StepCategory;\n}\n\n/**\n * Categorize a step based on its text\n */\nexport function categorizeStep(text: string): StepCategory {\n  const lowerText = text.toLowerCase();\n\n  if (lowerText.includes('navigate') || lowerText.includes('go to') ||\n      lowerText.includes('open') || lowerText.includes('visit')) {\n    return 'navigation';\n  }\n\n  if (lowerText.includes('click') || lowerText.includes('fill') ||\n      lowerText.includes('enter') || lowerText.includes('type') ||\n      lowerText.includes('select') || lowerText.includes('check') ||\n      lowerText.includes('press')) {\n    return 'interaction';\n  }\n\n  if (lowerText.includes('see') || lowerText.includes('visible') ||\n      lowerText.includes('verify') || lowerText.includes('assert') ||\n      lowerText.includes('confirm') || lowerText.includes('should') ||\n      lowerText.includes('expect')) {\n    return 'assertion';\n  }\n\n  if (lowerText.includes('wait') || lowerText.includes('load') ||\n      lowerText.includes('until') || lowerText.includes('appear')) {\n    return 'wait';\n  }\n\n  return 'unknown';\n}\n\n/**\n * Infer a machine hint from step text\n */\nexport function inferMachineHint(text: string): string | undefined {\n  const lowerText = text.toLowerCase();\n\n  // Extract element name from quotes\n  const quotedMatch = text.match(/['\"]([^'\"]+)['\"]/);\n  const elementName = quotedMatch?.[1];\n\n  if (!elementName) return undefined;\n\n  // Suggest hint based on context (check more specific terms first)\n  if (lowerText.includes('link')) {\n    return `(role=link, name=${elementName})`;\n  }\n\n  if (lowerText.includes('button') || lowerText.includes('click')) {\n    return `(role=button, name=${elementName})`;\n  }\n\n  if (lowerText.includes('field') || lowerText.includes('input') ||\n      lowerText.includes('enter') || lowerText.includes('type')) {\n    return `(role=textbox, name=${elementName})`;\n  }\n\n  if (lowerText.includes('heading')) {\n    return `(role=heading, name=${elementName})`;\n  }\n\n  if (lowerText.includes('checkbox')) {\n    return `(role=checkbox, name=${elementName})`;\n  }\n\n  return `(text=${elementName})`;\n}\n\n/**\n * Get suggestions for navigation steps\n */\nexport function getNavigationSuggestions(text: string): StepSuggestion[] {\n  const suggestions: StepSuggestion[] = [];\n  const urlMatch = text.match(/\\/[a-zA-Z0-9/_-]+/);\n\n  if (urlMatch) {\n    suggestions.push({\n      priority: 1,\n      text: `User navigates to ${urlMatch[0]}`,\n      explanation: 'Standard navigation pattern',\n      confidence: 0.9,\n    });\n  } else {\n    suggestions.push({\n      priority: 1,\n      text: 'User navigates to /[path]',\n      explanation: 'Add explicit URL path',\n      confidence: 0.5,\n    });\n  }\n\n  return suggestions;\n}\n\n/**\n * Get suggestions for interaction steps\n */\nexport function getInteractionSuggestions(text: string): StepSuggestion[] {\n  const suggestions: StepSuggestion[] = [];\n  const quotedMatch = text.match(/['\"]([^'\"]+)['\"]/);\n  const elementName = quotedMatch?.[1] || '[element]';\n  const lowerText = text.toLowerCase();\n\n  if (lowerText.includes('click')) {\n    suggestions.push({\n      priority: 1,\n      text: `User clicks '${elementName}' button \\`(role=button, name=${elementName})\\``,\n      explanation: 'Add role=button locator hint',\n      confidence: 0.85,\n    });\n  }\n\n  if (lowerText.includes('fill') || lowerText.includes('enter') ||\n      lowerText.includes('type')) {\n    // Try to extract value being entered\n    const valueMatch = text.match(/['\"]([^'\"]+)['\"]/);\n    const value = valueMatch?.[1] || 'value';\n    suggestions.push({\n      priority: 1,\n      text: `User enters '${value}' in '${elementName}' field \\`(role=textbox, name=${elementName})\\``,\n      explanation: 'Add role=textbox locator hint',\n      confidence: 0.85,\n    });\n  }\n\n  return suggestions;\n}\n\n/**\n * Get suggestions for assertion steps\n */\nexport function getAssertionSuggestions(text: string): StepSuggestion[] {\n  const suggestions: StepSuggestion[] = [];\n  const quotedMatch = text.match(/['\"]([^'\"]+)['\"]/);\n  const content = quotedMatch?.[1] || '[content]';\n\n  suggestions.push({\n    priority: 1,\n    text: `User should see '${content}' \\`(text=${content})\\``,\n    explanation: 'Standard visibility assertion',\n    confidence: 0.8,\n  });\n\n  suggestions.push({\n    priority: 2,\n    text: `**Assert**: '${content}' is visible \\`(role=heading, name=${content})\\``,\n    explanation: 'Structured assertion format with heading role',\n    confidence: 0.7,\n  });\n\n  return suggestions;\n}\n\n/**\n * Get suggestions for wait steps\n */\nexport function getWaitSuggestions(_text: string): StepSuggestion[] {\n  const suggestions: StepSuggestion[] = [];\n\n  suggestions.push({\n    priority: 1,\n    text: 'Wait for network idle `(signal=networkidle)`',\n    explanation: 'Standard network wait pattern',\n    confidence: 0.8,\n  });\n\n  suggestions.push({\n    priority: 2,\n    text: 'Wait for page to load `(signal=load)`',\n    explanation: 'Wait for load event',\n    confidence: 0.7,\n  });\n\n  return suggestions;\n}\n\n/**\n * Get generic suggestions for unknown step categories\n */\nexport function getGenericSuggestions(text: string): StepSuggestion[] {\n  return [{\n    priority: 1,\n    text: `**Action**: ${text}`,\n    explanation: 'Use structured format with Action prefix',\n    confidence: 0.5,\n  }];\n}\n\n/**\n * Analyze a blocked step and generate suggestions\n */\nexport function analyzeBlockedStep(\n  step: string,\n  reason: string,\n  patterns?: Map<string, PatternDefinition> | StepPattern[]\n): BlockedStepAnalysis {\n  const category = categorizeStep(step);\n\n  const analysis: BlockedStepAnalysis = {\n    step,\n    reason,\n    suggestions: [],\n    category,\n  };\n\n  // Find nearest pattern if patterns provided\n  if (patterns) {\n    const nearest = findNearestPattern(step, patterns);\n    if (nearest) {\n      analysis.nearestPattern = nearest;\n    }\n  }\n\n  // Generate category-specific suggestions\n  switch (category) {\n    case 'navigation':\n      analysis.suggestions = getNavigationSuggestions(step);\n      break;\n    case 'interaction':\n      analysis.suggestions = getInteractionSuggestions(step);\n      analysis.machineHintSuggestion = inferMachineHint(step);\n      break;\n    case 'assertion':\n      analysis.suggestions = getAssertionSuggestions(step);\n      break;\n    case 'wait':\n      analysis.suggestions = getWaitSuggestions(step);\n      break;\n    default:\n      analysis.suggestions = getGenericSuggestions(step);\n  }\n\n  return analysis;\n}\n\n/**\n * Format a blocked step analysis for console output\n */\nexport function formatBlockedStepAnalysis(analysis: BlockedStepAnalysis): string {\n  const lines: string[] = [];\n\n  lines.push(`\\n  Step: \"${analysis.step}\"`);\n  lines.push(`  Category: ${analysis.category}`);\n  lines.push(`  Reason: ${analysis.reason}`);\n\n  if (analysis.nearestPattern) {\n    lines.push(`  Nearest pattern: ${analysis.nearestPattern.name}`);\n    lines.push(`  Example that works: \"${analysis.nearestPattern.exampleMatch}\"`);\n    lines.push(`  Why it didn't match: ${analysis.nearestPattern.mismatchReason}`);\n  }\n\n  lines.push('  Suggestions:');\n  for (const suggestion of analysis.suggestions) {\n    lines.push(`    ${suggestion.priority}. ${suggestion.text}`);\n    lines.push(`       (${suggestion.explanation}, confidence: ${(suggestion.confidence * 100).toFixed(0)}%)`);\n  }\n\n  if (analysis.machineHintSuggestion) {\n    lines.push(`  Suggested hint: ${analysis.machineHintSuggestion}`);\n  }\n\n  return lines.join('\\n');\n}\n","/**\n * Telemetry for blocked steps - Records blocked steps for pattern analysis\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md Phase 3\n */\nimport { existsSync, readFileSync, appendFileSync, mkdirSync, unlinkSync } from 'node:fs';\nimport { join, dirname } from 'node:path';\nimport { getArtkDir } from '../utils/paths.js';\n\n/**\n * Record for a blocked step\n */\nexport interface BlockedStepRecord {\n  /** ISO timestamp when the step was blocked */\n  timestamp: string;\n  /** Journey ID where this step was found */\n  journeyId: string;\n  /** Original step text that was blocked */\n  stepText: string;\n  /** Normalized text (lowercase, trimmed) */\n  normalizedText: string;\n  /** Category of the step */\n  category: 'navigation' | 'interaction' | 'assertion' | 'wait' | 'unknown';\n  /** Reason the step was blocked */\n  reason: string;\n  /** Suggested fix from the system */\n  suggestedFix?: string;\n  /** User's manual fix (if captured) */\n  userFix?: string;\n  /** Nearest pattern that almost matched */\n  nearestPattern?: string;\n  /** Distance to nearest pattern */\n  nearestDistance?: number;\n}\n\n/**\n * Pattern gap identified from telemetry analysis\n */\nexport interface PatternGap {\n  /** Example text that represents this gap */\n  exampleText: string;\n  /** Normalized form of the text */\n  normalizedText: string;\n  /** Number of times this gap was encountered */\n  count: number;\n  /** Category of the gap */\n  category: string;\n  /** All unique step texts that fall into this gap */\n  variants: string[];\n  /** Suggested regex pattern to add */\n  suggestedPattern?: string;\n  /** First occurrence timestamp */\n  firstSeen: string;\n  /** Last occurrence timestamp */\n  lastSeen: string;\n}\n\n/**\n * Telemetry statistics\n */\nexport interface TelemetryStats {\n  /** Total number of blocked steps recorded */\n  totalRecords: number;\n  /** Unique patterns identified */\n  uniquePatterns: number;\n  /** Records by category */\n  byCategory: Record<string, number>;\n  /** Date range of records */\n  dateRange: {\n    earliest: string;\n    latest: string;\n  };\n}\n\n/**\n * Telemetry file name\n */\nconst TELEMETRY_FILE = 'blocked-steps-telemetry.jsonl';\n\n/**\n * Get the telemetry file path.\n *\n * Automatically infers the correct .artk directory location by:\n * 1. Using explicit baseDir if provided\n * 2. Finding artk-e2e/.artk from project root\n * 3. Finding .artk in current directory if inside harness\n *\n * @param baseDir - Optional explicit base directory override\n * @returns Path to the telemetry file\n */\nexport function getTelemetryPath(baseDir?: string): string {\n  const artkDir = getArtkDir(baseDir);\n  return join(artkDir, TELEMETRY_FILE);\n}\n\n/**\n * Ensure the telemetry directory exists\n */\nfunction ensureTelemetryDir(telemetryPath: string): void {\n  const dir = dirname(telemetryPath);\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n}\n\n/**\n * Normalize step text for telemetry comparison\n * (Simpler normalization than glossary - for deduplication purposes)\n */\nexport function normalizeStepTextForTelemetry(text: string): string {\n  return text\n    .toLowerCase()\n    .trim()\n    // Remove common articles\n    .replace(/\\b(the|a|an)\\b/g, '')\n    // Remove extra whitespace\n    .replace(/\\s+/g, ' ')\n    // Remove quoted values but keep structure\n    .replace(/\"[^\"]*\"/g, '\"\"')\n    .replace(/'[^']*'/g, \"''\")\n    .trim();\n}\n\n/**\n * Categorize a step based on its text\n */\nexport function categorizeStepText(text: string): BlockedStepRecord['category'] {\n  const lower = text.toLowerCase();\n\n  if (\n    lower.includes('navigate') ||\n    lower.includes('go to') ||\n    lower.includes('open') ||\n    lower.includes('visit')\n  ) {\n    return 'navigation';\n  }\n\n  if (\n    lower.includes('click') ||\n    lower.includes('fill') ||\n    lower.includes('enter') ||\n    lower.includes('type') ||\n    lower.includes('select') ||\n    lower.includes('check') ||\n    lower.includes('press') ||\n    lower.includes('submit') ||\n    lower.includes('input')\n  ) {\n    return 'interaction';\n  }\n\n  if (\n    lower.includes('see') ||\n    lower.includes('visible') ||\n    lower.includes('verify') ||\n    lower.includes('assert') ||\n    lower.includes('confirm') ||\n    lower.includes('should') ||\n    lower.includes('ensure') ||\n    lower.includes('expect') ||\n    lower.includes('display')\n  ) {\n    return 'assertion';\n  }\n\n  if (lower.includes('wait') || lower.includes('load') || lower.includes('until')) {\n    return 'wait';\n  }\n\n  return 'unknown';\n}\n\n/**\n * Record a blocked step to the telemetry file\n */\nexport function recordBlockedStep(\n  record: Omit<BlockedStepRecord, 'timestamp' | 'normalizedText' | 'category'> & {\n    category?: BlockedStepRecord['category'];\n  },\n  options: { baseDir?: string } = {}\n): void {\n  const telemetryPath = getTelemetryPath(options.baseDir);\n  ensureTelemetryDir(telemetryPath);\n\n  const fullRecord: BlockedStepRecord = {\n    ...record,\n    timestamp: new Date().toISOString(),\n    normalizedText: normalizeStepTextForTelemetry(record.stepText),\n    category: record.category || categorizeStepText(record.stepText),\n  };\n\n  appendFileSync(telemetryPath, JSON.stringify(fullRecord) + '\\n');\n}\n\n/**\n * Read all blocked step records from the telemetry file\n */\nexport function readBlockedStepRecords(options: { baseDir?: string } = {}): BlockedStepRecord[] {\n  const telemetryPath = getTelemetryPath(options.baseDir);\n\n  if (!existsSync(telemetryPath)) {\n    return [];\n  }\n\n  try {\n    const content = readFileSync(telemetryPath, 'utf-8');\n    return content\n      .split('\\n')\n      .filter(Boolean)\n      .map((line) => {\n        try {\n          return JSON.parse(line) as BlockedStepRecord;\n        } catch {\n          return null;\n        }\n      })\n      .filter((record): record is BlockedStepRecord => record !== null);\n  } catch {\n    return [];\n  }\n}\n\n/**\n * Calculate similarity between two normalized texts\n * Uses simple token-based Jaccard similarity\n */\nfunction calculateTokenSimilarity(a: string, b: string): number {\n  const tokensA = new Set(a.split(' ').filter(Boolean));\n  const tokensB = new Set(b.split(' ').filter(Boolean));\n\n  if (tokensA.size === 0 && tokensB.size === 0) return 1;\n  if (tokensA.size === 0 || tokensB.size === 0) return 0;\n\n  const intersection = new Set([...tokensA].filter((x) => tokensB.has(x)));\n  const union = new Set([...tokensA, ...tokensB]);\n\n  return intersection.size / union.size;\n}\n\n/**\n * Group blocked step records by similarity\n */\nfunction groupBySimilarity(\n  records: BlockedStepRecord[],\n  threshold: number = 0.7\n): Map<string, BlockedStepRecord[]> {\n  const groups = new Map<string, BlockedStepRecord[]>();\n  const processed = new Set<number>();\n\n  for (let i = 0; i < records.length; i++) {\n    if (processed.has(i)) continue;\n\n    const record = records[i]!;\n    const normalized = record.normalizedText;\n    const group: BlockedStepRecord[] = [record];\n    processed.add(i);\n\n    // Find similar records\n    for (let j = i + 1; j < records.length; j++) {\n      if (processed.has(j)) continue;\n\n      const other = records[j]!;\n      const similarity = calculateTokenSimilarity(normalized, other.normalizedText);\n\n      if (similarity >= threshold) {\n        group.push(other);\n        processed.add(j);\n      }\n    }\n\n    groups.set(normalized, group);\n  }\n\n  return groups;\n}\n\n/**\n * Analyze blocked steps to find top pattern gaps\n */\nexport function analyzeBlockedPatterns(options: { baseDir?: string; limit?: number } = {}): PatternGap[] {\n  const records = readBlockedStepRecords(options);\n\n  if (records.length === 0) {\n    return [];\n  }\n\n  const groups = groupBySimilarity(records);\n  const gaps: PatternGap[] = [];\n\n  for (const [normalizedText, groupRecords] of groups) {\n    const timestamps = groupRecords.map((r) => r.timestamp).sort();\n    const variants = [...new Set(groupRecords.map((r) => r.stepText))];\n\n    gaps.push({\n      exampleText: groupRecords[0]!.stepText,\n      normalizedText,\n      count: groupRecords.length,\n      category: groupRecords[0]!.category,\n      variants,\n      suggestedPattern: generateSuggestedPattern(variants),\n      firstSeen: timestamps[0]!,\n      lastSeen: timestamps[timestamps.length - 1]!,\n    });\n  }\n\n  // Sort by count (most frequent first)\n  gaps.sort((a, b) => b.count - a.count);\n\n  return options.limit ? gaps.slice(0, options.limit) : gaps;\n}\n\n/**\n * Generate a suggested regex pattern from examples\n */\nfunction generateSuggestedPattern(variants: string[]): string | undefined {\n  if (variants.length === 0) return undefined;\n\n  // Find common prefix and suffix\n  const example = variants[0]!.toLowerCase();\n\n  // Extract quoted values and replace with placeholders\n  const pattern = example\n    .replace(/\"[^\"]+\"/g, '\"([^\"]+)\"')\n    .replace(/'[^']+'/g, \"'([^']+)'\")\n    // Escape special regex chars (except those we use)\n    .replace(/[.*+?^${}()|[\\]\\\\]/g, (char) => {\n      if (char === '(' || char === ')' || char === '[' || char === ']' || char === '+') {\n        return char;\n      }\n      return '\\\\' + char;\n    });\n\n  return `^(?:user\\\\s+)?${pattern}$`;\n}\n\n/**\n * Get telemetry statistics\n */\nexport function getTelemetryStats(options: { baseDir?: string } = {}): TelemetryStats {\n  const records = readBlockedStepRecords(options);\n\n  if (records.length === 0) {\n    return {\n      totalRecords: 0,\n      uniquePatterns: 0,\n      byCategory: {},\n      dateRange: {\n        earliest: '',\n        latest: '',\n      },\n    };\n  }\n\n  const byCategory: Record<string, number> = {};\n  const normalizedSet = new Set<string>();\n  const timestamps = records.map((r) => r.timestamp).sort();\n\n  for (const record of records) {\n    byCategory[record.category] = (byCategory[record.category] || 0) + 1;\n    normalizedSet.add(record.normalizedText);\n  }\n\n  return {\n    totalRecords: records.length,\n    uniquePatterns: normalizedSet.size,\n    byCategory,\n    dateRange: {\n      earliest: timestamps[0]!,\n      latest: timestamps[timestamps.length - 1]!,\n    },\n  };\n}\n\n/**\n * Record a user fix for a previously blocked step\n */\nexport function recordUserFix(\n  originalStepText: string,\n  userFixedText: string,\n  options: { baseDir?: string } = {}\n): void {\n  const records = readBlockedStepRecords(options);\n  const normalizedOriginal = normalizeStepTextForTelemetry(originalStepText);\n\n  // Find matching record and update it (append new record with fix)\n  const matchingRecord = records.find((r) => r.normalizedText === normalizedOriginal && !r.userFix);\n\n  if (matchingRecord) {\n    // Record the user fix - timestamp and normalizedText will be set by recordBlockedStep\n    // eslint-disable-next-line no-unused-vars\n    const { timestamp: _t, normalizedText: _n, ...recordWithoutTimestamp } = matchingRecord;\n    recordBlockedStep(\n      {\n        ...recordWithoutTimestamp,\n        userFix: userFixedText,\n      },\n      options\n    );\n  }\n}\n\n/**\n * Clear telemetry data (for testing or reset)\n */\nexport function clearTelemetry(options: { baseDir?: string } = {}): void {\n  const telemetryPath = getTelemetryPath(options.baseDir);\n  if (existsSync(telemetryPath)) {\n    unlinkSync(telemetryPath);\n  }\n}\n","/**\n * Unified Pattern Matcher - Single entry point for all pattern matching\n * Combines core patterns (patterns.ts) with LLKB learned patterns and fuzzy matching\n *\n * Coverage Flow: Normalization  Core Patterns  LLKB  Fuzzy  LLM  TODO\n *\n * This eliminates duplicate pattern logic in plan.ts and ensures consistent\n * pattern matching behavior across the entire system.\n *\n * @see research/2026-02-03_unified-pattern-matching-plan.md Phase 2\n * @see research/2026-02-03_multi-ai-debate-coverage-improvement.md\n */\nimport { allPatterns, type StepPattern } from './patterns.js';\nimport { matchLlkbPattern, loadLearnedPatterns } from '../llkb/patternExtension.js';\nimport { fuzzyMatch } from './fuzzyMatcher.js';\nimport type { IRPrimitive } from '../ir/types.js';\n\n/**\n * Options for unified pattern matching\n */\nexport interface UnifiedMatchOptions {\n  /** Use LLKB learned patterns as fallback (default: true) */\n  useLlkb?: boolean;\n  /** LLKB root directory (auto-detected if not provided) */\n  llkbRoot?: string;\n  /** Minimum confidence for LLKB patterns (default: 0.7) */\n  minLlkbConfidence?: number;\n  /** Use fuzzy matching as final fallback before TODO (default: true) */\n  useFuzzy?: boolean;\n  /** Minimum similarity for fuzzy matching (default: 0.85) */\n  minFuzzySimilarity?: number;\n  /** Enable debug logging (default: false) */\n  debug?: boolean;\n}\n\n/**\n * Result of unified pattern matching\n */\nexport interface UnifiedMatchResult {\n  /** The matched IR primitive, or null if no match */\n  primitive: IRPrimitive | null;\n  /** Source of the match */\n  source: 'core' | 'llkb' | 'fuzzy' | 'none';\n  /** Pattern name that matched (if core or fuzzy) */\n  patternName?: string;\n  /** LLKB pattern ID (if LLKB) */\n  llkbPatternId?: string;\n  /** LLKB confidence (if LLKB) */\n  llkbConfidence?: number;\n  /** Fuzzy match similarity score (if fuzzy) */\n  fuzzySimilarity?: number;\n  /** Fuzzy matched example (if fuzzy) */\n  fuzzyMatchedExample?: string;\n}\n\n/**\n * Match step text against unified pattern system\n *\n * Priority order (Coverage Flow):\n * 1. Core patterns from patterns.ts (84+ patterns)\n * 2. LLKB learned patterns (dynamic, confidence-filtered)\n * 3. Fuzzy matching (high similarity threshold, 0.85+)\n * 4. No match  TODO (or LLM fallback in future)\n *\n * @param text - Step text to match\n * @param options - Matching options\n * @returns Match result with primitive and source\n */\nexport function unifiedMatch(\n  text: string,\n  options: UnifiedMatchOptions = {}\n): UnifiedMatchResult {\n  const {\n    useLlkb = true,\n    llkbRoot,\n    minLlkbConfidence = 0.7,\n    useFuzzy = true,\n    minFuzzySimilarity = 0.85,\n    debug = false,\n  } = options;\n\n  const trimmedText = text.trim();\n\n  // 1. Try core patterns first (highest priority)\n  for (const pattern of allPatterns) {\n    const match = trimmedText.match(pattern.regex);\n    if (match) {\n      const primitive = pattern.extract(match);\n      if (primitive) {\n        if (debug) {\n          console.log(`[UnifiedMatcher] Core match: ${pattern.name} for \"${trimmedText}\"`);\n        }\n        return {\n          primitive,\n          source: 'core',\n          patternName: pattern.name,\n        };\n      }\n    }\n  }\n\n  // 2. Try LLKB patterns as fallback\n  if (useLlkb) {\n    try {\n      const llkbMatch = matchLlkbPattern(trimmedText, {\n        llkbRoot,\n        minConfidence: minLlkbConfidence,\n      });\n\n      if (llkbMatch) {\n        if (debug) {\n          console.log(\n            `[UnifiedMatcher] LLKB match: ${llkbMatch.patternId} (confidence: ${llkbMatch.confidence}) for \"${trimmedText}\"`\n          );\n        }\n        return {\n          primitive: llkbMatch.primitive,\n          source: 'llkb',\n          llkbPatternId: llkbMatch.patternId,\n          llkbConfidence: llkbMatch.confidence,\n        };\n      }\n    } catch (err) {\n      // LLKB might not be initialized - continue without it\n      if (debug) {\n        console.log(`[UnifiedMatcher] LLKB lookup failed: ${err}`);\n      }\n    }\n  }\n\n  // 3. Try fuzzy matching as final fallback before TODO\n  if (useFuzzy) {\n    try {\n      const fuzzyResult = fuzzyMatch(trimmedText, {\n        minSimilarity: minFuzzySimilarity,\n        useNormalization: true,\n        debug,\n      });\n\n      if (fuzzyResult) {\n        if (debug) {\n          console.log(\n            `[UnifiedMatcher] Fuzzy match: ${fuzzyResult.patternName} (similarity: ${(fuzzyResult.similarity * 100).toFixed(1)}%) for \"${trimmedText}\"`\n          );\n        }\n        return {\n          primitive: fuzzyResult.primitive,\n          source: 'fuzzy',\n          patternName: fuzzyResult.patternName,\n          fuzzySimilarity: fuzzyResult.similarity,\n          fuzzyMatchedExample: fuzzyResult.matchedExample,\n        };\n      }\n    } catch (err) {\n      // Fuzzy matching failed - continue without it\n      if (debug) {\n        console.log(`[UnifiedMatcher] Fuzzy matching failed: ${err}`);\n      }\n    }\n  }\n\n  // 4. No match found  TODO (or LLM fallback in future)\n  if (debug) {\n    console.log(`[UnifiedMatcher] No match for: \"${trimmedText}\"`);\n  }\n\n  return {\n    primitive: null,\n    source: 'none',\n  };\n}\n\n/**\n * Match step text and return all potential matches (for debugging)\n */\nexport function unifiedMatchAll(\n  text: string,\n  options: UnifiedMatchOptions = {}\n): Array<{ source: 'core' | 'llkb' | 'fuzzy'; name: string; primitive: IRPrimitive; confidence?: number; similarity?: number }> {\n  const trimmedText = text.trim();\n  const matches: Array<{ source: 'core' | 'llkb' | 'fuzzy'; name: string; primitive: IRPrimitive; confidence?: number; similarity?: number }> = [];\n\n  // Core patterns\n  for (const pattern of allPatterns) {\n    const match = trimmedText.match(pattern.regex);\n    if (match) {\n      const primitive = pattern.extract(match);\n      if (primitive) {\n        matches.push({\n          source: 'core',\n          name: pattern.name,\n          primitive,\n        });\n      }\n    }\n  }\n\n  // LLKB patterns\n  if (options.useLlkb !== false) {\n    try {\n      const llkbMatch = matchLlkbPattern(trimmedText, {\n        llkbRoot: options.llkbRoot,\n        minConfidence: 0, // Get all LLKB matches for debugging\n      });\n\n      if (llkbMatch) {\n        matches.push({\n          source: 'llkb',\n          name: llkbMatch.patternId,\n          primitive: llkbMatch.primitive,\n          confidence: llkbMatch.confidence,\n        });\n      }\n    } catch {\n      // Ignore LLKB errors in debug mode\n    }\n  }\n\n  // Fuzzy matches\n  if (options.useFuzzy !== false) {\n    try {\n      const fuzzyResult = fuzzyMatch(trimmedText, {\n        minSimilarity: 0.5, // Lower threshold for debugging (show more candidates)\n        useNormalization: true,\n      });\n\n      if (fuzzyResult) {\n        matches.push({\n          source: 'fuzzy',\n          name: fuzzyResult.patternName,\n          primitive: fuzzyResult.primitive,\n          similarity: fuzzyResult.similarity,\n        });\n      }\n    } catch {\n      // Ignore fuzzy errors in debug mode\n    }\n  }\n\n  return matches;\n}\n\n/**\n * Get statistics about the unified matcher\n */\nexport function getUnifiedMatcherStats(options?: { llkbRoot?: string }): {\n  corePatternCount: number;\n  llkbPatternCount: number;\n  totalPatterns: number;\n  coreCategories: Record<string, number>;\n} {\n  let llkbPatternCount = 0;\n\n  try {\n    const llkbPatterns = loadLearnedPatterns({ llkbRoot: options?.llkbRoot });\n    llkbPatternCount = llkbPatterns.length;\n  } catch {\n    // LLKB might not be available\n  }\n\n  // Count core patterns by category\n  const coreCategories: Record<string, number> = {};\n  for (const pattern of allPatterns) {\n    const category = pattern.name.split('-')[0] || 'other';\n    coreCategories[category] = (coreCategories[category] || 0) + 1;\n  }\n\n  return {\n    corePatternCount: allPatterns.length,\n    llkbPatternCount,\n    totalPatterns: allPatterns.length + llkbPatternCount,\n    coreCategories,\n  };\n}\n\n/**\n * Warm up the pattern cache for better performance\n * Call this before batch processing\n */\nexport async function warmUpUnifiedMatcher(options?: { llkbRoot?: string }): Promise<void> {\n  // Load LLKB patterns into cache\n  try {\n    loadLearnedPatterns({ llkbRoot: options?.llkbRoot, bypassCache: true });\n  } catch {\n    // LLKB might not be available\n  }\n}\n\n/**\n * Check if text matches any pattern (without extracting)\n * Useful for quick filtering\n */\nexport function hasPatternMatch(text: string, options: UnifiedMatchOptions = {}): boolean {\n  const result = unifiedMatch(text, options);\n  return result.primitive !== null;\n}\n\n/**\n * Get pattern name for matched text (for telemetry/logging)\n */\nexport function getMatchedPatternName(text: string, options: UnifiedMatchOptions = {}): string | null {\n  const result = unifiedMatch(text, options);\n\n  if (result.source === 'core' && result.patternName) {\n    return result.patternName;\n  }\n\n  if (result.source === 'llkb' && result.llkbPatternId) {\n    return `llkb:${result.llkbPatternId}`;\n  }\n\n  return null;\n}\n\n/**\n * Export for testing - get all core patterns\n */\nexport function getCorePatterns(): StepPattern[] {\n  return [...allPatterns];\n}\n","/**\n * Fuzzy Matcher - Tier 4 in the coverage improvement architecture\n * Uses Levenshtein distance with high confidence threshold\n *\n * Coverage Flow: Normalization  Core Patterns  LLKB  Fuzzy  LLM  TODO\n *\n * @see research/2026-02-03_multi-ai-debate-coverage-improvement.md\n */\nimport { calculateSimilarity } from './patternDistance.js';\nimport { getCanonicalForm } from './normalize.js';\nimport { allPatterns, type StepPattern } from './patterns.js';\nimport type { IRPrimitive } from '../ir/types.js';\n\n/**\n * Fuzzy match configuration\n */\nexport interface FuzzyMatchConfig {\n  /** Minimum similarity threshold (0-1, default: 0.85) */\n  minSimilarity?: number;\n  /** Use normalized text for comparison (default: true) */\n  useNormalization?: boolean;\n  /** Maximum candidates to consider (default: 10) */\n  maxCandidates?: number;\n  /** Enable debug logging (default: false) */\n  debug?: boolean;\n}\n\n/**\n * Fuzzy match result\n */\nexport interface FuzzyMatchResult {\n  /** The matched primitive */\n  primitive: IRPrimitive;\n  /** The pattern that matched */\n  patternName: string;\n  /** Similarity score (0-1) */\n  similarity: number;\n  /** The example that was matched */\n  matchedExample: string;\n  /** Original input text */\n  originalText: string;\n  /** Normalized input text */\n  normalizedText: string;\n}\n\n/**\n * Pattern with examples for fuzzy matching\n */\ninterface PatternWithExamples {\n  pattern: StepPattern;\n  examples: string[];\n}\n\n/**\n * Generate canonical examples for each pattern type\n */\nfunction getPatternExamples(pattern: StepPattern): string[] {\n  const examples: string[] = [];\n  const name = pattern.name.toLowerCase();\n\n  // Navigation patterns\n  if (name.includes('navigate') || name.includes('goto')) {\n    examples.push(\n      'navigate to /home',\n      'go to /login',\n      'open /dashboard',\n      'visit the homepage',\n      'navigate to the settings page'\n    );\n  }\n\n  // Click patterns\n  if (name.includes('click')) {\n    examples.push(\n      'click the submit button',\n      'click on save',\n      'click cancel button',\n      'press the login button',\n      'tap the menu icon'\n    );\n  }\n\n  // Fill/Enter patterns\n  if (name.includes('fill') || name.includes('enter') || name.includes('type')) {\n    examples.push(\n      'enter username in the username field',\n      'fill password in password field',\n      'type hello in the search box',\n      'input test@example.com in email field',\n      'enter value into the input'\n    );\n  }\n\n  // See/Verify patterns\n  if (name.includes('see') || name.includes('visible') || name.includes('verify')) {\n    examples.push(\n      'see the welcome message',\n      'verify the success message is displayed',\n      'confirm the error appears',\n      'should see login button',\n      'expect the form to be visible'\n    );\n  }\n\n  // Wait patterns\n  if (name.includes('wait')) {\n    examples.push(\n      'wait for network idle',\n      'wait for page to load',\n      'wait 3 seconds',\n      'wait for the spinner to disappear',\n      'wait until the modal closes'\n    );\n  }\n\n  // Select patterns\n  if (name.includes('select')) {\n    examples.push(\n      'select option 1 from dropdown',\n      'choose value from the list',\n      'pick an item from menu',\n      'select country from country dropdown'\n    );\n  }\n\n  // Check/Uncheck patterns\n  if (name.includes('check')) {\n    examples.push(\n      'check the checkbox',\n      'tick the agreement box',\n      'check remember me',\n      'uncheck the newsletter option'\n    );\n  }\n\n  // Upload patterns\n  if (name.includes('upload')) {\n    examples.push(\n      'upload file.pdf',\n      'attach document.docx',\n      'upload image to the form'\n    );\n  }\n\n  // Hover patterns\n  if (name.includes('hover')) {\n    examples.push(\n      'hover over the menu',\n      'mouse over the dropdown',\n      'hover on the button'\n    );\n  }\n\n  // Scroll patterns\n  if (name.includes('scroll')) {\n    examples.push(\n      'scroll down',\n      'scroll to the bottom',\n      'scroll to element'\n    );\n  }\n\n  // Press patterns (keyboard)\n  if (name.includes('press')) {\n    examples.push(\n      'press enter',\n      'press tab',\n      'press escape key',\n      'hit the enter key'\n    );\n  }\n\n  // Table patterns\n  if (name.includes('table') || name.includes('grid')) {\n    examples.push(\n      'see 5 rows in the table',\n      'verify table has data',\n      'check grid contains value'\n    );\n  }\n\n  // Text assertion patterns\n  if (name.includes('text') || name.includes('contain')) {\n    examples.push(\n      'see text welcome back',\n      'page contains login form',\n      'element has text submit'\n    );\n  }\n\n  return examples;\n}\n\n/**\n * Build pattern examples cache\n */\nfunction buildPatternExamplesCache(): PatternWithExamples[] {\n  return allPatterns.map(pattern => ({\n    pattern,\n    examples: getPatternExamples(pattern),\n  }));\n}\n\n// Cached pattern examples\nlet patternExamplesCache: PatternWithExamples[] | null = null;\n\n/**\n * Get or build pattern examples cache\n */\nfunction getPatternExamples_cached(): PatternWithExamples[] {\n  if (!patternExamplesCache) {\n    patternExamplesCache = buildPatternExamplesCache();\n  }\n  return patternExamplesCache;\n}\n\n/**\n * Find best fuzzy match for step text\n *\n * @param text - Step text to match\n * @param config - Fuzzy match configuration\n * @returns Best match if similarity >= threshold, null otherwise\n */\nexport function fuzzyMatch(\n  text: string,\n  config: FuzzyMatchConfig = {}\n): FuzzyMatchResult | null {\n  const {\n    minSimilarity = 0.85,\n    useNormalization = true,\n    maxCandidates = 10,\n    debug = false,\n  } = config;\n\n  const trimmedText = text.trim();\n  const normalizedText = useNormalization\n    ? getCanonicalForm(trimmedText)\n    : trimmedText.toLowerCase();\n\n  // Get pattern examples\n  const patternsWithExamples = getPatternExamples_cached();\n\n  // Score all candidates\n  const candidates: Array<{\n    pattern: StepPattern;\n    example: string;\n    similarity: number;\n  }> = [];\n\n  // Track best match for early termination\n  let bestSimilarity = 0;\n\n  outer: for (const { pattern, examples } of patternsWithExamples) {\n    for (const example of examples) {\n      const normalizedExample = useNormalization\n        ? getCanonicalForm(example)\n        : example.toLowerCase();\n\n      const similarity = calculateSimilarity(normalizedText, normalizedExample);\n\n      if (similarity >= minSimilarity) {\n        candidates.push({ pattern, example, similarity });\n\n        // Track best similarity for early termination\n        if (similarity > bestSimilarity) {\n          bestSimilarity = similarity;\n        }\n\n        // Early termination: if we find a perfect or near-perfect match, stop searching\n        if (similarity >= 0.98) {\n          break outer;\n        }\n      }\n    }\n  }\n\n  // Sort by similarity (descending)\n  candidates.sort((a, b) => b.similarity - a.similarity);\n\n  // Take top candidates\n  const topCandidates = candidates.slice(0, maxCandidates);\n\n  if (debug && topCandidates.length > 0) {\n    console.log(\n      `[FuzzyMatcher] Top ${topCandidates.length} candidates for \"${trimmedText}\":`\n    );\n    for (const c of topCandidates) {\n      console.log(`  ${c.pattern.name}: ${(c.similarity * 100).toFixed(1)}% (vs \"${c.example}\")`);\n    }\n  }\n\n  // Return best match if above threshold\n  if (topCandidates.length > 0) {\n    const best = topCandidates[0]!;\n\n    // Try to extract primitive using the pattern\n    const match = trimmedText.match(best.pattern.regex);\n    if (match) {\n      const primitive = best.pattern.extract(match);\n      if (primitive) {\n        return {\n          primitive,\n          patternName: best.pattern.name,\n          similarity: best.similarity,\n          matchedExample: best.example,\n          originalText: trimmedText,\n          normalizedText,\n        };\n      }\n    }\n\n    // Pattern didn't extract - try to create a generic primitive\n    // based on the pattern type (only for very high confidence)\n    if (best.similarity >= 0.90) {\n      const genericPrimitive = createGenericPrimitive(best.pattern, trimmedText);\n      if (genericPrimitive) {\n        if (debug) {\n          console.log(\n            `[FuzzyMatcher] Created generic primitive for ${best.pattern.name}`\n          );\n        }\n        return {\n          primitive: genericPrimitive,\n          patternName: `${best.pattern.name}:fuzzy`,\n          similarity: best.similarity,\n          matchedExample: best.example,\n          originalText: trimmedText,\n          normalizedText,\n        };\n      }\n    }\n  }\n\n  if (debug) {\n    console.log(`[FuzzyMatcher] No match above ${minSimilarity * 100}% for \"${trimmedText}\"`);\n  }\n\n  return null;\n}\n\n/**\n * Create a generic primitive when pattern extraction fails but similarity is very high\n * Returns properly typed IR primitives that match the schema\n */\nfunction createGenericPrimitive(pattern: StepPattern, text: string): IRPrimitive | null {\n  const type = pattern.primitiveType;\n\n  // Extract quoted strings from text\n  const quotedStrings = text.match(/[\"']([^\"']+)[\"']/g)?.map(s => s.slice(1, -1)) || [];\n  const targetStr = quotedStrings[0] || extractTarget(text) || 'element';\n  const valueStr = quotedStrings[1] || quotedStrings[0] || '';\n\n  // Helper to create a locator from extracted text\n  const makeLocator = (value: string) => ({\n    strategy: 'text' as const,\n    value: value,\n  });\n\n  switch (type) {\n    case 'click':\n    case 'dblclick':\n    case 'rightClick':\n      return { type, locator: makeLocator(targetStr) };\n\n    case 'fill':\n      return {\n        type: 'fill',\n        locator: makeLocator(targetStr),\n        value: { type: 'literal', value: valueStr },\n      };\n\n    case 'goto': {\n      // Extract URL or path\n      const urlMatch = text.match(/(?:to|\\/)\\s*([\\/\\w.-]+)/i);\n      return {\n        type: 'goto',\n        url: urlMatch?.[1] || '/',\n      };\n    }\n\n    case 'waitForTimeout': {\n      // Check for time-based wait\n      const timeMatch = text.match(/(\\d+)\\s*(?:second|sec|ms|millisecond)/i);\n      if (timeMatch) {\n        const amount = parseInt(timeMatch[1]!, 10);\n        const unit = text.toLowerCase().includes('ms') ? 'ms' : 's';\n        return {\n          type: 'waitForTimeout',\n          ms: unit === 'ms' ? amount : amount * 1000,\n        };\n      }\n      return { type: 'waitForTimeout', ms: 1000 };\n    }\n\n    case 'waitForNetworkIdle':\n      return { type: 'waitForNetworkIdle' };\n\n    case 'waitForVisible':\n      return { type: 'waitForVisible', locator: makeLocator(targetStr) };\n\n    case 'waitForHidden':\n      return { type: 'waitForHidden', locator: makeLocator(targetStr) };\n\n    case 'expectVisible':\n    case 'expectNotVisible':\n    case 'expectHidden':\n      return { type, locator: makeLocator(targetStr) };\n\n    case 'expectText':\n      return {\n        type: 'expectText',\n        locator: makeLocator(targetStr),\n        text: valueStr,\n      };\n\n    case 'select':\n      return {\n        type: 'select',\n        locator: makeLocator(targetStr),\n        option: valueStr,\n      };\n\n    case 'hover':\n    case 'focus':\n    case 'clear':\n    case 'check':\n    case 'uncheck':\n      return { type, locator: makeLocator(targetStr) };\n\n    case 'press': {\n      // Extract key name\n      const keyMatch = text.match(/(?:press|hit|key)\\s+(\\w+)/i);\n      return {\n        type: 'press',\n        key: keyMatch?.[1] || 'Enter',\n      };\n    }\n\n    default:\n      // Type doesn't have a direct mapping - return null\n      return null;\n  }\n}\n\n/**\n * Extract potential target from step text\n */\nfunction extractTarget(text: string): string | null {\n  // Try to extract target from common patterns\n  const patterns = [\n    /(?:the|a)\\s+[\"']?(\\w+(?:\\s+\\w+)?)[\"']?\\s+(?:button|field|input|link|element)/i,\n    /(?:on|click|tap|press)\\s+(?:the\\s+)?[\"']?(\\w+(?:\\s+\\w+)?)[\"']?/i,\n    /(?:in|into)\\s+(?:the\\s+)?[\"']?(\\w+(?:\\s+\\w+)?)[\"']?\\s+(?:field|input)/i,\n  ];\n\n  for (const pattern of patterns) {\n    const match = text.match(pattern);\n    if (match?.[1]) {\n      return match[1];\n    }\n  }\n\n  return null;\n}\n\n/**\n * Get fuzzy match statistics\n */\nexport function getFuzzyMatchStats(): {\n  patternsWithExamples: number;\n  totalExamples: number;\n  examplesByType: Record<string, number>;\n} {\n  const patternsWithExamples = getPatternExamples_cached();\n\n  const examplesByType: Record<string, number> = {};\n  let totalExamples = 0;\n\n  for (const { pattern, examples } of patternsWithExamples) {\n    const type = pattern.primitiveType;\n    examplesByType[type] = (examplesByType[type] || 0) + examples.length;\n    totalExamples += examples.length;\n  }\n\n  return {\n    patternsWithExamples: patternsWithExamples.length,\n    totalExamples,\n    examplesByType,\n  };\n}\n\n/**\n * Clear the pattern examples cache (for testing)\n */\nexport function clearFuzzyMatchCache(): void {\n  patternExamplesCache = null;\n}\n","/**\n * Enhanced Normalization Pipeline for Step Text\n * Implements Tier 1 of the coverage improvement strategy:\n * - Stemming (verb form normalization)\n * - Glossary expansion\n * - Canonical form transformation\n * - Whitespace and punctuation normalization\n *\n * @see research/2026-02-03_multi-ai-debate-coverage-improvement.md\n */\n\n/**\n * Common verb stems for normalization\n * Maps various verb forms to their base form\n */\nconst VERB_STEMS: Record<string, string> = {\n  // Click variants\n  clicking: 'click',\n  clicked: 'click',\n  clicks: 'click',\n\n  // Fill variants\n  filling: 'fill',\n  filled: 'fill',\n  fills: 'fill',\n  entering: 'fill',\n  entered: 'fill',\n  enters: 'fill',\n  typing: 'fill',\n  typed: 'fill',\n  types: 'fill',\n\n  // Select variants\n  selecting: 'select',\n  selected: 'select',\n  selects: 'select',\n  choosing: 'select',\n  chose: 'select',\n  chosen: 'select',\n  chooses: 'select',\n\n  // Check variants\n  checking: 'check',\n  checked: 'check',\n  checks: 'check',\n\n  // Uncheck variants\n  unchecking: 'uncheck',\n  unchecked: 'uncheck',\n  unchecks: 'uncheck',\n\n  // Navigate variants\n  navigating: 'navigate',\n  navigated: 'navigate',\n  navigates: 'navigate',\n  going: 'navigate',\n  went: 'navigate',\n  goes: 'navigate',\n  visiting: 'navigate',\n  visited: 'navigate',\n  visits: 'navigate',\n  opening: 'navigate',\n  opened: 'navigate',\n  opens: 'navigate',\n\n  // See/Verify variants\n  seeing: 'see',\n  saw: 'see',\n  seen: 'see',\n  sees: 'see',\n  verifying: 'verify',\n  verified: 'verify',\n  verifies: 'verify',\n  confirming: 'verify',\n  confirmed: 'verify',\n  confirms: 'verify',\n  ensuring: 'verify',\n  ensured: 'verify',\n  ensures: 'verify',\n\n  // Wait variants\n  waiting: 'wait',\n  waited: 'wait',\n  waits: 'wait',\n\n  // Submit variants\n  submitting: 'submit',\n  submitted: 'submit',\n  submits: 'submit',\n\n  // Press variants\n  pressing: 'press',\n  pressed: 'press',\n  presses: 'press',\n\n  // Hover variants\n  hovering: 'hover',\n  hovered: 'hover',\n  hovers: 'hover',\n\n  // Scroll variants\n  scrolling: 'scroll',\n  scrolled: 'scroll',\n  scrolls: 'scroll',\n\n  // Focus variants\n  focusing: 'focus',\n  focused: 'focus',\n  focuses: 'focus',\n\n  // Drag variants\n  dragging: 'drag',\n  dragged: 'drag',\n  drags: 'drag',\n\n  // Drop variants\n  dropping: 'drop',\n  dropped: 'drop',\n  drops: 'drop',\n\n  // Clear variants\n  clearing: 'clear',\n  cleared: 'clear',\n  clears: 'clear',\n\n  // Upload variants\n  uploading: 'upload',\n  uploaded: 'upload',\n  uploads: 'upload',\n\n  // Download variants\n  downloading: 'download',\n  downloaded: 'download',\n  downloads: 'download',\n\n  // Assert/Expect variants\n  asserting: 'assert',\n  asserted: 'assert',\n  asserts: 'assert',\n  expecting: 'expect',\n  expected: 'expect',\n  expects: 'expect',\n\n  // Show/Display variants\n  showing: 'show',\n  showed: 'show',\n  shown: 'show',\n  shows: 'show',\n  displaying: 'display',\n  displayed: 'display',\n  displays: 'display',\n\n  // Hide variants\n  hiding: 'hide',\n  hid: 'hide',\n  hidden: 'hide',\n  hides: 'hide',\n\n  // Enable/Disable variants\n  enabling: 'enable',\n  enabled: 'enable',\n  enables: 'enable',\n  disabling: 'disable',\n  disabled: 'disable',\n  disables: 'disable',\n\n  // Compound verb forms (hyphenated and spaced)\n  'double-click': 'dblclick',\n  'double click': 'dblclick',\n  'double-clicking': 'dblclick',\n  'double clicking': 'dblclick',\n  'double-clicked': 'dblclick',\n  'double clicked': 'dblclick',\n  doubleclick: 'dblclick',\n  doubleclicking: 'dblclick',\n  doubleclicked: 'dblclick',\n\n  'right-click': 'rightclick',\n  'right click': 'rightclick',\n  'right-clicking': 'rightclick',\n  'right clicking': 'rightclick',\n  'right-clicked': 'rightclick',\n  'right clicked': 'rightclick',\n  rightclick: 'rightclick',\n  rightclicking: 'rightclick',\n  rightclicked: 'rightclick',\n\n  'drag-and-drop': 'dragdrop',\n  'drag and drop': 'dragdrop',\n  'drag-n-drop': 'dragdrop',\n\n  'sign-in': 'login',\n  'sign in': 'login',\n  'signing-in': 'login',\n  'signing in': 'login',\n  'signed-in': 'login',\n  'signed in': 'login',\n  signin: 'login',\n\n  'log-in': 'login',\n  'log in': 'login',\n  'logging-in': 'login',\n  'logging in': 'login',\n  'logged-in': 'login',\n  'logged in': 'login',\n\n  'sign-out': 'logout',\n  'sign out': 'logout',\n  'signing-out': 'logout',\n  'signing out': 'logout',\n  'signed-out': 'logout',\n  'signed out': 'logout',\n  signout: 'logout',\n\n  'log-out': 'logout',\n  'log out': 'logout',\n  'logging-out': 'logout',\n  'logging out': 'logout',\n  'logged-out': 'logout',\n  'logged out': 'logout',\n\n  'sign-up': 'register',\n  'sign up': 'register',\n  'signing-up': 'register',\n  'signing up': 'register',\n  'signed-up': 'register',\n  'signed up': 'register',\n  signup: 'register',\n};\n\n/**\n * Expanded glossary for abbreviation and synonym expansion\n */\nconst ABBREVIATION_EXPANSIONS: Record<string, string> = {\n  // Common abbreviations\n  btn: 'button',\n  msg: 'message',\n  err: 'error',\n  pwd: 'password',\n  usr: 'user',\n  nav: 'navigation',\n  pg: 'page',\n  txt: 'text',\n  num: 'number',\n  val: 'value',\n  img: 'image',\n  pic: 'picture',\n  lbl: 'label',\n  chk: 'checkbox',\n  chkbox: 'checkbox',\n  cb: 'checkbox',\n  rb: 'radio',\n  dd: 'dropdown',\n  sel: 'select',\n  dlg: 'dialog',\n  mdl: 'modal',\n  lnk: 'link',\n  tbl: 'table',\n  col: 'column',\n  hdr: 'header',\n  ftr: 'footer',\n  sec: 'section',\n\n  // UI element synonyms\n  textbox: 'field',\n  'text field': 'field',\n  'text input': 'field',\n  'input field': 'field',\n  inputbox: 'field',\n  combobox: 'dropdown',\n  'combo box': 'dropdown',\n  selectbox: 'dropdown',\n  'select box': 'dropdown',\n  picker: 'dropdown',\n  listbox: 'dropdown',\n  'list box': 'dropdown',\n\n  // Action synonyms\n  'sign in': 'login',\n  'log in': 'login',\n  signin: 'login',\n  'sign out': 'logout',\n  'log out': 'logout',\n  signout: 'logout',\n\n  // Common element names\n  'submit button': 'submit',\n  'cancel button': 'cancel',\n  'ok button': 'ok',\n  'close button': 'close',\n  'save button': 'save',\n  'delete button': 'delete',\n  'edit button': 'edit',\n  'add button': 'add',\n  'remove button': 'remove',\n  'search button': 'search',\n  'search box': 'search field',\n  'search bar': 'search field',\n};\n\n/**\n * Words to remove (articles, prepositions that don't add meaning)\n */\nconst STOP_WORDS = new Set([\n  'the', 'a', 'an', 'is', 'are', 'was', 'were', 'be', 'been', 'being',\n  'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could',\n  'should', 'may', 'might', 'must', 'shall', 'can', 'need', 'dare',\n  'ought', 'used', 'to', 'of', 'in', 'for', 'on', 'with', 'at', 'by',\n  'from', 'up', 'about', 'into', 'through', 'during', 'before', 'after',\n  'above', 'below', 'between', 'under', 'again', 'further', 'then',\n  'once', 'here', 'there', 'when', 'where', 'why', 'how', 'all', 'each',\n  'few', 'more', 'most', 'other', 'some', 'such', 'no', 'nor', 'not',\n  'only', 'own', 'same', 'so', 'than', 'too', 'very', 'just', 'and',\n]);\n\n/**\n * User/Actor prefixes to remove\n */\nconst ACTOR_PREFIXES = [\n  /^user\\s+/i,\n  /^the user\\s+/i,\n  /^i\\s+/i,\n  /^we\\s+/i,\n  /^they\\s+/i,\n  /^customer\\s+/i,\n  /^visitor\\s+/i,\n  /^admin\\s+/i,\n  /^administrator\\s+/i,\n];\n\n/**\n * Normalize options\n */\nexport interface NormalizeOptions {\n  /** Apply verb stemming */\n  stemVerbs?: boolean;\n  /** Expand abbreviations */\n  expandAbbreviations?: boolean;\n  /** Remove stop words */\n  removeStopWords?: boolean;\n  /** Remove actor prefixes (e.g., \"user clicks\" -> \"click\") */\n  removeActorPrefixes?: boolean;\n  /** Lowercase everything */\n  lowercase?: boolean;\n  /** Preserve quoted strings */\n  preserveQuoted?: boolean;\n}\n\nconst DEFAULT_OPTIONS: NormalizeOptions = {\n  stemVerbs: true,\n  expandAbbreviations: true,\n  removeStopWords: false, // Keep stop words by default for better pattern matching\n  removeActorPrefixes: true,\n  lowercase: true,\n  preserveQuoted: true,\n};\n\n/**\n * Stem a single word (verb normalization)\n */\nexport function stemWord(word: string): string {\n  const lower = word.toLowerCase();\n  return VERB_STEMS[lower] ?? lower;\n}\n\n/**\n * Expand abbreviations in text\n */\nexport function expandAbbreviations(text: string): string {\n  let result = text.toLowerCase();\n\n  // Sort by length (longest first) to avoid partial replacements\n  const sorted = Object.entries(ABBREVIATION_EXPANSIONS)\n    .sort(([a], [b]) => b.length - a.length);\n\n  for (const [abbr, expansion] of sorted) {\n    // Word boundary replacement\n    const regex = new RegExp(`\\\\b${escapeRegex(abbr)}\\\\b`, 'gi');\n    result = result.replace(regex, expansion);\n  }\n\n  return result;\n}\n\n/**\n * Escape regex special characters\n */\nfunction escapeRegex(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\n/**\n * Remove actor prefixes from step text\n */\nexport function removeActorPrefixes(text: string): string {\n  let result = text;\n  for (const pattern of ACTOR_PREFIXES) {\n    result = result.replace(pattern, '');\n  }\n  return result.trim();\n}\n\n/**\n * Remove stop words from text\n */\nexport function removeStopWords(text: string): string {\n  const words = text.split(/\\s+/);\n  const filtered = words.filter(word => !STOP_WORDS.has(word.toLowerCase()));\n  return filtered.join(' ');\n}\n\n/**\n * Extract quoted strings and replace with placeholders\n * Returns the modified text and a map of placeholders to original values\n */\nfunction extractQuotedStrings(text: string): { text: string; quotes: Map<string, string> } {\n  const quotes = new Map<string, string>();\n  let placeholderIndex = 0;\n\n  const processedText = text.replace(/(['\"])([^'\"]*)\\1/g, (_match, quote, content) => {\n    const placeholder = `__QUOTED_${placeholderIndex}__`;\n    quotes.set(placeholder, `${quote}${content}${quote}`);\n    placeholderIndex++;\n    return placeholder;\n  });\n\n  return { text: processedText, quotes };\n}\n\n/**\n * Restore quoted strings from placeholders\n */\nfunction restoreQuotedStrings(text: string, quotes: Map<string, string>): string {\n  let result = text;\n  for (const [placeholder, original] of quotes) {\n    result = result.replace(placeholder, original);\n  }\n  return result;\n}\n\n/**\n * Enhanced step text normalization\n * Applies all normalization transformations\n */\nexport function normalizeStepTextEnhanced(text: string, options: NormalizeOptions = {}): string {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n\n  let result = text.trim();\n\n  // Extract quoted strings to preserve them\n  let quotesMap = new Map<string, string>();\n  if (opts.preserveQuoted) {\n    const extracted = extractQuotedStrings(result);\n    result = extracted.text;\n    quotesMap = extracted.quotes;\n  }\n\n  // Remove actor prefixes first\n  if (opts.removeActorPrefixes) {\n    result = removeActorPrefixes(result);\n  }\n\n  // Lowercase\n  if (opts.lowercase) {\n    result = result.toLowerCase();\n  }\n\n  // Expand abbreviations\n  if (opts.expandAbbreviations) {\n    result = expandAbbreviations(result);\n  }\n\n  // Stem verbs (word by word)\n  if (opts.stemVerbs) {\n    const words = result.split(/\\s+/);\n    result = words.map(word => {\n      // Don't stem placeholders or words with special chars\n      if (word.startsWith('__QUOTED_') || /[^a-z]/.test(word)) {\n        return word;\n      }\n      return stemWord(word);\n    }).join(' ');\n  }\n\n  // Remove stop words (optional, off by default)\n  if (opts.removeStopWords) {\n    result = removeStopWords(result);\n  }\n\n  // Normalize whitespace\n  result = result.replace(/\\s+/g, ' ').trim();\n\n  // Restore quoted strings\n  if (opts.preserveQuoted) {\n    result = restoreQuotedStrings(result, quotesMap);\n  }\n\n  return result;\n}\n\n/**\n * Get the canonical form of a step (most normalized version)\n */\nexport function getCanonicalForm(text: string): string {\n  return normalizeStepTextEnhanced(text, {\n    stemVerbs: true,\n    expandAbbreviations: true,\n    removeStopWords: true,\n    removeActorPrefixes: true,\n    lowercase: true,\n    preserveQuoted: true,\n  });\n}\n\n/**\n * Get a less aggressive normalization (preserves more structure)\n */\nexport function getLightNormalization(text: string): string {\n  return normalizeStepTextEnhanced(text, {\n    stemVerbs: true,\n    expandAbbreviations: true,\n    removeStopWords: false,\n    removeActorPrefixes: true,\n    lowercase: true,\n    preserveQuoted: true,\n  });\n}\n\n/**\n * Check if two step texts are semantically equivalent after normalization\n */\nexport function areStepsEquivalent(step1: string, step2: string): boolean {\n  const canonical1 = getCanonicalForm(step1);\n  const canonical2 = getCanonicalForm(step2);\n  return canonical1 === canonical2;\n}\n\n/**\n * Get all possible normalizations of a step (for fuzzy matching)\n */\nexport function getAllNormalizations(text: string): string[] {\n  const normalizations = new Set<string>();\n\n  // Original (lowercased)\n  normalizations.add(text.toLowerCase().trim());\n\n  // Light normalization\n  normalizations.add(getLightNormalization(text));\n\n  // Full canonical form\n  normalizations.add(getCanonicalForm(text));\n\n  // Without actor prefix only\n  normalizations.add(removeActorPrefixes(text.toLowerCase().trim()));\n\n  return Array.from(normalizations);\n}\n","/**\n * Adapter to convert IR Primitives to PlannedActions\n * This enables plan.ts to use the unified pattern matching system\n *\n * @see research/2026-02-03_unified-pattern-matching-plan.md Phase 1\n */\nimport type { IRPrimitive, LocatorSpec, ValueSpec } from '../ir/types.js';\nimport type { PlannedAction } from '../cli/plan.js';\n\n/**\n * Convert an IR Primitive to a PlannedAction\n * This is the bridge between the unified pattern system and plan.ts\n */\nexport function irPrimitiveToPlannedAction(primitive: IRPrimitive): PlannedAction {\n  switch (primitive.type) {\n    // \n    // NAVIGATION\n    // \n    case 'goto':\n      return { type: 'navigate', target: primitive.url };\n\n    case 'reload':\n      return { type: 'reload' };\n\n    case 'goBack':\n      return { type: 'goBack' };\n\n    case 'goForward':\n      return { type: 'goForward' };\n\n    case 'waitForURL':\n      return {\n        type: 'waitForURL',\n        target: typeof primitive.pattern === 'string' ? primitive.pattern : primitive.pattern.source,\n      };\n\n    case 'waitForResponse':\n      return { type: 'waitForNetwork', target: primitive.urlPattern };\n\n    case 'waitForLoadingComplete':\n      return { type: 'wait', options: { timeout: primitive.timeout ?? 5000 } };\n\n    // \n    // WAIT PRIMITIVES\n    // \n    case 'waitForVisible':\n      return { type: 'waitForVisible', target: locatorToTarget(primitive.locator) };\n\n    case 'waitForHidden':\n      return { type: 'waitForHidden', target: locatorToTarget(primitive.locator) };\n\n    case 'waitForTimeout':\n      return { type: 'wait', options: { timeout: primitive.ms } };\n\n    case 'waitForNetworkIdle':\n      return { type: 'waitForNetwork' };\n\n    // \n    // CLICK INTERACTIONS\n    // \n    case 'click':\n      return { type: 'click', target: locatorToTarget(primitive.locator) };\n\n    case 'dblclick':\n      return { type: 'dblclick', target: locatorToTarget(primitive.locator) };\n\n    case 'rightClick':\n      return { type: 'rightClick', target: locatorToTarget(primitive.locator) };\n\n    // \n    // FORM INTERACTIONS\n    // \n    case 'fill':\n      return {\n        type: 'fill',\n        target: locatorToTarget(primitive.locator),\n        value: valueToString(primitive.value),\n      };\n\n    case 'select':\n      return {\n        type: 'select',\n        target: locatorToTarget(primitive.locator),\n        value: primitive.option,\n      };\n\n    case 'check':\n      return { type: 'check', target: locatorToTarget(primitive.locator) };\n\n    case 'uncheck':\n      return { type: 'uncheck', target: locatorToTarget(primitive.locator) };\n\n    case 'clear':\n      return { type: 'clear', target: locatorToTarget(primitive.locator) };\n\n    case 'upload':\n      return {\n        type: 'upload',\n        target: locatorToTarget(primitive.locator),\n        files: primitive.files,\n      };\n\n    // \n    // OTHER INTERACTIONS\n    // \n    case 'press':\n      return { type: 'press', key: primitive.key };\n\n    case 'hover':\n      return { type: 'hover', target: locatorToTarget(primitive.locator) };\n\n    case 'focus':\n      return { type: 'focus', target: locatorToTarget(primitive.locator) };\n\n    // \n    // ASSERTIONS\n    // \n    case 'expectVisible':\n      return { type: 'assert', target: locatorToTarget(primitive.locator) };\n\n    case 'expectNotVisible':\n    case 'expectHidden':\n      return { type: 'assertHidden', target: locatorToTarget(primitive.locator) };\n\n    case 'expectText':\n      return {\n        type: 'assertText',\n        target: locatorToTarget(primitive.locator),\n        value: typeof primitive.text === 'string' ? primitive.text : primitive.text.source,\n      };\n\n    case 'expectContainsText':\n      return {\n        type: 'assertText',\n        target: locatorToTarget(primitive.locator),\n        value: primitive.text,\n      };\n\n    case 'expectValue':\n      return {\n        type: 'assertValue',\n        target: locatorToTarget(primitive.locator),\n        value: primitive.value,\n      };\n\n    case 'expectChecked':\n      return { type: 'assertChecked', target: locatorToTarget(primitive.locator) };\n\n    case 'expectEnabled':\n      return { type: 'assertEnabled', target: locatorToTarget(primitive.locator) };\n\n    case 'expectDisabled':\n      return { type: 'assertDisabled', target: locatorToTarget(primitive.locator) };\n\n    case 'expectURL':\n      return {\n        type: 'assertURL',\n        target: typeof primitive.pattern === 'string' ? primitive.pattern : primitive.pattern.source,\n      };\n\n    case 'expectTitle':\n      return {\n        type: 'assertTitle',\n        target: typeof primitive.title === 'string' ? primitive.title : primitive.title.source,\n      };\n\n    case 'expectCount':\n      return {\n        type: 'assertCount',\n        target: locatorToTarget(primitive.locator),\n        count: primitive.count,\n      };\n\n    // \n    // SIGNALS (TOASTS, MODALS, ALERTS)\n    // \n    case 'expectToast':\n      return {\n        type: 'assertToast',\n        toastType: primitive.toastType,\n        value: primitive.message,\n      };\n\n    case 'dismissModal':\n      return { type: 'dismissModal' };\n\n    case 'acceptAlert':\n      return { type: 'acceptAlert' };\n\n    case 'dismissAlert':\n      return { type: 'dismissAlert' };\n\n    // \n    // MODULE CALLS\n    // \n    case 'callModule':\n      return {\n        type: 'callModule',\n        module: primitive.module,\n        method: primitive.method,\n      };\n\n    // \n    // BLOCKED/TODO\n    // \n    case 'blocked':\n      return { type: 'custom', target: primitive.sourceText };\n\n    default:\n      // Exhaustiveness check - this should never happen if all types are handled\n      const _exhaustive: never = primitive;\n      return { type: 'custom', target: String((_exhaustive as IRPrimitive).type) };\n  }\n}\n\n/**\n * Convert a LocatorSpec to a target string for PlannedAction\n */\nfunction locatorToTarget(locator: LocatorSpec): string {\n  switch (locator.strategy) {\n    case 'role':\n      // For role locators, include the accessible name if available\n      if (locator.options?.name) {\n        return `${locator.value}:${locator.options.name}`;\n      }\n      return locator.value;\n\n    case 'placeholder':\n      // For placeholder locators, use placeholder: prefix\n      return `placeholder:${locator.value}`;\n\n    case 'label':\n    case 'text':\n    case 'testid':\n      return locator.value;\n\n    case 'css':\n      // For CSS selectors, return as-is\n      return locator.value;\n\n    default:\n      return locator.value;\n  }\n}\n\n/**\n * Convert a ValueSpec to a string for PlannedAction\n */\nfunction valueToString(value: ValueSpec): string {\n  switch (value.type) {\n    case 'literal':\n      return value.value;\n\n    case 'actor':\n      // Actor reference: {{email}}, {{password}}\n      return `{{${value.value}}}`;\n\n    case 'testData':\n      // Test data reference: $user.email\n      return `$${value.value}`;\n\n    case 'generated':\n      // Generated value: ${runId}, ${timestamp}\n      return value.value;\n\n    case 'runId':\n      return '${runId}';\n\n    default:\n      return value.value || '';\n  }\n}\n\n/**\n * Convert PlannedAction back to an IR Primitive (for round-trip consistency)\n * This is useful for testing and debugging\n */\nexport function plannedActionToIRPrimitive(action: PlannedAction): IRPrimitive | null {\n  switch (action.type) {\n    case 'navigate':\n      return { type: 'goto', url: action.target || '/' };\n\n    case 'reload':\n      return { type: 'reload' };\n\n    case 'goBack':\n      return { type: 'goBack' };\n\n    case 'goForward':\n      return { type: 'goForward' };\n\n    case 'click':\n      return { type: 'click', locator: targetToLocator(action.target || '') };\n\n    case 'dblclick':\n      return { type: 'dblclick', locator: targetToLocator(action.target || '') };\n\n    case 'rightClick':\n      return { type: 'rightClick', locator: targetToLocator(action.target || '') };\n\n    case 'fill':\n      return {\n        type: 'fill',\n        locator: targetToLocator(action.target || ''),\n        value: stringToValue(action.value || ''),\n      };\n\n    case 'select':\n      return {\n        type: 'select',\n        locator: targetToLocator(action.target || ''),\n        option: action.value || '',\n      };\n\n    case 'check':\n      return { type: 'check', locator: targetToLocator(action.target || '') };\n\n    case 'uncheck':\n      return { type: 'uncheck', locator: targetToLocator(action.target || '') };\n\n    case 'press':\n      return { type: 'press', key: action.key || 'Enter' };\n\n    case 'hover':\n      return { type: 'hover', locator: targetToLocator(action.target || '') };\n\n    case 'focus':\n      return { type: 'focus', locator: targetToLocator(action.target || '') };\n\n    case 'clear':\n      return { type: 'clear', locator: targetToLocator(action.target || '') };\n\n    case 'assert':\n      return { type: 'expectVisible', locator: targetToLocator(action.target || '') };\n\n    case 'assertHidden':\n      return { type: 'expectHidden', locator: targetToLocator(action.target || '') };\n\n    case 'assertText':\n      return {\n        type: 'expectText',\n        locator: targetToLocator(action.target || ''),\n        text: action.value || '',\n      };\n\n    case 'assertURL':\n      return { type: 'expectURL', pattern: action.target || '/' };\n\n    case 'assertTitle':\n      return { type: 'expectTitle', title: action.target || '' };\n\n    case 'assertToast':\n      return {\n        type: 'expectToast',\n        toastType: action.toastType || 'info',\n        message: action.value,\n      };\n\n    case 'waitForVisible':\n      return { type: 'waitForVisible', locator: targetToLocator(action.target || '') };\n\n    case 'waitForHidden':\n      return { type: 'waitForHidden', locator: targetToLocator(action.target || '') };\n\n    case 'waitForNetwork':\n      return { type: 'waitForNetworkIdle' };\n\n    case 'wait':\n      return { type: 'waitForTimeout', ms: (action.options?.timeout as number) || 5000 };\n\n    case 'dismissModal':\n      return { type: 'dismissModal' };\n\n    case 'acceptAlert':\n      return { type: 'acceptAlert' };\n\n    case 'dismissAlert':\n      return { type: 'dismissAlert' };\n\n    case 'callModule':\n      return {\n        type: 'callModule',\n        module: action.module || 'unknown',\n        method: action.method || 'unknown',\n      };\n\n    case 'custom':\n      return { type: 'blocked', reason: 'custom action', sourceText: action.target || '' };\n\n    default:\n      return null;\n  }\n}\n\n/**\n * Convert a target string back to a LocatorSpec\n */\nfunction targetToLocator(target: string): LocatorSpec {\n  // Check for role:name pattern (e.g., \"button:Submit\")\n  const roleMatch = target.match(/^(\\w+):(.+)$/);\n  if (roleMatch) {\n    return {\n      strategy: 'role',\n      value: roleMatch[1]!,\n      options: { name: roleMatch[2] },\n    };\n  }\n\n  // Default to text locator\n  return { strategy: 'text', value: target };\n}\n\n/**\n * Convert a string value back to a ValueSpec\n */\nfunction stringToValue(str: string): ValueSpec {\n  // Actor reference: {{email}}\n  if (/^\\{\\{.+\\}\\}$/.test(str)) {\n    return { type: 'actor', value: str.slice(2, -2) };\n  }\n\n  // Test data reference: $user.email\n  if (/^\\$.+/.test(str)) {\n    return { type: 'testData', value: str.slice(1) };\n  }\n\n  // Generated value: ${runId}\n  if (/\\$\\{.+\\}/.test(str)) {\n    return { type: 'generated', value: str };\n  }\n\n  // Literal\n  return { type: 'literal', value: str };\n}\n","/**\n * LLM Fallback - Final tier in coverage architecture\n * Handles blocked steps that can't be matched by patterns, LLKB, or fuzzy matching\n *\n * Coverage Flow: Normalization  Core Patterns  LLKB  Fuzzy  LLM  TODO\n *\n * Key features:\n * - Schema-constrained outputs (only valid IR primitives)\n * - Validation before use\n * - Cost and latency tracking\n * - Non-determinism awareness (logging, telemetry)\n * - Disabled by default for deterministic builds\n *\n * @see research/2026-02-03_multi-ai-debate-coverage-improvement.md\n */\nimport type { IRPrimitive, LocatorSpec, ValueSpec } from '../ir/types.js';\n\n/**\n * LLM provider type\n */\nexport type LlmProvider = 'claude' | 'gpt' | 'gemini' | 'mock';\n\n/**\n * Configuration for LLM fallback\n */\nexport interface LlmFallbackConfig {\n  /** Whether LLM fallback is enabled (default: false) */\n  enabled: boolean;\n  /** LLM provider to use */\n  provider: LlmProvider;\n  /** Model name (e.g., 'claude-3-haiku', 'gpt-4o-mini') */\n  model?: string;\n  /** API key (environment variable name) */\n  apiKeyEnvVar?: string;\n  /** Maximum tokens for response */\n  maxTokens?: number;\n  /** Temperature (0-1, lower = more deterministic) */\n  temperature?: number;\n  /** Timeout in milliseconds */\n  timeout?: number;\n  /** Maximum retries on failure */\n  maxRetries?: number;\n  /** Whether to cache LLM responses */\n  cacheResponses?: boolean;\n  /** Cache TTL in seconds */\n  cacheTtlSeconds?: number;\n  /** Cost budget per session (in USD) */\n  costBudgetUsd?: number;\n}\n\n/**\n * Default configuration (disabled by default)\n */\nexport const DEFAULT_LLM_CONFIG: LlmFallbackConfig = {\n  enabled: false,\n  provider: 'claude',\n  model: 'claude-3-haiku-20240307',\n  apiKeyEnvVar: 'ANTHROPIC_API_KEY',\n  maxTokens: 500,\n  temperature: 0.1, // Low temperature for consistency\n  timeout: 10000,\n  maxRetries: 2,\n  cacheResponses: true,\n  cacheTtlSeconds: 3600,\n  costBudgetUsd: 0.50,\n};\n\n/**\n * LLM fallback result\n */\nexport interface LlmFallbackResult {\n  /** The generated primitive */\n  primitive: IRPrimitive;\n  /** Confidence in the result (0-1) */\n  confidence: number;\n  /** Whether result is from cache */\n  fromCache: boolean;\n  /** Latency in milliseconds */\n  latencyMs: number;\n  /** Estimated cost in USD */\n  estimatedCostUsd: number;\n  /** Provider used */\n  provider: LlmProvider;\n  /** Model used */\n  model: string;\n}\n\n/**\n * LLM fallback telemetry\n */\nexport interface LlmFallbackTelemetry {\n  /** Total LLM calls made */\n  totalCalls: number;\n  /** Successful calls */\n  successfulCalls: number;\n  /** Failed calls (validation failures, timeouts) */\n  failedCalls: number;\n  /** Cache hits */\n  cacheHits: number;\n  /** Total latency (ms) */\n  totalLatencyMs: number;\n  /** Total estimated cost (USD) */\n  totalCostUsd: number;\n  /** Call history for analysis */\n  history: Array<{\n    timestamp: string;\n    stepText: string;\n    success: boolean;\n    latencyMs: number;\n    costUsd: number;\n    error?: string;\n  }>;\n}\n\n// Telemetry state\nlet telemetry: LlmFallbackTelemetry = {\n  totalCalls: 0,\n  successfulCalls: 0,\n  failedCalls: 0,\n  cacheHits: 0,\n  totalLatencyMs: 0,\n  totalCostUsd: 0,\n  history: [],\n};\n\n// Simple in-memory cache\nconst responseCache = new Map<string, { result: LlmFallbackResult; expiry: number }>();\n\n/** Maximum history entries to keep (avoid unbounded memory growth) */\nconst MAX_HISTORY_ENTRIES = 1000;\n\n/**\n * Add a history entry with bounded array size\n */\nfunction addHistoryEntry(entry: LlmFallbackTelemetry['history'][0]): void {\n  telemetry.history.push(entry);\n  // Trim history if it exceeds max size (keep most recent)\n  if (telemetry.history.length > MAX_HISTORY_ENTRIES) {\n    telemetry.history = telemetry.history.slice(-MAX_HISTORY_ENTRIES);\n  }\n}\n\n/**\n * Valid primitive types for schema validation\n */\nconst VALID_PRIMITIVE_TYPES = [\n  'goto', 'waitForURL', 'waitForResponse', 'waitForLoadingComplete', 'reload', 'goBack', 'goForward',\n  'waitForVisible', 'waitForHidden', 'waitForTimeout', 'waitForNetworkIdle',\n  'click', 'dblclick', 'rightClick', 'fill', 'select', 'check', 'uncheck', 'upload', 'press', 'hover', 'focus', 'clear',\n  'expectVisible', 'expectNotVisible', 'expectHidden', 'expectText', 'expectValue', 'expectChecked',\n  'expectEnabled', 'expectDisabled', 'expectURL', 'expectTitle', 'expectCount', 'expectContainsText',\n  'expectToast', 'dismissModal', 'acceptAlert', 'dismissAlert',\n  'callModule', 'blocked',\n] as const;\n\n/**\n * Valid locator strategies\n */\nconst VALID_LOCATOR_STRATEGIES = ['role', 'label', 'placeholder', 'text', 'testid', 'css'] as const;\n\n/**\n * Validate a locator spec\n */\nfunction validateLocatorSpec(locator: unknown): locator is LocatorSpec {\n  if (!locator || typeof locator !== 'object') return false;\n  const loc = locator as Record<string, unknown>;\n\n  if (!VALID_LOCATOR_STRATEGIES.includes(loc.strategy as typeof VALID_LOCATOR_STRATEGIES[number])) {\n    return false;\n  }\n\n  if (typeof loc.value !== 'string' || loc.value.length === 0) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Validate a value spec\n */\nfunction validateValueSpec(value: unknown): value is ValueSpec {\n  if (!value || typeof value !== 'object') return false;\n  const val = value as Record<string, unknown>;\n\n  const validTypes = ['literal', 'actor', 'runId', 'generated', 'testData'];\n  if (!validTypes.includes(val.type as string)) {\n    return false;\n  }\n\n  if (typeof val.value !== 'string') {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Validate an IR primitive from LLM response\n */\nexport function validateLlmPrimitive(primitive: unknown): { valid: boolean; errors: string[] } {\n  const errors: string[] = [];\n\n  if (!primitive || typeof primitive !== 'object') {\n    errors.push('Primitive must be an object');\n    return { valid: false, errors };\n  }\n\n  const prim = primitive as Record<string, unknown>;\n\n  // Check type\n  if (!VALID_PRIMITIVE_TYPES.includes(prim.type as typeof VALID_PRIMITIVE_TYPES[number])) {\n    errors.push(`Invalid primitive type: ${prim.type}`);\n    return { valid: false, errors };\n  }\n\n  // Type-specific validation\n  switch (prim.type) {\n    // Navigation primitives\n    case 'goto':\n      if (typeof prim.url !== 'string') errors.push('goto requires url string');\n      break;\n\n    case 'waitForURL':\n      if (typeof prim.pattern !== 'string') errors.push('waitForURL requires pattern string');\n      break;\n\n    case 'waitForResponse':\n      if (typeof prim.urlPattern !== 'string') errors.push('waitForResponse requires urlPattern string');\n      break;\n\n    case 'reload':\n    case 'goBack':\n    case 'goForward':\n      // No additional validation needed\n      break;\n\n    case 'waitForLoadingComplete':\n    case 'waitForNetworkIdle':\n      // Optional timeout, no validation needed\n      break;\n\n    // Wait primitives with locator\n    case 'waitForVisible':\n    case 'waitForHidden':\n      if (!validateLocatorSpec(prim.locator)) errors.push(`${prim.type} requires valid locator`);\n      break;\n\n    case 'waitForTimeout':\n      if (typeof prim.ms !== 'number' || prim.ms < 0) errors.push('waitForTimeout requires positive ms');\n      break;\n\n    // Interaction primitives with locator\n    case 'click':\n    case 'dblclick':\n    case 'rightClick':\n    case 'hover':\n    case 'focus':\n    case 'clear':\n    case 'check':\n    case 'uncheck':\n      if (!validateLocatorSpec(prim.locator)) errors.push(`${prim.type} requires valid locator`);\n      break;\n\n    case 'fill':\n      if (!validateLocatorSpec(prim.locator)) errors.push('fill requires valid locator');\n      if (!validateValueSpec(prim.value)) errors.push('fill requires valid value');\n      break;\n\n    case 'select':\n      if (!validateLocatorSpec(prim.locator)) errors.push('select requires valid locator');\n      if (typeof prim.option !== 'string') errors.push('select requires option string');\n      break;\n\n    case 'press':\n      if (typeof prim.key !== 'string') errors.push('press requires key string');\n      break;\n\n    case 'upload':\n      if (!validateLocatorSpec(prim.locator)) errors.push('upload requires valid locator');\n      if (!Array.isArray(prim.files) || prim.files.length === 0) errors.push('upload requires non-empty files array');\n      break;\n\n    // Assertion primitives\n    case 'expectText':\n    case 'expectContainsText':\n      if (!validateLocatorSpec(prim.locator)) errors.push(`${prim.type} requires valid locator`);\n      if (typeof prim.text !== 'string') errors.push(`${prim.type} requires text string`);\n      break;\n\n    case 'expectValue':\n      if (!validateLocatorSpec(prim.locator)) errors.push('expectValue requires valid locator');\n      if (typeof prim.value !== 'string') errors.push('expectValue requires value string');\n      break;\n\n    case 'expectVisible':\n    case 'expectNotVisible':\n    case 'expectHidden':\n    case 'expectEnabled':\n    case 'expectDisabled':\n    case 'expectChecked':\n      if (!validateLocatorSpec(prim.locator)) errors.push(`${prim.type} requires valid locator`);\n      break;\n\n    case 'expectCount':\n      if (!validateLocatorSpec(prim.locator)) errors.push('expectCount requires valid locator');\n      if (typeof prim.count !== 'number') errors.push('expectCount requires count number');\n      break;\n\n    case 'expectURL':\n      if (typeof prim.pattern !== 'string') errors.push('expectURL requires pattern string');\n      break;\n\n    case 'expectTitle':\n      if (typeof prim.title !== 'string') errors.push('expectTitle requires title string');\n      break;\n\n    // Signal primitives\n    case 'expectToast':\n      if (!['success', 'error', 'info', 'warning'].includes(prim.toastType as string)) {\n        errors.push('expectToast requires valid toastType (success|error|info|warning)');\n      }\n      break;\n\n    case 'dismissModal':\n    case 'acceptAlert':\n    case 'dismissAlert':\n      // No additional validation needed\n      break;\n\n    // Module calls\n    case 'callModule':\n      if (typeof prim.module !== 'string') errors.push('callModule requires module string');\n      if (typeof prim.method !== 'string') errors.push('callModule requires method string');\n      break;\n\n    // Blocked steps\n    case 'blocked':\n      if (typeof prim.reason !== 'string') errors.push('blocked requires reason string');\n      if (typeof prim.sourceText !== 'string') errors.push('blocked requires sourceText string');\n      break;\n  }\n\n  return { valid: errors.length === 0, errors };\n}\n\n/**\n * Generate the prompt for LLM\n */\nfunction generatePrompt(stepText: string): string {\n  return `You are an expert at converting natural language test steps into structured IR (Intermediate Representation) primitives for Playwright test automation.\n\nGiven this test step:\n\"${stepText}\"\n\nReturn a JSON object representing the IR primitive. The primitive must follow this schema:\n\nPrimitive Types:\n- Navigation: goto (url), waitForURL (pattern), reload, goBack, goForward\n- Wait: waitForVisible (locator), waitForHidden (locator), waitForTimeout (ms), waitForNetworkIdle\n- Actions: click (locator), fill (locator, value), select (locator, option), check (locator), uncheck (locator), press (key), hover (locator)\n- Assertions: expectVisible (locator), expectText (locator, text), expectValue (locator, value), expectURL (pattern), expectTitle (title)\n\nLocator format:\n{\n  \"strategy\": \"role\" | \"label\" | \"text\" | \"testid\" | \"css\",\n  \"value\": \"string\",\n  \"options\": { \"name\": \"string\", \"exact\": boolean } // optional\n}\n\nValue format (for fill):\n{\n  \"type\": \"literal\" | \"actor\" | \"testData\",\n  \"value\": \"string\"\n}\n\nExamples:\n- \"Click the Submit button\"  {\"type\": \"click\", \"locator\": {\"strategy\": \"role\", \"value\": \"button\", \"options\": {\"name\": \"Submit\"}}}\n- \"Enter 'john@test.com' in email field\"  {\"type\": \"fill\", \"locator\": {\"strategy\": \"label\", \"value\": \"email\"}, \"value\": {\"type\": \"literal\", \"value\": \"john@test.com\"}}\n- \"Wait for page to load\"  {\"type\": \"waitForNetworkIdle\"}\n\nRESPOND WITH ONLY THE JSON OBJECT, NO EXPLANATION.`;\n}\n\n/**\n * Parse LLM response into primitive\n */\nfunction parseResponse(response: string): IRPrimitive | null {\n  try {\n    // Try to extract JSON from response\n    const jsonMatch = response.match(/\\{[\\s\\S]*\\}/);\n    if (!jsonMatch) return null;\n\n    const parsed = JSON.parse(jsonMatch[0]);\n    const validation = validateLlmPrimitive(parsed);\n\n    if (validation.valid) {\n      return parsed as IRPrimitive;\n    }\n\n    console.warn('[LLM Fallback] Validation errors:', validation.errors);\n    return null;\n  } catch (e) {\n    console.warn('[LLM Fallback] Failed to parse response:', e);\n    return null;\n  }\n}\n\n/**\n * Get cache key for a step\n */\nfunction getCacheKey(stepText: string, config: LlmFallbackConfig): string {\n  return `${config.provider}:${config.model}:${stepText.toLowerCase().trim()}`;\n}\n\n/**\n * Estimate cost for a call\n */\nfunction estimateCost(_provider: LlmProvider, model: string, inputTokens: number, outputTokens: number): number {\n  // Rough estimates per 1M tokens (as of early 2025)\n  const costs: Record<string, { input: number; output: number }> = {\n    'claude-3-haiku': { input: 0.25, output: 1.25 },\n    'claude-3-sonnet': { input: 3.00, output: 15.00 },\n    'gpt-4o-mini': { input: 0.15, output: 0.60 },\n    'gpt-4o': { input: 5.00, output: 15.00 },\n    'gemini-1.5-flash': { input: 0.075, output: 0.30 },\n  };\n\n  const modelKey = Object.keys(costs).find(k => model.includes(k)) || 'gpt-4o-mini';\n  const rates = costs[modelKey]!;\n\n  return (inputTokens * rates.input + outputTokens * rates.output) / 1_000_000;\n}\n\n/**\n * Mock LLM call for testing\n */\nasync function mockLlmCall(stepText: string): Promise<{ response: string; latencyMs: number }> {\n  // Simulate latency\n  await new Promise(r => setTimeout(r, 100));\n\n  const lower = stepText.toLowerCase();\n\n  // Simple mock responses based on keywords\n  let primitive: IRPrimitive;\n\n  if (lower.includes('click')) {\n    const match = stepText.match(/[\"']([^\"']+)[\"']/);\n    primitive = {\n      type: 'click',\n      locator: { strategy: 'role', value: 'button', options: { name: match?.[1] || 'button' } },\n    };\n  } else if (lower.includes('enter') || lower.includes('fill') || lower.includes('type')) {\n    const matches = stepText.match(/[\"']([^\"']+)[\"']/g);\n    const value = matches?.[0]?.slice(1, -1) || '';\n    const field = matches?.[1]?.slice(1, -1) || 'input';\n    primitive = {\n      type: 'fill',\n      locator: { strategy: 'label', value: field },\n      value: { type: 'literal', value },\n    };\n  } else if (lower.includes('see') || lower.includes('visible')) {\n    const match = stepText.match(/[\"']([^\"']+)[\"']/);\n    primitive = {\n      type: 'expectVisible',\n      locator: { strategy: 'text', value: match?.[1] || 'element' },\n    };\n  } else if (lower.includes('navigate') || lower.includes('go to')) {\n    const match = stepText.match(/(?:to|\\/)\\s*([\\/\\w.-]+)/i);\n    primitive = { type: 'goto', url: match?.[1] || '/' };\n  } else if (lower.includes('wait')) {\n    primitive = { type: 'waitForNetworkIdle' };\n  } else {\n    // Fallback to blocked\n    primitive = { type: 'blocked', reason: 'LLM mock could not interpret', sourceText: stepText };\n  }\n\n  return {\n    response: JSON.stringify(primitive),\n    latencyMs: 100,\n  };\n}\n\n/**\n * Make actual LLM API call\n * Note: This is a placeholder - actual implementation would use provider SDKs\n */\nasync function callLlmApi(\n  _prompt: string,\n  _config: LlmFallbackConfig\n): Promise<{ response: string; latencyMs: number; inputTokens: number; outputTokens: number }> {\n  // TODO: Implement actual LLM API calls using provider SDKs\n  // For now, throw an error indicating it's not implemented\n  throw new Error(\n    'LLM API calls not implemented. Use mock provider for testing or implement callLlmApi with your preferred provider SDK.'\n  );\n}\n\n/**\n * Main LLM fallback function\n */\nexport async function llmFallback(\n  stepText: string,\n  config: Partial<LlmFallbackConfig> = {}\n): Promise<LlmFallbackResult | null> {\n  const mergedConfig: LlmFallbackConfig = { ...DEFAULT_LLM_CONFIG, ...config };\n\n  if (!mergedConfig.enabled) {\n    return null;\n  }\n\n  const startTime = Date.now();\n  const cacheKey = getCacheKey(stepText, mergedConfig);\n\n  // Check cache\n  if (mergedConfig.cacheResponses) {\n    const cached = responseCache.get(cacheKey);\n    if (cached && cached.expiry > Date.now()) {\n      telemetry.cacheHits++;\n      return { ...cached.result, fromCache: true };\n    }\n  }\n\n  // Check cost budget\n  if (mergedConfig.costBudgetUsd && telemetry.totalCostUsd >= mergedConfig.costBudgetUsd) {\n    console.warn('[LLM Fallback] Cost budget exceeded, skipping LLM call');\n    telemetry.failedCalls++;\n    addHistoryEntry({\n      timestamp: new Date().toISOString(),\n      stepText,\n      success: false,\n      latencyMs: 0,\n      costUsd: 0,\n      error: 'Cost budget exceeded',\n    });\n    return null;\n  }\n\n  telemetry.totalCalls++;\n\n  try {\n    let response: string;\n    let latencyMs: number;\n    let inputTokens = 0;\n    let outputTokens = 0;\n\n    if (mergedConfig.provider === 'mock') {\n      const result = await mockLlmCall(stepText);\n      response = result.response;\n      latencyMs = result.latencyMs;\n      inputTokens = Math.ceil(stepText.length / 4);\n      outputTokens = Math.ceil(response.length / 4);\n    } else {\n      const prompt = generatePrompt(stepText);\n      const result = await callLlmApi(prompt, mergedConfig);\n      response = result.response;\n      latencyMs = result.latencyMs;\n      inputTokens = result.inputTokens;\n      outputTokens = result.outputTokens;\n    }\n\n    const primitive = parseResponse(response);\n\n    if (!primitive) {\n      telemetry.failedCalls++;\n      addHistoryEntry({\n        timestamp: new Date().toISOString(),\n        stepText,\n        success: false,\n        latencyMs: Date.now() - startTime,\n        costUsd: 0,\n        error: 'Failed to parse response',\n      });\n      return null;\n    }\n\n    const costUsd = estimateCost(mergedConfig.provider, mergedConfig.model || '', inputTokens, outputTokens);\n\n    const result: LlmFallbackResult = {\n      primitive,\n      confidence: primitive.type === 'blocked' ? 0.3 : 0.7,\n      fromCache: false,\n      latencyMs,\n      estimatedCostUsd: costUsd,\n      provider: mergedConfig.provider,\n      model: mergedConfig.model || 'unknown',\n    };\n\n    // Update telemetry\n    telemetry.successfulCalls++;\n    telemetry.totalLatencyMs += latencyMs;\n    telemetry.totalCostUsd += costUsd;\n    addHistoryEntry({\n      timestamp: new Date().toISOString(),\n      stepText,\n      success: true,\n      latencyMs,\n      costUsd,\n    });\n\n    // Cache result\n    if (mergedConfig.cacheResponses) {\n      responseCache.set(cacheKey, {\n        result,\n        expiry: Date.now() + (mergedConfig.cacheTtlSeconds || 3600) * 1000,\n      });\n    }\n\n    return result;\n  } catch (error) {\n    telemetry.failedCalls++;\n    addHistoryEntry({\n      timestamp: new Date().toISOString(),\n      stepText,\n      success: false,\n      latencyMs: Date.now() - startTime,\n      costUsd: 0,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    });\n    return null;\n  }\n}\n\n/**\n * Get current telemetry\n */\nexport function getLlmFallbackTelemetry(): LlmFallbackTelemetry {\n  return { ...telemetry };\n}\n\n/**\n * Reset telemetry (for testing)\n */\nexport function resetLlmFallbackTelemetry(): void {\n  telemetry = {\n    totalCalls: 0,\n    successfulCalls: 0,\n    failedCalls: 0,\n    cacheHits: 0,\n    totalLatencyMs: 0,\n    totalCostUsd: 0,\n    history: [],\n  };\n}\n\n/**\n * Clear response cache (for testing)\n */\nexport function clearLlmResponseCache(): void {\n  responseCache.clear();\n}\n\n/**\n * Check if LLM fallback is available and configured\n */\nexport function isLlmFallbackAvailable(config: Partial<LlmFallbackConfig> = {}): {\n  available: boolean;\n  reason?: string;\n} {\n  const mergedConfig = { ...DEFAULT_LLM_CONFIG, ...config };\n\n  if (!mergedConfig.enabled) {\n    return { available: false, reason: 'LLM fallback is disabled' };\n  }\n\n  if (mergedConfig.provider === 'mock') {\n    return { available: true };\n  }\n\n  // Check for API key\n  const apiKey = process.env[mergedConfig.apiKeyEnvVar || 'ANTHROPIC_API_KEY'];\n  if (!apiKey) {\n    return {\n      available: false,\n      reason: `API key not found in environment variable: ${mergedConfig.apiKeyEnvVar}`,\n    };\n  }\n\n  return { available: true };\n}\n"]}
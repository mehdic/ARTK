{"version":3,"sources":["../../src/ir/types.ts","../../src/ir/builder.ts","../../src/ir/serialize.ts","../../src/config/schema.ts","../../src/config/loader.ts","../../src/journey/schema.ts","../../src/mapping/patterns.ts","../../src/utils/result.ts","../../src/journey/parseJourney.ts","../../src/mapping/glossary.ts","../../src/journey/hintPatterns.ts","../../src/journey/parseHints.ts","../../src/mapping/telemetry.ts","../../src/llkb/patternExtension.ts","../../src/mapping/stepMapper.ts","../../src/utils/escaping.ts","../../src/journey/normalize.ts","../../src/selectors/priority.ts","../../src/selectors/catalogSchema.ts","../../src/selectors/catalog.ts","../../src/selectors/infer.ts","../../src/selectors/scanner.ts","../../src/selectors/debt.ts","../../src/codegen/blocks.ts","../../src/journey/updater.ts","../../src/utils/paths.ts","../../src/utils/version.ts","../../src/variants/index.ts","../../src/codegen/generateTest.ts","../../src/codegen/generateModule.ts","../../src/codegen/astEdit.ts","../../src/codegen/registry.ts","../../src/utils/parsing.ts","../../src/validate/journey.ts","../../src/validate/patterns.ts","../../src/validate/lint.ts","../../src/validate/tags.ts","../../src/validate/coverage.ts","../../src/validate/code.ts","../../src/validate/index.ts","../../src/verify/runner.ts","../../src/verify/parser.ts","../../src/verify/classifier.ts","../../src/verify/stability.ts","../../src/verify/evidence.ts","../../src/verify/summary.ts","../../src/verify/index.ts","../../src/heal/rules.ts","../../src/heal/logger.ts","../../src/heal/fixes/selector.ts","../../src/heal/fixes/navigation.ts","../../src/heal/fixes/timing.ts","../../src/heal/loop.ts","../../src/heal/fixes/data.ts","../../src/heal/index.ts","../../src/instance/install.ts","../../src/instance/upgrade.ts","../../src/index.ts","../../src/cli/install.ts","../../src/cli/upgrade.ts","../../src/mapping/patternDistance.ts","../../src/mapping/blockedStepAnalysis.ts","../../src/cli/generate.ts","../../src/cli/validate.ts","../../src/cli/verify.ts","../../src/cli/patterns.ts","../../src/cli/llkb-patterns.ts","../../src/cli/index.ts"],"names":["err","parseYaml","init_schema","z","resolve","existsSync","readFileSync","join","unlinkSync","dirname","mkdirSync","isAssertion","stringifyYaml","writeFileSync","escapeString","loadDefaultTemplate","ejs","getPatternStats","init_patterns","DEFAULT_OPTIONS","execSync","tmpdir","matchPattern","CURRENT_CONFIG_VERSION","checkStability","runHealingLoop","DEFAULT_HEALING_CONFIG","init_install","parseArgs","init_upgrade","fg","basename","USAGE","init_validate","hasFailures","init_verify","runList","runStats","runExport","runClear","runInstall","runUpgrade","runGenerate","runValidate","runVerify","runPatterns","runLlkbPatterns"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Intermediate Representation (IR) Types\n * @see research/2026-01-02_autogen-refined-plan.md Section 9\n *\n * All code generation goes through IR. Prompts never generate Playwright code directly.\n */\n\n/**\n * Locator strategy following Playwright priority\n * role > label > text > testid > css\n */\nexport type LocatorStrategy = 'role' | 'label' | 'placeholder' | 'text' | 'testid' | 'css';\n\n/**\n * Specification for how to locate an element\n */\nexport interface LocatorSpec {\n  /** Locator strategy to use */\n  strategy: LocatorStrategy;\n  /** Primary value for the strategy (e.g., role name, label text) */\n  value: string;\n  /** Additional options for the locator */\n  options?: {\n    /** Accessible name for role locators */\n    name?: string;\n    /** Exact match flag */\n    exact?: boolean;\n    /** Heading level for heading role */\n    level?: number;\n    /** Whether to use strict mode (fail if multiple matches) */\n    strict?: boolean;\n  };\n}\n\n/**\n * Value specification for inputs and assertions\n */\nexport interface ValueSpec {\n  /** Type of value */\n  type: 'literal' | 'actor' | 'runId' | 'generated' | 'testData';\n  /** Value content or path */\n  value: string;\n  /** Optional transform to apply */\n  transform?: 'uppercase' | 'lowercase' | 'trim';\n}\n\n/**\n * IR Primitive - atomic actions that map to Playwright calls\n */\nexport type IRPrimitive =\n  // Navigation\n  | { type: 'goto'; url: string; waitForLoad?: boolean }\n  | { type: 'waitForURL'; pattern: string | RegExp }\n  | { type: 'waitForResponse'; urlPattern: string }\n  | { type: 'waitForLoadingComplete'; timeout?: number }\n  | { type: 'reload' }\n  | { type: 'goBack' }\n  | { type: 'goForward' }\n\n  // Wait primitives\n  | { type: 'waitForVisible'; locator: LocatorSpec; timeout?: number }\n  | { type: 'waitForHidden'; locator: LocatorSpec; timeout?: number }\n  | { type: 'waitForTimeout'; ms: number }\n  | { type: 'waitForNetworkIdle'; timeout?: number }\n\n  // Interactions\n  | { type: 'click'; locator: LocatorSpec }\n  | { type: 'dblclick'; locator: LocatorSpec }\n  | { type: 'rightClick'; locator: LocatorSpec }\n  | { type: 'fill'; locator: LocatorSpec; value: ValueSpec }\n  | { type: 'select'; locator: LocatorSpec; option: string }\n  | { type: 'check'; locator: LocatorSpec }\n  | { type: 'uncheck'; locator: LocatorSpec }\n  | { type: 'upload'; locator: LocatorSpec; files: string[] }\n  | { type: 'press'; key: string; locator?: LocatorSpec }\n  | { type: 'hover'; locator: LocatorSpec }\n  | { type: 'focus'; locator: LocatorSpec }\n  | { type: 'clear'; locator: LocatorSpec }\n\n  // Assertions (web-first, auto-retrying)\n  | { type: 'expectVisible'; locator: LocatorSpec; timeout?: number }\n  | { type: 'expectNotVisible'; locator: LocatorSpec; timeout?: number }\n  | { type: 'expectHidden'; locator: LocatorSpec; timeout?: number }\n  | { type: 'expectText'; locator: LocatorSpec; text: string | RegExp; timeout?: number }\n  | { type: 'expectValue'; locator: LocatorSpec; value: string; timeout?: number }\n  | { type: 'expectChecked'; locator: LocatorSpec; checked?: boolean }\n  | { type: 'expectEnabled'; locator: LocatorSpec }\n  | { type: 'expectDisabled'; locator: LocatorSpec }\n  | { type: 'expectURL'; pattern: string | RegExp }\n  | { type: 'expectTitle'; title: string | RegExp }\n  | { type: 'expectCount'; locator: LocatorSpec; count: number }\n  | { type: 'expectContainsText'; locator: LocatorSpec; text: string }\n\n  // Signals (toasts, modals, alerts)\n  | { type: 'expectToast'; toastType: 'success' | 'error' | 'info' | 'warning'; message?: string }\n  | { type: 'dismissModal'; }\n  | { type: 'acceptAlert'; }\n  | { type: 'dismissAlert'; }\n\n  // Module calls (abstraction layer)\n  | { type: 'callModule'; module: string; method: string; args?: unknown[] }\n\n  // Blocked/TODO (for steps that cannot be mapped)\n  | { type: 'blocked'; reason: string; sourceText: string };\n\n/**\n * A single step in the IR Journey\n * Maps to a test.step() in generated code\n */\nexport interface IRStep {\n  /** Step identifier (e.g., 'AC-1', 'AC-2') */\n  id: string;\n  /** Human-readable description */\n  description: string;\n  /** Actions to perform (clicks, fills, navigations) */\n  actions: IRPrimitive[];\n  /** Assertions to verify (expects) */\n  assertions: IRPrimitive[];\n  /** Original source text from Journey */\n  sourceText?: string;\n  /** Notes for debugging or TODOs */\n  notes?: string[];\n}\n\n/**\n * Journey tier classification\n */\nexport type JourneyTier = 'smoke' | 'release' | 'regression';\n\n/**\n * Data strategy for test data management\n */\nexport type DataStrategy = 'seed' | 'create' | 'reuse';\n\n/**\n * Cleanup strategy for test data\n */\nexport type CleanupStrategy = 'required' | 'best-effort' | 'none';\n\n/**\n * Module dependencies for a Journey\n */\nexport interface ModuleDependencies {\n  /** Foundation modules (auth, nav, etc.) */\n  foundation: string[];\n  /** Feature modules specific to this journey */\n  feature: string[];\n}\n\n/**\n * Completion signal types\n */\nexport type CompletionSignalType = 'url' | 'toast' | 'element' | 'text' | 'title' | 'api';\n\n/**\n * Completion signal for journey success\n */\nexport interface CompletionSignal {\n  type: CompletionSignalType;\n  value: string;\n  options?: {\n    timeout?: number;\n    exact?: boolean;\n    state?: 'visible' | 'hidden' | 'attached' | 'detached';\n    method?: string; // For API signals\n    status?: number; // For API signals\n  };\n}\n\n/**\n * Data configuration for a journey\n */\nexport interface JourneyDataConfig {\n  strategy: DataStrategy;\n  cleanup: CleanupStrategy;\n  /** Seed data requirements */\n  seeds?: string[];\n  /** Test data factory references */\n  factories?: string[];\n}\n\n/**\n * Negative path definition for error scenario testing\n */\nexport interface NegativePath {\n  /** Name of the negative path scenario */\n  name: string;\n  /** Input values to trigger the error */\n  input: Record<string, unknown>;\n  /** Expected error message */\n  expectedError: string;\n  /** Optional element selector where error should appear */\n  expectedElement?: string;\n}\n\n/**\n * Visual regression configuration\n */\nexport interface VisualRegressionConfig {\n  enabled: boolean;\n  snapshots?: string[];\n  threshold?: number;\n}\n\n/**\n * Accessibility timing mode\n */\nexport type AccessibilityTiming = 'afterEach' | 'inTest';\n\n/**\n * Accessibility configuration\n */\nexport interface AccessibilityConfig {\n  enabled: boolean;\n  rules?: string[];\n  exclude?: string[];\n  /** When to run checks: 'afterEach' (default) or 'inTest' */\n  timing?: AccessibilityTiming;\n}\n\n/**\n * Performance budgets configuration\n */\nexport interface PerformanceConfig {\n  enabled: boolean;\n  budgets?: {\n    lcp?: number;\n    fid?: number;\n    cls?: number;\n    ttfb?: number;\n  };\n  /** Timeout for collecting performance metrics in ms (default: 3000) */\n  collectTimeout?: number;\n}\n\n/**\n * Test data set for parameterized testing\n */\nexport interface TestDataSet {\n  /** Name of the test data set */\n  name: string;\n  /** Optional description */\n  description?: string;\n  /** Test data key-value pairs */\n  data: Record<string, unknown>;\n}\n\n/**\n * Complete IR representation of a Journey\n * This is the canonical format before code generation\n */\nexport interface IRJourney {\n  /** Journey ID (e.g., 'JRN-0001') */\n  id: string;\n  /** Human-readable title */\n  title: string;\n  /** Tier classification */\n  tier: JourneyTier;\n  /** Scope/area (e.g., 'billing', 'auth') */\n  scope: string;\n  /** Actor performing the journey */\n  actor: string;\n  /** Tags for filtering and organization */\n  tags: string[];\n  /** Module dependencies */\n  moduleDependencies: ModuleDependencies;\n  /** Data configuration */\n  data?: JourneyDataConfig;\n  /** Completion signals */\n  completion?: CompletionSignal[];\n  /** Setup steps (before main journey) */\n  setup?: IRPrimitive[];\n  /** Main journey steps */\n  steps: IRStep[];\n  /** Cleanup steps (after main journey) */\n  cleanup?: IRPrimitive[];\n  /** Journey revision number */\n  revision?: number;\n  /** Source file path */\n  sourcePath?: string;\n  /** Prerequisites - Journey IDs that must run first */\n  prerequisites?: string[];\n  /** Negative paths - Error scenarios to test */\n  negativePaths?: NegativePath[];\n  /** Test data sets for parameterized testing */\n  testData?: TestDataSet[];\n  /** Visual regression configuration */\n  visualRegression?: VisualRegressionConfig;\n  /** Accessibility configuration */\n  accessibility?: AccessibilityConfig;\n  /** Performance configuration */\n  performance?: PerformanceConfig;\n}\n\n/**\n * Result of mapping a journey to IR\n */\nexport interface IRMappingResult {\n  /** The mapped IR Journey */\n  journey: IRJourney;\n  /** Steps that could not be fully mapped */\n  blockedSteps: Array<{\n    stepId: string;\n    sourceText: string;\n    reason: string;\n  }>;\n  /** Warnings during mapping */\n  warnings: string[];\n  /** Mapping statistics */\n  stats: {\n    totalSteps: number;\n    mappedSteps: number;\n    blockedSteps: number;\n    totalActions: number;\n    totalAssertions: number;\n  };\n}\n","/**\n * IR Builder - Fluent API for constructing IR structures\n * @see research/2026-01-02_autogen-refined-plan.md Section 9\n */\nimport type {\n  IRJourney,\n  IRStep,\n  IRPrimitive,\n  LocatorSpec,\n  ValueSpec,\n  JourneyTier,\n  ModuleDependencies,\n  CompletionSignal,\n  JourneyDataConfig,\n  LocatorStrategy,\n} from './types.js';\n\n/**\n * Builder for constructing LocatorSpec\n */\nexport class LocatorBuilder {\n  private spec: Partial<LocatorSpec> = {};\n\n  static role(role: string, name?: string): LocatorBuilder {\n    const builder = new LocatorBuilder();\n    builder.spec.strategy = 'role';\n    builder.spec.value = role;\n    if (name) {\n      builder.spec.options = { ...builder.spec.options, name };\n    }\n    return builder;\n  }\n\n  static label(label: string): LocatorBuilder {\n    const builder = new LocatorBuilder();\n    builder.spec.strategy = 'label';\n    builder.spec.value = label;\n    return builder;\n  }\n\n  static placeholder(placeholder: string): LocatorBuilder {\n    const builder = new LocatorBuilder();\n    builder.spec.strategy = 'placeholder';\n    builder.spec.value = placeholder;\n    return builder;\n  }\n\n  static text(text: string): LocatorBuilder {\n    const builder = new LocatorBuilder();\n    builder.spec.strategy = 'text';\n    builder.spec.value = text;\n    return builder;\n  }\n\n  static testId(testId: string): LocatorBuilder {\n    const builder = new LocatorBuilder();\n    builder.spec.strategy = 'testid';\n    builder.spec.value = testId;\n    return builder;\n  }\n\n  static css(selector: string): LocatorBuilder {\n    const builder = new LocatorBuilder();\n    builder.spec.strategy = 'css';\n    builder.spec.value = selector;\n    return builder;\n  }\n\n  static fromSpec(strategy: LocatorStrategy, value: string): LocatorBuilder {\n    const builder = new LocatorBuilder();\n    builder.spec.strategy = strategy;\n    builder.spec.value = value;\n    return builder;\n  }\n\n  exact(exact = true): LocatorBuilder {\n    this.spec.options = { ...this.spec.options, exact };\n    return this;\n  }\n\n  level(level: number): LocatorBuilder {\n    this.spec.options = { ...this.spec.options, level };\n    return this;\n  }\n\n  strict(strict = true): LocatorBuilder {\n    this.spec.options = { ...this.spec.options, strict };\n    return this;\n  }\n\n  name(name: string): LocatorBuilder {\n    this.spec.options = { ...this.spec.options, name };\n    return this;\n  }\n\n  build(): LocatorSpec {\n    if (!this.spec.strategy || !this.spec.value) {\n      throw new Error('LocatorSpec requires strategy and value');\n    }\n    return this.spec as LocatorSpec;\n  }\n}\n\n/**\n * Builder for constructing ValueSpec\n */\nexport class ValueBuilder {\n  static literal(value: string): ValueSpec {\n    return { type: 'literal', value };\n  }\n\n  static actor(path: string): ValueSpec {\n    return { type: 'actor', value: path };\n  }\n\n  static runId(): ValueSpec {\n    return { type: 'runId', value: 'runId' };\n  }\n\n  static generated(template: string): ValueSpec {\n    return { type: 'generated', value: template };\n  }\n\n  static testData(path: string): ValueSpec {\n    return { type: 'testData', value: path };\n  }\n}\n\n/**\n * Builder for constructing IRStep\n */\nexport class StepBuilder {\n  private step: Partial<IRStep> = {\n    actions: [],\n    assertions: [],\n    notes: [],\n  };\n\n  constructor(id: string, description: string) {\n    this.step.id = id;\n    this.step.description = description;\n  }\n\n  sourceText(text: string): StepBuilder {\n    this.step.sourceText = text;\n    return this;\n  }\n\n  note(note: string): StepBuilder {\n    this.step.notes!.push(note);\n    return this;\n  }\n\n  // Navigation actions\n  goto(url: string, waitForLoad = true): StepBuilder {\n    this.step.actions!.push({ type: 'goto', url, waitForLoad });\n    return this;\n  }\n\n  waitForURL(pattern: string | RegExp): StepBuilder {\n    this.step.actions!.push({ type: 'waitForURL', pattern });\n    return this;\n  }\n\n  // Interaction actions\n  click(locator: LocatorSpec | LocatorBuilder): StepBuilder {\n    const spec = locator instanceof LocatorBuilder ? locator.build() : locator;\n    this.step.actions!.push({ type: 'click', locator: spec });\n    return this;\n  }\n\n  fill(locator: LocatorSpec | LocatorBuilder, value: ValueSpec | string): StepBuilder {\n    const spec = locator instanceof LocatorBuilder ? locator.build() : locator;\n    const valueSpec = typeof value === 'string' ? ValueBuilder.literal(value) : value;\n    this.step.actions!.push({ type: 'fill', locator: spec, value: valueSpec });\n    return this;\n  }\n\n  select(locator: LocatorSpec | LocatorBuilder, option: string): StepBuilder {\n    const spec = locator instanceof LocatorBuilder ? locator.build() : locator;\n    this.step.actions!.push({ type: 'select', locator: spec, option });\n    return this;\n  }\n\n  check(locator: LocatorSpec | LocatorBuilder): StepBuilder {\n    const spec = locator instanceof LocatorBuilder ? locator.build() : locator;\n    this.step.actions!.push({ type: 'check', locator: spec });\n    return this;\n  }\n\n  press(key: string, locator?: LocatorSpec | LocatorBuilder): StepBuilder {\n    const spec = locator\n      ? locator instanceof LocatorBuilder\n        ? locator.build()\n        : locator\n      : undefined;\n    this.step.actions!.push({ type: 'press', key, locator: spec });\n    return this;\n  }\n\n  // Assertions\n  expectVisible(\n    locator: LocatorSpec | LocatorBuilder,\n    timeout?: number\n  ): StepBuilder {\n    const spec = locator instanceof LocatorBuilder ? locator.build() : locator;\n    this.step.assertions!.push({ type: 'expectVisible', locator: spec, timeout });\n    return this;\n  }\n\n  expectNotVisible(\n    locator: LocatorSpec | LocatorBuilder,\n    timeout?: number\n  ): StepBuilder {\n    const spec = locator instanceof LocatorBuilder ? locator.build() : locator;\n    this.step.assertions!.push({ type: 'expectNotVisible', locator: spec, timeout });\n    return this;\n  }\n\n  expectText(\n    locator: LocatorSpec | LocatorBuilder,\n    text: string | RegExp,\n    timeout?: number\n  ): StepBuilder {\n    const spec = locator instanceof LocatorBuilder ? locator.build() : locator;\n    this.step.assertions!.push({ type: 'expectText', locator: spec, text, timeout });\n    return this;\n  }\n\n  expectURL(pattern: string | RegExp): StepBuilder {\n    this.step.assertions!.push({ type: 'expectURL', pattern });\n    return this;\n  }\n\n  expectTitle(title: string | RegExp): StepBuilder {\n    this.step.assertions!.push({ type: 'expectTitle', title });\n    return this;\n  }\n\n  expectToast(\n    toastType: 'success' | 'error' | 'info' | 'warning',\n    message?: string\n  ): StepBuilder {\n    this.step.assertions!.push({ type: 'expectToast', toastType, message });\n    return this;\n  }\n\n  // Module calls\n  callModule(module: string, method: string, args?: unknown[]): StepBuilder {\n    this.step.actions!.push({ type: 'callModule', module, method, args });\n    return this;\n  }\n\n  // Blocked step\n  blocked(reason: string, sourceText: string): StepBuilder {\n    this.step.actions!.push({ type: 'blocked', reason, sourceText });\n    return this;\n  }\n\n  // Raw primitive\n  action(primitive: IRPrimitive): StepBuilder {\n    this.step.actions!.push(primitive);\n    return this;\n  }\n\n  assertion(primitive: IRPrimitive): StepBuilder {\n    this.step.assertions!.push(primitive);\n    return this;\n  }\n\n  build(): IRStep {\n    if (!this.step.id || !this.step.description) {\n      throw new Error('IRStep requires id and description');\n    }\n    return this.step as IRStep;\n  }\n}\n\n/**\n * Builder for constructing IRJourney\n */\nexport class JourneyBuilder {\n  private journey: Partial<IRJourney> = {\n    tags: [],\n    steps: [],\n    moduleDependencies: { foundation: [], feature: [] },\n  };\n\n  constructor(id: string, title: string) {\n    this.journey.id = id;\n    this.journey.title = title;\n  }\n\n  tier(tier: JourneyTier): JourneyBuilder {\n    this.journey.tier = tier;\n    return this;\n  }\n\n  scope(scope: string): JourneyBuilder {\n    this.journey.scope = scope;\n    return this;\n  }\n\n  actor(actor: string): JourneyBuilder {\n    this.journey.actor = actor;\n    return this;\n  }\n\n  tag(tag: string): JourneyBuilder {\n    this.journey.tags!.push(tag);\n    return this;\n  }\n\n  tags(tags: string[]): JourneyBuilder {\n    this.journey.tags!.push(...tags);\n    return this;\n  }\n\n  foundationModule(module: string): JourneyBuilder {\n    this.journey.moduleDependencies!.foundation.push(module);\n    return this;\n  }\n\n  featureModule(module: string): JourneyBuilder {\n    this.journey.moduleDependencies!.feature.push(module);\n    return this;\n  }\n\n  modules(deps: ModuleDependencies): JourneyBuilder {\n    this.journey.moduleDependencies = deps;\n    return this;\n  }\n\n  data(config: JourneyDataConfig): JourneyBuilder {\n    this.journey.data = config;\n    return this;\n  }\n\n  completion(signals: CompletionSignal[]): JourneyBuilder {\n    this.journey.completion = signals;\n    return this;\n  }\n\n  setup(primitives: IRPrimitive[]): JourneyBuilder {\n    this.journey.setup = primitives;\n    return this;\n  }\n\n  step(step: IRStep | StepBuilder): JourneyBuilder {\n    const builtStep = step instanceof StepBuilder ? step.build() : step;\n    this.journey.steps!.push(builtStep);\n    return this;\n  }\n\n  cleanup(primitives: IRPrimitive[]): JourneyBuilder {\n    this.journey.cleanup = primitives;\n    return this;\n  }\n\n  revision(rev: number): JourneyBuilder {\n    this.journey.revision = rev;\n    return this;\n  }\n\n  sourcePath(path: string): JourneyBuilder {\n    this.journey.sourcePath = path;\n    return this;\n  }\n\n  build(): IRJourney {\n    if (\n      !this.journey.id ||\n      !this.journey.title ||\n      !this.journey.tier ||\n      !this.journey.scope ||\n      !this.journey.actor\n    ) {\n      throw new Error('IRJourney requires id, title, tier, scope, and actor');\n    }\n\n    // Add standard tags\n    const standardTags = [\n      '@artk',\n      '@journey',\n      `@${this.journey.id}`,\n      `@tier-${this.journey.tier}`,\n      `@scope-${this.journey.scope}`,\n    ];\n\n    const allTags = [...new Set([...standardTags, ...this.journey.tags!])];\n    this.journey.tags = allTags;\n\n    return this.journey as IRJourney;\n  }\n}\n\n/**\n * Convenience factory functions\n */\nexport const IR = {\n  journey: (id: string, title: string) => new JourneyBuilder(id, title),\n  step: (id: string, description: string) => new StepBuilder(id, description),\n  locator: {\n    role: LocatorBuilder.role,\n    label: LocatorBuilder.label,\n    placeholder: LocatorBuilder.placeholder,\n    text: LocatorBuilder.text,\n    testId: LocatorBuilder.testId,\n    css: LocatorBuilder.css,\n  },\n  value: ValueBuilder,\n};\n","/**\n * IR Serializer - Convert IR to JSON for debugging and analysis\n * @see research/2026-01-02_autogen-refined-plan.md Section 9\n */\nimport type { IRJourney, IRStep, IRPrimitive, LocatorSpec } from './types.js';\n\n/**\n * Options for IR serialization\n */\nexport interface SerializeOptions {\n  /** Include null/undefined values */\n  includeEmpty?: boolean;\n  /** Pretty print with indentation */\n  pretty?: boolean;\n  /** Indent size for pretty printing */\n  indent?: number;\n}\n\n/**\n * Serialize an IR Journey to JSON string\n */\nexport function serializeJourney(\n  journey: IRJourney,\n  options: SerializeOptions = {}\n): string {\n  const { pretty = true, indent = 2 } = options;\n\n  const cleaned = cleanObject(journey, options.includeEmpty ?? false);\n\n  return pretty\n    ? JSON.stringify(cleaned, null, indent)\n    : JSON.stringify(cleaned);\n}\n\n/**\n * Serialize an IR Step to JSON string\n */\nexport function serializeStep(\n  step: IRStep,\n  options: SerializeOptions = {}\n): string {\n  const { pretty = true, indent = 2 } = options;\n\n  const cleaned = cleanObject(step, options.includeEmpty ?? false);\n\n  return pretty\n    ? JSON.stringify(cleaned, null, indent)\n    : JSON.stringify(cleaned);\n}\n\n/**\n * Serialize an IR Primitive to JSON string\n */\nexport function serializePrimitive(\n  primitive: IRPrimitive,\n  options: SerializeOptions = {}\n): string {\n  const { pretty = true, indent = 2 } = options;\n\n  const cleaned = cleanObject(primitive, options.includeEmpty ?? false);\n\n  return pretty\n    ? JSON.stringify(cleaned, null, indent)\n    : JSON.stringify(cleaned);\n}\n\n/**\n * Convert a LocatorSpec to a human-readable description\n */\nexport function describeLocator(locator: LocatorSpec): string {\n  const { strategy, value, options } = locator;\n\n  switch (strategy) {\n    case 'role': {\n      let desc = `getByRole('${value}'`;\n      if (options?.name) {\n        desc += `, { name: '${options.name}'`;\n        if (options.exact) desc += ', exact: true';\n        if (options.level) desc += `, level: ${options.level}`;\n        desc += ' }';\n      }\n      desc += ')';\n      return desc;\n    }\n    case 'label':\n      return `getByLabel('${value}'${options?.exact ? ', { exact: true }' : ''})`;\n    case 'placeholder':\n      return `getByPlaceholder('${value}'${options?.exact ? ', { exact: true }' : ''})`;\n    case 'text':\n      return `getByText('${value}'${options?.exact ? ', { exact: true }' : ''})`;\n    case 'testid':\n      return `getByTestId('${value}')`;\n    case 'css':\n      return `locator('${value}')`;\n    default:\n      return `unknown('${value}')`;\n  }\n}\n\n/**\n * Convert an IR Primitive to a human-readable description\n */\nexport function describePrimitive(primitive: IRPrimitive): string {\n  switch (primitive.type) {\n    case 'goto':\n      return `Navigate to ${primitive.url}`;\n    case 'click':\n      return `Click ${describeLocator(primitive.locator)}`;\n    case 'fill':\n      return `Fill ${describeLocator(primitive.locator)} with \"${primitive.value.value}\"`;\n    case 'select':\n      return `Select \"${primitive.option}\" in ${describeLocator(primitive.locator)}`;\n    case 'check':\n      return `Check ${describeLocator(primitive.locator)}`;\n    case 'uncheck':\n      return `Uncheck ${describeLocator(primitive.locator)}`;\n    case 'press':\n      return `Press \"${primitive.key}\"`;\n    case 'hover':\n      return `Hover ${describeLocator(primitive.locator)}`;\n    case 'expectVisible':\n      return `Expect ${describeLocator(primitive.locator)} to be visible`;\n    case 'expectNotVisible':\n      return `Expect ${describeLocator(primitive.locator)} to be hidden`;\n    case 'expectText':\n      return `Expect ${describeLocator(primitive.locator)} to have text \"${primitive.text}\"`;\n    case 'expectURL':\n      return `Expect URL to match ${primitive.pattern}`;\n    case 'expectTitle':\n      return `Expect title to be \"${primitive.title}\"`;\n    case 'expectToast':\n      return `Expect ${primitive.toastType} toast${primitive.message ? `: \"${primitive.message}\"` : ''}`;\n    case 'callModule':\n      return `Call ${primitive.module}.${primitive.method}()`;\n    case 'blocked':\n      return `BLOCKED: ${primitive.reason}`;\n    case 'waitForURL':\n      return `Wait for URL to match ${primitive.pattern}`;\n    case 'waitForResponse':\n      return `Wait for response matching ${primitive.urlPattern}`;\n    case 'waitForLoadingComplete':\n      return `Wait for loading to complete`;\n    default:\n      return `Unknown primitive: ${(primitive as { type: string }).type}`;\n  }\n}\n\n/**\n * Generate a summary of an IR Journey\n */\nexport function summarizeJourney(journey: IRJourney): string {\n  const lines: string[] = [\n    `Journey: ${journey.id} - ${journey.title}`,\n    `  Tier: ${journey.tier}`,\n    `  Scope: ${journey.scope}`,\n    `  Actor: ${journey.actor}`,\n    `  Tags: ${journey.tags.join(', ')}`,\n    '',\n    `  Steps (${journey.steps.length}):`,\n  ];\n\n  for (const step of journey.steps) {\n    lines.push(`    ${step.id}: ${step.description}`);\n    lines.push(`      Actions: ${step.actions.length}`);\n    lines.push(`      Assertions: ${step.assertions.length}`);\n  }\n\n  if (journey.moduleDependencies.foundation.length > 0) {\n    lines.push('');\n    lines.push(`  Foundation Modules: ${journey.moduleDependencies.foundation.join(', ')}`);\n  }\n\n  if (journey.moduleDependencies.feature.length > 0) {\n    lines.push(`  Feature Modules: ${journey.moduleDependencies.feature.join(', ')}`);\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Remove null/undefined values from an object recursively\n */\nfunction cleanObject(obj: unknown, includeEmpty: boolean): unknown {\n  if (obj === null || obj === undefined) {\n    return includeEmpty ? obj : undefined;\n  }\n\n  if (Array.isArray(obj)) {\n    const cleaned = obj\n      .map((item) => cleanObject(item, includeEmpty))\n      .filter((item) => includeEmpty || item !== undefined);\n    return cleaned.length > 0 || includeEmpty ? cleaned : undefined;\n  }\n\n  if (typeof obj === 'object') {\n    const cleaned: Record<string, unknown> = {};\n    for (const [key, value] of Object.entries(obj)) {\n      const cleanedValue = cleanObject(value, includeEmpty);\n      if (includeEmpty || cleanedValue !== undefined) {\n        cleaned[key] = cleanedValue;\n      }\n    }\n    return Object.keys(cleaned).length > 0 || includeEmpty ? cleaned : undefined;\n  }\n\n  return obj;\n}\n","/**\n * Zod schema for autogen.config.yml\n * @see research/2026-01-02_autogen-refined-plan.md Section 7\n */\nimport { z } from 'zod';\n\n/**\n * Selector strategy types following Playwright priority\n */\nexport const SelectorStrategySchema = z.enum([\n  'role',\n  'label',\n  'placeholder',\n  'text',\n  'testid',\n  'css',\n]);\n\n/**\n * Path configuration for generated artifacts\n */\nexport const PathsSchema = z.object({\n  journeys: z.string().default('journeys'),\n  modules: z.string().default('e2e/modules'),\n  tests: z.string().default('e2e/tests'),\n  templates: z.string().default('artk/templates'),\n  catalog: z.string().default('artk/selectors'),\n});\n\n/**\n * ESLint rule severity\n */\nexport const EslintSeveritySchema = z.enum(['error', 'warn', 'off']);\n\n/**\n * ESLint rules configuration\n */\nexport const EslintRulesSchema = z.record(z.string(), EslintSeveritySchema).default({\n  'no-wait-for-timeout': 'error',\n  'no-force-option': 'error',\n  'prefer-web-first-assertions': 'error',\n});\n\n/**\n * Selector policy configuration\n */\nexport const SelectorPolicySchema = z.object({\n  priority: z.array(SelectorStrategySchema).default([\n    'role',\n    'label',\n    'placeholder',\n    'text',\n    'testid',\n    'css',\n  ]),\n  forbiddenPatterns: z.array(z.string()).default([]),\n});\n\n/**\n * Validation configuration\n */\nexport const ValidationSchema = z.object({\n  eslintRules: EslintRulesSchema.default({\n    'no-wait-for-timeout': 'error',\n    'no-force-option': 'error',\n    'prefer-web-first-assertions': 'error',\n  }),\n  customRules: z.array(z.string()).default([]),\n});\n\n/**\n * Healing configuration\n */\nexport const HealSchema = z.object({\n  enabled: z.boolean().default(true),\n  maxSuggestions: z.number().min(1).max(10).default(5),\n  skipPatterns: z.array(z.string()).default([]),\n});\n\n/**\n * Code regeneration strategy\n */\nexport const RegenerationStrategySchema = z.enum(['ast', 'blocks']).default('ast');\n\n/**\n * LLKB integration level\n * - minimal: Only load patterns, no glossary extension\n * - enhance: Load patterns and extend glossary (default)\n * - aggressive: Full LLKB integration with selector overrides\n */\nexport const LLKBIntegrationLevelSchema = z.enum(['minimal', 'enhance', 'aggressive']).default('enhance');\n\n/**\n * LLKB integration configuration (optional)\n * @see research/2026-01-23_llkb-autogen-integration-specification.md\n */\nexport const LLKBIntegrationSchema = z.object({\n  /** Enable LLKB integration */\n  enabled: z.boolean().default(false),\n\n  /** Path to LLKB-generated config file */\n  configPath: z.string().optional(),\n\n  /** Path to LLKB-generated glossary file */\n  glossaryPath: z.string().optional(),\n\n  /** Integration level */\n  level: LLKBIntegrationLevelSchema,\n}).default({});\n\n/**\n * Complete AutoGen configuration schema\n */\nexport const AutogenConfigSchema = z.object({\n  version: z.literal(1).default(1),\n  paths: PathsSchema.default({}),\n  selectorPolicy: SelectorPolicySchema.default({}),\n  validation: ValidationSchema.default({}),\n  heal: HealSchema.default({}),\n  regenerationStrategy: RegenerationStrategySchema,\n  llkb: LLKBIntegrationSchema,\n});\n\n/**\n * TypeScript types derived from schemas\n */\nexport type SelectorStrategy = z.infer<typeof SelectorStrategySchema>;\nexport type Paths = z.infer<typeof PathsSchema>;\nexport type EslintSeverity = z.infer<typeof EslintSeveritySchema>;\nexport type SelectorPolicy = z.infer<typeof SelectorPolicySchema>;\nexport type Validation = z.infer<typeof ValidationSchema>;\nexport type Heal = z.infer<typeof HealSchema>;\nexport type RegenerationStrategy = z.infer<typeof RegenerationStrategySchema>;\nexport type LLKBIntegrationLevel = z.infer<typeof LLKBIntegrationLevelSchema>;\nexport type LLKBIntegration = z.infer<typeof LLKBIntegrationSchema>;\nexport type AutogenConfig = z.infer<typeof AutogenConfigSchema>;\n","/**\n * Config loader for artk/autogen.config.yml\n * @see research/2026-01-02_autogen-refined-plan.md Section 7\n * @see research/2026-01-23_llkb-autogen-integration-specification.md (LLKB integration)\n */\nimport { readFileSync, existsSync } from 'node:fs';\nimport { join, resolve } from 'node:path';\nimport { parse as parseYaml } from 'yaml';\nimport { AutogenConfigSchema, type AutogenConfig } from './schema.js';\n\n/**\n * Default config file locations to search\n */\nconst CONFIG_PATHS = [\n  'artk/autogen.config.yml',\n  'artk/autogen.config.yaml',\n  '.artk/autogen.config.yml',\n  '.artk/autogen.config.yaml',\n];\n\n/**\n * Error thrown when config loading fails\n */\nexport class ConfigLoadError extends Error {\n  constructor(\n    message: string,\n    public readonly cause?: unknown // Preserved for error chaining, used by callers\n  ) {\n    super(message);\n    this.name = 'ConfigLoadError';\n    // Store cause in standard Error.cause property if supported\n    if (cause !== undefined) {\n      (this as { cause?: unknown }).cause = cause;\n    }\n  }\n}\n\n/**\n * Find the config file in the project\n */\nexport function findConfigFile(rootDir: string): string | null {\n  for (const configPath of CONFIG_PATHS) {\n    const fullPath = join(rootDir, configPath);\n    if (existsSync(fullPath)) {\n      return fullPath;\n    }\n  }\n  return null;\n}\n\n/**\n * Load and parse the autogen config file\n * @param configPath - Path to config file, or project root to auto-detect\n * @returns Parsed and validated config\n * @throws ConfigLoadError if config cannot be loaded or is invalid\n */\nexport function loadConfig(configPath?: string): AutogenConfig {\n  const rootDir = process.cwd();\n  let resolvedPath: string;\n\n  if (configPath) {\n    resolvedPath = resolve(rootDir, configPath);\n  } else {\n    const found = findConfigFile(rootDir);\n    if (!found) {\n      // Return default config if no file found\n      console.warn(\n        'No autogen config file found, using defaults. Create artk/autogen.config.yml to customize.'\n      );\n      return AutogenConfigSchema.parse({});\n    }\n    resolvedPath = found;\n  }\n\n  if (!existsSync(resolvedPath)) {\n    throw new ConfigLoadError(`Config file not found: ${resolvedPath}`);\n  }\n\n  let rawContent: string;\n  try {\n    rawContent = readFileSync(resolvedPath, 'utf-8');\n  } catch (err) {\n    throw new ConfigLoadError(`Failed to read config file: ${resolvedPath}`, err);\n  }\n\n  let parsed: unknown;\n  try {\n    parsed = parseYaml(rawContent);\n  } catch (err) {\n    throw new ConfigLoadError(`Invalid YAML in config file: ${resolvedPath}`, err);\n  }\n\n  // Validate with Zod schema\n  const result = AutogenConfigSchema.safeParse(parsed);\n  if (!result.success) {\n    const issues = result.error.issues\n      .map((i) => `  - ${i.path.join('.')}: ${i.message}`)\n      .join('\\n');\n    throw new ConfigLoadError(\n      `Invalid config in ${resolvedPath}:\\n${issues}`,\n      result.error\n    );\n  }\n\n  return result.data;\n}\n\n/**\n * Get the default config without loading from file\n */\nexport function getDefaultConfig(): AutogenConfig {\n  return AutogenConfigSchema.parse({});\n}\n\n/**\n * Resolve a path from config relative to project root\n */\nexport function resolveConfigPath(\n  config: AutogenConfig,\n  pathKey: keyof AutogenConfig['paths'],\n  rootDir?: string\n): string {\n  const base = rootDir || process.cwd();\n  return resolve(base, config.paths[pathKey]);\n}\n\n/**\n * Load a single config file without validation error handling\n * Used internally by loadConfigs for multi-config merging\n */\nfunction loadSingleConfig(configPath: string): AutogenConfig {\n  const resolvedPath = resolve(process.cwd(), configPath);\n\n  if (!existsSync(resolvedPath)) {\n    throw new ConfigLoadError(`Config file not found: ${resolvedPath}`);\n  }\n\n  let rawContent: string;\n  try {\n    rawContent = readFileSync(resolvedPath, 'utf-8');\n  } catch (err) {\n    throw new ConfigLoadError(`Failed to read config file: ${resolvedPath}`, err);\n  }\n\n  let parsed: unknown;\n  try {\n    parsed = parseYaml(rawContent);\n  } catch (err) {\n    throw new ConfigLoadError(`Invalid YAML in config file: ${resolvedPath}`, err);\n  }\n\n  const result = AutogenConfigSchema.safeParse(parsed);\n  if (!result.success) {\n    const issues = result.error.issues\n      .map((i) => `  - ${i.path.join('.')}: ${i.message}`)\n      .join('\\n');\n    throw new ConfigLoadError(\n      `Invalid config in ${resolvedPath}:\\n${issues}`,\n      result.error\n    );\n  }\n\n  return result.data;\n}\n\n/**\n * Deep merge helper for nested objects\n * Only merges properties that are explicitly defined (not undefined)\n */\nfunction deepMerge<T extends Record<string, unknown>>(base: T, override: Partial<T>): T {\n  const result = { ...base };\n\n  for (const key of Object.keys(override) as Array<keyof T>) {\n    const overrideValue = override[key];\n    if (overrideValue !== undefined) {\n      result[key] = overrideValue as T[keyof T];\n    }\n  }\n\n  return result;\n}\n\n/**\n * Merge multiple configs with later configs taking precedence\n * Arrays are merged additively for forbiddenPatterns, but overwritten for others\n * @see research/2026-01-23_llkb-autogen-integration-specification.md Round 2\n */\nexport function mergeConfigs(configs: AutogenConfig[]): AutogenConfig {\n  if (configs.length === 0) {\n    return getDefaultConfig();\n  }\n\n  // Start with first config, then merge subsequent configs into it\n  return configs.reduce((merged, config, index) => {\n    if (index === 0) {\n      return config;\n    }\n\n    return {\n      ...merged,\n      version: config.version ?? merged.version,\n      regenerationStrategy: config.regenerationStrategy ?? merged.regenerationStrategy,\n      paths: deepMerge(merged.paths, config.paths),\n      selectorPolicy: {\n        ...merged.selectorPolicy,\n        ...config.selectorPolicy,\n        // Merge arrays additively for forbiddenPatterns\n        forbiddenPatterns: [\n          ...new Set([\n            ...(merged.selectorPolicy?.forbiddenPatterns ?? []),\n            ...(config.selectorPolicy?.forbiddenPatterns ?? []),\n          ]),\n        ],\n        // Priority is overwritten if provided, not merged\n        priority: config.selectorPolicy?.priority?.length\n          ? config.selectorPolicy.priority\n          : merged.selectorPolicy?.priority,\n      },\n      validation: {\n        ...merged.validation,\n        ...config.validation,\n        eslintRules: {\n          ...merged.validation?.eslintRules,\n          ...config.validation?.eslintRules,\n        },\n        customRules: [\n          ...new Set([\n            ...(merged.validation?.customRules ?? []),\n            ...(config.validation?.customRules ?? []),\n          ]),\n        ],\n      },\n      heal: deepMerge(merged.heal, config.heal),\n      llkb: deepMerge(merged.llkb, config.llkb),\n    };\n  });\n}\n\n/**\n * Load and merge multiple config files\n * Later configs take precedence over earlier ones\n * @param configPaths - Array of config file paths to load and merge\n * @returns Merged config\n */\nexport function loadConfigs(configPaths: string[]): AutogenConfig {\n  const existingPaths = configPaths.filter((p) => {\n    const resolved = resolve(process.cwd(), p);\n    return existsSync(resolved);\n  });\n\n  if (existingPaths.length === 0) {\n    return getDefaultConfig();\n  }\n\n  const configs = existingPaths.map((p) => loadSingleConfig(p));\n  return mergeConfigs(configs);\n}\n\n/**\n * Load LLKB extension config if present\n * @param basePath - Base path to search for LLKB config\n * @returns Partial config or null if not found\n */\nexport function loadLLKBConfig(basePath: string): AutogenConfig | null {\n  const llkbConfigPaths = [\n    join(basePath, 'autogen-llkb.config.yml'),\n    join(basePath, 'autogen-llkb.config.yaml'),\n  ];\n\n  for (const llkbConfigPath of llkbConfigPaths) {\n    if (existsSync(llkbConfigPath)) {\n      try {\n        return loadSingleConfig(llkbConfigPath);\n      } catch {\n        // If LLKB config is invalid, return null rather than failing\n        console.warn(`Warning: Invalid LLKB config at ${llkbConfigPath}, skipping`);\n        return null;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Load config with automatic migration for backward compatibility (T009)\n *\n * This function ensures backward compatibility when the llkb field was added\n * to the AutogenConfig schema. Old configs without the llkb field will be\n * migrated to include it with default values.\n *\n * @param configPath - Path to config file, or project root to auto-detect\n * @returns Parsed config with llkb field guaranteed to exist\n *\n * @example\n * ```typescript\n * // Load config with automatic migration\n * const config = loadConfigWithMigration();\n * // config.llkb is guaranteed to exist (even for old configs)\n * ```\n */\nexport function loadConfigWithMigration(configPath?: string): AutogenConfig {\n  const config = loadConfig(configPath);\n\n  // Migration: Ensure llkb field exists\n  // The schema already has .default({}) but we add explicit migration\n  // for clarity and to handle edge cases where partial configs are loaded\n  if (config.llkb === undefined) {\n    config.llkb = {\n      enabled: false,\n      level: 'minimal',\n    };\n  }\n\n  return config;\n}\n\n/**\n * Check if a config needs migration\n *\n * @param config - Config to check\n * @returns True if migration is needed\n */\nexport function needsConfigMigration(config: unknown): boolean {\n  if (typeof config !== 'object' || config === null) {\n    return false;\n  }\n\n  const obj = config as Record<string, unknown>;\n\n  // Check if llkb field is missing or undefined\n  return obj.llkb === undefined;\n}\n\n/**\n * Get schema version from config\n *\n * This helps track which version of the schema a config file was created with.\n * Future schema changes can use this for more sophisticated migrations.\n *\n * @param config - Config object\n * @returns Schema version number\n */\nexport function getSchemaVersion(config: AutogenConfig): number {\n  return config.version;\n}\n","/**\n * Journey Frontmatter Zod Schema\n * @see research/2026-01-02_autogen-refined-plan.md Section 8\n */\nimport { z } from 'zod';\n\n/**\n * Journey status enum\n */\nexport const JourneyStatusSchema = z.enum([\n  'proposed',\n  'defined',\n  'clarified',\n  'implemented',\n  'quarantined',\n  'deprecated',\n]);\n\n/**\n * Journey tier enum\n */\nexport const JourneyTierSchema = z.enum(['smoke', 'release', 'regression']);\n\n/**\n * Data strategy enum\n */\nexport const DataStrategySchema = z.enum(['seed', 'create', 'reuse']);\n\n/**\n * Cleanup strategy enum\n */\nexport const CleanupStrategySchema = z.enum(['required', 'best-effort', 'none']);\n\n/**\n * Completion signal type enum\n */\nexport const CompletionTypeSchema = z.enum(['url', 'toast', 'element', 'text', 'title', 'api']);\n\n/**\n * Element state enum for completion signals\n */\nexport const ElementStateSchema = z.enum(['visible', 'hidden', 'attached', 'detached']);\n\n/**\n * Completion signal schema\n */\nexport const CompletionSignalSchema = z.object({\n  type: CompletionTypeSchema,\n  value: z.string().min(1, 'Completion signal value is required'),\n  options: z.object({\n    timeout: z.number().positive().optional(),\n    exact: z.boolean().optional(),\n    state: ElementStateSchema.optional(),\n    method: z.string().optional(),\n    status: z.number().int().positive().optional(),\n  }).optional(),\n});\n\n/**\n * Data configuration schema\n */\nexport const DataConfigSchema = z.object({\n  strategy: DataStrategySchema.default('create'),\n  cleanup: CleanupStrategySchema.default('best-effort'),\n});\n\n/**\n * Module dependencies schema\n */\nexport const ModulesSchema = z.object({\n  foundation: z.array(z.string()).default([]),\n  features: z.array(z.string()).default([]),\n});\n\n/**\n * Test reference schema\n */\nexport const TestRefSchema = z.object({\n  file: z.string(),\n  line: z.number().optional(),\n});\n\n/**\n * Link schema\n */\nexport const LinksSchema = z.object({\n  issues: z.array(z.string()).optional(),\n  prs: z.array(z.string()).optional(),\n  docs: z.array(z.string()).optional(),\n});\n\n/**\n * Negative path schema for error scenario testing\n */\nexport const NegativePathSchema = z.object({\n  name: z.string().min(1, 'Negative path name is required'),\n  input: z.record(z.any()),\n  expectedError: z.string().min(1, 'Expected error message is required'),\n  expectedElement: z.string().optional(),\n});\n\n/**\n * Visual regression configuration schema\n */\nexport const VisualRegressionSchema = z.object({\n  enabled: z.boolean(),\n  snapshots: z.array(z.string()).optional(),\n  threshold: z.number().min(0).max(1).optional(),\n});\n\n/**\n * Accessibility timing mode enum\n */\nexport const AccessibilityTimingSchema = z.enum(['afterEach', 'inTest']);\n\n/**\n * Accessibility configuration schema\n */\nexport const AccessibilitySchema = z.object({\n  enabled: z.boolean(),\n  rules: z.array(z.string()).optional(),\n  exclude: z.array(z.string()).optional(),\n  /**\n   * When to run accessibility checks:\n   * - 'afterEach': Run after each test (default, catches issues but doesn't fail individual tests)\n   * - 'inTest': Run within test steps (fails immediately, better for CI)\n   */\n  timing: AccessibilityTimingSchema.default('afterEach'),\n});\n\n/**\n * Performance budgets schema\n */\nexport const PerformanceSchema = z.object({\n  enabled: z.boolean(),\n  budgets: z\n    .object({\n      lcp: z.number().positive().optional(),\n      fid: z.number().positive().optional(),\n      cls: z.number().min(0).optional(),\n      ttfb: z.number().positive().optional(),\n    })\n    .optional(),\n  /** Timeout for collecting performance metrics in ms (default: 3000) */\n  collectTimeout: z.number().positive().optional(),\n});\n\n/**\n * Test data set schema for parameterized/data-driven tests\n */\nexport const TestDataSetSchema = z.object({\n  name: z.string().min(1, 'Test data set name is required'),\n  description: z.string().optional(),\n  data: z.record(z.string(), z.any()),\n});\n\n/**\n * Complete Journey frontmatter schema\n */\nexport const JourneyFrontmatterSchema = z.object({\n  id: z\n    .string()\n    .regex(/^JRN-\\d{4}$/, 'Journey ID must be in format JRN-XXXX'),\n  title: z.string().min(1, 'Title is required'),\n  status: JourneyStatusSchema,\n  tier: JourneyTierSchema,\n  scope: z.string().min(1, 'Scope is required'),\n  actor: z.string().min(1, 'Actor is required'),\n  revision: z.number().int().positive().default(1),\n  owner: z.string().optional(),\n  statusReason: z.string().optional(),\n  modules: ModulesSchema.default({ foundation: [], features: [] }),\n  tests: z.array(z.union([z.string(), TestRefSchema])).default([]),\n  data: DataConfigSchema.optional(),\n  completion: z.array(CompletionSignalSchema).optional(),\n  links: LinksSchema.optional(),\n  tags: z.array(z.string()).optional(),\n  flags: z\n    .object({\n      required: z.array(z.string()).optional(),\n      forbidden: z.array(z.string()).optional(),\n    })\n    .optional(),\n  prerequisites: z\n    .array(z.string())\n    .optional()\n    .describe('Array of Journey IDs that must run first'),\n  negativePaths: z\n    .array(NegativePathSchema)\n    .optional()\n    .describe('Error scenarios to test'),\n  testData: z\n    .array(TestDataSetSchema)\n    .optional()\n    .describe('Parameterized test data sets for data-driven testing'),\n  visualRegression: VisualRegressionSchema.optional(),\n  accessibility: AccessibilitySchema.optional(),\n  performance: PerformanceSchema.optional(),\n});\n\n/**\n * Schema specifically for clarified journeys (required for AutoGen)\n */\nexport const ClarifiedJourneyFrontmatterSchema = JourneyFrontmatterSchema.extend({\n  status: z.literal('clarified'),\n}).refine(\n  (data) => {\n    // Clarified journeys should have completion signals\n    return data.completion && data.completion.length > 0;\n  },\n  {\n    message: 'Clarified journeys must have at least one completion signal',\n    path: ['completion'],\n  }\n);\n\n/**\n * Schema for implemented journeys (must have tests)\n */\nexport const ImplementedJourneyFrontmatterSchema = JourneyFrontmatterSchema.extend({\n  status: z.literal('implemented'),\n}).refine(\n  (data) => {\n    return data.tests && data.tests.length > 0;\n  },\n  {\n    message: 'Implemented journeys must have at least one test reference',\n    path: ['tests'],\n  }\n);\n\n/**\n * Schema for quarantined journeys (must have owner and reason)\n */\nexport const QuarantinedJourneyFrontmatterSchema = JourneyFrontmatterSchema.extend({\n  status: z.literal('quarantined'),\n  owner: z.string().min(1, 'Quarantined journeys require an owner'),\n  statusReason: z.string().min(1, 'Quarantined journeys require a status reason'),\n}).refine(\n  (data) => {\n    return data.links?.issues && data.links.issues.length > 0;\n  },\n  {\n    message: 'Quarantined journeys must have at least one linked issue',\n    path: ['links', 'issues'],\n  }\n);\n\n/**\n * TypeScript types\n */\nexport type JourneyStatus = z.infer<typeof JourneyStatusSchema>;\nexport type JourneyTier = z.infer<typeof JourneyTierSchema>;\nexport type DataStrategy = z.infer<typeof DataStrategySchema>;\nexport type CleanupStrategy = z.infer<typeof CleanupStrategySchema>;\nexport type CompletionType = z.infer<typeof CompletionTypeSchema>;\nexport type CompletionSignal = z.infer<typeof CompletionSignalSchema>;\nexport type DataConfig = z.infer<typeof DataConfigSchema>;\nexport type Modules = z.infer<typeof ModulesSchema>;\nexport type TestRef = z.infer<typeof TestRefSchema>;\nexport type Links = z.infer<typeof LinksSchema>;\nexport type NegativePath = z.infer<typeof NegativePathSchema>;\nexport type TestDataSet = z.infer<typeof TestDataSetSchema>;\nexport type VisualRegression = z.infer<typeof VisualRegressionSchema>;\nexport type Accessibility = z.infer<typeof AccessibilitySchema>;\nexport type Performance = z.infer<typeof PerformanceSchema>;\nexport type JourneyFrontmatter = z.infer<typeof JourneyFrontmatterSchema>;\n\n/**\n * Validate that a journey is ready for AutoGen (must be clarified)\n */\nexport function validateForAutoGen(\n  frontmatter: JourneyFrontmatter\n): { valid: boolean; errors: string[] } {\n  const errors: string[] = [];\n\n  if (frontmatter.status !== 'clarified') {\n    errors.push(\n      `Journey status must be \"clarified\" for AutoGen, got \"${frontmatter.status}\"`\n    );\n  }\n\n  if (!frontmatter.completion || frontmatter.completion.length === 0) {\n    errors.push('Journey must have completion signals defined');\n  }\n\n  if (!frontmatter.actor) {\n    errors.push('Journey must have an actor defined');\n  }\n\n  if (!frontmatter.scope) {\n    errors.push('Journey must have a scope defined');\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n","/**\n * Step Mapping Patterns - Regex patterns for parsing step text into IR primitives\n * @see research/2026-01-02_autogen-refined-plan.md Section 10\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md Phase 3\n */\nimport type { IRPrimitive, LocatorSpec, ValueSpec, LocatorStrategy } from '../ir/types.js';\n\n/**\n * Pattern version - increment when patterns change\n * Format: MAJOR.MINOR.PATCH\n * - MAJOR: Breaking changes to pattern behavior\n * - MINOR: New patterns added\n * - PATCH: Bug fixes to existing patterns\n */\nexport const PATTERN_VERSION = '1.1.0';\n\n/**\n * Pattern metadata for tracking\n */\nexport interface PatternMetadata {\n  name: string;\n  version: string;\n  addedDate: string;\n  source: 'core' | 'llkb' | 'telemetry';\n  category: string;\n}\n\n/**\n * Pattern result with match groups\n */\nexport interface PatternMatch {\n  type: IRPrimitive['type'];\n  groups: Record<string, string>;\n}\n\n/**\n * Pattern definition\n */\nexport interface StepPattern {\n  /** Pattern name for debugging */\n  name: string;\n  /** Regex pattern with named groups */\n  regex: RegExp;\n  /** IR primitive type this pattern produces */\n  primitiveType: IRPrimitive['type'];\n  /** Extract IR primitive from match (prefix with _ if unused) */\n  extract: (_match: RegExpMatchArray) => IRPrimitive | null;\n}\n\n/**\n * Create a locator spec from pattern match\n */\nexport function createLocatorFromMatch(\n  strategy: LocatorStrategy,\n  value: string,\n  name?: string\n): LocatorSpec {\n  const locator: LocatorSpec = { strategy, value };\n  if (name) {\n    locator.options = { name };\n  }\n  return locator;\n}\n\n/**\n * Create a value spec from text\n */\nexport function createValueFromText(text: string): ValueSpec {\n  // Actor reference: {{email}}, {{password}}, etc.\n  if (/^\\{\\{.+\\}\\}$/.test(text)) {\n    const path = text.slice(2, -2).trim();\n    return { type: 'actor', value: path };\n  }\n\n  // Test data reference: $user.email, $testData.field\n  if (/^\\$.+/.test(text)) {\n    return { type: 'testData', value: text.slice(1) };\n  }\n\n  // Generated value: ${runId}, ${timestamp}\n  if (/\\$\\{.+\\}/.test(text)) {\n    return { type: 'generated', value: text };\n  }\n\n  // Literal value\n  return { type: 'literal', value: text };\n}\n\n/**\n * Navigation patterns\n */\nexport const navigationPatterns: StepPattern[] = [\n  {\n    name: 'navigate-to-url',\n    regex: /^(?:user\\s+)?(?:navigates?|go(?:es)?|opens?)\\s+(?:to\\s+)?(?:the\\s+)?[\"']?([^\"'\\s]+)[\"']?$/i,\n    primitiveType: 'goto',\n    extract: (match) => ({\n      type: 'goto',\n      url: match[1]!,\n      waitForLoad: true,\n    }),\n  },\n  {\n    name: 'navigate-to-page',\n    regex: /^(?:user\\s+)?(?:navigates?|go(?:es)?|opens?)\\s+(?:to\\s+)?(?:the\\s+)?(.+?)\\s+page$/i,\n    primitiveType: 'goto',\n    extract: (match) => ({\n      type: 'goto',\n      url: `/${match[1]!.toLowerCase().replace(/\\s+/g, '-')}`,\n      waitForLoad: true,\n    }),\n  },\n];\n\n/**\n * Click patterns\n */\nexport const clickPatterns: StepPattern[] = [\n  {\n    name: 'click-button-quoted',\n    regex: /^(?:user\\s+)?(?:clicks?|presses?|taps?)\\s+(?:on\\s+)?(?:the\\s+)?[\"']([^\"']+)[\"']\\s+button$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('role', 'button', match[1]!),\n    }),\n  },\n  {\n    name: 'click-link-quoted',\n    regex: /^(?:user\\s+)?(?:clicks?|presses?|taps?)\\s+(?:on\\s+)?(?:the\\s+)?[\"']([^\"']+)[\"']\\s+link$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('role', 'link', match[1]!),\n    }),\n  },\n  {\n    name: 'click-element-quoted',\n    regex: /^(?:user\\s+)?(?:clicks?|presses?|taps?)\\s+(?:on\\s+)?(?:the\\s+)?[\"']([^\"']+)[\"']$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'click-element-generic',\n    regex: /^(?:user\\s+)?(?:clicks?|presses?|taps?)\\s+(?:on\\s+)?(?:the\\s+)?(.+?)\\s+(?:button|link|icon|menu|tab)$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n];\n\n/**\n * Fill/Input patterns\n */\nexport const fillPatterns: StepPattern[] = [\n  {\n    name: 'fill-field-quoted-value',\n    regex: /^(?:user\\s+)?(?:enters?|types?|fills?\\s+in?|inputs?)\\s+[\"']([^\"']+)[\"']\\s+(?:in|into)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']\\s*(?:field|input)?$/i,\n    primitiveType: 'fill',\n    extract: (match) => ({\n      type: 'fill',\n      locator: createLocatorFromMatch('label', match[2]!),\n      value: createValueFromText(match[1]!),\n    }),\n  },\n  {\n    name: 'fill-field-actor-value',\n    regex: /^(?:user\\s+)?(?:enters?|types?|fills?\\s+in?|inputs?)\\s+(\\{\\{[^}]+\\}\\})\\s+(?:in|into)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']\\s*(?:field|input)?$/i,\n    primitiveType: 'fill',\n    extract: (match) => ({\n      type: 'fill',\n      locator: createLocatorFromMatch('label', match[2]!),\n      value: createValueFromText(match[1]!),\n    }),\n  },\n  {\n    name: 'fill-field-generic',\n    regex: /^(?:user\\s+)?(?:enters?|types?|fills?\\s+in?|inputs?)\\s+(.+?)\\s+(?:in|into)\\s+(?:the\\s+)?(.+?)\\s*(?:field|input)?$/i,\n    primitiveType: 'fill',\n    extract: (match) => ({\n      type: 'fill',\n      locator: createLocatorFromMatch('label', match[2]!.replace(/[\"']/g, '')),\n      value: createValueFromText(match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n];\n\n/**\n * Select patterns\n */\nexport const selectPatterns: StepPattern[] = [\n  {\n    name: 'select-option',\n    regex: /^(?:user\\s+)?(?:selects?|chooses?)\\s+[\"']([^\"']+)[\"']\\s+(?:from|in)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']\\s*(?:dropdown|select|menu)?$/i,\n    primitiveType: 'select',\n    extract: (match) => ({\n      type: 'select',\n      locator: createLocatorFromMatch('label', match[2]!),\n      option: match[1]!,\n    }),\n  },\n];\n\n/**\n * Check/Uncheck patterns\n */\nexport const checkPatterns: StepPattern[] = [\n  {\n    name: 'check-checkbox',\n    regex: /^(?:user\\s+)?(?:checks?|enables?|ticks?)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']\\s*(?:checkbox|option)?$/i,\n    primitiveType: 'check',\n    extract: (match) => ({\n      type: 'check',\n      locator: createLocatorFromMatch('label', match[1]!),\n    }),\n  },\n  {\n    name: 'uncheck-checkbox',\n    regex: /^(?:user\\s+)?(?:unchecks?|disables?|unticks?)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']\\s*(?:checkbox|option)?$/i,\n    primitiveType: 'uncheck',\n    extract: (match) => ({\n      type: 'uncheck',\n      locator: createLocatorFromMatch('label', match[1]!),\n    }),\n  },\n];\n\n/**\n * Visibility assertion patterns\n */\nexport const visibilityPatterns: StepPattern[] = [\n  {\n    name: 'should-see-text',\n    regex: /^(?:user\\s+)?(?:should\\s+)?(?:sees?|views?)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'is-visible',\n    regex: /^[\"']?([^\"']+)[\"']?\\s+(?:is\\s+)?(?:visible|displayed|shown)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'should-see-element',\n    regex: /^(?:user\\s+)?(?:should\\s+)?(?:sees?|views?)\\s+(?:the\\s+)?(.+?)\\s+(?:heading|button|link|form|page|element)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'page-displayed',\n    regex: /^(?:the\\s+)?(.+?)\\s+(?:page|screen|view)\\s+(?:is\\s+)?(?:displayed|shown|visible)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n];\n\n/**\n * Toast/notification patterns\n */\nexport const toastPatterns: StepPattern[] = [\n  {\n    name: 'success-toast-message',\n    regex: /^(?:a\\s+)?success\\s+toast\\s+(?:with\\s+)?[\"']([^\"']+)[\"']\\s*(?:message\\s+)?(?:appears?|is\\s+shown|displays?)$/i,\n    primitiveType: 'expectToast',\n    extract: (match) => ({\n      type: 'expectToast',\n      toastType: 'success',\n      message: match[1]!,\n    }),\n  },\n  {\n    name: 'error-toast-message',\n    regex: /^(?:an?\\s+)?error\\s+toast\\s+(?:with\\s+)?[\"']([^\"']+)[\"']\\s*(?:message\\s+)?(?:appears?|is\\s+shown|displays?)$/i,\n    primitiveType: 'expectToast',\n    extract: (match) => ({\n      type: 'expectToast',\n      toastType: 'error',\n      message: match[1]!,\n    }),\n  },\n  {\n    name: 'toast-appears',\n    regex: /^(?:a\\s+)?(success|error|info|warning)\\s+toast\\s+(?:appears?|is\\s+shown|displays?)$/i,\n    primitiveType: 'expectToast',\n    extract: (match) => ({\n      type: 'expectToast',\n      toastType: match[1]!.toLowerCase() as 'success' | 'error' | 'info' | 'warning',\n    }),\n  },\n  {\n    name: 'toast-with-text',\n    regex: /^(?:toast|notification)\\s+(?:with\\s+)?[\"']([^\"']+)[\"']\\s+(?:appears?|is\\s+shown|displays?)$/i,\n    primitiveType: 'expectToast',\n    extract: (match) => ({\n      type: 'expectToast',\n      toastType: 'info',\n      message: match[1]!,\n    }),\n  },\n];\n\n/**\n * URL assertion patterns\n */\nexport const urlPatterns: StepPattern[] = [\n  {\n    name: 'url-contains',\n    regex: /^(?:the\\s+)?url\\s+(?:should\\s+)?(?:contains?|includes?)\\s+[\"']?([^\"'\\s]+)[\"']?$/i,\n    primitiveType: 'expectURL',\n    extract: (match) => ({\n      type: 'expectURL',\n      pattern: match[1]!,\n    }),\n  },\n  {\n    name: 'url-is',\n    regex: /^(?:the\\s+)?url\\s+(?:should\\s+)?(?:is|equals?|be)\\s+[\"']?([^\"'\\s]+)[\"']?$/i,\n    primitiveType: 'expectURL',\n    extract: (match) => ({\n      type: 'expectURL',\n      pattern: match[1]!,\n    }),\n  },\n  {\n    name: 'redirected-to',\n    regex: /^(?:user\\s+)?(?:is\\s+)?redirected\\s+to\\s+[\"']?([^\"'\\s]+)[\"']?$/i,\n    primitiveType: 'expectURL',\n    extract: (match) => ({\n      type: 'expectURL',\n      pattern: match[1]!,\n    }),\n  },\n];\n\n/**\n * Module call patterns (authentication)\n */\nexport const authPatterns: StepPattern[] = [\n  {\n    name: 'user-login',\n    regex: /^(?:user\\s+)?(?:logs?\\s*in|login\\s+is\\s+performed|authenticates?)$/i,\n    primitiveType: 'callModule',\n    extract: (_match) => ({\n      type: 'callModule',\n      module: 'auth',\n      method: 'login',\n    }),\n  },\n  {\n    name: 'user-logout',\n    regex: /^(?:user\\s+)?(?:logs?\\s*out|logout\\s+is\\s+performed|signs?\\s*out)$/i,\n    primitiveType: 'callModule',\n    extract: (_match) => ({\n      type: 'callModule',\n      module: 'auth',\n      method: 'logout',\n    }),\n  },\n  {\n    name: 'login-as-role',\n    regex: /^(?:user\\s+)?logs?\\s*in\\s+as\\s+(?:an?\\s+)?(.+?)(?:\\s+user)?$/i,\n    primitiveType: 'callModule',\n    extract: (match) => ({\n      type: 'callModule',\n      module: 'auth',\n      method: 'loginAs',\n      args: [match[1]!.toLowerCase()],\n    }),\n  },\n];\n\n/**\n * Wait patterns\n */\nexport const waitPatterns: StepPattern[] = [\n  {\n    name: 'wait-for-navigation',\n    regex: /^(?:user\\s+)?(?:waits?\\s+)?(?:for\\s+)?navigation\\s+to\\s+[\"']?([^\"'\\s]+)[\"']?$/i,\n    primitiveType: 'waitForURL',\n    extract: (match) => ({\n      type: 'waitForURL',\n      pattern: match[1]!,\n    }),\n  },\n  {\n    name: 'wait-for-page',\n    regex: /^(?:user\\s+)?(?:waits?\\s+)?(?:for\\s+)?(?:the\\s+)?(.+?)\\s+(?:page|screen)\\s+to\\s+load$/i,\n    primitiveType: 'waitForLoadingComplete',\n    extract: (_match) => ({\n      type: 'waitForLoadingComplete',\n    }),\n  },\n];\n\n/**\n * Helper function to convert natural language selectors to Playwright locator strategies\n */\nexport function parseSelectorToLocator(selector: string): { strategy: LocatorStrategy; value: string; name?: string } {\n  // Remove leading \"the\" if present\n  let cleanSelector = selector.replace(/^the\\s+/i, '').trim();\n\n  // Match button patterns\n  if (/button$/i.test(cleanSelector)) {\n    const buttonName = cleanSelector.replace(/\\s*button$/i, '').trim();\n    return { strategy: 'role', value: 'button', name: buttonName };\n  }\n\n  // Match link patterns\n  if (/link$/i.test(cleanSelector)) {\n    const linkName = cleanSelector.replace(/\\s*link$/i, '').trim();\n    return { strategy: 'role', value: 'link', name: linkName };\n  }\n\n  // Match input/field patterns\n  if (/(?:input|field)$/i.test(cleanSelector)) {\n    const labelName = cleanSelector.replace(/\\s*(?:input|field)$/i, '').trim();\n    return { strategy: 'label', value: labelName };\n  }\n\n  // Default to text locator\n  return { strategy: 'text', value: cleanSelector };\n}\n\n/**\n * Structured step patterns for Journey markdown format\n * Matches patterns like:\n * - **Action**: Click the login button\n * - **Wait for**: Dashboard to load\n * - **Assert**: User name is visible\n */\nexport const structuredPatterns: StepPattern[] = [\n  // Action patterns\n  {\n    name: 'structured-action-click',\n    regex: /^\\*\\*Action\\*\\*:\\s*[Cc]lick\\s+(?:the\\s+)?['\"]?(.+?)['\"]?\\s*(?:button|link)?$/i,\n    primitiveType: 'click',\n    extract: (match) => {\n      const target = match[1]!;\n      const locatorInfo = parseSelectorToLocator(target + ' button');\n      return {\n        type: 'click',\n        locator: locatorInfo.name\n          ? createLocatorFromMatch(locatorInfo.strategy, locatorInfo.value, locatorInfo.name)\n          : { strategy: locatorInfo.strategy, value: locatorInfo.value },\n      };\n    },\n  },\n  {\n    name: 'structured-action-fill',\n    regex: /^\\*\\*Action\\*\\*:\\s*[Ff]ill\\s+(?:in\\s+)?['\"]?(.+?)['\"]?\\s+with\\s+['\"]?(.+?)['\"]?$/i,\n    primitiveType: 'fill',\n    extract: (match) => {\n      const target = match[1]!;\n      const value = match[2]!;\n      const locatorInfo = parseSelectorToLocator(target);\n      return {\n        type: 'fill',\n        locator: locatorInfo.name\n          ? createLocatorFromMatch(locatorInfo.strategy, locatorInfo.value, locatorInfo.name)\n          : { strategy: locatorInfo.strategy, value: locatorInfo.value },\n        value: createValueFromText(value),\n      };\n    },\n  },\n  {\n    name: 'structured-action-navigate',\n    regex: /^\\*\\*Action\\*\\*:\\s*[Nn]avigate\\s+to\\s+['\"]?(.+?)['\"]?$/i,\n    primitiveType: 'goto',\n    extract: (match) => ({\n      type: 'goto',\n      url: match[1]!,\n      waitForLoad: true,\n    }),\n  },\n\n  // Wait patterns\n  {\n    name: 'structured-wait-for-visible',\n    regex: /^\\*\\*Wait for\\*\\*:\\s*(.+?)\\s+(?:to\\s+)?(?:be\\s+)?(?:visible|appear|load)/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => {\n      const target = match[1]!;\n      const locatorInfo = parseSelectorToLocator(target);\n      return {\n        type: 'expectVisible',\n        locator: locatorInfo.name\n          ? createLocatorFromMatch(locatorInfo.strategy, locatorInfo.value, locatorInfo.name)\n          : { strategy: locatorInfo.strategy, value: locatorInfo.value },\n      };\n    },\n  },\n\n  // Assert patterns\n  {\n    name: 'structured-assert-visible',\n    regex: /^\\*\\*Assert\\*\\*:\\s*(.+?)\\s+(?:is\\s+)?visible$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => {\n      const target = match[1]!;\n      const locatorInfo = parseSelectorToLocator(target);\n      return {\n        type: 'expectVisible',\n        locator: locatorInfo.name\n          ? createLocatorFromMatch(locatorInfo.strategy, locatorInfo.value, locatorInfo.name)\n          : { strategy: locatorInfo.strategy, value: locatorInfo.value },\n      };\n    },\n  },\n  {\n    name: 'structured-assert-text',\n    regex: /^\\*\\*Assert\\*\\*:\\s*(.+?)\\s+(?:contains|has text)\\s+['\"]?(.+?)['\"]?$/i,\n    primitiveType: 'expectText',\n    extract: (match) => {\n      const target = match[1]!;\n      const text = match[2]!;\n      const locatorInfo = parseSelectorToLocator(target);\n      return {\n        type: 'expectText',\n        locator: locatorInfo.name\n          ? createLocatorFromMatch(locatorInfo.strategy, locatorInfo.value, locatorInfo.name)\n          : { strategy: locatorInfo.strategy, value: locatorInfo.value },\n        text,\n      };\n    },\n  },\n];\n\n/**\n * Extended click patterns - Common variations missed by core patterns\n * Added in v1.1.0 based on telemetry analysis\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md Phase 3\n */\nexport const extendedClickPatterns: StepPattern[] = [\n  {\n    name: 'click-on-element',\n    // \"Click on Submit\" or \"Click on the Submit button\"\n    regex: /^(?:user\\s+)?clicks?\\s+on\\s+(?:the\\s+)?(.+?)(?:\\s+button|\\s+link)?$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('text', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n  {\n    name: 'press-enter-key',\n    // \"Press Enter\" or \"Press the Enter key\" or \"Hit Enter\"\n    regex: /^(?:user\\s+)?(?:press(?:es)?|hits?)\\s+(?:the\\s+)?(?:enter|return)(?:\\s+key)?$/i,\n    primitiveType: 'press',\n    extract: () => ({\n      type: 'press',\n      key: 'Enter',\n    }),\n  },\n  {\n    name: 'press-tab-key',\n    // \"Press Tab\" or \"Press the Tab key\"\n    regex: /^(?:user\\s+)?(?:press(?:es)?|hits?)\\s+(?:the\\s+)?tab(?:\\s+key)?$/i,\n    primitiveType: 'press',\n    extract: () => ({\n      type: 'press',\n      key: 'Tab',\n    }),\n  },\n  {\n    name: 'press-escape-key',\n    // \"Press Escape\" or \"Press Esc\"\n    regex: /^(?:user\\s+)?(?:press(?:es)?|hits?)\\s+(?:the\\s+)?(?:escape|esc)(?:\\s+key)?$/i,\n    primitiveType: 'press',\n    extract: () => ({\n      type: 'press',\n      key: 'Escape',\n    }),\n  },\n  {\n    name: 'double-click',\n    // \"Double click on\" or \"Double-click the\"\n    regex: /^(?:user\\s+)?double[-\\s]?clicks?\\s+(?:on\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?$/i,\n    primitiveType: 'dblclick',\n    extract: (match) => ({\n      type: 'dblclick',\n      locator: createLocatorFromMatch('text', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n  {\n    name: 'right-click',\n    // \"Right click on\" or \"Right-click the\"\n    regex: /^(?:user\\s+)?right[-\\s]?clicks?\\s+(?:on\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?$/i,\n    primitiveType: 'rightClick',\n    extract: (match) => ({\n      type: 'rightClick',\n      locator: createLocatorFromMatch('text', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n  {\n    name: 'submit-form',\n    // \"Submit the form\" or \"Submits form\"\n    regex: /^(?:user\\s+)?submits?\\s+(?:the\\s+)?form$/i,\n    primitiveType: 'click',\n    extract: () => ({\n      type: 'click',\n      locator: createLocatorFromMatch('role', 'button', 'Submit'),\n    }),\n  },\n];\n\n/**\n * Extended fill patterns - Common variations missed by core patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const extendedFillPatterns: StepPattern[] = [\n  {\n    name: 'type-into-field',\n    // \"Type 'password' into the Password field\"\n    regex: /^(?:user\\s+)?types?\\s+['\"](.+?)['\"]\\s+into\\s+(?:the\\s+)?[\"']?(.+?)[\"']?\\s*(?:field|input)?$/i,\n    primitiveType: 'fill',\n    extract: (match) => ({\n      type: 'fill',\n      locator: createLocatorFromMatch('label', match[2]!),\n      value: createValueFromText(match[1]!),\n    }),\n  },\n  {\n    name: 'fill-in-field-no-value',\n    // \"Fill in the email address\" (without explicit value - uses actor data)\n    regex: /^(?:user\\s+)?fills?\\s+in\\s+(?:the\\s+)?[\"']?(.+?)[\"']?\\s*(?:field|input)?$/i,\n    primitiveType: 'fill',\n    extract: (match) => {\n      const fieldName = match[1]!.replace(/[\"']/g, '');\n      return {\n        type: 'fill',\n        locator: createLocatorFromMatch('label', fieldName),\n        value: { type: 'actor', value: fieldName.toLowerCase().replace(/\\s+/g, '_') },\n      };\n    },\n  },\n  {\n    name: 'clear-field',\n    // \"Clear the email field\" or \"Clears the input\"\n    regex: /^(?:user\\s+)?clears?\\s+(?:the\\s+)?[\"']?(.+?)[\"']?\\s*(?:field|input)?$/i,\n    primitiveType: 'clear',\n    extract: (match) => ({\n      type: 'clear',\n      locator: createLocatorFromMatch('label', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n  {\n    name: 'set-value',\n    // \"Set the value to 'test'\" or \"Sets field to 'value'\"\n    regex: /^(?:user\\s+)?sets?\\s+(?:the\\s+)?(?:value\\s+)?(?:of\\s+)?[\"']?(.+?)[\"']?\\s+to\\s+['\"](.+?)['\"]$/i,\n    primitiveType: 'fill',\n    extract: (match) => ({\n      type: 'fill',\n      locator: createLocatorFromMatch('label', match[1]!),\n      value: createValueFromText(match[2]!),\n    }),\n  },\n];\n\n/**\n * Extended assertion patterns - Common variations missed by core patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const extendedAssertionPatterns: StepPattern[] = [\n  {\n    name: 'verify-element-showing',\n    // \"Verify the dashboard is showing/displayed\"\n    regex: /^(?:verify|confirm|ensure)\\s+(?:that\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:is\\s+)?(?:showing|displayed|visible)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'page-should-show',\n    // \"The page should show 'Welcome'\" or \"Page should display 'text'\"\n    regex: /^(?:the\\s+)?page\\s+should\\s+(?:show|display|contain)\\s+['\"](.+?)['\"]$/i,\n    primitiveType: 'expectText',\n    extract: (match) => ({\n      type: 'expectText',\n      locator: { strategy: 'role', value: 'main' },\n      text: match[1]!,\n    }),\n  },\n  {\n    name: 'make-sure-assertion',\n    // \"Make sure the button is visible\" or \"Make sure user sees 'text'\"\n    regex: /^make\\s+sure\\s+(?:that\\s+)?(?:the\\s+)?(.+?)\\s+(?:is\\s+)?(?:visible|displayed|shown)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'confirm-that-assertion',\n    // \"Confirm that the message appears\" or \"Confirm the error is shown\"\n    regex: /^confirm\\s+(?:that\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:appears?|is\\s+shown|displays?)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'check-element-exists',\n    // \"Check that the element exists\" or \"Check the button is present\"\n    regex: /^check\\s+(?:that\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:exists?|is\\s+present)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'element-should-not-be-visible',\n    // \"The error should not be visible\" or \"Error message is not displayed\"\n    regex: /^(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:should\\s+)?(?:not\\s+be|is\\s+not)\\s+(?:visible|displayed|shown)$/i,\n    primitiveType: 'expectHidden',\n    extract: (match) => ({\n      type: 'expectHidden',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'element-contains-text',\n    // \"The header contains 'Welcome'\" or \"Element should contain 'text'\"\n    regex: /^(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:should\\s+)?contains?\\s+['\"](.+?)['\"]$/i,\n    primitiveType: 'expectText',\n    extract: (match) => ({\n      type: 'expectText',\n      locator: createLocatorFromMatch('text', match[1]!),\n      text: match[2]!,\n    }),\n  },\n];\n\n/**\n * Extended wait patterns - Common variations missed by core patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const extendedWaitPatterns: StepPattern[] = [\n  {\n    name: 'wait-for-element-visible',\n    // \"Wait for the loading spinner to disappear\"\n    regex: /^(?:user\\s+)?waits?\\s+(?:for\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+to\\s+(?:disappear|be\\s+hidden)$/i,\n    primitiveType: 'waitForHidden',\n    extract: (match) => ({\n      type: 'waitForHidden',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'wait-for-element-appear',\n    // \"Wait for the modal to appear\" or \"Wait for dialog to show\"\n    regex: /^(?:user\\s+)?waits?\\s+(?:for\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+to\\s+(?:appear|show|be\\s+visible)$/i,\n    primitiveType: 'waitForVisible',\n    extract: (match) => ({\n      type: 'waitForVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'wait-until-loaded',\n    // \"Wait until the page is loaded\" or \"Wait until content loads\"\n    regex: /^(?:user\\s+)?waits?\\s+until\\s+(?:the\\s+)?(?:page|content|data)\\s+(?:is\\s+)?loaded$/i,\n    primitiveType: 'waitForLoadingComplete',\n    extract: () => ({\n      type: 'waitForLoadingComplete',\n    }),\n  },\n  {\n    name: 'wait-seconds',\n    // \"Wait for 2 seconds\" or \"Wait 3 seconds\"\n    regex: /^(?:user\\s+)?waits?\\s+(?:for\\s+)?(\\d+)\\s+seconds?$/i,\n    primitiveType: 'waitForTimeout',\n    extract: (match) => ({\n      type: 'waitForTimeout',\n      ms: parseInt(match[1]!, 10) * 1000,\n    }),\n  },\n  {\n    name: 'wait-for-network',\n    // \"Wait for network to be idle\" or \"Wait for network idle\"\n    regex: /^(?:user\\s+)?waits?\\s+(?:for\\s+)?(?:the\\s+)?network\\s+(?:to\\s+be\\s+)?idle$/i,\n    primitiveType: 'waitForNetworkIdle',\n    extract: () => ({\n      type: 'waitForNetworkIdle',\n    }),\n  },\n];\n\n/**\n * Extended navigation patterns - Common variations missed by core patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const extendedNavigationPatterns: StepPattern[] = [\n  {\n    name: 'refresh-page',\n    // \"Refresh the page\" or \"Reload the page\"\n    regex: /^(?:user\\s+)?(?:refresh(?:es)?|reloads?)\\s+(?:the\\s+)?page$/i,\n    primitiveType: 'reload',\n    extract: () => ({\n      type: 'reload',\n    }),\n  },\n  {\n    name: 'go-back',\n    // \"Go back\" or \"Navigate back\" or \"User goes back\"\n    regex: /^(?:user\\s+)?(?:go(?:es)?|navigates?)\\s+back$/i,\n    primitiveType: 'goBack',\n    extract: () => ({\n      type: 'goBack',\n    }),\n  },\n  {\n    name: 'go-forward',\n    // \"Go forward\" or \"Navigate forward\"\n    regex: /^(?:user\\s+)?(?:go(?:es)?|navigates?)\\s+forward$/i,\n    primitiveType: 'goForward',\n    extract: () => ({\n      type: 'goForward',\n    }),\n  },\n];\n\n/**\n * Extended select/dropdown patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const extendedSelectPatterns: StepPattern[] = [\n  {\n    name: 'select-from-dropdown',\n    // \"Select 'Option' from dropdown\" or \"Choose 'Value' from the dropdown\"\n    regex: /^(?:user\\s+)?(?:selects?|chooses?)\\s+['\"](.+?)['\"]\\s+from\\s+(?:the\\s+)?dropdown$/i,\n    primitiveType: 'select',\n    extract: (match) => ({\n      type: 'select',\n      locator: { strategy: 'role', value: 'combobox' },\n      option: match[1]!,\n    }),\n  },\n  {\n    name: 'select-option-named',\n    // \"Select option 'Value'\" or \"Choose the 'Option' option\"\n    regex: /^(?:user\\s+)?(?:selects?|chooses?)\\s+(?:the\\s+)?(?:option\\s+)?['\"](.+?)['\"](?:\\s+option)?$/i,\n    primitiveType: 'select',\n    extract: (match) => ({\n      type: 'select',\n      locator: { strategy: 'role', value: 'combobox' },\n      option: match[1]!,\n    }),\n  },\n];\n\n/**\n * Hover patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const hoverPatterns: StepPattern[] = [\n  {\n    name: 'hover-over-element',\n    // \"Hover over the menu\" or \"User hovers on button\"\n    regex: /^(?:user\\s+)?hovers?\\s+(?:over|on)\\s+(?:the\\s+)?[\"']?(.+?)[\"']?$/i,\n    primitiveType: 'hover',\n    extract: (match) => ({\n      type: 'hover',\n      locator: createLocatorFromMatch('text', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n  {\n    name: 'mouse-over',\n    // \"Mouse over the element\" or \"Mouseover the button\"\n    regex: /^(?:user\\s+)?mouse\\s*over\\s+(?:the\\s+)?[\"']?(.+?)[\"']?$/i,\n    primitiveType: 'hover',\n    extract: (match) => ({\n      type: 'hover',\n      locator: createLocatorFromMatch('text', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n];\n\n/**\n * Focus patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const focusPatterns: StepPattern[] = [\n  {\n    name: 'focus-on-element',\n    // \"Focus on the input\" or \"User focuses the field\"\n    regex: /^(?:user\\s+)?focus(?:es)?\\s+(?:on\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?$/i,\n    primitiveType: 'focus',\n    extract: (match) => ({\n      type: 'focus',\n      locator: createLocatorFromMatch('label', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n];\n\n/**\n * All patterns in priority order (more specific patterns first)\n * Structured patterns come first to prioritize the Journey markdown format\n */\nexport const allPatterns: StepPattern[] = [\n  ...structuredPatterns,\n  ...authPatterns,\n  ...toastPatterns,\n  // Extended patterns come BEFORE base patterns to match more specific cases first\n  ...extendedNavigationPatterns, // Must be before navigationPatterns (e.g., \"Go back\" vs \"Go to\")\n  ...navigationPatterns,\n  ...extendedClickPatterns, // Must be before clickPatterns (e.g., \"Click on\" vs \"Click\")\n  ...clickPatterns,\n  ...extendedFillPatterns,\n  ...fillPatterns,\n  ...extendedSelectPatterns,\n  ...selectPatterns,\n  ...checkPatterns,\n  ...extendedAssertionPatterns, // Must be before visibilityPatterns (e.g., \"not be visible\")\n  ...visibilityPatterns,\n  ...urlPatterns,\n  ...extendedWaitPatterns,\n  ...waitPatterns,\n  ...hoverPatterns,\n  ...focusPatterns,\n];\n\n/**\n * Match text against all patterns and return the first matching primitive\n */\nexport function matchPattern(text: string): IRPrimitive | null {\n  const trimmedText = text.trim();\n\n  for (const pattern of allPatterns) {\n    const match = trimmedText.match(pattern.regex);\n    if (match) {\n      const primitive = pattern.extract(match);\n      if (primitive) {\n        return primitive;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Get all pattern matches for debugging\n */\nexport function getPatternMatches(text: string): Array<{ pattern: string; match: IRPrimitive }> {\n  const trimmedText = text.trim();\n  const matches: Array<{ pattern: string; match: IRPrimitive }> = [];\n\n  for (const pattern of allPatterns) {\n    const match = trimmedText.match(pattern.regex);\n    if (match) {\n      const primitive = pattern.extract(match);\n      if (primitive) {\n        matches.push({ pattern: pattern.name, match: primitive });\n      }\n    }\n  }\n\n  return matches;\n}\n\n/**\n * Get all pattern names for CLI listing\n */\nexport function getAllPatternNames(): string[] {\n  return allPatterns.map((p) => p.name);\n}\n\n/**\n * Get pattern count by category\n */\nexport function getPatternCountByCategory(): Record<string, number> {\n  const counts: Record<string, number> = {};\n\n  for (const pattern of allPatterns) {\n    const category = pattern.name.split('-')[0] || 'other';\n    counts[category] = (counts[category] || 0) + 1;\n  }\n\n  return counts;\n}\n\n/**\n * Get pattern metadata for a specific pattern\n */\nexport function getPatternMetadata(patternName: string): PatternMetadata | null {\n  const pattern = allPatterns.find((p) => p.name === patternName);\n  if (!pattern) return null;\n\n  // Determine version based on pattern name prefix\n  const isExtended =\n    patternName.includes('extended') ||\n    patternName.startsWith('hover') ||\n    patternName.startsWith('focus') ||\n    patternName.startsWith('press-') ||\n    patternName.startsWith('double-') ||\n    patternName.startsWith('right-');\n\n  return {\n    name: pattern.name,\n    version: isExtended ? '1.1.0' : '1.0.0',\n    addedDate: isExtended ? '2026-01-27' : '2026-01-02',\n    source: 'core',\n    category: pattern.name.split('-')[0] || 'other',\n  };\n}\n\n/**\n * Find patterns that match a given text (for debugging)\n */\nexport function findMatchingPatterns(text: string): string[] {\n  const trimmedText = text.trim();\n  const matchingNames: string[] = [];\n\n  for (const pattern of allPatterns) {\n    if (pattern.regex.test(trimmedText)) {\n      matchingNames.push(pattern.name);\n    }\n  }\n\n  return matchingNames;\n}\n","/**\n * Result type pattern for structured error handling\n *\n * Replaces boolean returns with structured results that include:\n * - Success/failure status\n * - Value on success\n * - Error information on failure\n * - Optional warnings for partial success cases\n *\n * @see research/2026-01-15_code_quality_standards.md Category 2 (Silent Failures)\n */\n\n/**\n * A Result type representing either success with a value or failure with an error\n *\n * @example\n * ```typescript\n * function parseConfig(path: string): Result<Config, ConfigError> {\n *   if (!fileExists(path)) {\n *     return { success: false, error: { code: 'NOT_FOUND', message: 'Config file not found' } };\n *   }\n *   const config = JSON.parse(readFile(path));\n *   return { success: true, value: config };\n * }\n *\n * const result = parseConfig('config.json');\n * if (result.success) {\n *   console.log(result.value); // Config object\n * } else {\n *   console.error(result.error); // ConfigError\n * }\n * ```\n */\nexport type Result<T, E = string> =\n  | { success: true; value: T; warnings?: string[] }\n  | { success: false; error: E };\n\n/**\n * Create a successful result\n *\n * @param value - The success value\n * @param warnings - Optional warnings to include\n * @returns A success Result\n *\n * @example\n * ```typescript\n * return ok({ name: 'test', count: 5 });\n * return ok(true, ['Some warning about the operation']);\n * ```\n */\nexport function ok<T>(value: T, warnings?: string[]): Result<T, never> {\n  return warnings?.length\n    ? { success: true, value, warnings }\n    : { success: true, value };\n}\n\n/**\n * Create a failed result\n *\n * @param error - The error information\n * @returns A failure Result\n *\n * @example\n * ```typescript\n * return err('File not found');\n * return err({ code: 'NOT_FOUND', path: '/missing.txt' });\n * ```\n */\nexport function err<E>(error: E): Result<never, E> {\n  return { success: false, error };\n}\n\n/**\n * Check if a result is successful\n *\n * @param result - The result to check\n * @returns True if the result is successful\n */\nexport function isOk<T, E>(result: Result<T, E>): result is { success: true; value: T; warnings?: string[] } {\n  return result.success;\n}\n\n/**\n * Check if a result is a failure\n *\n * @param result - The result to check\n * @returns True if the result is a failure\n */\nexport function isErr<T, E>(result: Result<T, E>): result is { success: false; error: E } {\n  return !result.success;\n}\n\n/**\n * Unwrap a result, throwing if it's a failure\n *\n * @param result - The result to unwrap\n * @param errorMessage - Optional custom error message\n * @returns The success value\n * @throws Error if the result is a failure\n *\n * @example\n * ```typescript\n * const config = unwrap(parseConfig('config.json'));\n * // Throws if parsing failed\n * ```\n */\nexport function unwrap<T, E>(result: Result<T, E>, errorMessage?: string): T {\n  if (result.success) {\n    return result.value;\n  }\n  const message = errorMessage\n    ? `${errorMessage}: ${String(result.error)}`\n    : String(result.error);\n  throw new Error(message);\n}\n\n/**\n * Unwrap a result or return a default value\n *\n * @param result - The result to unwrap\n * @param defaultValue - The default value to return on failure\n * @returns The success value or default\n *\n * @example\n * ```typescript\n * const config = unwrapOr(parseConfig('config.json'), defaultConfig);\n * ```\n */\nexport function unwrapOr<T, E>(result: Result<T, E>, defaultValue: T): T {\n  return result.success ? result.value : defaultValue;\n}\n\n/**\n * Map a successful result to a new value\n *\n * @param result - The result to map\n * @param fn - The mapping function\n * @returns A new result with the mapped value\n *\n * @example\n * ```typescript\n * const nameResult = map(parseConfig('config.json'), config => config.name);\n * ```\n */\nexport function map<T, U, E>(result: Result<T, E>, fn: (_value: T) => U): Result<U, E> {\n  if (result.success) {\n    return ok(fn(result.value), result.warnings);\n  }\n  return result;\n}\n\n/**\n * Map a failed result to a new error\n *\n * @param result - The result to map\n * @param fn - The error mapping function\n * @returns A new result with the mapped error\n */\nexport function mapErr<T, E, F>(result: Result<T, E>, fn: (_error: E) => F): Result<T, F> {\n  if (!result.success) {\n    return err(fn(result.error));\n  }\n  return result;\n}\n\n/**\n * Chain result operations (flatMap)\n *\n * @param result - The result to chain from\n * @param fn - The function returning a new result\n * @returns The chained result\n *\n * @example\n * ```typescript\n * const result = andThen(\n *   parseConfig('config.json'),\n *   config => validateConfig(config)\n * );\n * ```\n */\nexport function andThen<T, U, E>(\n  result: Result<T, E>,\n  fn: (_value: T) => Result<U, E>\n): Result<U, E> {\n  if (result.success) {\n    const newResult = fn(result.value);\n    // Merge warnings\n    if (newResult.success && result.warnings?.length) {\n      return ok(newResult.value, [\n        ...result.warnings,\n        ...(newResult.warnings || []),\n      ]);\n    }\n    return newResult;\n  }\n  return result;\n}\n\n/**\n * Collect an array of results into a result of an array\n *\n * @param results - Array of results to collect\n * @returns A single result containing all values or the first error\n *\n * @example\n * ```typescript\n * const configs = collect([\n *   parseConfig('a.json'),\n *   parseConfig('b.json'),\n *   parseConfig('c.json'),\n * ]);\n * // Either Result<Config[], E> with all configs or first error\n * ```\n */\nexport function collect<T, E>(results: Result<T, E>[]): Result<T[], E> {\n  const values: T[] = [];\n  const allWarnings: string[] = [];\n\n  for (const result of results) {\n    if (!result.success) {\n      return result;\n    }\n    values.push(result.value);\n    if (result.warnings) {\n      allWarnings.push(...result.warnings);\n    }\n  }\n\n  return allWarnings.length > 0\n    ? ok(values, allWarnings)\n    : ok(values);\n}\n\n/**\n * Partition an array of results into successes and failures\n *\n * @param results - Array of results to partition\n * @returns Object with values and errors arrays\n *\n * @example\n * ```typescript\n * const { values, errors } = partition([\n *   parseConfig('a.json'),\n *   parseConfig('b.json'),\n *   parseConfig('c.json'),\n * ]);\n * console.log(`${values.length} succeeded, ${errors.length} failed`);\n * ```\n */\nexport function partition<T, E>(\n  results: Result<T, E>[]\n): { values: T[]; errors: E[]; warnings: string[] } {\n  const values: T[] = [];\n  const errors: E[] = [];\n  const warnings: string[] = [];\n\n  for (const result of results) {\n    if (result.success) {\n      values.push(result.value);\n      if (result.warnings) {\n        warnings.push(...result.warnings);\n      }\n    } else {\n      errors.push(result.error);\n    }\n  }\n\n  return { values, errors, warnings };\n}\n\n/**\n * Try to execute a function and wrap the result\n *\n * @param fn - Function to execute\n * @returns Result with the return value or caught error\n *\n * @example\n * ```typescript\n * const result = tryCatch(() => JSON.parse(jsonString));\n * if (result.success) {\n *   console.log(result.value);\n * } else {\n *   console.error('Parse failed:', result.error);\n * }\n * ```\n */\nexport function tryCatch<T>(fn: () => T): Result<T, Error> {\n  try {\n    return ok(fn());\n  } catch (error) {\n    return err(error instanceof Error ? error : new Error(String(error)));\n  }\n}\n\n/**\n * Try to execute an async function and wrap the result\n *\n * @param fn - Async function to execute\n * @returns Promise of Result with the return value or caught error\n *\n * @example\n * ```typescript\n * const result = await tryCatchAsync(() => fetch('/api/data').then(r => r.json()));\n * ```\n */\nexport async function tryCatchAsync<T>(fn: () => Promise<T>): Promise<Result<T, Error>> {\n  try {\n    return ok(await fn());\n  } catch (error) {\n    return err(error instanceof Error ? error : new Error(String(error)));\n  }\n}\n\n/**\n * Error class with code, message, and optional details.\n *\n * Can be used both with Result type and thrown directly.\n * Extends Error to provide proper stack traces and instanceof checks.\n *\n * @example\n * ```typescript\n * // With Result type\n * return err(new CodedError('NOT_FOUND', 'File not found', { path: '/missing.txt' }));\n *\n * // Thrown directly\n * throw new CodedError('VALIDATION_ERROR', 'Invalid input');\n *\n * // Caught with instanceof\n * try {\n *   riskyOperation();\n * } catch (error) {\n *   if (error instanceof CodedError) {\n *     console.error(`[${error.code}] ${error.message}`);\n *   }\n * }\n * ```\n */\nexport class CodedError extends Error {\n  readonly code: string;\n  readonly details?: Record<string, unknown>;\n\n  constructor(code: string, message: string, details?: Record<string, unknown>) {\n    super(message);\n    this.name = 'CodedError';\n    this.code = code;\n    this.details = details;\n\n    // Maintains proper stack trace in V8 environments (Node.js, Chrome)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, CodedError);\n    }\n  }\n\n  /**\n   * Create a CodedError (convenience factory, same as constructor)\n   */\n  static create(code: string, message: string, details?: Record<string, unknown>): CodedError {\n    return new CodedError(code, message, details);\n  }\n\n  /**\n   * Convert to plain object (for serialization/logging)\n   */\n  toJSON(): { code: string; message: string; details?: Record<string, unknown>; stack?: string } {\n    return {\n      code: this.code,\n      message: this.message,\n      ...(this.details && { details: this.details }),\n      ...(this.stack && { stack: this.stack }),\n    };\n  }\n\n  /**\n   * Format error for display\n   */\n  toString(): string {\n    const base = `[${this.code}] ${this.message}`;\n    if (this.details) {\n      return `${base} ${JSON.stringify(this.details)}`;\n    }\n    return base;\n  }\n}\n\n/**\n * Create a coded error (convenience factory function)\n *\n * @param code - Error code (e.g., 'NOT_FOUND', 'VALIDATION_ERROR')\n * @param message - Human-readable error message\n * @param details - Optional additional details\n * @returns A CodedError instance\n *\n * @example\n * ```typescript\n * return err(codedError('PARSE_ERROR', 'Invalid JSON', { line: 42 }));\n * ```\n */\nexport function codedError(\n  code: string,\n  message: string,\n  details?: Record<string, unknown>\n): CodedError {\n  return new CodedError(code, message, details);\n}\n","/**\n * Journey Parser - Parse YAML frontmatter + markdown body\n * @see research/2026-01-02_autogen-refined-plan.md Section 8\n */\nimport { readFileSync, existsSync } from 'node:fs';\nimport { resolve } from 'node:path';\nimport { parse as parseYaml } from 'yaml';\nimport {\n  JourneyFrontmatterSchema,\n  JourneyStatusSchema,\n  type JourneyFrontmatter,\n  type JourneyStatus,\n  validateForAutoGen,\n} from './schema.js';\nimport { matchPattern } from '../mapping/patterns.js';\nimport { type Result, ok, err, CodedError } from '../utils/result.js';\n\n// Re-export for convenience\nexport { JourneyFrontmatterSchema, JourneyStatusSchema };\nexport type { JourneyFrontmatter, JourneyStatus };\n\n/**\n * Error thrown when journey parsing fails\n */\nexport class JourneyParseError extends Error {\n  public readonly filePath: string;\n  public readonly cause?: unknown;\n\n  constructor(\n    message: string,\n    filePath: string,\n    cause?: unknown\n  ) {\n    super(message);\n    this.name = 'JourneyParseError';\n    this.filePath = filePath;\n    this.cause = cause;\n  }\n}\n\n/**\n * Parsed journey structure\n */\nexport interface ParsedJourney {\n  /** Journey frontmatter (validated) */\n  frontmatter: JourneyFrontmatter;\n  /** Raw markdown body (everything after frontmatter) */\n  body: string;\n  /** Acceptance Criteria section */\n  acceptanceCriteria: AcceptanceCriterion[];\n  /** Procedural Steps section */\n  proceduralSteps: ProceduralStep[];\n  /** Data/Environment notes */\n  dataNotes: string[];\n  /** Source file path */\n  sourcePath: string;\n}\n\n/**\n * Acceptance criterion from journey body\n */\nexport interface AcceptanceCriterion {\n  /** Criterion ID (e.g., 'AC-1') */\n  id: string;\n  /** Title/description */\n  title: string;\n  /** Bullet points under this criterion */\n  steps: string[];\n  /** Raw markdown content */\n  rawContent: string;\n}\n\n/**\n * Procedural step from journey body\n */\nexport interface ProceduralStep {\n  /** Step number */\n  number: number;\n  /** Step text */\n  text: string;\n  /** Associated AC (if any) */\n  linkedAC?: string;\n}\n\n/**\n * Structured step action from journey body\n */\nexport interface StructuredStepAction {\n  /** Action type: 'action', 'wait', or 'assert' */\n  type: 'action' | 'wait' | 'assert';\n  /** The parsed action string */\n  action: string;\n  /** Target element or condition */\n  target: string;\n  /** Optional value for the action */\n  value?: string;\n}\n\n/**\n * Structured step from journey body\n */\nexport interface StructuredStep {\n  /** Step number */\n  stepNumber: number;\n  /** Step name/title */\n  stepName: string;\n  /** Array of parsed actions */\n  actions: StructuredStepAction[];\n}\n\n/**\n * Regex patterns for parsing\n */\nconst FRONTMATTER_REGEX = /^---\\r?\\n([\\s\\S]*?)\\r?\\n---/;\n\n/**\n * Extract frontmatter from markdown content\n */\nfunction extractFrontmatter(content: string): {\n  frontmatter: string;\n  body: string;\n} {\n  const match = FRONTMATTER_REGEX.exec(content);\n  if (!match) {\n    throw new Error('No YAML frontmatter found (content should start with ---)');\n  }\n\n  return {\n    frontmatter: match[1]!,\n    body: content.slice(match[0]!.length).trim(),\n  };\n}\n\n/**\n * Parse acceptance criteria from markdown body\n */\nfunction parseAcceptanceCriteria(body: string): AcceptanceCriterion[] {\n  const criteria: AcceptanceCriterion[] = [];\n\n  // Find the Acceptance Criteria section\n  const acSectionMatch = body.match(/##\\s*Acceptance\\s*Criteria\\s*\\n([\\s\\S]*?)(?=\\n##\\s[^#]|$)/i);\n  if (!acSectionMatch) {\n    return criteria;\n  }\n\n  const acSection = acSectionMatch[1]!;\n\n  // Split by AC headers (### AC-N or ## AC-N)\n  const acPattern = /^###?\\s*(AC-\\d+)[:\\s]*(.*?)$/gim;\n  const parts: Array<{ id: string; title: string; startIndex: number }> = [];\n\n  let match;\n  while ((match = acPattern.exec(acSection)) !== null) {\n    parts.push({\n      id: match[1]!.toUpperCase(),\n      title: match[2]!.trim(),\n      startIndex: match.index + match[0]!.length,\n    });\n  }\n\n  // Extract content for each AC\n  for (let i = 0; i < parts.length; i++) {\n    const part = parts[i]!;\n\n    // Get content between this AC header and the next\n    const contentStart = part.startIndex;\n    const contentEnd = i + 1 < parts.length\n      ? acSection.lastIndexOf('###', parts[i + 1]!.startIndex)\n      : acSection.length;\n\n    const content = acSection.slice(contentStart, contentEnd > contentStart ? contentEnd : acSection.length);\n\n    // Extract bullet points as steps\n    const steps: string[] = [];\n    const bulletPattern = /^[-*]\\s+(.+)$/gm;\n    let bulletMatch;\n    while ((bulletMatch = bulletPattern.exec(content)) !== null) {\n      steps.push(bulletMatch[1]!.trim());\n    }\n\n    // Build raw content\n    const headerMatch = acSection.match(new RegExp(`###?\\\\s*${part.id}[:\\\\s]*${part.title.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}`, 'i'));\n    const rawContent = headerMatch\n      ? headerMatch[0]! + content.slice(0, content.indexOf('\\n###') > 0 ? content.indexOf('\\n###') : content.length)\n      : content;\n\n    criteria.push({\n      id: part.id,\n      title: part.title,\n      steps,\n      rawContent: rawContent.trim(),\n    });\n  }\n\n  return criteria;\n}\n\n/**\n * Parse procedural steps from markdown body\n */\nfunction parseProceduralSteps(body: string): ProceduralStep[] {\n  const steps: ProceduralStep[] = [];\n\n  // Find the Procedural Steps section\n  const psMatch = body.match(\n    /##\\s*Procedural\\s*Steps?\\s*\\n([\\s\\S]*?)(?=\\n##\\s[^#]|$)/i\n  );\n  if (!psMatch) {\n    return steps;\n  }\n\n  const psSection = psMatch[1]!;\n\n  // Parse numbered steps\n  const numberedPattern = /^\\d+\\.\\s+(.+)$/gm;\n  let match;\n  let stepNumber = 1;\n\n  while ((match = numberedPattern.exec(psSection)) !== null) {\n    const text = match[1]!.trim();\n\n    // Check for AC reference in text (e.g., \"(AC-1)\")\n    const acRef = text.match(/\\(AC-(\\d+)\\)/i);\n\n    steps.push({\n      number: stepNumber++,\n      text: text.replace(/\\s*\\(AC-\\d+\\)\\s*/gi, '').trim(),\n      linkedAC: acRef ? `AC-${acRef[1]!}` : undefined,\n    });\n  }\n\n  // Also parse bullet points if no numbered steps\n  if (steps.length === 0) {\n    const bulletPattern = /^[-*]\\s+(.+)$/gm;\n    while ((match = bulletPattern.exec(psSection)) !== null) {\n      const text = match[1]!.trim();\n      const acRef = text.match(/\\(AC-(\\d+)\\)/i);\n\n      steps.push({\n        number: stepNumber++,\n        text: text.replace(/\\s*\\(AC-\\d+\\)\\s*/gi, '').trim(),\n        linkedAC: acRef ? `AC-${acRef[1]!}` : undefined,\n      });\n    }\n  }\n\n  return steps;\n}\n\n/**\n * Parse data/environment notes from markdown body\n */\nfunction parseDataNotes(body: string): string[] {\n  const notes: string[] = [];\n\n  // Find Data/Environment section\n  const dataMatch = body.match(\n    /##\\s*(Data|Environment|Data\\/Environment)\\s*(Notes?)?\\s*\\n([\\s\\S]*?)(?=\\n##\\s[^#]|$)/i\n  );\n  if (!dataMatch) {\n    return notes;\n  }\n\n  const dataSection = dataMatch[3]!;\n\n  // Extract bullet points\n  const bulletPattern = /^[-*]\\s+(.+)$/gm;\n  let match;\n  while ((match = bulletPattern.exec(dataSection)) !== null) {\n    notes.push(match[1]!.trim());\n  }\n\n  return notes;\n}\n\n/**\n * Parse structured steps from markdown content\n * Parses the new structured format with Action/Wait for/Assert bullets\n * @param content - The markdown content containing structured steps\n * @returns Array of parsed structured steps\n */\nexport function parseStructuredSteps(content: string): StructuredStep[] {\n  const steps: StructuredStep[] = [];\n\n  // Split content by step headers\n  const sections = content.split(/(?=^###\\s*Step\\s+\\d+:)/m);\n\n  for (const section of sections) {\n    // Match the step header\n    const headerMatch = section.match(/^###\\s*Step\\s+(\\d+):\\s*(.+)$/m);\n    if (!headerMatch) continue;\n\n    const step: StructuredStep = {\n      stepNumber: parseInt(headerMatch[1]!, 10),\n      stepName: headerMatch[2]!.trim(),\n      actions: [],\n    };\n\n    // Parse bullet points in this section\n    let bulletMatch: RegExpExecArray | null;\n    // Create a fresh regex for each section to reset lastIndex\n    const sectionBulletRegex = /^-\\s*\\*\\*(Action|Wait for|Assert)\\*\\*:\\s*(.+)$/gm;\n\n    while ((bulletMatch = sectionBulletRegex.exec(section)) !== null) {\n      const [, type, text] = bulletMatch;\n\n      // Determine action type\n      const actionType = type!.toLowerCase() === 'action' ? 'action'\n        : type!.toLowerCase() === 'wait for' ? 'wait'\n        : 'assert';\n\n      // Try to parse the text using pattern matching\n      const primitive = matchPattern(text!.trim());\n\n      if (primitive) {\n        // Extract meaningful info from the primitive\n        let action = '';\n        let target = '';\n        let value: string | undefined;\n\n        switch (primitive.type) {\n          case 'goto':\n            action = 'navigate';\n            target = primitive.url;\n            break;\n          case 'click':\n            action = 'click';\n            target = primitive.locator.value;\n            break;\n          case 'fill':\n            action = 'fill';\n            target = primitive.locator.value;\n            value = primitive.value.value;\n            break;\n          case 'select':\n            action = 'select';\n            target = primitive.locator.value;\n            value = primitive.option;\n            break;\n          case 'check':\n            action = 'check';\n            target = primitive.locator.value;\n            break;\n          case 'uncheck':\n            action = 'uncheck';\n            target = primitive.locator.value;\n            break;\n          case 'expectVisible':\n            action = 'expectVisible';\n            target = primitive.locator.value;\n            break;\n          case 'expectToast':\n            action = 'expectToast';\n            target = primitive.toastType || 'info';\n            value = primitive.message;\n            break;\n          case 'expectURL':\n            action = 'expectURL';\n            target = typeof primitive.pattern === 'string' ? primitive.pattern : primitive.pattern.source;\n            break;\n          case 'callModule':\n            action = `${primitive.module}.${primitive.method}`;\n            target = primitive.args?.join(', ') || '';\n            break;\n          case 'waitForURL':\n            action = 'waitForURL';\n            target = typeof primitive.pattern === 'string' ? primitive.pattern : primitive.pattern.source;\n            break;\n          case 'waitForLoadingComplete':\n            action = 'waitForLoadingComplete';\n            target = '';\n            break;\n          default:\n            // Fallback for unknown primitive types\n            action = text!.trim();\n            target = '';\n        }\n\n        step.actions.push({\n          type: actionType,\n          action,\n          target,\n          value,\n        });\n      } else {\n        // If pattern matching fails, store the raw text\n        step.actions.push({\n          type: actionType,\n          action: text!.trim(),\n          target: '',\n          value: undefined,\n        });\n      }\n    }\n\n    // Only add steps that have actions\n    if (step.actions.length > 0) {\n      steps.push(step);\n    }\n  }\n\n  return steps;\n}\n\n/**\n * Parse a journey markdown file\n * @param filePath - Path to the journey file\n * @returns Parsed journey structure\n * @throws JourneyParseError if parsing fails\n */\nexport function parseJourney(filePath: string): ParsedJourney {\n  const resolvedPath = resolve(filePath);\n\n  if (!existsSync(resolvedPath)) {\n    throw new JourneyParseError(\n      `Journey file not found: ${resolvedPath}`,\n      resolvedPath\n    );\n  }\n\n  let content: string;\n  try {\n    content = readFileSync(resolvedPath, 'utf-8');\n  } catch (err) {\n    throw new JourneyParseError(\n      `Failed to read journey file: ${resolvedPath}`,\n      resolvedPath,\n      err\n    );\n  }\n\n  // Extract frontmatter and body\n  let frontmatterStr: string;\n  let body: string;\n  try {\n    const extracted = extractFrontmatter(content);\n    frontmatterStr = extracted.frontmatter;\n    body = extracted.body;\n  } catch (err) {\n    throw new JourneyParseError(\n      `Invalid frontmatter in journey file: ${resolvedPath}`,\n      resolvedPath,\n      err\n    );\n  }\n\n  // Parse YAML frontmatter\n  let rawFrontmatter: unknown;\n  try {\n    rawFrontmatter = parseYaml(frontmatterStr);\n  } catch (err) {\n    throw new JourneyParseError(\n      `Invalid YAML in journey frontmatter: ${resolvedPath}`,\n      resolvedPath,\n      err\n    );\n  }\n\n  // Validate frontmatter with Zod\n  const result = JourneyFrontmatterSchema.safeParse(rawFrontmatter);\n  if (!result.success) {\n    const issues = result.error.issues\n      .map((i) => `  - ${i.path.join('.')}: ${i.message}`)\n      .join('\\n');\n    throw new JourneyParseError(\n      `Invalid journey frontmatter in ${resolvedPath}:\\n${issues}`,\n      resolvedPath,\n      result.error\n    );\n  }\n\n  // Parse body sections\n  const acceptanceCriteria = parseAcceptanceCriteria(body);\n  const proceduralSteps = parseProceduralSteps(body);\n  const dataNotes = parseDataNotes(body);\n\n  return {\n    frontmatter: result.data,\n    body,\n    acceptanceCriteria,\n    proceduralSteps,\n    dataNotes,\n    sourcePath: resolvedPath,\n  };\n}\n\n/**\n * Parse and validate a journey for AutoGen (must be clarified)\n */\nexport function parseJourneyForAutoGen(filePath: string): ParsedJourney {\n  const parsed = parseJourney(filePath);\n\n  const validation = validateForAutoGen(parsed.frontmatter);\n  if (!validation.valid) {\n    throw new JourneyParseError(\n      `Journey not ready for AutoGen:\\n${validation.errors.map((e) => `  - ${e}`).join('\\n')}`,\n      filePath\n    );\n  }\n\n  return parsed;\n}\n\n/**\n * Parse journey from string content (for testing)\n */\nexport function parseJourneyContent(\n  content: string,\n  virtualPath = 'virtual.journey.md'\n): ParsedJourney {\n  // Extract frontmatter and body\n  const { frontmatter: frontmatterStr, body } = extractFrontmatter(content);\n\n  // Parse YAML frontmatter\n  const rawFrontmatter = parseYaml(frontmatterStr);\n\n  // Validate frontmatter with Zod\n  const result = JourneyFrontmatterSchema.safeParse(rawFrontmatter);\n  if (!result.success) {\n    const issues = result.error.issues\n      .map((i) => `  - ${i.path.join('.')}: ${i.message}`)\n      .join('\\n');\n    throw new JourneyParseError(\n      `Invalid journey frontmatter:\\n${issues}`,\n      virtualPath,\n      result.error\n    );\n  }\n\n  // Parse body sections\n  const acceptanceCriteria = parseAcceptanceCriteria(body);\n  const proceduralSteps = parseProceduralSteps(body);\n  const dataNotes = parseDataNotes(body);\n\n  return {\n    frontmatter: result.data,\n    body,\n    acceptanceCriteria,\n    proceduralSteps,\n    dataNotes,\n    sourcePath: virtualPath,\n  };\n}\n\n/**\n * Parse journey from string content with Result type (no exceptions)\n *\n * This is the recommended way to parse journey content as it returns\n * structured errors via Result type instead of throwing exceptions.\n *\n * @param content - Raw markdown content to parse\n * @param virtualPath - Virtual path for error reporting (default: 'virtual.journey.md')\n * @returns Result with ParsedJourney on success or CodedError on failure\n *\n * @example\n * ```typescript\n * const result = tryParseJourneyContent(markdownContent);\n * if (result.success) {\n *   console.log('Parsed:', result.value.frontmatter.id);\n * } else {\n *   console.error(`[${result.error.code}] ${result.error.message}`);\n * }\n * ```\n */\nexport function tryParseJourneyContent(\n  content: string,\n  virtualPath = 'virtual.journey.md'\n): Result<ParsedJourney, CodedError> {\n  // Extract frontmatter and body\n  const frontmatterMatch = FRONTMATTER_REGEX.exec(content);\n  if (!frontmatterMatch) {\n    return err(new CodedError(\n      'FRONTMATTER_NOT_FOUND',\n      'No YAML frontmatter found (content should start with ---)',\n      { path: virtualPath }\n    ));\n  }\n\n  const frontmatterStr = frontmatterMatch[1]!;\n  const body = content.slice(frontmatterMatch[0]!.length).trim();\n\n  // Parse YAML frontmatter\n  let rawFrontmatter: unknown;\n  try {\n    rawFrontmatter = parseYaml(frontmatterStr);\n  } catch (yamlError) {\n    return err(new CodedError(\n      'YAML_PARSE_ERROR',\n      'Invalid YAML in journey frontmatter',\n      {\n        path: virtualPath,\n        cause: yamlError instanceof Error ? yamlError.message : String(yamlError)\n      }\n    ));\n  }\n\n  // Validate frontmatter with Zod\n  const zodResult = JourneyFrontmatterSchema.safeParse(rawFrontmatter);\n  if (!zodResult.success) {\n    const issues = zodResult.error.issues\n      .map((i) => `${i.path.join('.')}: ${i.message}`)\n      .join('; ');\n    return err(new CodedError(\n      'FRONTMATTER_VALIDATION_ERROR',\n      `Invalid journey frontmatter: ${issues}`,\n      {\n        path: virtualPath,\n        issues: zodResult.error.issues.map((i) => ({\n          path: i.path.join('.'),\n          message: i.message,\n          code: i.code,\n        }))\n      }\n    ));\n  }\n\n  // Parse body sections\n  const acceptanceCriteria = parseAcceptanceCriteria(body);\n  const proceduralSteps = parseProceduralSteps(body);\n  const dataNotes = parseDataNotes(body);\n\n  return ok({\n    frontmatter: zodResult.data,\n    body,\n    acceptanceCriteria,\n    proceduralSteps,\n    dataNotes,\n    sourcePath: virtualPath,\n  });\n}\n","/**\n * Glossary Loader - Load and resolve synonyms for step text normalization\n * @see research/2026-01-02_autogen-refined-plan.md Section 10\n * @see research/2026-01-23_llkb-autogen-integration-specification.md (LLKB integration)\n */\nimport { readFileSync, existsSync } from 'node:fs';\nimport { resolve } from 'node:path';\nimport { pathToFileURL } from 'node:url';\nimport { parse as parseYaml } from 'yaml';\nimport { z } from 'zod';\nimport type { IRPrimitive } from '../ir/types.js';\n\n/**\n * Glossary entry schema\n */\nconst GlossaryEntrySchema = z.object({\n  canonical: z.string(),\n  synonyms: z.array(z.string()),\n});\n\n/**\n * Label alias entry schema (maps display labels to testids/selectors)\n * @see T082 - Extend glossary schema for labelAliases\n */\nconst LabelAliasSchema = z.object({\n  label: z.string(),\n  testid: z.string().optional(),\n  role: z.string().optional(),\n  selector: z.string().optional(),\n});\n\n/**\n * Module method mapping schema (maps phrases to module.method calls)\n * @see T082 - Module method resolution\n */\nconst ModuleMethodMappingSchema = z.object({\n  phrase: z.string(),\n  module: z.string(),\n  method: z.string(),\n  params: z.record(z.string()).optional(),\n});\n\n/**\n * Glossary file schema\n */\nconst GlossarySchema = z.object({\n  version: z.number().default(1),\n  entries: z.array(GlossaryEntrySchema),\n  labelAliases: z.array(LabelAliasSchema).default([]),\n  moduleMethods: z.array(ModuleMethodMappingSchema).default([]),\n});\n\nexport type LabelAlias = z.infer<typeof LabelAliasSchema>;\nexport type ModuleMethodMapping = z.infer<typeof ModuleMethodMappingSchema>;\n\nexport type GlossaryEntry = z.infer<typeof GlossaryEntrySchema>;\nexport type Glossary = z.infer<typeof GlossarySchema>;\n\n/**\n * Default glossary entries for common terms\n */\nexport const defaultGlossary: Glossary = {\n  version: 1,\n  labelAliases: [\n    // Common label-to-selector mappings\n    { label: 'email', testid: 'email-input', role: 'textbox' },\n    { label: 'password', testid: 'password-input', role: 'textbox' },\n    { label: 'username', testid: 'username-input', role: 'textbox' },\n    { label: 'search', testid: 'search-input', role: 'searchbox' },\n    { label: 'submit', testid: 'submit-button', role: 'button' },\n    { label: 'cancel', testid: 'cancel-button', role: 'button' },\n    { label: 'close', testid: 'close-button', role: 'button' },\n  ],\n  moduleMethods: [\n    // Common phrase-to-module mappings\n    { phrase: 'log in', module: 'auth', method: 'login' },\n    { phrase: 'login', module: 'auth', method: 'login' },\n    { phrase: 'sign in', module: 'auth', method: 'login' },\n    { phrase: 'log out', module: 'auth', method: 'logout' },\n    { phrase: 'logout', module: 'auth', method: 'logout' },\n    { phrase: 'sign out', module: 'auth', method: 'logout' },\n    { phrase: 'navigate to', module: 'navigation', method: 'goToPath' },\n    { phrase: 'go to', module: 'navigation', method: 'goToPath' },\n    { phrase: 'open', module: 'navigation', method: 'goToPath' },\n    { phrase: 'fill form', module: 'forms', method: 'fillForm' },\n    { phrase: 'submit form', module: 'forms', method: 'submitForm' },\n    { phrase: 'wait for', module: 'waits', method: 'waitForSignal' },\n  ],\n  entries: [\n    {\n      canonical: 'click',\n      synonyms: ['press', 'tap', 'select', 'hit'],\n    },\n    {\n      canonical: 'enter',\n      synonyms: ['type', 'fill', 'input', 'write'],\n    },\n    {\n      canonical: 'navigate',\n      synonyms: ['go', 'open', 'visit', 'browse'],\n    },\n    {\n      canonical: 'see',\n      synonyms: ['view', 'observe', 'notice', 'find'],\n    },\n    {\n      canonical: 'visible',\n      synonyms: ['displayed', 'shown', 'present'],\n    },\n    {\n      canonical: 'button',\n      synonyms: ['btn', 'action', 'cta'],\n    },\n    {\n      canonical: 'field',\n      synonyms: ['input', 'textbox', 'text field', 'text input'],\n    },\n    {\n      canonical: 'dropdown',\n      synonyms: ['select', 'combo', 'combobox', 'selector', 'picker'],\n    },\n    {\n      canonical: 'checkbox',\n      synonyms: ['check', 'tick', 'toggle'],\n    },\n    {\n      canonical: 'login',\n      synonyms: ['log in', 'sign in', 'authenticate'],\n    },\n    {\n      canonical: 'logout',\n      synonyms: ['log out', 'sign out', 'exit'],\n    },\n    {\n      canonical: 'submit',\n      synonyms: ['send', 'save', 'confirm', 'ok'],\n    },\n    {\n      canonical: 'cancel',\n      synonyms: ['close', 'dismiss', 'abort', 'back'],\n    },\n    {\n      canonical: 'success',\n      synonyms: ['passed', 'completed', 'done', 'finished'],\n    },\n    {\n      canonical: 'error',\n      synonyms: ['failure', 'failed', 'problem', 'issue'],\n    },\n    {\n      canonical: 'toast',\n      synonyms: ['notification', 'message', 'alert', 'snackbar'],\n    },\n    {\n      canonical: 'modal',\n      synonyms: ['dialog', 'popup', 'overlay', 'lightbox'],\n    },\n    {\n      canonical: 'user',\n      synonyms: ['customer', 'visitor', 'member', 'client'],\n    },\n    {\n      canonical: 'page',\n      synonyms: ['screen', 'view', 'section'],\n    },\n    {\n      canonical: 'form',\n      synonyms: ['questionnaire', 'survey', 'wizard'],\n    },\n  ],\n};\n\n/**\n * Loaded glossary cache\n */\nlet glossaryCache: Glossary | null = null;\nlet synonymMap: Map<string, string> | null = null;\n\n/**\n * Build a synonym lookup map from glossary\n */\nfunction buildSynonymMap(glossary: Glossary): Map<string, string> {\n  const map = new Map<string, string>();\n\n  for (const entry of glossary.entries) {\n    // Map canonical to itself\n    map.set(entry.canonical.toLowerCase(), entry.canonical);\n\n    // Map all synonyms to canonical\n    for (const synonym of entry.synonyms) {\n      map.set(synonym.toLowerCase(), entry.canonical);\n    }\n  }\n\n  return map;\n}\n\n/**\n * Load glossary from file\n * @param glossaryPath - Path to glossary YAML file\n */\nexport function loadGlossary(glossaryPath: string): Glossary {\n  const resolvedPath = resolve(glossaryPath);\n\n  if (!existsSync(resolvedPath)) {\n    console.warn(`Glossary file not found at ${resolvedPath}, using defaults`);\n    return defaultGlossary;\n  }\n\n  try {\n    const content = readFileSync(resolvedPath, 'utf-8');\n    const parsed = parseYaml(content);\n    const result = GlossarySchema.safeParse(parsed);\n\n    if (!result.success) {\n      console.warn(`Invalid glossary file at ${resolvedPath}, using defaults`);\n      return defaultGlossary;\n    }\n\n    // Merge with defaults\n    return mergeGlossaries(defaultGlossary, result.data);\n  } catch {\n    console.warn(`Failed to load glossary from ${resolvedPath}, using defaults`);\n    return defaultGlossary;\n  }\n}\n\n/**\n * Merge two glossaries (user glossary extends defaults)\n */\nexport function mergeGlossaries(base: Glossary, extension: Glossary): Glossary {\n  const merged: Glossary = {\n    version: Math.max(base.version, extension.version),\n    entries: [...base.entries],\n    labelAliases: [...(base.labelAliases ?? [])],\n    moduleMethods: [...(base.moduleMethods ?? [])],\n  };\n\n  // Add or extend entries from extension\n  for (const extEntry of extension.entries) {\n    const existing = merged.entries.find(\n      (e) => e.canonical.toLowerCase() === extEntry.canonical.toLowerCase()\n    );\n\n    if (existing) {\n      // Merge synonyms\n      const allSynonyms = new Set([...existing.synonyms, ...extEntry.synonyms]);\n      existing.synonyms = Array.from(allSynonyms);\n    } else {\n      // Add new entry\n      merged.entries.push(extEntry);\n    }\n  }\n\n  // Add or extend label aliases from extension\n  for (const extAlias of extension.labelAliases ?? []) {\n    const existing = merged.labelAliases.find(\n      (a) => a.label.toLowerCase() === extAlias.label.toLowerCase()\n    );\n\n    if (!existing) {\n      merged.labelAliases.push(extAlias);\n    } else {\n      // Override with extension values\n      Object.assign(existing, extAlias);\n    }\n  }\n\n  // Add or extend module methods from extension\n  for (const extMethod of extension.moduleMethods ?? []) {\n    const existing = merged.moduleMethods.find(\n      (m) => m.phrase.toLowerCase() === extMethod.phrase.toLowerCase()\n    );\n\n    if (!existing) {\n      merged.moduleMethods.push(extMethod);\n    } else {\n      // Override with extension values\n      Object.assign(existing, extMethod);\n    }\n  }\n\n  return merged;\n}\n\n/**\n * Initialize the glossary (call once at startup)\n * @param glossaryPath - Optional path to custom glossary\n */\nexport function initGlossary(glossaryPath?: string): void {\n  if (glossaryPath) {\n    glossaryCache = loadGlossary(glossaryPath);\n  } else {\n    glossaryCache = defaultGlossary;\n  }\n  synonymMap = buildSynonymMap(glossaryCache);\n}\n\n/**\n * Get the current glossary\n */\nexport function getGlossary(): Glossary {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n  return glossaryCache!;\n}\n\n/**\n * Resolve a term to its canonical form\n * @param term - Term to resolve\n * @returns Canonical form or original term if not found\n */\nexport function resolveCanonical(term: string): string {\n  if (!synonymMap) {\n    initGlossary();\n  }\n  return synonymMap!.get(term.toLowerCase()) ?? term;\n}\n\n/**\n * Normalize step text by replacing synonyms with canonical terms\n * @param text - Step text to normalize\n * @returns Normalized text\n */\nexport function normalizeStepText(text: string): string {\n  if (!synonymMap) {\n    initGlossary();\n  }\n\n  // Split into words, preserving quoted strings\n  const parts: string[] = [];\n  const regex = /(['\"][^'\"]+['\"])|(\\S+)/g;\n  let match;\n\n  while ((match = regex.exec(text)) !== null) {\n    const part = match[0];\n\n    // Don't normalize quoted strings\n    if (part.startsWith('\"') || part.startsWith(\"'\")) {\n      parts.push(part);\n    } else {\n      // Check if this word has a canonical form\n      const canonical = synonymMap!.get(part.toLowerCase());\n      parts.push(canonical ?? part);\n    }\n  }\n\n  return parts.join(' ');\n}\n\n/**\n * Get all synonyms for a canonical term\n */\nexport function getSynonyms(canonical: string): string[] {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n\n  const entry = glossaryCache!.entries.find(\n    (e) => e.canonical.toLowerCase() === canonical.toLowerCase()\n  );\n\n  return entry?.synonyms ?? [];\n}\n\n/**\n * Check if a term is a synonym of a canonical term\n */\nexport function isSynonymOf(term: string, canonical: string): boolean {\n  const resolved = resolveCanonical(term);\n  return resolved.toLowerCase() === canonical.toLowerCase();\n}\n\n/**\n * Reset the glossary cache (for testing)\n */\nexport function resetGlossaryCache(): void {\n  glossaryCache = null;\n  synonymMap = null;\n}\n\n/**\n * Find a label alias by label text\n * @see T082 - Label alias matching\n */\nexport function findLabelAlias(label: string): LabelAlias | null {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n\n  const normalizedLabel = label.toLowerCase().trim();\n\n  return (\n    glossaryCache!.labelAliases?.find(\n      (alias) => alias.label.toLowerCase() === normalizedLabel\n    ) ?? null\n  );\n}\n\n/**\n * Get locator info from label alias\n */\nexport function getLocatorFromLabel(label: string): { strategy: string; value: string } | null {\n  const alias = findLabelAlias(label);\n  if (!alias) return null;\n\n  // Priority: testid > role > selector\n  if (alias.testid) {\n    return { strategy: 'testid', value: alias.testid };\n  }\n  if (alias.role) {\n    return { strategy: 'role', value: alias.role };\n  }\n  if (alias.selector) {\n    return { strategy: 'css', value: alias.selector };\n  }\n\n  return null;\n}\n\n/**\n * Find a module method mapping by phrase\n * @see T083 - Module method resolution in step mapper\n */\nexport function findModuleMethod(text: string): ModuleMethodMapping | null {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n\n  const normalizedText = text.toLowerCase().trim();\n\n  // Find the best matching phrase (longest match wins)\n  let bestMatch: ModuleMethodMapping | null = null;\n  let bestMatchLength = 0;\n\n  for (const mapping of glossaryCache!.moduleMethods ?? []) {\n    const phrase = mapping.phrase.toLowerCase();\n    if (normalizedText.includes(phrase) && phrase.length > bestMatchLength) {\n      bestMatch = mapping;\n      bestMatchLength = phrase.length;\n    }\n  }\n\n  return bestMatch;\n}\n\n/**\n * Resolve a step to a module method call if it matches\n */\nexport function resolveModuleMethod(\n  text: string\n): { module: string; method: string; params?: Record<string, string> } | null {\n  const mapping = findModuleMethod(text);\n  if (!mapping) return null;\n\n  return {\n    module: mapping.module,\n    method: mapping.method,\n    params: mapping.params,\n  };\n}\n\n/**\n * Get all label aliases\n */\nexport function getLabelAliases(): LabelAlias[] {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n  return glossaryCache!.labelAliases ?? [];\n}\n\n/**\n * Get all module method mappings\n */\nexport function getModuleMethods(): ModuleMethodMapping[] {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n  return glossaryCache!.moduleMethods ?? [];\n}\n\n// ============================================================================\n// LLKB Extended Glossary Support\n// @see research/2026-01-23_llkb-autogen-integration-specification.md\n// ============================================================================\n\n/**\n * Extended glossary metadata from LLKB export\n */\nexport interface ExtendedGlossaryMeta {\n  exportedAt: string;\n  entryCount: number;\n  minConfidence?: number;\n  sourceComponents?: string[];\n  sourceLessons?: string[];\n}\n\n/**\n * Extended glossary loaded from LLKB export\n */\nlet extendedGlossary: Map<string, IRPrimitive> | null = null;\nlet extendedGlossaryMeta: ExtendedGlossaryMeta | null = null;\n\n/**\n * Load extended glossary from LLKB export file\n * @param glossaryPath - Path to the LLKB-generated glossary TypeScript file\n * @returns Loading result with entry count and metadata\n */\nexport async function loadExtendedGlossary(glossaryPath: string): Promise<{\n  loaded: boolean;\n  entryCount: number;\n  exportedAt: string | null;\n  error?: string;\n}> {\n  try {\n    const resolvedPath = resolve(glossaryPath);\n\n    if (!existsSync(resolvedPath)) {\n      return {\n        loaded: false,\n        entryCount: 0,\n        exportedAt: null,\n        error: `Glossary file not found: ${resolvedPath}`,\n      };\n    }\n\n    // Dynamic import of the generated glossary file\n    // Use file:// URL for Windows compatibility\n    const fileUrl = pathToFileURL(resolvedPath).href;\n    const module = await import(fileUrl);\n\n    if (module.llkbGlossary instanceof Map) {\n      const glossaryMap: Map<string, IRPrimitive> = module.llkbGlossary;\n      extendedGlossary = glossaryMap;\n      extendedGlossaryMeta = module.llkbGlossaryMeta ?? null;\n\n      return {\n        loaded: true,\n        entryCount: glossaryMap.size,\n        exportedAt: extendedGlossaryMeta?.exportedAt ?? null,\n      };\n    }\n\n    // If llkbGlossary is a plain object, convert to Map\n    if (module.llkbGlossary && typeof module.llkbGlossary === 'object') {\n      const glossaryMap = new Map<string, IRPrimitive>(\n        Object.entries(module.llkbGlossary) as [string, IRPrimitive][]\n      );\n      extendedGlossary = glossaryMap;\n      extendedGlossaryMeta = module.llkbGlossaryMeta ?? null;\n\n      return {\n        loaded: true,\n        entryCount: glossaryMap.size,\n        exportedAt: extendedGlossaryMeta?.exportedAt ?? null,\n      };\n    }\n\n    return {\n      loaded: false,\n      entryCount: 0,\n      exportedAt: null,\n      error: 'Invalid glossary format: llkbGlossary not found or not a Map/object',\n    };\n  } catch (err) {\n    return {\n      loaded: false,\n      entryCount: 0,\n      exportedAt: null,\n      error: `Failed to load glossary: ${err instanceof Error ? err.message : String(err)}`,\n    };\n  }\n}\n\n/**\n * Clear extended glossary (for testing)\n */\nexport function clearExtendedGlossary(): void {\n  extendedGlossary = null;\n  extendedGlossaryMeta = null;\n}\n\n/**\n * Check if a term exactly matches a core glossary phrase\n * (not just a partial/substring match)\n */\nfunction isExactCoreMatch(term: string): boolean {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n\n  const normalizedTerm = term.toLowerCase().trim();\n\n  // Check if any module method phrase exactly matches the term\n  for (const mapping of glossaryCache!.moduleMethods ?? []) {\n    if (mapping.phrase.toLowerCase() === normalizedTerm) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Lookup a term in both core glossary and extended LLKB glossary\n * Core glossary takes precedence for exact matches (LLKB only extends, never overrides)\n * @param term - Term to look up\n * @returns IR primitive if found, undefined otherwise\n */\nexport function lookupGlossary(term: string): IRPrimitive | undefined {\n  const normalizedTerm = term.toLowerCase().trim();\n\n  // First check if core glossary has an EXACT match for this term\n  // Core always wins for exact matches (LLKB never overrides core)\n  if (isExactCoreMatch(normalizedTerm)) {\n    const coreMapping = findModuleMethod(normalizedTerm);\n    if (coreMapping) {\n      return {\n        type: 'callModule',\n        module: coreMapping.module,\n        method: coreMapping.method,\n        args: coreMapping.params ? [coreMapping.params] : undefined,\n      };\n    }\n  }\n\n  // Then check extended glossary for exact match\n  // LLKB extends core glossary with new terms\n  if (extendedGlossary) {\n    const extendedMatch = extendedGlossary.get(normalizedTerm);\n    if (extendedMatch) {\n      return extendedMatch;\n    }\n  }\n\n  // Finally, check core glossary for partial/substring matches\n  // This allows core patterns like \"wait for\" to match \"wait for something\"\n  const coreMapping = findModuleMethod(normalizedTerm);\n  if (coreMapping) {\n    return {\n      type: 'callModule',\n      module: coreMapping.module,\n      method: coreMapping.method,\n      args: coreMapping.params ? [coreMapping.params] : undefined,\n    };\n  }\n\n  return undefined;\n}\n\n/**\n * Lookup a term in core glossary only (for priority enforcement)\n * Used when LLKB should NOT override core mappings\n * @param term - Term to look up\n * @returns IR primitive if found, undefined otherwise\n */\nexport function lookupCoreGlossary(term: string): IRPrimitive | undefined {\n  const normalizedTerm = term.toLowerCase().trim();\n\n  const coreMapping = findModuleMethod(normalizedTerm);\n  if (coreMapping) {\n    return {\n      type: 'callModule',\n      module: coreMapping.module,\n      method: coreMapping.method,\n      args: coreMapping.params ? [coreMapping.params] : undefined,\n    };\n  }\n\n  return undefined;\n}\n\n/**\n * Get glossary statistics\n */\nexport function getGlossaryStats(): {\n  coreEntries: number;\n  extendedEntries: number;\n  extendedExportedAt: string | null;\n  extendedMeta: ExtendedGlossaryMeta | null;\n} {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n\n  return {\n    coreEntries: glossaryCache!.moduleMethods?.length ?? 0,\n    extendedEntries: extendedGlossary?.size ?? 0,\n    extendedExportedAt: extendedGlossaryMeta?.exportedAt ?? null,\n    extendedMeta: extendedGlossaryMeta,\n  };\n}\n\n/**\n * Check if extended glossary is loaded\n */\nexport function hasExtendedGlossary(): boolean {\n  return extendedGlossary !== null && extendedGlossary.size > 0;\n}\n","/**\n * Machine Hint Syntax Patterns - Define regex patterns for parsing hints\n * @see T071 - Define machine hint syntax regex patterns\n */\n\n/**\n * Machine hint types\n */\nexport type HintType =\n  | 'role'       // ARIA role hint: (role=button)\n  | 'testid'     // Test ID hint: (testid=submit-btn)\n  | 'label'      // Label hint: (label=\"Email Address\")\n  | 'text'       // Text hint: (text=\"Submit\")\n  | 'exact'      // Exact matching: (exact=true)\n  | 'level'      // Heading level: (level=2)\n  | 'signal'     // Signal hint: (signal=loading-done)\n  | 'module'     // Module method hint: (module=auth.login)\n  | 'wait'       // Wait strategy: (wait=networkidle)\n  | 'timeout';   // Timeout hint: (timeout=5000)\n\n/**\n * Parsed machine hint\n */\nexport interface MachineHint {\n  /** Hint type */\n  type: HintType;\n  /** Hint value */\n  value: string;\n  /** Raw hint string */\n  raw: string;\n}\n\n/**\n * Pattern for detecting hint blocks: (key=value) or (key=\"value with spaces\")\n */\nexport const HINT_BLOCK_PATTERN = /\\(([a-z]+)=(?:\"([^\"]+)\"|'([^']+)'|([^,)\\s]+))\\)/gi;\n\n/**\n * Pattern for a complete hints section: (...hints...)\n */\nexport const HINTS_SECTION_PATTERN = /\\((?:[a-z]+=(?:\"[^\"]+\"|'[^']+'|[^,)\\s]+)(?:,\\s*)?)+\\)/gi;\n\n/**\n * Individual hint patterns for validation\n */\nexport const HINT_PATTERNS: Record<HintType, RegExp> = {\n  role: /role=(?:\"([^\"]+)\"|'([^']+)'|([a-z]+))/i,\n  testid: /testid=(?:\"([^\"]+)\"|'([^']+)'|([a-z0-9_-]+))/i,\n  label: /label=(?:\"([^\"]+)\"|'([^']+)')/i,\n  text: /text=(?:\"([^\"]+)\"|'([^']+)')/i,\n  exact: /exact=(true|false)/i,\n  level: /level=([1-6])/i,\n  signal: /signal=(?:\"([^\"]+)\"|'([^']+)'|([a-z0-9_-]+))/i,\n  module: /module=(?:\"([^\"]+)\"|'([^']+)'|([a-z0-9_.]+))/i,\n  wait: /wait=(networkidle|domcontentloaded|load|commit)/i,\n  timeout: /timeout=(\\d+)/i,\n};\n\n/**\n * Valid ARIA roles for validation\n */\nexport const VALID_ROLES = [\n  'alert',\n  'alertdialog',\n  'application',\n  'article',\n  'banner',\n  'button',\n  'cell',\n  'checkbox',\n  'columnheader',\n  'combobox',\n  'complementary',\n  'contentinfo',\n  'definition',\n  'dialog',\n  'directory',\n  'document',\n  'feed',\n  'figure',\n  'form',\n  'grid',\n  'gridcell',\n  'group',\n  'heading',\n  'img',\n  'link',\n  'list',\n  'listbox',\n  'listitem',\n  'log',\n  'main',\n  'marquee',\n  'math',\n  'menu',\n  'menubar',\n  'menuitem',\n  'menuitemcheckbox',\n  'menuitemradio',\n  'navigation',\n  'none',\n  'note',\n  'option',\n  'presentation',\n  'progressbar',\n  'radio',\n  'radiogroup',\n  'region',\n  'row',\n  'rowgroup',\n  'rowheader',\n  'scrollbar',\n  'search',\n  'searchbox',\n  'separator',\n  'slider',\n  'spinbutton',\n  'status',\n  'switch',\n  'tab',\n  'table',\n  'tablist',\n  'tabpanel',\n  'term',\n  'textbox',\n  'timer',\n  'toolbar',\n  'tooltip',\n  'tree',\n  'treegrid',\n  'treeitem',\n];\n\n/**\n * Check if a role is valid\n */\nexport function isValidRole(role: string): boolean {\n  return VALID_ROLES.includes(role.toLowerCase());\n}\n\n/**\n * Extract hint value from a match (handles quoted and unquoted values)\n */\nexport function extractHintValue(match: RegExpMatchArray): string | null {\n  // Try quoted values first, then unquoted\n  for (let i = 1; i < match.length; i++) {\n    if (match[i] !== undefined) {\n      return match[i] ?? null;\n    }\n  }\n  return null;\n}\n\n/**\n * Check if text contains machine hints\n */\nexport function containsHints(text: string): boolean {\n  // Reset lastIndex for global regex\n  HINTS_SECTION_PATTERN.lastIndex = 0;\n  return HINTS_SECTION_PATTERN.test(text);\n}\n\n/**\n * Remove hints section from step text\n */\nexport function removeHints(text: string): string {\n  return text.replace(HINTS_SECTION_PATTERN, '').trim();\n}\n","/**\n * Machine Hint Parser - Extract hints from Journey step text\n * @see T072 - Implement machine hint parser\n */\nimport {\n  type HintType,\n  type MachineHint,\n  HINT_BLOCK_PATTERN,\n  HINT_PATTERNS,\n  isValidRole,\n  containsHints,\n  removeHints,\n} from './hintPatterns.js';\n\n/**\n * Parsed hints result\n */\nexport interface ParsedHints {\n  /** All parsed hints */\n  hints: MachineHint[];\n  /** Step text with hints removed */\n  cleanText: string;\n  /** Original text */\n  originalText: string;\n  /** Validation warnings */\n  warnings: string[];\n}\n\n/**\n * Locator hints extracted for code generation\n */\nexport interface LocatorHints {\n  /** ARIA role */\n  role?: string;\n  /** Test ID */\n  testid?: string;\n  /** Label text */\n  label?: string;\n  /** Text content */\n  text?: string;\n  /** Exact matching */\n  exact?: boolean;\n  /** Heading level (for role=heading) */\n  level?: number;\n}\n\n/**\n * Behavioral hints extracted for code generation\n */\nexport interface BehaviorHints {\n  /** Signal to wait for */\n  signal?: string;\n  /** Module method to call */\n  module?: string;\n  /** Wait strategy */\n  wait?: 'networkidle' | 'domcontentloaded' | 'load' | 'commit';\n  /** Timeout in ms */\n  timeout?: number;\n}\n\n/**\n * Complete hint extraction result\n */\nexport interface ExtractedHints {\n  /** Locator-related hints */\n  locator: LocatorHints;\n  /** Behavior-related hints */\n  behavior: BehaviorHints;\n  /** Whether any hints were found */\n  hasHints: boolean;\n  /** Clean step text */\n  cleanText: string;\n  /** Warnings */\n  warnings: string[];\n}\n\n/**\n * Parse machine hints from step text\n */\nexport function parseHints(text: string): ParsedHints {\n  const hints: MachineHint[] = [];\n  const warnings: string[] = [];\n\n  if (!containsHints(text)) {\n    return {\n      hints: [],\n      cleanText: text,\n      originalText: text,\n      warnings: [],\n    };\n  }\n\n  // Extract all hint blocks\n  HINT_BLOCK_PATTERN.lastIndex = 0;\n  let match;\n\n  while ((match = HINT_BLOCK_PATTERN.exec(text)) !== null) {\n    const key = match[1]!.toLowerCase() as HintType;\n    const value = match[2] || match[3] || match[4];\n\n    if (!value) {\n      warnings.push(`Empty value for hint: ${key}`);\n      continue;\n    }\n\n    // Validate the hint type\n    if (!(key in HINT_PATTERNS)) {\n      warnings.push(`Unknown hint type: ${key}`);\n      continue;\n    }\n\n    // Validate role values\n    if (key === 'role' && !isValidRole(value)) {\n      warnings.push(`Invalid ARIA role: ${value}`);\n    }\n\n    hints.push({\n      type: key,\n      value,\n      raw: match[0],\n    });\n  }\n\n  return {\n    hints,\n    cleanText: removeHints(text),\n    originalText: text,\n    warnings,\n  };\n}\n\n/**\n * Extract structured hints for code generation\n */\nexport function extractHints(text: string): ExtractedHints {\n  const parsed = parseHints(text);\n\n  const locator: LocatorHints = {};\n  const behavior: BehaviorHints = {};\n\n  for (const hint of parsed.hints) {\n    switch (hint.type) {\n      case 'role':\n        locator.role = hint.value;\n        break;\n      case 'testid':\n        locator.testid = hint.value;\n        break;\n      case 'label':\n        locator.label = hint.value;\n        break;\n      case 'text':\n        locator.text = hint.value;\n        break;\n      case 'exact':\n        locator.exact = hint.value.toLowerCase() === 'true';\n        break;\n      case 'level':\n        locator.level = parseInt(hint.value, 10);\n        break;\n      case 'signal':\n        behavior.signal = hint.value;\n        break;\n      case 'module':\n        behavior.module = hint.value;\n        break;\n      case 'wait':\n        behavior.wait = hint.value as BehaviorHints['wait'];\n        break;\n      case 'timeout':\n        behavior.timeout = parseInt(hint.value, 10);\n        break;\n    }\n  }\n\n  return {\n    locator,\n    behavior,\n    hasHints: parsed.hints.length > 0,\n    cleanText: parsed.cleanText,\n    warnings: parsed.warnings,\n  };\n}\n\n/**\n * Check if hints specify a locator strategy\n */\nexport function hasLocatorHints(hints: ExtractedHints): boolean {\n  const { locator } = hints;\n  return !!(locator.role || locator.testid || locator.label || locator.text);\n}\n\n/**\n * Check if hints specify behavioral modifications\n */\nexport function hasBehaviorHints(hints: ExtractedHints): boolean {\n  const { behavior } = hints;\n  return !!(behavior.signal || behavior.module || behavior.wait || behavior.timeout);\n}\n\n/**\n * Generate locator code from hints\n */\nexport function generateLocatorFromHints(hints: LocatorHints): string | null {\n  // Priority: testid > role > label > text\n  if (hints.testid) {\n    return `page.getByTestId('${hints.testid}')`;\n  }\n\n  if (hints.role) {\n    const options: string[] = [];\n    if (hints.label) {\n      options.push(`name: '${hints.label}'`);\n    }\n    if (hints.exact) {\n      options.push('exact: true');\n    }\n    if (hints.level && hints.role === 'heading') {\n      options.push(`level: ${hints.level}`);\n    }\n\n    if (options.length > 0) {\n      return `page.getByRole('${hints.role}', { ${options.join(', ')} })`;\n    }\n    return `page.getByRole('${hints.role}')`;\n  }\n\n  if (hints.label) {\n    if (hints.exact) {\n      return `page.getByLabel('${hints.label}', { exact: true })`;\n    }\n    return `page.getByLabel('${hints.label}')`;\n  }\n\n  if (hints.text) {\n    if (hints.exact) {\n      return `page.getByText('${hints.text}', { exact: true })`;\n    }\n    return `page.getByText('${hints.text}')`;\n  }\n\n  return null;\n}\n\n/**\n * Parse module hint into module name and method\n */\nexport function parseModuleHint(moduleHint: string): { module: string; method: string } | null {\n  const parts = moduleHint.split('.');\n  if (parts.length !== 2) {\n    return null;\n  }\n  return {\n    module: parts[0]!,\n    method: parts[1]!,\n  };\n}\n\n/**\n * Validate hints for consistency\n */\nexport function validateHints(hints: ExtractedHints): string[] {\n  const errors: string[] = [];\n\n  // Check for conflicting locator hints\n  const locatorCount = [\n    hints.locator.testid,\n    hints.locator.role,\n    hints.locator.label && !hints.locator.role, // label with role is fine\n    hints.locator.text,\n  ].filter(Boolean).length;\n\n  if (locatorCount > 1) {\n    errors.push('Multiple conflicting locator hints specified');\n  }\n\n  // Check for level without heading role\n  if (hints.locator.level && hints.locator.role !== 'heading') {\n    errors.push('level hint only applies to role=heading');\n  }\n\n  // Check for module hint format\n  if (hints.behavior.module) {\n    const parsed = parseModuleHint(hints.behavior.module);\n    if (!parsed) {\n      errors.push('module hint must be in format: moduleName.methodName');\n    }\n  }\n\n  return errors;\n}\n\n/**\n * Merge hints with inferred locator (hints take priority)\n */\nexport function mergeWithInferred(\n  hints: LocatorHints,\n  inferred: { strategy: string; value: string }\n): { strategy: string; value: string; options?: Record<string, unknown> } {\n  // If hints specify a locator, use it\n  if (hints.testid) {\n    return { strategy: 'testid', value: hints.testid };\n  }\n\n  if (hints.role) {\n    const options: Record<string, unknown> = {};\n    if (hints.label) {\n      options.name = hints.label;\n    }\n    if (hints.exact) {\n      options.exact = true;\n    }\n    if (hints.level) {\n      options.level = hints.level;\n    }\n    return { strategy: 'role', value: hints.role, options };\n  }\n\n  if (hints.label) {\n    const options: Record<string, unknown> = {};\n    if (hints.exact) {\n      options.exact = true;\n    }\n    return { strategy: 'label', value: hints.label, options };\n  }\n\n  if (hints.text) {\n    const options: Record<string, unknown> = {};\n    if (hints.exact) {\n      options.exact = true;\n    }\n    return { strategy: 'text', value: hints.text, options };\n  }\n\n  // Add exact option to inferred if specified\n  if (hints.exact) {\n    return { ...inferred, options: { exact: true } };\n  }\n\n  // Fall back to inferred\n  return inferred;\n}\n","/**\n * Telemetry for blocked steps - Records blocked steps for pattern analysis\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md Phase 3\n */\nimport { existsSync, readFileSync, appendFileSync, mkdirSync } from 'node:fs';\nimport { join, dirname } from 'node:path';\n\n/**\n * Record for a blocked step\n */\nexport interface BlockedStepRecord {\n  /** ISO timestamp when the step was blocked */\n  timestamp: string;\n  /** Journey ID where this step was found */\n  journeyId: string;\n  /** Original step text that was blocked */\n  stepText: string;\n  /** Normalized text (lowercase, trimmed) */\n  normalizedText: string;\n  /** Category of the step */\n  category: 'navigation' | 'interaction' | 'assertion' | 'wait' | 'unknown';\n  /** Reason the step was blocked */\n  reason: string;\n  /** Suggested fix from the system */\n  suggestedFix?: string;\n  /** User's manual fix (if captured) */\n  userFix?: string;\n  /** Nearest pattern that almost matched */\n  nearestPattern?: string;\n  /** Distance to nearest pattern */\n  nearestDistance?: number;\n}\n\n/**\n * Pattern gap identified from telemetry analysis\n */\nexport interface PatternGap {\n  /** Example text that represents this gap */\n  exampleText: string;\n  /** Normalized form of the text */\n  normalizedText: string;\n  /** Number of times this gap was encountered */\n  count: number;\n  /** Category of the gap */\n  category: string;\n  /** All unique step texts that fall into this gap */\n  variants: string[];\n  /** Suggested regex pattern to add */\n  suggestedPattern?: string;\n  /** First occurrence timestamp */\n  firstSeen: string;\n  /** Last occurrence timestamp */\n  lastSeen: string;\n}\n\n/**\n * Telemetry statistics\n */\nexport interface TelemetryStats {\n  /** Total number of blocked steps recorded */\n  totalRecords: number;\n  /** Unique patterns identified */\n  uniquePatterns: number;\n  /** Records by category */\n  byCategory: Record<string, number>;\n  /** Date range of records */\n  dateRange: {\n    earliest: string;\n    latest: string;\n  };\n}\n\n/**\n * Default telemetry file location\n */\nconst DEFAULT_TELEMETRY_DIR = '.artk';\nconst TELEMETRY_FILE = 'blocked-steps-telemetry.jsonl';\n\n/**\n * Get the telemetry file path\n */\nexport function getTelemetryPath(baseDir?: string): string {\n  const dir = baseDir || process.cwd();\n  return join(dir, DEFAULT_TELEMETRY_DIR, TELEMETRY_FILE);\n}\n\n/**\n * Ensure the telemetry directory exists\n */\nfunction ensureTelemetryDir(telemetryPath: string): void {\n  const dir = dirname(telemetryPath);\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n}\n\n/**\n * Normalize step text for telemetry comparison\n * (Simpler normalization than glossary - for deduplication purposes)\n */\nexport function normalizeStepTextForTelemetry(text: string): string {\n  return text\n    .toLowerCase()\n    .trim()\n    // Remove common articles\n    .replace(/\\b(the|a|an)\\b/g, '')\n    // Remove extra whitespace\n    .replace(/\\s+/g, ' ')\n    // Remove quoted values but keep structure\n    .replace(/\"[^\"]*\"/g, '\"\"')\n    .replace(/'[^']*'/g, \"''\")\n    .trim();\n}\n\n/**\n * Categorize a step based on its text\n */\nexport function categorizeStepText(text: string): BlockedStepRecord['category'] {\n  const lower = text.toLowerCase();\n\n  if (\n    lower.includes('navigate') ||\n    lower.includes('go to') ||\n    lower.includes('open') ||\n    lower.includes('visit')\n  ) {\n    return 'navigation';\n  }\n\n  if (\n    lower.includes('click') ||\n    lower.includes('fill') ||\n    lower.includes('enter') ||\n    lower.includes('type') ||\n    lower.includes('select') ||\n    lower.includes('check') ||\n    lower.includes('press') ||\n    lower.includes('submit') ||\n    lower.includes('input')\n  ) {\n    return 'interaction';\n  }\n\n  if (\n    lower.includes('see') ||\n    lower.includes('visible') ||\n    lower.includes('verify') ||\n    lower.includes('assert') ||\n    lower.includes('confirm') ||\n    lower.includes('should') ||\n    lower.includes('ensure') ||\n    lower.includes('expect') ||\n    lower.includes('display')\n  ) {\n    return 'assertion';\n  }\n\n  if (lower.includes('wait') || lower.includes('load') || lower.includes('until')) {\n    return 'wait';\n  }\n\n  return 'unknown';\n}\n\n/**\n * Record a blocked step to the telemetry file\n */\nexport function recordBlockedStep(\n  record: Omit<BlockedStepRecord, 'timestamp' | 'normalizedText' | 'category'> & {\n    category?: BlockedStepRecord['category'];\n  },\n  options: { baseDir?: string } = {}\n): void {\n  const telemetryPath = getTelemetryPath(options.baseDir);\n  ensureTelemetryDir(telemetryPath);\n\n  const fullRecord: BlockedStepRecord = {\n    ...record,\n    timestamp: new Date().toISOString(),\n    normalizedText: normalizeStepTextForTelemetry(record.stepText),\n    category: record.category || categorizeStepText(record.stepText),\n  };\n\n  appendFileSync(telemetryPath, JSON.stringify(fullRecord) + '\\n');\n}\n\n/**\n * Read all blocked step records from the telemetry file\n */\nexport function readBlockedStepRecords(options: { baseDir?: string } = {}): BlockedStepRecord[] {\n  const telemetryPath = getTelemetryPath(options.baseDir);\n\n  if (!existsSync(telemetryPath)) {\n    return [];\n  }\n\n  try {\n    const content = readFileSync(telemetryPath, 'utf-8');\n    return content\n      .split('\\n')\n      .filter(Boolean)\n      .map((line) => {\n        try {\n          return JSON.parse(line) as BlockedStepRecord;\n        } catch {\n          return null;\n        }\n      })\n      .filter((record): record is BlockedStepRecord => record !== null);\n  } catch {\n    return [];\n  }\n}\n\n/**\n * Calculate similarity between two normalized texts\n * Uses simple token-based Jaccard similarity\n */\nfunction calculateTokenSimilarity(a: string, b: string): number {\n  const tokensA = new Set(a.split(' ').filter(Boolean));\n  const tokensB = new Set(b.split(' ').filter(Boolean));\n\n  if (tokensA.size === 0 && tokensB.size === 0) return 1;\n  if (tokensA.size === 0 || tokensB.size === 0) return 0;\n\n  const intersection = new Set([...tokensA].filter((x) => tokensB.has(x)));\n  const union = new Set([...tokensA, ...tokensB]);\n\n  return intersection.size / union.size;\n}\n\n/**\n * Group blocked step records by similarity\n */\nfunction groupBySimilarity(\n  records: BlockedStepRecord[],\n  threshold: number = 0.7\n): Map<string, BlockedStepRecord[]> {\n  const groups = new Map<string, BlockedStepRecord[]>();\n  const processed = new Set<number>();\n\n  for (let i = 0; i < records.length; i++) {\n    if (processed.has(i)) continue;\n\n    const record = records[i]!;\n    const normalized = record.normalizedText;\n    const group: BlockedStepRecord[] = [record];\n    processed.add(i);\n\n    // Find similar records\n    for (let j = i + 1; j < records.length; j++) {\n      if (processed.has(j)) continue;\n\n      const other = records[j]!;\n      const similarity = calculateTokenSimilarity(normalized, other.normalizedText);\n\n      if (similarity >= threshold) {\n        group.push(other);\n        processed.add(j);\n      }\n    }\n\n    groups.set(normalized, group);\n  }\n\n  return groups;\n}\n\n/**\n * Analyze blocked steps to find top pattern gaps\n */\nexport function analyzeBlockedPatterns(options: { baseDir?: string; limit?: number } = {}): PatternGap[] {\n  const records = readBlockedStepRecords(options);\n\n  if (records.length === 0) {\n    return [];\n  }\n\n  const groups = groupBySimilarity(records);\n  const gaps: PatternGap[] = [];\n\n  for (const [normalizedText, groupRecords] of groups) {\n    const timestamps = groupRecords.map((r) => r.timestamp).sort();\n    const variants = [...new Set(groupRecords.map((r) => r.stepText))];\n\n    gaps.push({\n      exampleText: groupRecords[0]!.stepText,\n      normalizedText,\n      count: groupRecords.length,\n      category: groupRecords[0]!.category,\n      variants,\n      suggestedPattern: generateSuggestedPattern(variants),\n      firstSeen: timestamps[0]!,\n      lastSeen: timestamps[timestamps.length - 1]!,\n    });\n  }\n\n  // Sort by count (most frequent first)\n  gaps.sort((a, b) => b.count - a.count);\n\n  return options.limit ? gaps.slice(0, options.limit) : gaps;\n}\n\n/**\n * Generate a suggested regex pattern from examples\n */\nfunction generateSuggestedPattern(variants: string[]): string | undefined {\n  if (variants.length === 0) return undefined;\n\n  // Find common prefix and suffix\n  const example = variants[0]!.toLowerCase();\n\n  // Extract quoted values and replace with placeholders\n  const pattern = example\n    .replace(/\"[^\"]+\"/g, '\"([^\"]+)\"')\n    .replace(/'[^']+'/g, \"'([^']+)'\")\n    // Escape special regex chars (except those we use)\n    .replace(/[.*+?^${}()|[\\]\\\\]/g, (char) => {\n      if (char === '(' || char === ')' || char === '[' || char === ']' || char === '+') {\n        return char;\n      }\n      return '\\\\' + char;\n    });\n\n  return `^(?:user\\\\s+)?${pattern}$`;\n}\n\n/**\n * Get telemetry statistics\n */\nexport function getTelemetryStats(options: { baseDir?: string } = {}): TelemetryStats {\n  const records = readBlockedStepRecords(options);\n\n  if (records.length === 0) {\n    return {\n      totalRecords: 0,\n      uniquePatterns: 0,\n      byCategory: {},\n      dateRange: {\n        earliest: '',\n        latest: '',\n      },\n    };\n  }\n\n  const byCategory: Record<string, number> = {};\n  const normalizedSet = new Set<string>();\n  const timestamps = records.map((r) => r.timestamp).sort();\n\n  for (const record of records) {\n    byCategory[record.category] = (byCategory[record.category] || 0) + 1;\n    normalizedSet.add(record.normalizedText);\n  }\n\n  return {\n    totalRecords: records.length,\n    uniquePatterns: normalizedSet.size,\n    byCategory,\n    dateRange: {\n      earliest: timestamps[0]!,\n      latest: timestamps[timestamps.length - 1]!,\n    },\n  };\n}\n\n/**\n * Record a user fix for a previously blocked step\n */\nexport function recordUserFix(\n  originalStepText: string,\n  userFixedText: string,\n  options: { baseDir?: string } = {}\n): void {\n  const records = readBlockedStepRecords(options);\n  const normalizedOriginal = normalizeStepTextForTelemetry(originalStepText);\n\n  // Find matching record and update it (append new record with fix)\n  const matchingRecord = records.find((r) => r.normalizedText === normalizedOriginal && !r.userFix);\n\n  if (matchingRecord) {\n    // Record the user fix - timestamp and normalizedText will be set by recordBlockedStep\n    const { timestamp: _t, normalizedText: _n, ...recordWithoutTimestamp } = matchingRecord;\n    recordBlockedStep(\n      {\n        ...recordWithoutTimestamp,\n        userFix: userFixedText,\n      },\n      options\n    );\n  }\n}\n\n/**\n * Clear telemetry data (for testing or reset)\n */\nexport function clearTelemetry(options: { baseDir?: string } = {}): void {\n  const telemetryPath = getTelemetryPath(options.baseDir);\n  if (existsSync(telemetryPath)) {\n    const { unlinkSync } = require('node:fs');\n    unlinkSync(telemetryPath);\n  }\n}\n","/**\n * LLKB Pattern Extension - Learning and promotion of patterns from LLKB\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md Phase 4\n */\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { join, dirname } from 'node:path';\nimport type { IRPrimitive } from '../ir/types.js';\nimport { normalizeStepTextForTelemetry as normalizeStepText } from '../mapping/telemetry.js';\n\n/**\n * A pattern learned from successful step mappings\n */\nexport interface LearnedPattern {\n  /** Unique identifier */\n  id: string;\n  /** Original step text that was learned from */\n  originalText: string;\n  /** Normalized form for matching */\n  normalizedText: string;\n  /** The IR primitive this text maps to */\n  mappedPrimitive: IRPrimitive;\n  /** Confidence score (0-1) */\n  confidence: number;\n  /** Journey IDs where this pattern was used */\n  sourceJourneys: string[];\n  /** Number of successful uses */\n  successCount: number;\n  /** Number of failed uses */\n  failCount: number;\n  /** Timestamp of last use */\n  lastUsed: string;\n  /** Timestamp when created */\n  createdAt: string;\n  /** Whether this pattern has been promoted to core */\n  promotedToCore: boolean;\n  /** Promotion timestamp if promoted */\n  promotedAt?: string;\n}\n\n/**\n * Pattern ready for promotion to core\n */\nexport interface PromotedPattern {\n  /** The learned pattern being promoted */\n  pattern: LearnedPattern;\n  /** Generated regex string for the pattern */\n  generatedRegex: string;\n  /** Priority score for ordering */\n  priority: number;\n}\n\n/**\n * LLKB pattern match result\n */\nexport interface LlkbPatternMatch {\n  /** Pattern ID that matched */\n  patternId: string;\n  /** The IR primitive */\n  primitive: IRPrimitive;\n  /** Confidence of the match */\n  confidence: number;\n}\n\n/**\n * Options for pruning patterns\n */\nexport interface PruneOptions {\n  /** Minimum confidence to keep */\n  minConfidence?: number;\n  /** Minimum success count to keep */\n  minSuccess?: number;\n  /** Maximum age in days to keep */\n  maxAgeDays?: number;\n}\n\n/**\n * Storage file for learned patterns\n */\nconst PATTERNS_FILE = 'learned-patterns.json';\nconst DEFAULT_LLKB_ROOT = '.artk/llkb';\n\n/**\n * Get the path to the patterns file\n */\nexport function getPatternsFilePath(llkbRoot?: string): string {\n  const root = llkbRoot || join(process.cwd(), DEFAULT_LLKB_ROOT);\n  return join(root, PATTERNS_FILE);\n}\n\n/**\n * Generate a unique pattern ID\n */\nexport function generatePatternId(): string {\n  return `LP${Date.now().toString(36)}${Math.random().toString(36).slice(2, 6)}`.toUpperCase();\n}\n\n/**\n * Load learned patterns from storage\n */\nexport function loadLearnedPatterns(options: { llkbRoot?: string } = {}): LearnedPattern[] {\n  const filePath = getPatternsFilePath(options.llkbRoot);\n\n  if (!existsSync(filePath)) {\n    return [];\n  }\n\n  try {\n    const content = readFileSync(filePath, 'utf-8');\n    const data = JSON.parse(content);\n    return Array.isArray(data.patterns) ? data.patterns : [];\n  } catch {\n    return [];\n  }\n}\n\n/**\n * Save learned patterns to storage\n */\nexport function saveLearnedPatterns(\n  patterns: LearnedPattern[],\n  options: { llkbRoot?: string } = {}\n): void {\n  const filePath = getPatternsFilePath(options.llkbRoot);\n  const dir = dirname(filePath);\n\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n\n  const data = {\n    version: '1.0.0',\n    lastUpdated: new Date().toISOString(),\n    patterns,\n  };\n\n  writeFileSync(filePath, JSON.stringify(data, null, 2), 'utf-8');\n}\n\n/**\n * Calculate confidence from success/fail counts\n * Uses Wilson score interval for small sample sizes\n */\nexport function calculateConfidence(successCount: number, failCount: number): number {\n  const total = successCount + failCount;\n  if (total === 0) return 0.5;\n\n  const p = successCount / total;\n  const z = 1.96; // 95% confidence\n  const n = total;\n\n  // Wilson score lower bound\n  const denominator = 1 + (z * z) / n;\n  const center = p + (z * z) / (2 * n);\n  const spread = z * Math.sqrt((p * (1 - p) + (z * z) / (4 * n)) / n);\n\n  return Math.max(0, Math.min(1, (center - spread) / denominator));\n}\n\n/**\n * Record a successful pattern transformation\n */\nexport function recordPatternSuccess(\n  originalText: string,\n  primitive: IRPrimitive,\n  journeyId: string,\n  options: { llkbRoot?: string } = {}\n): LearnedPattern {\n  const patterns = loadLearnedPatterns(options);\n  const normalizedText = normalizeStepText(originalText);\n\n  // Find existing pattern\n  let pattern = patterns.find((p) => p.normalizedText === normalizedText);\n\n  if (pattern) {\n    // Update existing\n    pattern.successCount++;\n    pattern.confidence = calculateConfidence(pattern.successCount, pattern.failCount);\n    pattern.lastUsed = new Date().toISOString();\n    if (!pattern.sourceJourneys.includes(journeyId)) {\n      pattern.sourceJourneys.push(journeyId);\n    }\n  } else {\n    // Create new\n    pattern = {\n      id: generatePatternId(),\n      originalText,\n      normalizedText,\n      mappedPrimitive: primitive,\n      confidence: 0.5, // Initial confidence\n      sourceJourneys: [journeyId],\n      successCount: 1,\n      failCount: 0,\n      lastUsed: new Date().toISOString(),\n      createdAt: new Date().toISOString(),\n      promotedToCore: false,\n    };\n    patterns.push(pattern);\n  }\n\n  saveLearnedPatterns(patterns, options);\n  return pattern;\n}\n\n/**\n * Record a failed pattern use\n */\nexport function recordPatternFailure(\n  originalText: string,\n  journeyId: string,\n  options: { llkbRoot?: string } = {}\n): LearnedPattern | null {\n  const patterns = loadLearnedPatterns(options);\n  const normalizedText = normalizeStepText(originalText);\n\n  const pattern = patterns.find((p) => p.normalizedText === normalizedText);\n\n  if (pattern) {\n    pattern.failCount++;\n    pattern.confidence = calculateConfidence(pattern.successCount, pattern.failCount);\n    pattern.lastUsed = new Date().toISOString();\n    saveLearnedPatterns(patterns, options);\n    return pattern;\n  }\n\n  return null;\n}\n\n/**\n * Match text against learned LLKB patterns\n */\nexport function matchLlkbPattern(\n  text: string,\n  options: { llkbRoot?: string; minConfidence?: number } = {}\n): LlkbPatternMatch | null {\n  const patterns = loadLearnedPatterns(options);\n  const normalizedText = normalizeStepText(text);\n  const minConfidence = options.minConfidence ?? 0.7;\n\n  // Find exact normalized match with sufficient confidence\n  const match = patterns.find(\n    (p) => p.normalizedText === normalizedText && p.confidence >= minConfidence && !p.promotedToCore\n  );\n\n  if (match) {\n    return {\n      patternId: match.id,\n      primitive: match.mappedPrimitive,\n      confidence: match.confidence,\n    };\n  }\n\n  return null;\n}\n\n/**\n * Generate a regex pattern from a learned text pattern\n * This is a heuristic approach - complex patterns may need manual refinement\n */\nexport function generateRegexFromText(text: string): string {\n  let pattern = text\n    .toLowerCase()\n    // Escape special regex chars\n    .replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n    // Replace quoted values with capture groups\n    .replace(/\"[^\"]+\"/g, '\"([^\"]+)\"')\n    .replace(/'[^']+'/g, \"'([^']+)'\")\n    // Make articles optional\n    .replace(/\\b(the|a|an)\\b/g, '(?:$1\\\\s+)?')\n    // Make \"user\" prefix optional\n    .replace(/^user\\s+/, '(?:user\\\\s+)?')\n    // Handle common verbs\n    .replace(/\\bclicks?\\b/g, 'clicks?')\n    .replace(/\\bfills?\\b/g, 'fills?')\n    .replace(/\\bselects?\\b/g, 'selects?')\n    .replace(/\\btypes?\\b/g, 'types?')\n    .replace(/\\bsees?\\b/g, 'sees?')\n    .replace(/\\bwaits?\\b/g, 'waits?');\n\n  return `^${pattern}$`;\n}\n\n/**\n * Get patterns ready for promotion to core\n */\nexport function getPromotablePatterns(options: { llkbRoot?: string } = {}): PromotedPattern[] {\n  const patterns = loadLearnedPatterns(options);\n\n  const promotable = patterns.filter(\n    (p) =>\n      p.confidence >= 0.9 &&\n      p.successCount >= 5 &&\n      p.sourceJourneys.length >= 2 &&\n      !p.promotedToCore\n  );\n\n  return promotable.map((pattern) => ({\n    pattern,\n    generatedRegex: generateRegexFromText(pattern.originalText),\n    priority: pattern.successCount * pattern.confidence,\n  }));\n}\n\n/**\n * Mark patterns as promoted\n */\nexport function markPatternsPromoted(\n  patternIds: string[],\n  options: { llkbRoot?: string } = {}\n): void {\n  const patterns = loadLearnedPatterns(options);\n  const now = new Date().toISOString();\n\n  for (const pattern of patterns) {\n    if (patternIds.includes(pattern.id)) {\n      pattern.promotedToCore = true;\n      pattern.promotedAt = now;\n    }\n  }\n\n  saveLearnedPatterns(patterns, options);\n}\n\n/**\n * Prune low-quality patterns\n */\nexport function prunePatterns(options: PruneOptions & { llkbRoot?: string } = {}): {\n  removed: number;\n  remaining: number;\n} {\n  const patterns = loadLearnedPatterns(options);\n  const now = Date.now();\n  const maxAge = (options.maxAgeDays ?? 90) * 24 * 60 * 60 * 1000;\n  const minConfidence = options.minConfidence ?? 0.3;\n  const minSuccess = options.minSuccess ?? 1;\n\n  const filtered = patterns.filter((p) => {\n    // Keep if already promoted\n    if (p.promotedToCore) return true;\n\n    // Remove if below minimum confidence\n    if (p.confidence < minConfidence) return false;\n\n    // Remove if no successes and required\n    if (minSuccess > 0 && p.successCount < minSuccess) return false;\n\n    // Remove if too old and never successful\n    const age = now - new Date(p.createdAt).getTime();\n    if (age > maxAge && p.successCount === 0) return false;\n\n    return true;\n  });\n\n  const removed = patterns.length - filtered.length;\n\n  if (removed > 0) {\n    saveLearnedPatterns(filtered, options);\n  }\n\n  return {\n    removed,\n    remaining: filtered.length,\n  };\n}\n\n/**\n * Get pattern statistics\n */\nexport function getPatternStats(options: { llkbRoot?: string } = {}): {\n  total: number;\n  promoted: number;\n  highConfidence: number;\n  lowConfidence: number;\n  avgConfidence: number;\n  totalSuccesses: number;\n  totalFailures: number;\n} {\n  const patterns = loadLearnedPatterns(options);\n\n  if (patterns.length === 0) {\n    return {\n      total: 0,\n      promoted: 0,\n      highConfidence: 0,\n      lowConfidence: 0,\n      avgConfidence: 0,\n      totalSuccesses: 0,\n      totalFailures: 0,\n    };\n  }\n\n  const promoted = patterns.filter((p) => p.promotedToCore).length;\n  const highConfidence = patterns.filter((p) => p.confidence >= 0.7).length;\n  const lowConfidence = patterns.filter((p) => p.confidence < 0.3).length;\n  const totalConfidence = patterns.reduce((sum, p) => sum + p.confidence, 0);\n  const totalSuccesses = patterns.reduce((sum, p) => sum + p.successCount, 0);\n  const totalFailures = patterns.reduce((sum, p) => sum + p.failCount, 0);\n\n  return {\n    total: patterns.length,\n    promoted,\n    highConfidence,\n    lowConfidence,\n    avgConfidence: totalConfidence / patterns.length,\n    totalSuccesses,\n    totalFailures,\n  };\n}\n\n/**\n * Export learned patterns to LLKB config format\n */\nexport function exportPatternsToConfig(options: {\n  llkbRoot?: string;\n  outputPath?: string;\n  minConfidence?: number;\n}): { exported: number; path: string } {\n  const patterns = loadLearnedPatterns(options);\n  const minConfidence = options.minConfidence ?? 0.7;\n\n  const exportable = patterns.filter((p) => p.confidence >= minConfidence && !p.promotedToCore);\n\n  const config = {\n    version: '1.0.0',\n    exportedAt: new Date().toISOString(),\n    patterns: exportable.map((p) => ({\n      id: p.id,\n      trigger: generateRegexFromText(p.originalText),\n      primitive: p.mappedPrimitive,\n      confidence: p.confidence,\n      sourceCount: p.sourceJourneys.length,\n    })),\n  };\n\n  const outputPath =\n    options.outputPath || join(dirname(getPatternsFilePath(options.llkbRoot)), 'autogen-patterns.json');\n\n  writeFileSync(outputPath, JSON.stringify(config, null, 2), 'utf-8');\n\n  return {\n    exported: exportable.length,\n    path: outputPath,\n  };\n}\n\n/**\n * Clear all learned patterns (for testing)\n */\nexport function clearLearnedPatterns(options: { llkbRoot?: string } = {}): void {\n  const filePath = getPatternsFilePath(options.llkbRoot);\n  if (existsSync(filePath)) {\n    const { unlinkSync } = require('node:fs');\n    unlinkSync(filePath);\n  }\n}\n","/**\n * Step Mapper - Convert step text to IR primitives\n * @see research/2026-01-02_autogen-refined-plan.md Section 10\n * @see T073 - Update step mapper to prioritize explicit hints over inference\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md Phase 4 - LLKB integration\n */\nimport type {\n  IRPrimitive,\n  IRStep,\n  LocatorSpec,\n} from '../ir/types.js';\nimport type { AcceptanceCriterion, ProceduralStep } from '../journey/parseJourney.js';\nimport { matchPattern } from './patterns.js';\nimport { normalizeStepText } from './glossary.js';\nimport {\n  extractHints,\n  hasLocatorHints,\n  hasBehaviorHints,\n  parseModuleHint,\n  type ExtractedHints,\n} from '../journey/parseHints.js';\n\n// LLKB integration types - imported dynamically to avoid hard dependency\ntype LlkbPatternMatch = {\n  patternId: string;\n  primitive: IRPrimitive;\n  confidence: number;\n};\n\n// LLKB module reference - loaded lazily\nlet llkbModule: {\n  matchLlkbPattern: (text: string, options?: { llkbRoot?: string; minConfidence?: number }) => LlkbPatternMatch | null;\n  recordPatternSuccess: (text: string, primitive: IRPrimitive, journeyId: string, options?: { llkbRoot?: string }) => void;\n} | null = null;\n\n// Track if we've attempted to load LLKB\nlet llkbLoadAttempted = false;\n\n/**\n * Lazily load LLKB module (graceful degradation if not available)\n */\nasync function loadLlkbModule(): Promise<typeof llkbModule> {\n  if (llkbLoadAttempted) return llkbModule;\n  llkbLoadAttempted = true;\n\n  try {\n    const mod = await import('../llkb/patternExtension.js');\n    llkbModule = {\n      matchLlkbPattern: mod.matchLlkbPattern,\n      recordPatternSuccess: mod.recordPatternSuccess,\n    };\n  } catch {\n    // LLKB not available - this is fine, graceful degradation\n    llkbModule = null;\n  }\n\n  return llkbModule;\n}\n\n/**\n * Synchronously check LLKB (for non-async contexts)\n * Uses previously loaded module if available\n */\nfunction tryLlkbMatch(text: string, options?: { llkbRoot?: string; minConfidence?: number }): LlkbPatternMatch | null {\n  if (!llkbModule) return null;\n  return llkbModule.matchLlkbPattern(text, options);\n}\n\n/**\n * Options for step mapping\n */\nexport interface StepMapperOptions {\n  /** Whether to normalize text before matching */\n  normalizeText?: boolean;\n  /** Whether to include blocked steps for unmatched text */\n  includeBlocked?: boolean;\n  /** Default timeout for assertions */\n  defaultTimeout?: number;\n  /** Whether to use LLKB patterns as fallback (default: true) */\n  useLlkb?: boolean;\n  /** LLKB root directory (default: .artk/llkb) */\n  llkbRoot?: string;\n  /** Minimum confidence for LLKB pattern matches (default: 0.7) */\n  llkbMinConfidence?: number;\n  /** Journey ID for LLKB recording (optional) */\n  journeyId?: string;\n}\n\n/**\n * Result of mapping a single step\n */\nexport interface StepMappingResult {\n  /** The parsed primitive, or null if not matched */\n  primitive: IRPrimitive | null;\n  /** Original text that was mapped */\n  sourceText: string;\n  /** Whether this is an assertion (expect*) or action */\n  isAssertion: boolean;\n  /** Warning or error message if any */\n  message?: string;\n  /** Source of the match */\n  matchSource?: 'pattern' | 'llkb' | 'hints' | 'none';\n  /** LLKB pattern ID if matched via LLKB */\n  llkbPatternId?: string;\n  /** LLKB match confidence if matched via LLKB */\n  llkbConfidence?: number;\n}\n\n/**\n * Result of mapping an acceptance criterion\n */\nexport interface ACMappingResult {\n  /** The mapped IR step */\n  step: IRStep;\n  /** Individual step mapping results */\n  mappings: StepMappingResult[];\n  /** Number of successfully mapped steps */\n  mappedCount: number;\n  /** Number of blocked/unmatched steps */\n  blockedCount: number;\n}\n\n/**\n * Check if a primitive is an assertion\n */\nfunction isAssertion(primitive: IRPrimitive): boolean {\n  return primitive.type.startsWith('expect');\n}\n\n/**\n * Map a single text step to an IR primitive\n */\nexport function mapStepText(\n  text: string,\n  options: StepMapperOptions = {}\n): StepMappingResult {\n  const {\n    normalizeText = true,\n    useLlkb = true,\n    llkbRoot,\n    llkbMinConfidence = 0.7,\n  } = options;\n\n  // Extract machine hints first (T073 - hints take priority)\n  const hints = extractHints(text);\n  const cleanText = hints.hasHints ? hints.cleanText : text;\n\n  // Normalize text if enabled\n  const processedText = normalizeText ? normalizeStepText(cleanText) : cleanText;\n\n  // Try to match against core patterns first\n  let primitive = matchPattern(processedText);\n  let matchSource: 'pattern' | 'llkb' | 'hints' | 'none' = primitive ? 'pattern' : 'none';\n\n  // If we have hints, enhance or override the primitive\n  if (primitive && hints.hasHints) {\n    primitive = applyHintsToPrimitive(primitive, hints);\n  }\n\n  // If no core pattern match, try LLKB patterns (Phase 4 integration)\n  let llkbPatternId: string | undefined;\n  let llkbConfidence: number | undefined;\n\n  if (!primitive && useLlkb) {\n    const llkbMatch = tryLlkbMatch(processedText, {\n      llkbRoot,\n      minConfidence: llkbMinConfidence,\n    });\n\n    if (llkbMatch) {\n      primitive = llkbMatch.primitive;\n      matchSource = 'llkb';\n      llkbPatternId = llkbMatch.patternId;\n      llkbConfidence = llkbMatch.confidence;\n\n      // Apply hints to LLKB-matched primitive if available\n      if (hints.hasHints) {\n        primitive = applyHintsToPrimitive(primitive, hints);\n      }\n    }\n  }\n\n  // If still no match but we have locator hints, try to create primitive from hints\n  if (!primitive && hasLocatorHints(hints)) {\n    primitive = createPrimitiveFromHints(processedText, hints);\n    if (primitive) {\n      matchSource = 'hints';\n    }\n  }\n\n  if (primitive) {\n    return {\n      primitive,\n      sourceText: text,\n      isAssertion: isAssertion(primitive),\n      matchSource,\n      llkbPatternId,\n      llkbConfidence,\n    };\n  }\n\n  // No match - return blocked\n  return {\n    primitive: null,\n    sourceText: text,\n    isAssertion: false,\n    message: `Could not map step: \"${text}\"`,\n    matchSource: 'none',\n  };\n}\n\n/**\n * Apply hints to an existing primitive (override inferred values)\n */\nfunction applyHintsToPrimitive(primitive: IRPrimitive, hints: ExtractedHints): IRPrimitive {\n  // Clone the primitive to avoid mutation\n  const enhanced = { ...primitive };\n\n  // Apply locator hints if present\n  if (hasLocatorHints(hints)) {\n    const locatorSpec = buildLocatorFromHints(hints);\n    if (locatorSpec && 'locator' in enhanced) {\n      (enhanced as { locator: LocatorSpec }).locator = locatorSpec;\n    }\n  }\n\n  // Apply behavior hints\n  if (hasBehaviorHints(hints)) {\n    if (hints.behavior.timeout !== undefined && 'timeout' in enhanced) {\n      (enhanced as { timeout: number }).timeout = hints.behavior.timeout;\n    }\n    if (hints.behavior.signal && 'signal' in enhanced) {\n      (enhanced as { signal: string }).signal = hints.behavior.signal;\n    }\n    if (hints.behavior.module) {\n      const parsed = parseModuleHint(hints.behavior.module);\n      if (parsed) {\n        (enhanced as { module?: string; method?: string }).module = parsed.module;\n        (enhanced as { module?: string; method?: string }).method = parsed.method;\n      }\n    }\n  }\n\n  return enhanced;\n}\n\n/**\n * Build LocatorSpec from hints\n */\nfunction buildLocatorFromHints(hints: ExtractedHints): LocatorSpec | null {\n  const { locator } = hints;\n\n  if (locator.testid) {\n    return { strategy: 'testid', value: locator.testid };\n  }\n\n  if (locator.role) {\n    const options: Record<string, unknown> = {};\n    if (locator.label) options.name = locator.label;\n    if (locator.exact) options.exact = true;\n    if (locator.level) options.level = locator.level;\n    return {\n      strategy: 'role',\n      value: locator.role,\n      options: Object.keys(options).length > 0 ? options : undefined,\n    };\n  }\n\n  if (locator.label) {\n    return {\n      strategy: 'label',\n      value: locator.label,\n      options: locator.exact ? { exact: true } : undefined,\n    };\n  }\n\n  if (locator.text) {\n    return {\n      strategy: 'text',\n      value: locator.text,\n      options: locator.exact ? { exact: true } : undefined,\n    };\n  }\n\n  return null;\n}\n\n/**\n * Create a primitive from hints when no pattern matched\n */\nfunction createPrimitiveFromHints(text: string, hints: ExtractedHints): IRPrimitive | null {\n  const locator = buildLocatorFromHints(hints);\n  if (!locator) return null;\n\n  const lowerText = text.toLowerCase();\n\n  // Infer action type from text\n  if (lowerText.includes('click') || lowerText.includes('press')) {\n    return { type: 'click', locator };\n  }\n\n  if (lowerText.includes('enter') || lowerText.includes('type') || lowerText.includes('fill')) {\n    // Try to extract value from text\n    const valueMatch = text.match(/['\"]([^'\"]+)['\"]/);\n    return {\n      type: 'fill',\n      locator,\n      value: { type: 'literal', value: valueMatch ? valueMatch[1]! : '' },\n    };\n  }\n\n  if (lowerText.includes('see') || lowerText.includes('visible') || lowerText.includes('display')) {\n    return { type: 'expectVisible', locator };\n  }\n\n  if (lowerText.includes('check') || lowerText.includes('select')) {\n    return { type: 'check', locator };\n  }\n\n  // Default to click if we have a locator but can't determine action\n  return { type: 'click', locator };\n}\n\n/**\n * Map an acceptance criterion to an IR step\n */\nexport function mapAcceptanceCriterion(\n  ac: AcceptanceCriterion,\n  proceduralSteps: ProceduralStep[],\n  options: StepMapperOptions = {}\n): ACMappingResult {\n  const { includeBlocked = true } = options;\n\n  const actions: IRPrimitive[] = [];\n  const assertions: IRPrimitive[] = [];\n  const mappings: StepMappingResult[] = [];\n  const notes: string[] = [];\n\n  // Find procedural steps linked to this AC\n  const linkedProcedural = proceduralSteps.filter((ps) => ps.linkedAC === ac.id);\n\n  // Map all bullet points from the AC\n  for (const stepText of ac.steps) {\n    const result = mapStepText(stepText, options);\n    mappings.push(result);\n\n    if (result.primitive) {\n      if (result.isAssertion) {\n        assertions.push(result.primitive);\n      } else {\n        actions.push(result.primitive);\n      }\n    } else if (includeBlocked) {\n      actions.push({\n        type: 'blocked',\n        reason: result.message || 'Could not map step',\n        sourceText: stepText,\n      });\n    }\n  }\n\n  // Also map linked procedural steps\n  for (const ps of linkedProcedural) {\n    const result = mapStepText(ps.text, options);\n    // Don't duplicate in mappings, but add to actions if different from AC steps\n    if (result.primitive && !ac.steps.includes(ps.text)) {\n      if (result.isAssertion) {\n        assertions.push(result.primitive);\n      } else {\n        actions.push(result.primitive);\n      }\n    }\n  }\n\n  // Add note if no assertions\n  if (assertions.length === 0 && ac.title) {\n    notes.push(`TODO: Add assertion for: ${ac.title}`);\n  }\n\n  const step: IRStep = {\n    id: ac.id,\n    description: ac.title || `Step ${ac.id}`,\n    actions,\n    assertions,\n    sourceText: ac.rawContent,\n    notes: notes.length > 0 ? notes : undefined,\n  };\n\n  return {\n    step,\n    mappings,\n    mappedCount: mappings.filter((m) => m.primitive !== null).length,\n    blockedCount: mappings.filter((m) => m.primitive === null).length,\n  };\n}\n\n/**\n * Map a procedural step to an IR step\n */\nexport function mapProceduralStep(\n  ps: ProceduralStep,\n  options: StepMapperOptions = {}\n): ACMappingResult {\n  const { includeBlocked = true } = options;\n\n  const result = mapStepText(ps.text, options);\n  const actions: IRPrimitive[] = [];\n  const assertions: IRPrimitive[] = [];\n\n  if (result.primitive) {\n    if (result.isAssertion) {\n      assertions.push(result.primitive);\n    } else {\n      actions.push(result.primitive);\n    }\n  } else if (includeBlocked) {\n    actions.push({\n      type: 'blocked',\n      reason: result.message || 'Could not map procedural step',\n      sourceText: ps.text,\n    });\n  }\n\n  const step: IRStep = {\n    id: `PS-${ps.number}`,\n    description: ps.text,\n    actions,\n    assertions,\n  };\n\n  return {\n    step,\n    mappings: [result],\n    mappedCount: result.primitive ? 1 : 0,\n    blockedCount: result.primitive ? 0 : 1,\n  };\n}\n\n/**\n * Batch map multiple steps\n */\nexport function mapSteps(\n  steps: string[],\n  options: StepMapperOptions = {}\n): StepMappingResult[] {\n  return steps.map((step) => mapStepText(step, options));\n}\n\n/**\n * Get mapping statistics (enhanced with LLKB stats)\n */\nexport function getMappingStats(mappings: StepMappingResult[]): {\n  total: number;\n  mapped: number;\n  blocked: number;\n  actions: number;\n  assertions: number;\n  mappingRate: number;\n  /** Steps matched by core patterns */\n  patternMatches: number;\n  /** Steps matched by LLKB patterns */\n  llkbMatches: number;\n  /** Steps matched by hints */\n  hintMatches: number;\n} {\n  const mapped = mappings.filter((m) => m.primitive !== null);\n  const blocked = mappings.filter((m) => m.primitive === null);\n  const actions = mapped.filter((m) => !m.isAssertion);\n  const assertions = mapped.filter((m) => m.isAssertion);\n\n  const patternMatches = mappings.filter((m) => m.matchSource === 'pattern').length;\n  const llkbMatches = mappings.filter((m) => m.matchSource === 'llkb').length;\n  const hintMatches = mappings.filter((m) => m.matchSource === 'hints').length;\n\n  return {\n    total: mappings.length,\n    mapped: mapped.length,\n    blocked: blocked.length,\n    actions: actions.length,\n    assertions: assertions.length,\n    mappingRate: mappings.length > 0 ? mapped.length / mappings.length : 0,\n    patternMatches,\n    llkbMatches,\n    hintMatches,\n  };\n}\n\n/**\n * Initialize LLKB module for use with step mapping\n * Call this once at the start of generation to enable LLKB patterns\n */\nexport async function initializeLlkb(): Promise<boolean> {\n  const mod = await loadLlkbModule();\n  return mod !== null;\n}\n\n/**\n * Check if LLKB is available for use\n */\nexport function isLlkbAvailable(): boolean {\n  return llkbModule !== null;\n}\n\n/**\n * Suggest improvements for blocked steps\n */\nexport function suggestImprovements(blockedSteps: StepMappingResult[]): string[] {\n  const suggestions: string[] = [];\n\n  for (const step of blockedSteps) {\n    const text = step.sourceText.toLowerCase();\n\n    // Navigation suggestions\n    if (text.includes('go') || text.includes('open') || text.includes('navigate')) {\n      suggestions.push(\n        `\"${step.sourceText}\" - Try: \"User navigates to /path\" or \"User opens /path\"`\n      );\n    }\n    // Click suggestions\n    else if (text.includes('click') || text.includes('press') || text.includes('button')) {\n      suggestions.push(\n        `\"${step.sourceText}\" - Try: \"User clicks 'Button Name' button\" or \"Click the 'Label' button\"`\n      );\n    }\n    // Fill suggestions\n    else if (text.includes('enter') || text.includes('type') || text.includes('field')) {\n      suggestions.push(\n        `\"${step.sourceText}\" - Try: \"User enters 'value' in 'Field Label' field\"`\n      );\n    }\n    // Visibility suggestions\n    else if (text.includes('see') || text.includes('visible') || text.includes('display')) {\n      suggestions.push(\n        `\"${step.sourceText}\" - Try: \"User should see 'Text'\" or \"'Element' is visible\"`\n      );\n    }\n    // Generic suggestion\n    else {\n      suggestions.push(\n        `\"${step.sourceText}\" - Could not determine intent. Check the patterns documentation.`\n      );\n    }\n  }\n\n  return suggestions;\n}\n","/**\n * Shared escaping utilities for code generation.\n * Consolidates escapeRegex and escapeString from multiple locations.\n */\n\n/**\n * Escape special regex characters in a string.\n * Includes forward slash for URL patterns.\n */\nexport function escapeRegex(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\\\/]/g, '\\\\$&');\n}\n\n/**\n * Escape a string for use in generated JavaScript/TypeScript code.\n * Handles quotes, backslashes, newlines, and carriage returns.\n */\nexport function escapeString(str: string): string {\n  return str\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/'/g, \"\\\\'\")\n    .replace(/\"/g, '\\\\\"')\n    .replace(/\\n/g, '\\\\n')\n    .replace(/\\r/g, '\\\\r');\n}\n\n/**\n * Escape a selector string for use in Playwright locators.\n * Handles quotes that would break the selector syntax.\n */\nexport function escapeSelector(str: string): string {\n  return str.replace(/'/g, \"\\\\'\");\n}\n","/**\n * Journey Normalizer - Convert parsed Journey to IR\n * @see research/2026-01-02_autogen-refined-plan.md Section 9\n */\nimport type { ParsedJourney, AcceptanceCriterion, ProceduralStep } from './parseJourney.js';\nimport type {\n  IRJourney,\n  IRStep,\n  IRPrimitive,\n  IRMappingResult,\n  ModuleDependencies,\n  CompletionSignal,\n  JourneyDataConfig,\n  LocatorSpec,\n} from '../ir/types.js';\nimport { mapStepText } from '../mapping/stepMapper.js';\nimport { escapeRegex } from '../utils/escaping.js';\n\n/**\n * Options for normalizing a Journey\n */\nexport interface NormalizeOptions {\n  /** Include blocked steps in output */\n  includeBlocked?: boolean;\n  /** Strict mode - fail on any blocked step */\n  strict?: boolean;\n  /** Default timeout for assertions (ms) */\n  defaultTimeout?: number;\n}\n\n/**\n * Normalize a parsed Journey into IR format\n */\nexport function normalizeJourney(\n  parsed: ParsedJourney,\n  options: NormalizeOptions = {}\n): IRMappingResult {\n  const { includeBlocked = true, strict = false } = options;\n\n  const blockedSteps: IRMappingResult['blockedSteps'] = [];\n  const warnings: string[] = [];\n\n  // Map acceptance criteria to IR steps\n  const steps: IRStep[] = [];\n\n  for (const ac of parsed.acceptanceCriteria) {\n    const step = mapAcceptanceCriterionToStep(ac, parsed.proceduralSteps, warnings);\n\n    // Check for blocked primitives\n    const blockedPrimitives = [\n      ...step.actions.filter((a) => a.type === 'blocked'),\n      ...step.assertions.filter((a) => a.type === 'blocked'),\n    ] as Array<{ type: 'blocked'; reason: string; sourceText: string }>;\n\n    if (blockedPrimitives.length > 0) {\n      for (const blocked of blockedPrimitives) {\n        blockedSteps.push({\n          stepId: step.id,\n          sourceText: blocked.sourceText,\n          reason: blocked.reason,\n        });\n      }\n\n      if (strict) {\n        continue; // Skip blocked steps in strict mode\n      }\n    }\n\n    if (includeBlocked || blockedPrimitives.length === 0) {\n      steps.push(step);\n    }\n  }\n\n  // If no AC-based steps, create steps from procedural steps\n  if (steps.length === 0 && parsed.proceduralSteps.length > 0) {\n    for (const ps of parsed.proceduralSteps) {\n      const step = mapProceduralStepToIRStep(ps, warnings);\n      steps.push(step);\n    }\n  }\n\n  // Build module dependencies\n  const moduleDependencies: ModuleDependencies = {\n    foundation: parsed.frontmatter.modules?.foundation ?? [],\n    feature: parsed.frontmatter.modules?.features ?? [],\n  };\n\n  // Map completion signals\n  const completion: CompletionSignal[] | undefined = parsed.frontmatter.completion?.map((c) => ({\n    type: c.type,\n    value: c.value,\n    options: c.options,\n  }));\n\n  // Map data config\n  const data: JourneyDataConfig | undefined = parsed.frontmatter.data\n    ? {\n        strategy: parsed.frontmatter.data.strategy,\n        cleanup: parsed.frontmatter.data.cleanup,\n      }\n    : undefined;\n\n  // Build the IR Journey\n  const journey: IRJourney = {\n    id: parsed.frontmatter.id,\n    title: parsed.frontmatter.title,\n    tier: parsed.frontmatter.tier,\n    scope: parsed.frontmatter.scope,\n    actor: parsed.frontmatter.actor,\n    tags: buildTags(parsed),\n    moduleDependencies,\n    data,\n    completion,\n    steps,\n    revision: parsed.frontmatter.revision,\n    prerequisites: parsed.frontmatter.prerequisites,\n    negativePaths: parsed.frontmatter.negativePaths,\n    sourcePath: parsed.sourcePath,\n    // P3 Feature fields - pass through from frontmatter\n    testData: parsed.frontmatter.testData,\n    visualRegression: parsed.frontmatter.visualRegression,\n    accessibility: parsed.frontmatter.accessibility,\n    performance: parsed.frontmatter.performance,\n  };\n\n  // Calculate stats\n  const stats = {\n    totalSteps: parsed.acceptanceCriteria.length || parsed.proceduralSteps.length,\n    mappedSteps: steps.length,\n    blockedSteps: blockedSteps.length,\n    totalActions: steps.reduce((sum, s) => sum + s.actions.length, 0),\n    totalAssertions: steps.reduce((sum, s) => sum + s.assertions.length, 0),\n  };\n\n  return {\n    journey,\n    blockedSteps,\n    warnings,\n    stats,\n  };\n}\n\n/**\n * Map an acceptance criterion to an IR step\n */\nfunction mapAcceptanceCriterionToStep(\n  ac: AcceptanceCriterion,\n  proceduralSteps: ProceduralStep[],\n  warnings: string[]\n): IRStep {\n  const actions: IRPrimitive[] = [];\n  const assertions: IRPrimitive[] = [];\n  const notes: string[] = [];\n\n  // Find related procedural steps\n  const relatedProcedural = proceduralSteps.filter((ps) => ps.linkedAC === ac.id);\n\n  // Process bullet points as potential actions/assertions\n  for (const stepText of ac.steps) {\n    const result = mapStepText(stepText, { normalizeText: false });\n\n    if (result.primitive) {\n      if (isAssertion(result.primitive)) {\n        assertions.push(result.primitive);\n      } else {\n        actions.push(result.primitive);\n      }\n    } else {\n      // Cannot parse - add as blocked\n      actions.push({\n        type: 'blocked',\n        reason: result.message || 'Could not parse step into primitive',\n        sourceText: stepText,\n      });\n      if (result.message) {\n        warnings.push(result.message);\n      }\n    }\n  }\n\n  // Add related procedural steps as actions\n  for (const ps of relatedProcedural) {\n    const result = mapStepText(ps.text, { normalizeText: false });\n    if (result.primitive) {\n      if (isAssertion(result.primitive)) {\n        assertions.push(result.primitive);\n      } else {\n        actions.push(result.primitive);\n      }\n    } else if (result.message) {\n      warnings.push(result.message);\n    }\n  }\n\n  // If no assertions from steps, add a visibility check for the AC title\n  if (assertions.length === 0 && ac.title) {\n    notes.push(`TODO: Add assertion for: ${ac.title}`);\n  }\n\n  return {\n    id: ac.id,\n    description: ac.title || `Step ${ac.id}`,\n    actions,\n    assertions,\n    sourceText: ac.rawContent,\n    notes: notes.length > 0 ? notes : undefined,\n  };\n}\n\n/**\n * Map a procedural step to an IR step\n */\nfunction mapProceduralStepToIRStep(ps: ProceduralStep, warnings: string[]): IRStep {\n  const actions: IRPrimitive[] = [];\n  const assertions: IRPrimitive[] = [];\n\n  const result = mapStepText(ps.text, { normalizeText: false });\n  if (result.primitive) {\n    if (isAssertion(result.primitive)) {\n      assertions.push(result.primitive);\n    } else {\n      actions.push(result.primitive);\n    }\n  } else {\n    actions.push({\n      type: 'blocked',\n      reason: result.message || 'Could not parse procedural step',\n      sourceText: ps.text,\n    });\n    if (result.message) {\n      warnings.push(result.message);\n    }\n  }\n\n  return {\n    id: `PS-${ps.number}`,\n    description: ps.text,\n    actions,\n    assertions,\n  };\n}\n\n/**\n * Check if a primitive is an assertion\n */\nfunction isAssertion(primitive: IRPrimitive): boolean {\n  return primitive.type.startsWith('expect');\n}\n\n/**\n * Build tags for the journey\n */\nfunction buildTags(parsed: ParsedJourney): string[] {\n  const tags = new Set<string>();\n\n  // Standard tags\n  tags.add('@artk');\n  tags.add('@journey');\n  tags.add(`@${parsed.frontmatter.id}`);\n  tags.add(`@tier-${parsed.frontmatter.tier}`);\n  tags.add(`@scope-${parsed.frontmatter.scope}`);\n  tags.add(`@actor-${parsed.frontmatter.actor}`);\n\n  // User-defined tags\n  if (parsed.frontmatter.tags) {\n    for (const tag of parsed.frontmatter.tags) {\n      tags.add(tag.startsWith('@') ? tag : `@${tag}`);\n    }\n  }\n\n  return Array.from(tags);\n}\n\n/**\n * Convert completion signals to IR primitives (final assertions)\n */\nexport function completionSignalsToAssertions(\n  signals: CompletionSignal[]\n): IRPrimitive[] {\n  return signals.map(signal => {\n    switch (signal.type) {\n      case 'url':\n        return {\n          type: 'expectURL',\n          pattern: signal.options?.exact\n            ? signal.value\n            : new RegExp(escapeRegex(signal.value)),\n        } as IRPrimitive;\n\n      case 'toast': {\n        // Parse toast type from value if it contains \"success\", \"error\", \"info\", or \"warning\"\n        const lowerValue = signal.value.toLowerCase();\n        let toastType: 'success' | 'error' | 'info' | 'warning' = 'success';\n        if (lowerValue.includes('error')) {\n          toastType = 'error';\n        } else if (lowerValue.includes('warning')) {\n          toastType = 'warning';\n        } else if (lowerValue.includes('info')) {\n          toastType = 'info';\n        }\n\n        return {\n          type: 'expectToast',\n          toastType,\n          message: signal.value,\n        } as IRPrimitive;\n      }\n\n      case 'element': {\n        const state = signal.options?.state || 'visible';\n        return {\n          type: state === 'hidden' || state === 'detached'\n            ? 'expectNotVisible'\n            : 'expectVisible',\n          locator: parseLocatorFromSelector(signal.value),\n          timeout: signal.options?.timeout,\n        } as IRPrimitive;\n      }\n\n      case 'text':\n        return {\n          type: 'expectVisible',\n          locator: { strategy: 'text', value: signal.value },\n          timeout: signal.options?.timeout,\n        } as IRPrimitive;\n\n      case 'title':\n        return {\n          type: 'expectTitle',\n          title: signal.options?.exact\n            ? signal.value\n            : new RegExp(escapeRegex(signal.value)),\n        } as IRPrimitive;\n\n      case 'api':\n        return {\n          type: 'waitForResponse',\n          urlPattern: signal.value,\n        } as IRPrimitive;\n\n      default:\n        throw new Error(`Unknown completion signal type: ${(signal as CompletionSignal).type}`);\n    }\n  });\n}\n\n/**\n * Parse a selector string to LocatorSpec\n */\nfunction parseLocatorFromSelector(selector: string): LocatorSpec {\n  // data-testid\n  if (selector.includes('data-testid')) {\n    const match = selector.match(/\\[data-testid=['\"]([^'\"]+)['\"]\\]/);\n    if (match) {\n      return { strategy: 'testid', value: match[1]! };\n    }\n  }\n\n  // Role selector\n  if (selector.startsWith('role=')) {\n    return { strategy: 'role', value: selector.slice(5) };\n  }\n\n  // Text selector\n  if (selector.startsWith('text=')) {\n    return { strategy: 'text', value: selector.slice(5) };\n  }\n\n  // Label selector\n  if (selector.startsWith('label=')) {\n    return { strategy: 'label', value: selector.slice(6) };\n  }\n\n  // Placeholder selector\n  if (selector.startsWith('placeholder=')) {\n    return { strategy: 'placeholder', value: selector.slice(12) };\n  }\n\n  // Default to CSS\n  return { strategy: 'css', value: selector };\n}\n\n/**\n * Validate that a Journey is ready for code generation\n */\nexport function validateJourneyForCodeGen(result: IRMappingResult): {\n  valid: boolean;\n  errors: string[];\n} {\n  const errors: string[] = [];\n\n  // Must have at least one step\n  if (result.journey.steps.length === 0) {\n    errors.push('Journey has no steps');\n  }\n\n  // Must have completion signals\n  if (!result.journey.completion || result.journey.completion.length === 0) {\n    errors.push('Journey has no completion signals');\n  }\n\n  // Should not have too many blocked steps\n  if (result.stats.blockedSteps > result.stats.mappedSteps) {\n    errors.push(`Too many blocked steps: ${result.stats.blockedSteps} blocked vs ${result.stats.mappedSteps} mapped`);\n  }\n\n  // Must have at least one assertion\n  if (result.stats.totalAssertions === 0) {\n    errors.push('Journey has no assertions');\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n","/**\n * Selector Priority - Playwright best practices for selector selection\n * @see research/2026-01-02_autogen-refined-plan.md Section 11\n *\n * Priority order (per Playwright docs):\n * 1. role - ARIA roles (most stable, semantic)\n * 2. label - Form labels (accessible)\n * 3. placeholder - Input placeholders\n * 4. text - Visible text content\n * 5. testid - data-testid attributes\n * 6. css - CSS selectors (last resort)\n */\nimport type { LocatorSpec, LocatorStrategy } from '../ir/types.js';\nimport type { AutogenConfig } from '../config/schema.js';\n\n/**\n * Default selector priority\n */\nexport const DEFAULT_SELECTOR_PRIORITY: LocatorStrategy[] = [\n  'role',\n  'label',\n  'placeholder',\n  'text',\n  'testid',\n  'css',\n];\n\n/**\n * Map from element type to preferred selector strategies\n */\nexport const ELEMENT_TYPE_STRATEGIES: Record<string, LocatorStrategy[]> = {\n  button: ['role', 'text', 'testid'],\n  link: ['role', 'text', 'testid'],\n  textbox: ['role', 'label', 'placeholder', 'testid'],\n  checkbox: ['role', 'label', 'testid'],\n  radio: ['role', 'label', 'testid'],\n  combobox: ['role', 'label', 'testid'],\n  heading: ['role', 'text', 'testid'],\n  listitem: ['role', 'text', 'testid'],\n  menuitem: ['role', 'text', 'testid'],\n  tab: ['role', 'text', 'testid'],\n  dialog: ['role', 'testid'],\n  alert: ['role', 'testid'],\n  generic: ['text', 'testid', 'css'],\n};\n\n/**\n * ARIA roles that can have accessible names\n */\nexport const NAMEABLE_ROLES = [\n  'button',\n  'link',\n  'textbox',\n  'checkbox',\n  'radio',\n  'combobox',\n  'heading',\n  'tab',\n  'menuitem',\n  'listitem',\n  'option',\n  'cell',\n  'row',\n  'columnheader',\n  'rowheader',\n];\n\n/**\n * Get selector priority from config or use defaults\n */\nexport function getSelectorPriority(config?: AutogenConfig): LocatorStrategy[] {\n  if (config?.selectorPolicy?.priority) {\n    // Map config selector strategies to LocatorStrategy\n    return config.selectorPolicy.priority.map((s) => {\n      // Handle strategy name mapping if needed\n      return s as LocatorStrategy;\n    });\n  }\n  return DEFAULT_SELECTOR_PRIORITY;\n}\n\n/**\n * Check if a selector strategy is forbidden by config\n */\nexport function isForbiddenSelector(\n  locator: LocatorSpec,\n  config?: AutogenConfig\n): boolean {\n  const forbiddenPatterns = config?.selectorPolicy?.forbiddenPatterns ?? [];\n\n  for (const pattern of forbiddenPatterns) {\n    const regex = new RegExp(pattern);\n    if (regex.test(locator.value)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Score a locator based on priority (lower is better)\n */\nexport function scoreLocator(\n  locator: LocatorSpec,\n  priority: LocatorStrategy[] = DEFAULT_SELECTOR_PRIORITY\n): number {\n  const index = priority.indexOf(locator.strategy);\n  return index >= 0 ? index : priority.length;\n}\n\n/**\n * Compare two locators and return the better one\n */\nexport function compareLocators(\n  a: LocatorSpec,\n  b: LocatorSpec,\n  priority: LocatorStrategy[] = DEFAULT_SELECTOR_PRIORITY\n): LocatorSpec {\n  const scoreA = scoreLocator(a, priority);\n  const scoreB = scoreLocator(b, priority);\n  return scoreA <= scoreB ? a : b;\n}\n\n/**\n * Select the best locator from alternatives\n */\nexport function selectBestLocator(\n  alternatives: LocatorSpec[],\n  config?: AutogenConfig\n): LocatorSpec | null {\n  if (alternatives.length === 0) {\n    return null;\n  }\n\n  const priority = getSelectorPriority(config);\n\n  // Filter out forbidden selectors\n  const allowed = alternatives.filter((loc) => !isForbiddenSelector(loc, config));\n\n  if (allowed.length === 0) {\n    // All forbidden, return first original\n    return alternatives[0] ?? null;\n  }\n\n  // Sort by priority\n  allowed.sort((a, b) => scoreLocator(a, priority) - scoreLocator(b, priority));\n\n  return allowed[0] ?? null;\n}\n\n/**\n * Check if a locator is a role locator\n */\nexport function isRoleLocator(locator: LocatorSpec): boolean {\n  return locator.strategy === 'role';\n}\n\n/**\n * Check if a locator uses semantic selectors (role, label, text)\n */\nexport function isSemanticLocator(locator: LocatorSpec): boolean {\n  return ['role', 'label', 'text', 'placeholder'].includes(locator.strategy);\n}\n\n/**\n * Check if a locator is a test ID locator\n */\nexport function isTestIdLocator(locator: LocatorSpec): boolean {\n  return locator.strategy === 'testid';\n}\n\n/**\n * Check if a locator is a CSS locator (last resort)\n */\nexport function isCssLocator(locator: LocatorSpec): boolean {\n  return locator.strategy === 'css';\n}\n\n/**\n * Get recommended strategies for an element type\n */\nexport function getRecommendedStrategies(elementType: string): LocatorStrategy[] {\n  return ELEMENT_TYPE_STRATEGIES[elementType] ?? ELEMENT_TYPE_STRATEGIES.generic!;\n}\n\n/**\n * Validate a locator against best practices\n */\nexport function validateLocator(\n  locator: LocatorSpec,\n  config?: AutogenConfig\n): { valid: boolean; warnings: string[] } {\n  const warnings: string[] = [];\n\n  // Check if forbidden\n  if (isForbiddenSelector(locator, config)) {\n    warnings.push(`Selector matches forbidden pattern: ${locator.value}`);\n  }\n\n  // Warn about CSS selectors\n  if (isCssLocator(locator)) {\n    warnings.push(\n      `CSS selector \"${locator.value}\" is fragile. Consider using role, label, or testid.`\n    );\n  }\n\n  // Warn about XPath-like patterns in CSS\n  if (locator.value.includes('//') || locator.value.includes('..')) {\n    warnings.push(`Selector \"${locator.value}\" appears to use XPath syntax in CSS.`);\n  }\n\n  // Warn about nth-child selectors\n  if (locator.value.includes('nth-child') || locator.value.includes('nth-of-type')) {\n    warnings.push(`Selector \"${locator.value}\" uses nth-child which is position-dependent.`);\n  }\n\n  // Warn about ID selectors that might be dynamic\n  if (locator.strategy === 'css' && /^#[a-z]+-\\d+$/i.test(locator.value)) {\n    warnings.push(`Selector \"${locator.value}\" appears to have a dynamic ID.`);\n  }\n\n  return {\n    valid: warnings.length === 0,\n    warnings,\n  };\n}\n\n/**\n * Generate Playwright locator code from LocatorSpec\n */\nexport function toPlaywrightLocator(locator: LocatorSpec): string {\n  switch (locator.strategy) {\n    case 'role': {\n      const opts: string[] = [];\n      if (locator.options?.name) {\n        opts.push(`name: '${escapeString(locator.options.name)}'`);\n      }\n      if (locator.options?.exact) {\n        opts.push('exact: true');\n      }\n      if (locator.options?.level) {\n        opts.push(`level: ${locator.options.level}`);\n      }\n      const optsStr = opts.length > 0 ? `, { ${opts.join(', ')} }` : '';\n      return `getByRole('${locator.value}'${optsStr})`;\n    }\n    case 'label': {\n      const exact = locator.options?.exact ? ', { exact: true }' : '';\n      return `getByLabel('${escapeString(locator.value)}'${exact})`;\n    }\n    case 'placeholder': {\n      const exact = locator.options?.exact ? ', { exact: true }' : '';\n      return `getByPlaceholder('${escapeString(locator.value)}'${exact})`;\n    }\n    case 'text': {\n      const exact = locator.options?.exact ? ', { exact: true }' : '';\n      return `getByText('${escapeString(locator.value)}'${exact})`;\n    }\n    case 'testid':\n      return `getByTestId('${escapeString(locator.value)}')`;\n    case 'css':\n      return `locator('${escapeString(locator.value)}')`;\n    default:\n      return `locator('${escapeString(locator.value)}')`;\n  }\n}\n\n/**\n * Escape string for use in generated code\n */\nfunction escapeString(str: string): string {\n  return str.replace(/'/g, \"\\\\'\").replace(/\\n/g, '\\\\n');\n}\n","/**\n * Selector Catalog Schema - Define structure for repo-local selector catalog\n * @see T088 - Define selector catalog JSON schema\n */\nimport { z } from 'zod';\n\n/**\n * Selector entry in the catalog\n */\nexport const SelectorEntrySchema = z.object({\n  /** Unique identifier for this selector */\n  id: z.string(),\n  /** Human-readable description */\n  description: z.string().optional(),\n  /** The selector strategy */\n  strategy: z.enum(['testid', 'role', 'label', 'text', 'css', 'xpath']),\n  /** The selector value */\n  value: z.string(),\n  /** Additional options for the locator */\n  options: z\n    .object({\n      name: z.string().optional(),\n      exact: z.boolean().optional(),\n      level: z.number().optional(),\n    })\n    .optional(),\n  /** Component or page this selector belongs to */\n  component: z.string().optional(),\n  /** File where this selector was discovered */\n  sourceFile: z.string().optional(),\n  /** Line number in source file */\n  sourceLine: z.number().optional(),\n  /** Tags for categorization */\n  tags: z.array(z.string()).optional(),\n  /** Whether this is a stable selector (not likely to change) */\n  stable: z.boolean().default(true),\n  /** Last verified timestamp */\n  lastVerified: z.string().optional(),\n});\n\n/**\n * Component entry in the catalog\n */\nexport const ComponentEntrySchema = z.object({\n  /** Component name */\n  name: z.string(),\n  /** Component file path */\n  path: z.string().optional(),\n  /** Selectors within this component */\n  selectors: z.array(z.string()), // References to selector IDs\n  /** Child components */\n  children: z.array(z.string()).optional(),\n});\n\n/**\n * Page entry in the catalog\n */\nexport const PageEntrySchema = z.object({\n  /** Page name */\n  name: z.string(),\n  /** Route pattern */\n  route: z.string().optional(),\n  /** Page file path */\n  path: z.string().optional(),\n  /** Components on this page */\n  components: z.array(z.string()).optional(),\n  /** Direct selectors on this page */\n  selectors: z.array(z.string()).optional(),\n});\n\n/**\n * CSS debt entry - tracks CSS selectors that should be migrated\n */\nexport const CSSDebtEntrySchema = z.object({\n  /** The CSS selector being used */\n  selector: z.string(),\n  /** Files using this selector */\n  usages: z.array(\n    z.object({\n      file: z.string(),\n      line: z.number(),\n    })\n  ),\n  /** Suggested replacement */\n  suggestedReplacement: z\n    .object({\n      strategy: z.string(),\n      value: z.string(),\n    })\n    .optional(),\n  /** Priority for migration (higher = more urgent) */\n  priority: z.enum(['low', 'medium', 'high']).default('medium'),\n  /** Reason this is considered debt */\n  reason: z.string().optional(),\n});\n\n/**\n * Complete selector catalog schema\n */\nexport const SelectorCatalogSchema = z.object({\n  /** Schema version */\n  version: z.string().default('1.0.0'),\n  /** Generation timestamp */\n  generatedAt: z.string(),\n  /** Source directory that was scanned */\n  sourceDir: z.string().optional(),\n  /** All selectors indexed by ID */\n  selectors: z.record(SelectorEntrySchema),\n  /** Components indexed by name */\n  components: z.record(ComponentEntrySchema).default({}),\n  /** Pages indexed by name */\n  pages: z.record(PageEntrySchema).default({}),\n  /** TestIDs found in the codebase */\n  testIds: z.array(z.string()).default([]),\n  /** CSS debt entries */\n  cssDebt: z.array(CSSDebtEntrySchema).default([]),\n  /** Statistics */\n  stats: z\n    .object({\n      totalSelectors: z.number(),\n      byStrategy: z.record(z.number()),\n      stableCount: z.number(),\n      unstableCount: z.number(),\n      cssDebtCount: z.number(),\n    })\n    .optional(),\n});\n\nexport type SelectorEntry = z.infer<typeof SelectorEntrySchema>;\nexport type ComponentEntry = z.infer<typeof ComponentEntrySchema>;\nexport type PageEntry = z.infer<typeof PageEntrySchema>;\nexport type CSSDebtEntry = z.infer<typeof CSSDebtEntrySchema>;\nexport type SelectorCatalog = z.infer<typeof SelectorCatalogSchema>;\n\n/**\n * Create an empty catalog\n */\nexport function createEmptyCatalog(): SelectorCatalog {\n  return {\n    version: '1.0.0',\n    generatedAt: new Date().toISOString(),\n    selectors: {},\n    components: {},\n    pages: {},\n    testIds: [],\n    cssDebt: [],\n  };\n}\n\n/**\n * Validate a catalog object\n */\nexport function validateCatalog(catalog: unknown): {\n  valid: boolean;\n  errors: string[];\n  catalog?: SelectorCatalog;\n} {\n  const result = SelectorCatalogSchema.safeParse(catalog);\n\n  if (result.success) {\n    return { valid: true, errors: [], catalog: result.data };\n  }\n\n  return {\n    valid: false,\n    errors: result.error.errors.map((e) => `${e.path.join('.')}: ${e.message}`),\n  };\n}\n","/**\n * Selector Catalog Loader - Load and query the selector catalog\n * @see T089 - Implement catalog loader\n */\nimport { readFileSync, existsSync, writeFileSync } from 'node:fs';\nimport { resolve, dirname } from 'node:path';\nimport { mkdirSync } from 'node:fs';\nimport {\n  type SelectorCatalog,\n  type SelectorEntry,\n  createEmptyCatalog,\n  validateCatalog,\n} from './catalogSchema.js';\n\n/**\n * Default catalog file path\n */\nconst DEFAULT_CATALOG_PATH = 'config/selector-catalog.json';\n\n/**\n * Catalog cache\n */\nlet catalogCache: SelectorCatalog | null = null;\nlet catalogPath: string | null = null;\n\n/**\n * Load selector catalog from file\n * @param path - Path to catalog JSON file\n */\nexport function loadCatalog(path?: string): SelectorCatalog {\n  const resolvedPath = resolve(path ?? DEFAULT_CATALOG_PATH);\n\n  if (!existsSync(resolvedPath)) {\n    console.warn(`Selector catalog not found at ${resolvedPath}, using empty catalog`);\n    return createEmptyCatalog();\n  }\n\n  try {\n    const content = readFileSync(resolvedPath, 'utf-8');\n    const parsed = JSON.parse(content);\n    const result = validateCatalog(parsed);\n\n    if (!result.valid) {\n      console.warn(`Invalid selector catalog at ${resolvedPath}: ${result.errors.join(', ')}`);\n      return createEmptyCatalog();\n    }\n\n    catalogCache = result.catalog!;\n    catalogPath = resolvedPath;\n    return catalogCache;\n  } catch (_err) {\n    console.warn(`Failed to load selector catalog from ${resolvedPath}`);\n    return createEmptyCatalog();\n  }\n}\n\n/**\n * Save catalog to file\n * @param catalog - Catalog to save\n * @param path - Path to save to\n */\nexport function saveCatalog(catalog: SelectorCatalog, path?: string): void {\n  const resolvedPath = resolve(path ?? catalogPath ?? DEFAULT_CATALOG_PATH);\n\n  // Ensure directory exists\n  const dir = dirname(resolvedPath);\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n\n  // Update generation timestamp\n  catalog.generatedAt = new Date().toISOString();\n\n  // Calculate stats\n  catalog.stats = calculateStats(catalog);\n\n  writeFileSync(resolvedPath, JSON.stringify(catalog, null, 2));\n  catalogCache = catalog;\n  catalogPath = resolvedPath;\n}\n\n/**\n * Calculate catalog statistics\n */\nfunction calculateStats(\n  catalog: SelectorCatalog\n): SelectorCatalog['stats'] {\n  const selectors = Object.values(catalog.selectors);\n  const byStrategy: Record<string, number> = {};\n\n  let stableCount = 0;\n  let unstableCount = 0;\n\n  for (const selector of selectors) {\n    byStrategy[selector.strategy] = (byStrategy[selector.strategy] ?? 0) + 1;\n    if (selector.stable) {\n      stableCount++;\n    } else {\n      unstableCount++;\n    }\n  }\n\n  return {\n    totalSelectors: selectors.length,\n    byStrategy,\n    stableCount,\n    unstableCount,\n    cssDebtCount: catalog.cssDebt?.length ?? 0,\n  };\n}\n\n/**\n * Get the current catalog (loads if not cached)\n */\nexport function getCatalog(): SelectorCatalog {\n  if (!catalogCache) {\n    catalogCache = loadCatalog();\n  }\n  return catalogCache;\n}\n\n/**\n * Reset catalog cache (for testing)\n */\nexport function resetCatalogCache(): void {\n  catalogCache = null;\n  catalogPath = null;\n}\n\n/**\n * Find a selector by ID\n */\nexport function findSelectorById(id: string): SelectorEntry | null {\n  const catalog = getCatalog();\n  return catalog.selectors[id] ?? null;\n}\n\n/**\n * Find selectors by testid\n */\nexport function findByTestId(testId: string): SelectorEntry | null {\n  const catalog = getCatalog();\n\n  for (const selector of Object.values(catalog.selectors)) {\n    if (selector.strategy === 'testid' && selector.value === testId) {\n      return selector;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Find selectors by component name\n */\nexport function findByComponent(componentName: string): SelectorEntry[] {\n  const catalog = getCatalog();\n  const component = catalog.components[componentName];\n\n  if (!component) {\n    return [];\n  }\n\n  return component.selectors\n    .map((id) => catalog.selectors[id])\n    .filter((s): s is SelectorEntry => s !== undefined);\n}\n\n/**\n * Find selectors by page name\n */\nexport function findByPage(pageName: string): SelectorEntry[] {\n  const catalog = getCatalog();\n  const page = catalog.pages[pageName];\n\n  if (!page) {\n    return [];\n  }\n\n  const selectorIds = new Set<string>();\n\n  // Add direct page selectors\n  for (const id of page.selectors ?? []) {\n    selectorIds.add(id);\n  }\n\n  // Add component selectors\n  for (const componentName of page.components ?? []) {\n    const component = catalog.components[componentName];\n    if (component) {\n      for (const id of component.selectors) {\n        selectorIds.add(id);\n      }\n    }\n  }\n\n  return Array.from(selectorIds)\n    .map((id) => catalog.selectors[id])\n    .filter((s): s is SelectorEntry => s !== undefined);\n}\n\n/**\n * Search selectors by text (searches description, value, tags)\n */\nexport function searchSelectors(query: string): SelectorEntry[] {\n  const catalog = getCatalog();\n  const lowerQuery = query.toLowerCase();\n\n  return Object.values(catalog.selectors).filter((selector) => {\n    if (selector.value.toLowerCase().includes(lowerQuery)) return true;\n    if (selector.description?.toLowerCase().includes(lowerQuery)) return true;\n    if (selector.component?.toLowerCase().includes(lowerQuery)) return true;\n    if (selector.tags?.some((t) => t.toLowerCase().includes(lowerQuery))) return true;\n    return false;\n  });\n}\n\n/**\n * Get all testids in the catalog\n */\nexport function getAllTestIds(): string[] {\n  const catalog = getCatalog();\n  return catalog.testIds;\n}\n\n/**\n * Check if a testid exists in the catalog\n */\nexport function hasTestId(testId: string): boolean {\n  const catalog = getCatalog();\n  return catalog.testIds.includes(testId);\n}\n\n/**\n * Add a selector to the catalog\n */\nexport function addSelector(selector: SelectorEntry): void {\n  const catalog = getCatalog();\n  catalog.selectors[selector.id] = selector;\n\n  // Track testids\n  if (selector.strategy === 'testid' && !catalog.testIds.includes(selector.value)) {\n    catalog.testIds.push(selector.value);\n  }\n}\n\n/**\n * Remove a selector from the catalog\n */\nexport function removeSelector(id: string): boolean {\n  const catalog = getCatalog();\n  if (catalog.selectors[id]) {\n    delete catalog.selectors[id];\n    return true;\n  }\n  return false;\n}\n\n/**\n * Get selectors that need migration (CSS debt)\n */\nexport function getCSSDebt(): SelectorCatalog['cssDebt'] {\n  return getCatalog().cssDebt ?? [];\n}\n\n/**\n * Get stable selectors for a given element description\n * Useful for test generation to find the best available selector\n */\nexport function suggestSelector(description: string): SelectorEntry | null {\n  const results = searchSelectors(description);\n\n  if (results.length === 0) {\n    return null;\n  }\n\n  // Prefer stable selectors, then by strategy priority\n  const strategyPriority: Record<string, number> = {\n    testid: 1,\n    role: 2,\n    label: 3,\n    text: 4,\n    css: 5,\n    xpath: 6,\n  };\n\n  return results.sort((a, b) => {\n    // Stable first\n    if (a.stable && !b.stable) return -1;\n    if (!a.stable && b.stable) return 1;\n\n    // Then by strategy priority\n    return (strategyPriority[a.strategy] ?? 99) - (strategyPriority[b.strategy] ?? 99);\n  })[0] ?? null;\n}\n","/**\n * Selector Inference - Infer selectors from step text\n * @see research/2026-01-02_autogen-refined-plan.md Section 11\n * @see T092 - Integrate catalog querying into selector inference\n */\nimport type { LocatorSpec, LocatorStrategy } from '../ir/types.js';\nimport {\n  NAMEABLE_ROLES,\n  selectBestLocator,\n} from './priority.js';\nimport { suggestSelector, hasTestId } from './catalog.js';\n\n/**\n * Common element type keywords\n */\nconst ELEMENT_KEYWORDS: Record<string, string> = {\n  button: 'button',\n  btn: 'button',\n  submit: 'button',\n  link: 'link',\n  anchor: 'link',\n  input: 'textbox',\n  textbox: 'textbox',\n  field: 'textbox',\n  textarea: 'textbox',\n  checkbox: 'checkbox',\n  check: 'checkbox',\n  radio: 'radio',\n  dropdown: 'combobox',\n  select: 'combobox',\n  combo: 'combobox',\n  heading: 'heading',\n  title: 'heading',\n  header: 'heading',\n  menu: 'menu',\n  menuitem: 'menuitem',\n  tab: 'tab',\n  dialog: 'dialog',\n  modal: 'dialog',\n  alert: 'alert',\n  list: 'list',\n  listitem: 'listitem',\n  table: 'table',\n  row: 'row',\n  cell: 'cell',\n};\n\n/**\n * Infer the element type from text\n */\nexport function inferElementType(text: string): string | null {\n  const lowerText = text.toLowerCase();\n\n  for (const [keyword, elementType] of Object.entries(ELEMENT_KEYWORDS)) {\n    if (lowerText.includes(keyword)) {\n      return elementType;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Infer the ARIA role from element type\n */\nexport function inferRole(elementType: string): string | null {\n  // Most element types map directly to roles\n  const roleMap: Record<string, string> = {\n    button: 'button',\n    link: 'link',\n    textbox: 'textbox',\n    checkbox: 'checkbox',\n    radio: 'radio',\n    combobox: 'combobox',\n    heading: 'heading',\n    menu: 'menu',\n    menuitem: 'menuitem',\n    tab: 'tab',\n    dialog: 'dialog',\n    alert: 'alert',\n    list: 'list',\n    listitem: 'listitem',\n    table: 'table',\n    row: 'row',\n    cell: 'cell',\n  };\n\n  return roleMap[elementType] ?? null;\n}\n\n/**\n * Extract a name/label from text\n */\nexport function extractName(text: string): string | null {\n  // Look for quoted strings\n  const quotedMatch = text.match(/['\"]([^'\"]+)['\"]/);\n  if (quotedMatch) {\n    return quotedMatch[1] ?? null;\n  }\n\n  // Look for \"the X button\" pattern\n  const theMatch = text.match(/(?:the\\s+)?['\"]?([^'\"]+?)['\"]?\\s+(?:button|link|field|input|checkbox|dropdown)/i);\n  if (theMatch) {\n    return theMatch[1]!.trim();\n  }\n\n  return null;\n}\n\n/**\n * Infer selector alternatives from step text\n */\nexport function inferSelectors(text: string): LocatorSpec[] {\n  const alternatives: LocatorSpec[] = [];\n  const elementType = inferElementType(text);\n  const name = extractName(text);\n  const role = elementType ? inferRole(elementType) : null;\n\n  // Try role-based selector if we have a role\n  if (role && NAMEABLE_ROLES.includes(role)) {\n    if (name) {\n      alternatives.push({\n        strategy: 'role',\n        value: role,\n        options: { name },\n      });\n    } else {\n      alternatives.push({\n        strategy: 'role',\n        value: role,\n      });\n    }\n  }\n\n  // Try label selector for form elements\n  if (name && ['textbox', 'checkbox', 'radio', 'combobox'].includes(elementType || '')) {\n    alternatives.push({\n      strategy: 'label',\n      value: name,\n    });\n  }\n\n  // Try text selector\n  if (name) {\n    alternatives.push({\n      strategy: 'text',\n      value: name,\n    });\n  }\n\n  return alternatives;\n}\n\n/**\n * Infer the best selector from step text\n */\nexport function inferBestSelector(text: string): LocatorSpec | null {\n  const alternatives = inferSelectors(text);\n  return selectBestLocator(alternatives);\n}\n\n/**\n * Infer selector for a button element\n */\nexport function inferButtonSelector(name: string): LocatorSpec {\n  return {\n    strategy: 'role',\n    value: 'button',\n    options: { name },\n  };\n}\n\n/**\n * Infer selector for a link element\n */\nexport function inferLinkSelector(name: string): LocatorSpec {\n  return {\n    strategy: 'role',\n    value: 'link',\n    options: { name },\n  };\n}\n\n/**\n * Infer selector for an input field\n */\nexport function inferInputSelector(labelOrPlaceholder: string): LocatorSpec {\n  return {\n    strategy: 'label',\n    value: labelOrPlaceholder,\n  };\n}\n\n/**\n * Infer selector for a checkbox\n */\nexport function inferCheckboxSelector(label: string): LocatorSpec {\n  return {\n    strategy: 'role',\n    value: 'checkbox',\n    options: { name: label },\n  };\n}\n\n/**\n * Infer selector for a heading\n */\nexport function inferHeadingSelector(text: string, level?: number): LocatorSpec {\n  const locator: LocatorSpec = {\n    strategy: 'role',\n    value: 'heading',\n    options: { name: text },\n  };\n  if (level) {\n    locator.options!.level = level;\n  }\n  return locator;\n}\n\n/**\n * Infer selector for a tab\n */\nexport function inferTabSelector(name: string): LocatorSpec {\n  return {\n    strategy: 'role',\n    value: 'tab',\n    options: { name },\n  };\n}\n\n/**\n * Infer selector for generic text content\n */\nexport function inferTextSelector(text: string): LocatorSpec {\n  return {\n    strategy: 'text',\n    value: text,\n  };\n}\n\n/**\n * Infer selector from a test ID\n */\nexport function inferTestIdSelector(testId: string): LocatorSpec {\n  return {\n    strategy: 'testid',\n    value: testId,\n  };\n}\n\n/**\n * Create a CSS selector (last resort)\n */\nexport function createCssSelector(selector: string): LocatorSpec {\n  return {\n    strategy: 'css',\n    value: selector,\n  };\n}\n\n/**\n * Analyze text and suggest the best selector approach\n */\nexport function suggestSelectorApproach(text: string): {\n  elementType: string | null;\n  role: string | null;\n  name: string | null;\n  recommendedStrategy: LocatorStrategy;\n  alternatives: LocatorSpec[];\n} {\n  const elementType = inferElementType(text);\n  const role = elementType ? inferRole(elementType) : null;\n  const name = extractName(text);\n  const alternatives = inferSelectors(text);\n\n  // Determine recommended strategy\n  let recommendedStrategy: LocatorStrategy = 'text';\n\n  if (role && NAMEABLE_ROLES.includes(role)) {\n    recommendedStrategy = 'role';\n  } else if (name && ['textbox', 'checkbox', 'radio', 'combobox'].includes(elementType || '')) {\n    recommendedStrategy = 'label';\n  } else if (name) {\n    recommendedStrategy = 'text';\n  }\n\n  return {\n    elementType,\n    role,\n    name,\n    recommendedStrategy,\n    alternatives,\n  };\n}\n\n/**\n * Infer selector with catalog lookup (T092)\n * First checks the catalog for a known selector, then falls back to inference\n */\nexport function inferSelectorWithCatalog(\n  text: string,\n  options?: { useCatalog?: boolean }\n): LocatorSpec | null {\n  const useCatalog = options?.useCatalog ?? true;\n\n  // Try catalog first if enabled\n  if (useCatalog) {\n    const catalogEntry = suggestSelector(text);\n    if (catalogEntry) {\n      return {\n        strategy: catalogEntry.strategy as LocatorStrategy,\n        value: catalogEntry.value,\n        options: catalogEntry.options,\n      };\n    }\n\n    // Also try extracting a name and checking if it's a known testid\n    const name = extractName(text);\n    if (name) {\n      // Try common testid patterns\n      const possibleTestIds = [\n        name.toLowerCase().replace(/\\s+/g, '-'),\n        name.toLowerCase().replace(/\\s+/g, '_'),\n        name,\n      ];\n\n      for (const testId of possibleTestIds) {\n        if (hasTestId(testId)) {\n          return {\n            strategy: 'testid',\n            value: testId,\n          };\n        }\n      }\n    }\n  }\n\n  // Fall back to inference\n  return inferBestSelector(text);\n}\n\n/**\n * Infer selectors with catalog augmentation (T092)\n * Returns catalog-based selectors first, then inferred alternatives\n */\nexport function inferSelectorsWithCatalog(\n  text: string,\n  options?: { useCatalog?: boolean }\n): LocatorSpec[] {\n  const useCatalog = options?.useCatalog ?? true;\n  const alternatives: LocatorSpec[] = [];\n\n  // Try catalog first if enabled\n  if (useCatalog) {\n    const catalogEntry = suggestSelector(text);\n    if (catalogEntry) {\n      alternatives.push({\n        strategy: catalogEntry.strategy as LocatorStrategy,\n        value: catalogEntry.value,\n        options: catalogEntry.options,\n      });\n    }\n  }\n\n  // Add inferred selectors\n  alternatives.push(...inferSelectors(text));\n\n  // Deduplicate by strategy+value\n  const seen = new Set<string>();\n  return alternatives.filter((loc) => {\n    const key = `${loc.strategy}:${loc.value}`;\n    if (seen.has(key)) return false;\n    seen.add(key);\n    return true;\n  });\n}\n","/**\n * TestID Scanner - Scan source files for data-testid attributes\n * @see T090 - Implement testid scanner\n */\nimport { readFileSync, existsSync } from 'node:fs';\nimport { resolve, relative, basename, extname } from 'node:path';\nimport fg from 'fast-glob';\nimport {\n  type SelectorCatalog,\n  type SelectorEntry,\n  type CSSDebtEntry,\n  createEmptyCatalog,\n} from './catalogSchema.js';\n\n/**\n * Scanner options\n */\nexport interface ScannerOptions {\n  /** Source directory to scan */\n  sourceDir: string;\n  /** Test ID attribute name */\n  testIdAttribute?: string;\n  /** File patterns to include */\n  include?: string[];\n  /** File patterns to exclude */\n  exclude?: string[];\n  /** Whether to track CSS selector debt */\n  trackCSSDebt?: boolean;\n  /** Existing catalog to merge with */\n  existingCatalog?: SelectorCatalog;\n}\n\n/**\n * Scanner result\n */\nexport interface ScannerResult {\n  /** Generated catalog */\n  catalog: SelectorCatalog;\n  /** Files scanned */\n  filesScanned: number;\n  /** TestIDs found */\n  testIdsFound: number;\n  /** CSS debt entries found */\n  cssDebtFound: number;\n  /** Warnings during scanning */\n  warnings: string[];\n}\n\n/**\n * Default file patterns for scanning\n */\nconst DEFAULT_INCLUDE = [\n  '**/*.tsx',\n  '**/*.jsx',\n  '**/*.ts',\n  '**/*.js',\n  '**/*.vue',\n  '**/*.svelte',\n];\n\nconst DEFAULT_EXCLUDE = [\n  '**/node_modules/**',\n  '**/dist/**',\n  '**/build/**',\n  '**/*.test.*',\n  '**/*.spec.*',\n  '**/__tests__/**',\n];\n\n/**\n * Regex patterns for extracting testids\n */\nconst TESTID_PATTERNS = {\n  // data-testid=\"value\" or data-testid='value'\n  dataTestId: /data-testid=[\"']([^\"']+)[\"']/gi,\n  // data-test=\"value\" or data-test='value'\n  dataTest: /data-test=[\"']([^\"']+)[\"']/gi,\n  // data-cy=\"value\" (Cypress)\n  dataCy: /data-cy=[\"']([^\"']+)[\"']/gi,\n  // testID=\"value\" (React Native)\n  testID: /testID=[\"']([^\"']+)[\"']/gi,\n  // getByTestId('value') in tests\n  getByTestId: /getByTestId\\s*\\(\\s*[\"']([^\"']+)[\"']\\s*\\)/gi,\n};\n\n/**\n * Regex patterns for detecting CSS selectors (debt tracking)\n */\nconst CSS_DEBT_PATTERNS = {\n  // .className selectors in locator/querySelector\n  classSelector: /(?:locator|querySelector|querySelectorAll)\\s*\\(\\s*[\"']\\.([a-zA-Z_-][a-zA-Z0-9_-]*)[\"']/gi,\n  // #id selectors\n  idSelector: /(?:locator|querySelector)\\s*\\(\\s*[\"']#([a-zA-Z_-][a-zA-Z0-9_-]*)[\"']/gi,\n  // Complex CSS selectors\n  complexSelector: /(?:locator|querySelector)\\s*\\(\\s*[\"']([^\"']+\\s+[^\"']+)[\"']/gi,\n};\n\n/**\n * Extract component name from file path\n */\nfunction extractComponentName(filePath: string): string {\n  const baseName = basename(filePath, extname(filePath));\n  // Remove common suffixes\n  return baseName\n    .replace(/\\.(component|page|view|screen|container)$/i, '')\n    .replace(/[-_]/g, ' ')\n    .split(' ')\n    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))\n    .join('');\n}\n\n/**\n * Infer selector description from testid\n */\nfunction inferDescription(testId: string): string {\n  return testId\n    .replace(/[-_]/g, ' ')\n    .replace(/([a-z])([A-Z])/g, '$1 $2')\n    .toLowerCase();\n}\n\n/**\n * Generate a unique selector ID\n */\nfunction generateSelectorId(testId: string, component: string): string {\n  return `${component.toLowerCase()}-${testId}`;\n}\n\n/**\n * Scan a single file for testids\n */\nfunction scanFile(\n  filePath: string,\n  testIdAttribute: string,\n  trackCSSDebt: boolean\n): {\n  selectors: SelectorEntry[];\n  testIds: string[];\n  cssDebt: CSSDebtEntry[];\n} {\n  const content = readFileSync(filePath, 'utf-8');\n  const component = extractComponentName(filePath);\n  const selectors: SelectorEntry[] = [];\n  const testIds: string[] = [];\n  const cssDebt: CSSDebtEntry[] = [];\n  const seenTestIds = new Set<string>();\n\n  // Determine which pattern to use based on attribute name\n  let primaryPattern: RegExp;\n  if (testIdAttribute === 'data-testid') {\n    primaryPattern = TESTID_PATTERNS.dataTestId;\n  } else if (testIdAttribute === 'data-test') {\n    primaryPattern = TESTID_PATTERNS.dataTest;\n  } else if (testIdAttribute === 'data-cy') {\n    primaryPattern = TESTID_PATTERNS.dataCy;\n  } else {\n    // Generic pattern for custom attributes\n    primaryPattern = new RegExp(`${testIdAttribute}=[\"']([^\"']+)[\"']`, 'gi');\n  }\n\n  // Scan for primary testid pattern\n  primaryPattern.lastIndex = 0;\n  let match;\n  while ((match = primaryPattern.exec(content)) !== null) {\n    const testId = match[1]!; // Capture group guaranteed by pattern\n    if (!seenTestIds.has(testId)) {\n      seenTestIds.add(testId);\n      testIds.push(testId);\n\n      // Find line number\n      const lineNumber = content.substring(0, match.index).split('\\n').length;\n\n      selectors.push({\n        id: generateSelectorId(testId, component),\n        description: inferDescription(testId),\n        strategy: 'testid',\n        value: testId,\n        component,\n        sourceFile: filePath,\n        sourceLine: lineNumber,\n        stable: true,\n      });\n    }\n  }\n\n  // Also scan for getByTestId in test files\n  TESTID_PATTERNS.getByTestId.lastIndex = 0;\n  while ((match = TESTID_PATTERNS.getByTestId.exec(content)) !== null) {\n    const testId = match[1]!; // Capture group guaranteed by pattern\n    if (!seenTestIds.has(testId)) {\n      seenTestIds.add(testId);\n      testIds.push(testId);\n    }\n  }\n\n  // Track CSS debt if enabled\n  if (trackCSSDebt) {\n    for (const [patternName, pattern] of Object.entries(CSS_DEBT_PATTERNS)) {\n      pattern.lastIndex = 0;\n      while ((match = pattern.exec(content)) !== null) {\n        const selector = match[1]!; // Capture group guaranteed by pattern\n        const lineNumber = content.substring(0, match.index).split('\\n').length;\n\n        // Check if we already have this debt entry\n        const existing = cssDebt.find((d) => d.selector === selector);\n        if (existing) {\n          existing.usages.push({ file: filePath, line: lineNumber });\n        } else {\n          cssDebt.push({\n            selector: patternName === 'classSelector' ? `.${selector}` : selector,\n            usages: [{ file: filePath, line: lineNumber }],\n            priority: 'medium',\n            reason: `CSS ${patternName} found - consider using testid or role`,\n          });\n        }\n      }\n    }\n  }\n\n  return { selectors, testIds, cssDebt };\n}\n\n/**\n * Scan source directory for testids\n */\nexport async function scanForTestIds(options: ScannerOptions): Promise<ScannerResult> {\n  const {\n    sourceDir,\n    testIdAttribute = 'data-testid',\n    include = DEFAULT_INCLUDE,\n    exclude = DEFAULT_EXCLUDE,\n    trackCSSDebt = true,\n    existingCatalog,\n  } = options;\n\n  const resolvedDir = resolve(sourceDir);\n  const warnings: string[] = [];\n\n  if (!existsSync(resolvedDir)) {\n    return {\n      catalog: existingCatalog ?? createEmptyCatalog(),\n      filesScanned: 0,\n      testIdsFound: 0,\n      cssDebtFound: 0,\n      warnings: [`Source directory not found: ${resolvedDir}`],\n    };\n  }\n\n  // Find files to scan\n  const files = await fg(include, {\n    cwd: resolvedDir,\n    ignore: exclude,\n    absolute: true,\n  });\n\n  // Start with existing or empty catalog\n  const catalog: SelectorCatalog = existingCatalog ?? createEmptyCatalog();\n  catalog.sourceDir = sourceDir;\n  const allTestIds = new Set<string>(catalog.testIds);\n\n  let filesScanned = 0;\n  let testIdsFound = 0;\n  let cssDebtFound = 0;\n\n  // Scan each file\n  for (const filePath of files) {\n    try {\n      const result = scanFile(filePath, testIdAttribute, trackCSSDebt);\n      filesScanned++;\n\n      // Add selectors\n      for (const selector of result.selectors) {\n        // Use relative path for sourceFile\n        selector.sourceFile = relative(resolvedDir, filePath);\n        catalog.selectors[selector.id] = selector;\n      }\n\n      // Track testids\n      for (const testId of result.testIds) {\n        if (!allTestIds.has(testId)) {\n          allTestIds.add(testId);\n          testIdsFound++;\n        }\n      }\n\n      // Track CSS debt\n      for (const debt of result.cssDebt) {\n        // Convert file paths to relative\n        debt.usages = debt.usages.map((u) => ({\n          ...u,\n          file: relative(resolvedDir, u.file),\n        }));\n\n        // Merge with existing debt\n        const existing = catalog.cssDebt?.find((d) => d.selector === debt.selector);\n        if (existing) {\n          existing.usages.push(...debt.usages);\n        } else {\n          catalog.cssDebt = catalog.cssDebt ?? [];\n          catalog.cssDebt.push(debt);\n          cssDebtFound++;\n        }\n      }\n    } catch (err) {\n      warnings.push(`Failed to scan ${filePath}: ${err}`);\n    }\n  }\n\n  // Update catalog testIds\n  catalog.testIds = Array.from(allTestIds).sort();\n\n  return {\n    catalog,\n    filesScanned,\n    testIdsFound,\n    cssDebtFound,\n    warnings,\n  };\n}\n\n/**\n * Quick scan to just get testids (faster, no full catalog)\n */\nexport async function quickScanTestIds(\n  sourceDir: string,\n  testIdAttribute = 'data-testid'\n): Promise<string[]> {\n  const result = await scanForTestIds({\n    sourceDir,\n    testIdAttribute,\n    trackCSSDebt: false,\n  });\n  return result.catalog.testIds;\n}\n","/**\n * Selector Debt Tracker - Track CSS selector usage and generate debt reports\n * @see T093 - Implement selector debt tracker\n */\nimport { type CSSDebtEntry, type SelectorCatalog } from './catalogSchema.js';\nimport { getCatalog } from './catalog.js';\n\n/**\n * Debt report summary\n */\nexport interface DebtReportSummary {\n  /** Total number of CSS debt entries */\n  totalDebt: number;\n  /** Breakdown by priority */\n  byPriority: {\n    high: number;\n    medium: number;\n    low: number;\n  };\n  /** Total usage count across all debt */\n  totalUsages: number;\n  /** Files with most debt */\n  topDebtFiles: Array<{\n    file: string;\n    count: number;\n  }>;\n  /** Most common problematic selectors */\n  topSelectors: Array<{\n    selector: string;\n    usageCount: number;\n    priority: string;\n  }>;\n}\n\n/**\n * Debt migration plan\n */\nexport interface MigrationPlan {\n  /** Entries to migrate */\n  entries: Array<{\n    debt: CSSDebtEntry;\n    suggestedFix: string;\n    effort: 'low' | 'medium' | 'high';\n  }>;\n  /** Estimated total effort */\n  estimatedEffort: string;\n  /** Recommended migration order */\n  migrationOrder: string[];\n}\n\n/**\n * Record CSS selector usage as debt\n */\nexport function recordCSSDebt(\n  selector: string,\n  file: string,\n  line: number,\n  reason?: string\n): void {\n  const catalog = getCatalog();\n\n  // Find or create debt entry\n  let debt = catalog.cssDebt?.find((d) => d.selector === selector);\n\n  if (!debt) {\n    debt = {\n      selector,\n      usages: [],\n      priority: determinePriority(selector),\n      reason: reason ?? inferDebtReason(selector),\n    };\n    catalog.cssDebt = catalog.cssDebt ?? [];\n    catalog.cssDebt.push(debt);\n  }\n\n  // Add usage if not already tracked\n  const existingUsage = debt.usages.find((u) => u.file === file && u.line === line);\n  if (!existingUsage) {\n    debt.usages.push({ file, line });\n  }\n}\n\n/**\n * Determine priority based on selector type\n */\nfunction determinePriority(selector: string): 'low' | 'medium' | 'high' {\n  // High priority: dynamic or fragile selectors\n  if (selector.includes('[class*=') || selector.includes('[class^=')) {\n    return 'high';\n  }\n  if (selector.match(/\\d+/)) {\n    // Contains numbers (likely auto-generated)\n    return 'high';\n  }\n  if (selector.split(' ').length > 3) {\n    // Complex nested selector\n    return 'high';\n  }\n\n  // Medium priority: class selectors\n  if (selector.startsWith('.')) {\n    return 'medium';\n  }\n\n  // Low priority: ID selectors (more stable)\n  if (selector.startsWith('#')) {\n    return 'low';\n  }\n\n  return 'medium';\n}\n\n/**\n * Infer reason for debt based on selector pattern\n */\nfunction inferDebtReason(selector: string): string {\n  if (selector.includes('[class*=') || selector.includes('[class^=')) {\n    return 'Partial class matching is fragile - may break with CSS changes';\n  }\n  if (selector.match(/\\d+/)) {\n    return 'Selector contains numbers - may be auto-generated and unstable';\n  }\n  if (selector.split(' ').length > 3) {\n    return 'Complex nested selector - hard to maintain and fragile';\n  }\n  if (selector.startsWith('.')) {\n    return 'Class selector - consider using testid or role';\n  }\n  if (selector.startsWith('#')) {\n    return 'ID selector - consider using testid for test stability';\n  }\n  return 'CSS selector - consider using semantic locators';\n}\n\n/**\n * Suggest replacement for a CSS selector\n */\nexport function suggestReplacement(selector: string): {\n  strategy: string;\n  value: string;\n  code: string;\n} {\n  // Extract meaningful name from selector\n  let name = selector\n    .replace(/[.#\\[\\]=\"'^*~$]/g, ' ')\n    .trim()\n    .split(/\\s+/)\n    .filter((s) => s.length > 2)\n    .join('-')\n    .toLowerCase();\n\n  if (!name) {\n    name = 'element';\n  }\n\n  // Generate testid suggestion\n  const testId = name.replace(/\\s+/g, '-');\n\n  return {\n    strategy: 'testid',\n    value: testId,\n    code: `page.getByTestId('${testId}')`,\n  };\n}\n\n/**\n * Generate debt report summary\n */\nexport function generateDebtReport(catalog?: SelectorCatalog): DebtReportSummary {\n  const cat = catalog ?? getCatalog();\n  const debt = cat.cssDebt ?? [];\n\n  // Count by priority\n  const byPriority = { high: 0, medium: 0, low: 0 };\n  let totalUsages = 0;\n  const fileUsages: Record<string, number> = {};\n\n  for (const entry of debt) {\n    byPriority[entry.priority]++;\n    totalUsages += entry.usages.length;\n\n    for (const usage of entry.usages) {\n      fileUsages[usage.file] = (fileUsages[usage.file] ?? 0) + 1;\n    }\n  }\n\n  // Top debt files\n  const topDebtFiles = Object.entries(fileUsages)\n    .sort(([, a], [, b]) => b - a)\n    .slice(0, 10)\n    .map(([file, count]) => ({ file, count }));\n\n  // Top selectors\n  const topSelectors = debt\n    .sort((a, b) => b.usages.length - a.usages.length)\n    .slice(0, 10)\n    .map((d) => ({\n      selector: d.selector,\n      usageCount: d.usages.length,\n      priority: d.priority,\n    }));\n\n  return {\n    totalDebt: debt.length,\n    byPriority,\n    totalUsages,\n    topDebtFiles,\n    topSelectors,\n  };\n}\n\n/**\n * Generate migration plan for addressing debt\n */\nexport function generateMigrationPlan(catalog?: SelectorCatalog): MigrationPlan {\n  const cat = catalog ?? getCatalog();\n  const debt = cat.cssDebt ?? [];\n\n  const entries = debt.map((d) => {\n    const suggestion = suggestReplacement(d.selector);\n    const effort = d.priority === 'high' ? 'high' : d.usages.length > 5 ? 'medium' : 'low';\n\n    return {\n      debt: d,\n      suggestedFix: suggestion.code,\n      effort: effort as 'low' | 'medium' | 'high',\n    };\n  });\n\n  // Sort by priority (high first) then by usage count (most used first)\n  entries.sort((a, b) => {\n    const priorityOrder = { high: 0, medium: 1, low: 2 };\n    const pDiff = priorityOrder[a.debt.priority] - priorityOrder[b.debt.priority];\n    if (pDiff !== 0) return pDiff;\n    return b.debt.usages.length - a.debt.usages.length;\n  });\n\n  // Calculate estimated effort\n  const effortCounts = { low: 0, medium: 0, high: 0 };\n  for (const entry of entries) {\n    effortCounts[entry.effort]++;\n  }\n\n  let estimatedEffort: string;\n  if (effortCounts.high > 10 || effortCounts.medium > 20) {\n    estimatedEffort = 'Large refactoring effort required';\n  } else if (effortCounts.high > 5 || effortCounts.medium > 10) {\n    estimatedEffort = 'Medium refactoring effort required';\n  } else {\n    estimatedEffort = 'Small refactoring effort required';\n  }\n\n  // Migration order\n  const migrationOrder = entries.slice(0, 20).map((e) => e.debt.selector);\n\n  return {\n    entries,\n    estimatedEffort,\n    migrationOrder,\n  };\n}\n\n/**\n * Clear all debt entries (for testing or after migration)\n */\nexport function clearDebt(): void {\n  const catalog = getCatalog();\n  catalog.cssDebt = [];\n}\n\n/**\n * Remove specific debt entry\n */\nexport function removeDebt(selector: string): boolean {\n  const catalog = getCatalog();\n  const index = catalog.cssDebt?.findIndex((d) => d.selector === selector) ?? -1;\n\n  if (index >= 0) {\n    catalog.cssDebt?.splice(index, 1);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Update debt priority\n */\nexport function updateDebtPriority(\n  selector: string,\n  priority: 'low' | 'medium' | 'high'\n): boolean {\n  const catalog = getCatalog();\n  const debt = catalog.cssDebt?.find((d) => d.selector === selector);\n\n  if (debt) {\n    debt.priority = priority;\n    return true;\n  }\n  return false;\n}\n\n/**\n * Generate markdown debt report\n */\nexport function generateDebtMarkdown(catalog?: SelectorCatalog): string {\n  const report = generateDebtReport(catalog);\n  const plan = generateMigrationPlan(catalog);\n\n  const lines: string[] = [\n    '# Selector Debt Report',\n    '',\n    `Generated: ${new Date().toISOString()}`,\n    '',\n    '## Summary',\n    '',\n    `- **Total Debt Entries:** ${report.totalDebt}`,\n    `- **Total Usages:** ${report.totalUsages}`,\n    `- **High Priority:** ${report.byPriority.high}`,\n    `- **Medium Priority:** ${report.byPriority.medium}`,\n    `- **Low Priority:** ${report.byPriority.low}`,\n    '',\n    `**Effort Estimate:** ${plan.estimatedEffort}`,\n    '',\n    '## Top Selectors to Address',\n    '',\n    '| Selector | Usages | Priority | Suggested Fix |',\n    '|----------|--------|----------|---------------|',\n  ];\n\n  for (const entry of plan.entries.slice(0, 15)) {\n    lines.push(\n      `| \\`${entry.debt.selector}\\` | ${entry.debt.usages.length} | ${entry.debt.priority} | \\`${entry.suggestedFix}\\` |`\n    );\n  }\n\n  lines.push('', '## Files with Most Debt', '');\n\n  for (const file of report.topDebtFiles.slice(0, 10)) {\n    lines.push(`- \\`${file.file}\\`: ${file.count} debt usages`);\n  }\n\n  lines.push('', '## Migration Order', '', 'Address these selectors first:', '');\n\n  for (let i = 0; i < Math.min(10, plan.migrationOrder.length); i++) {\n    lines.push(`${i + 1}. \\`${plan.migrationOrder[i]}\\``);\n  }\n\n  return lines.join('\\n');\n}\n","/**\n * Managed Blocks - Alternative to AST editing for simpler code regeneration\n * @see research/2026-01-03_autogen-remaining-features-plan.md Feature 4\n */\n\n/**\n * Block markers for generated code boundaries\n */\nexport const BLOCK_START = '// ARTK:BEGIN GENERATED';\nexport const BLOCK_END = '// ARTK:END GENERATED';\nexport const BLOCK_ID_PATTERN = /ARTK:BEGIN GENERATED(?:\\s+id=([a-zA-Z0-9_-]+))?/;\n\n/**\n * Represents a managed block of generated code\n */\nexport interface ManagedBlock {\n  /** Optional identifier for the block */\n  id?: string;\n  /** Starting line number (0-indexed) */\n  startLine: number;\n  /** Ending line number (0-indexed) */\n  endLine: number;\n  /** Content between markers (excluding markers themselves) */\n  content: string;\n}\n\n/**\n * Information about a malformed block\n */\nexport interface BlockWarning {\n  /** Type of warning */\n  type: 'nested' | 'unclosed';\n  /** Line number where the issue occurred */\n  line: number;\n  /** Human-readable message */\n  message: string;\n}\n\n/**\n * Result of extracting managed blocks from code\n */\nexport interface BlockExtractionResult {\n  /** All managed blocks found */\n  blocks: ManagedBlock[];\n  /** Code outside of managed blocks */\n  preservedCode: string[];\n  /** Whether any blocks were found */\n  hasBlocks: boolean;\n  /** Warnings about malformed blocks */\n  warnings: BlockWarning[];\n}\n\n/**\n * Options for injecting managed blocks\n */\nexport interface InjectBlocksOptions {\n  /** Existing file content */\n  existingCode: string;\n  /** New blocks to inject */\n  newBlocks: Array<{\n    id?: string;\n    content: string;\n  }>;\n  /** Whether to preserve block order (default: true) */\n  preserveOrder?: boolean;\n}\n\n/**\n * Extract managed blocks from existing code\n *\n * @param code - Source code to analyze\n * @returns Extraction result with blocks and preserved code\n *\n * @example\n * ```typescript\n * const result = extractManagedBlocks(`\n *   // User code\n *   // ARTK:BEGIN GENERATED id=test-1\n *   test('example', () => {});\n *   // ARTK:END GENERATED\n *   // More user code\n * `);\n * // result.blocks.length === 1\n * // result.blocks[0].id === 'test-1'\n * ```\n */\nexport function extractManagedBlocks(code: string): BlockExtractionResult {\n  const lines = code.split('\\n');\n  const blocks: ManagedBlock[] = [];\n  const preservedCode: string[] = [];\n  const warnings: BlockWarning[] = [];\n\n  let inBlock = false;\n  let currentBlock: Partial<ManagedBlock> | null = null;\n  let blockContent: string[] = [];\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i]!;\n\n    // Check for block start\n    if (line.includes(BLOCK_START)) {\n      if (inBlock) {\n        // Nested block detected - close the previous block and record warning\n        warnings.push({\n          type: 'nested',\n          line: i + 1,\n          message: `Nested managed block detected at line ${i + 1}. Previous block starting at line ${(currentBlock?.startLine ?? 0) + 1} will be closed.`,\n        });\n        // Save the incomplete previous block\n        if (currentBlock) {\n          blocks.push({\n            ...currentBlock,\n            endLine: i - 1,\n            content: blockContent.join('\\n'),\n          } as ManagedBlock);\n        }\n      }\n      inBlock = true;\n      const match = line.match(BLOCK_ID_PATTERN);\n      currentBlock = {\n        id: match?.[1],\n        startLine: i,\n      };\n      blockContent = [];\n      continue;\n    }\n\n    // Check for block end\n    if (line.includes(BLOCK_END) && inBlock) {\n      inBlock = false;\n      if (currentBlock) {\n        blocks.push({\n          ...currentBlock,\n          endLine: i,\n          content: blockContent.join('\\n'),\n        } as ManagedBlock);\n      }\n      currentBlock = null;\n      blockContent = [];\n      continue;\n    }\n\n    // Collect content\n    if (inBlock) {\n      blockContent.push(line);\n    } else {\n      preservedCode.push(line);\n    }\n  }\n\n  // Handle unclosed block\n  if (inBlock && currentBlock) {\n    warnings.push({\n      type: 'unclosed',\n      line: (currentBlock.startLine ?? 0) + 1,\n      message: `Unclosed managed block starting at line ${(currentBlock.startLine ?? 0) + 1} - block will be ignored`,\n    });\n  }\n\n  return {\n    blocks,\n    preservedCode,\n    hasBlocks: blocks.length > 0,\n    warnings,\n  };\n}\n\n/**\n * Wrap content in managed block markers\n *\n * @param content - Code to wrap\n * @param id - Optional block identifier\n * @returns Wrapped content with markers\n *\n * @example\n * ```typescript\n * const wrapped = wrapInBlock(\"test('foo', () => {});\", 'test-foo');\n * // Returns:\n * // // ARTK:BEGIN GENERATED id=test-foo\n * // test('foo', () => {});\n * // // ARTK:END GENERATED\n * ```\n */\nexport function wrapInBlock(content: string, id?: string): string {\n  const startMarker = id\n    ? `${BLOCK_START} id=${id}`\n    : BLOCK_START;\n\n  return `${startMarker}\\n${content}\\n${BLOCK_END}`;\n}\n\n/**\n * Inject managed blocks into code, preserving user code outside blocks\n *\n * Behavior:\n * - If existing code has no blocks: append new blocks at end\n * - If existing code has blocks: replace matching blocks by ID\n * - If block ID not found: append new block at end\n * - All code outside blocks is preserved\n *\n * @param options - Injection options\n * @returns Updated code with injected blocks\n *\n * @example\n * ```typescript\n * const result = injectManagedBlocks({\n *   existingCode: `\n *     // User helper\n *     // ARTK:BEGIN GENERATED id=old-test\n *     test('old', () => {});\n *     // ARTK:END GENERATED\n *   `,\n *   newBlocks: [\n *     { id: 'old-test', content: \"test('new', () => {});\" }\n *   ]\n * });\n * // result contains replaced block with new content\n * ```\n */\nexport function injectManagedBlocks(options: InjectBlocksOptions): string {\n  const { existingCode, newBlocks } = options;\n\n  // If no existing code, just wrap new blocks\n  if (!existingCode.trim()) {\n    return newBlocks\n      .map(block => wrapInBlock(block.content, block.id))\n      .join('\\n\\n');\n  }\n\n  const { preservedCode, hasBlocks } =\n    extractManagedBlocks(existingCode);\n\n  if (!hasBlocks) {\n    // No existing blocks - append new blocks at end\n    const preserved = preservedCode.join('\\n').trim();\n    const newContent = newBlocks\n      .map(block => wrapInBlock(block.content, block.id))\n      .join('\\n\\n');\n\n    return preserved ? `${preserved}\\n\\n${newContent}` : newContent;\n  }\n\n  // Replace existing blocks by ID, preserve structure\n  const result: string[] = [];\n  const processedIds = new Set<string>();\n  // Track id-less blocks separately by position to avoid ambiguous matching\n  let idLessBlockIndex = 0;\n  const idLessNewBlocks = newBlocks.filter(b => !b.id);\n  const processedIdLessIndices = new Set<number>();\n\n  // Re-scan to maintain structure\n  const lines = existingCode.split('\\n');\n  let inBlock = false;\n  let currentBlockId: string | undefined;\n  let skipUntilEnd = false;\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i]!;\n\n    if (line.includes(BLOCK_START)) {\n      inBlock = true;\n      const match = line.match(BLOCK_ID_PATTERN);\n      currentBlockId = match?.[1];\n\n      // Find replacement block\n      let replacement;\n      if (currentBlockId) {\n        // Match by ID for blocks with IDs\n        replacement = newBlocks.find(b => b.id === currentBlockId);\n        if (replacement) {\n          processedIds.add(currentBlockId);\n        }\n      } else {\n        // Match id-less blocks by position\n        if (idLessBlockIndex < idLessNewBlocks.length) {\n          replacement = idLessNewBlocks[idLessBlockIndex];\n          processedIdLessIndices.add(idLessBlockIndex);\n        }\n        idLessBlockIndex++;\n      }\n\n      if (replacement) {\n        result.push(wrapInBlock(replacement.content, replacement.id));\n        skipUntilEnd = true;\n      } else {\n        // Keep original block\n        result.push(line);\n        skipUntilEnd = false;\n      }\n      continue;\n    }\n\n    if (line.includes(BLOCK_END) && inBlock) {\n      inBlock = false;\n      if (!skipUntilEnd) {\n        result.push(line);\n      }\n      currentBlockId = undefined;\n      skipUntilEnd = false;\n      continue;\n    }\n\n    // Add content\n    if (!inBlock) {\n      result.push(line);\n    } else if (!skipUntilEnd) {\n      result.push(line);\n    }\n  }\n\n  // Append new blocks that weren't replacements\n  for (let i = 0; i < newBlocks.length; i++) {\n    const block = newBlocks[i]!;\n    if (block.id) {\n      // Check if this ID was processed\n      if (!processedIds.has(block.id)) {\n        result.push('');\n        result.push(wrapInBlock(block.content, block.id));\n      }\n    } else {\n      // Check if this id-less block was processed (by its index in idLessNewBlocks)\n      const idLessIndex = idLessNewBlocks.indexOf(block);\n      if (!processedIdLessIndices.has(idLessIndex)) {\n        result.push('');\n        result.push(wrapInBlock(block.content, block.id));\n      }\n    }\n  }\n\n  return result.join('\\n');\n}\n","/**\n * Journey Frontmatter Updater - Enable bi-directional traceability\n * @see research/2026-01-03_autogen-remaining-features-plan.md Section 1\n */\nimport { readFileSync, writeFileSync } from 'node:fs';\nimport { parse as parseYaml, stringify as stringifyYaml } from 'yaml';\nimport { createHash } from 'node:crypto';\n\n/**\n * Journey test entry with generation metadata\n */\nexport interface JourneyTestEntry {\n  /** Path to generated test file (relative to project root) */\n  path: string;\n  /** Timestamp when test was generated */\n  generated: string;\n  /** Content hash for change detection (first 8 chars of SHA-256) */\n  hash: string;\n}\n\n/**\n * Options for updating journey frontmatter\n */\nexport interface JourneyUpdateOptions {\n  /** Path to the journey markdown file */\n  journeyPath: string;\n  /** Path to the generated test file */\n  testPath: string;\n  /** Content of the generated test (for hash calculation) */\n  testContent: string;\n  /** Module dependencies to add (foundation or feature module names) */\n  modules?: {\n    foundation?: string[];\n    features?: string[];\n  };\n}\n\n/**\n * Result of journey frontmatter update\n */\nexport interface JourneyUpdateResult {\n  /** Whether update succeeded */\n  success: boolean;\n  /** Previous tests array before update */\n  previousTests: JourneyTestEntry[];\n  /** Updated tests array after update */\n  updatedTests: JourneyTestEntry[];\n  /** Modules added (not previously in the list) */\n  modulesAdded: {\n    foundation: string[];\n    features: string[];\n  };\n}\n\n/**\n * Split journey content into frontmatter and body\n */\nfunction splitJourneyContent(content: string): {\n  frontmatter: string;\n  body: string;\n} {\n  const match = content.match(/^---\\r?\\n([\\s\\S]*?)\\r?\\n---\\r?\\n([\\s\\S]*)$/);\n\n  if (!match) {\n    throw new Error(\n      'Invalid Journey format: missing frontmatter delimiters (content should be wrapped in --- ... ---)'\n    );\n  }\n\n  return {\n    frontmatter: match[1]!,\n    body: match[2]!,\n  };\n}\n\n/**\n * Calculate SHA-256 hash of content (first 8 characters)\n */\nfunction calculateContentHash(content: string): string {\n  return createHash('sha256').update(content).digest('hex').substring(0, 8);\n}\n\n/**\n * Update Journey frontmatter with generated test info\n *\n * This enables bi-directional traceability by:\n * 1. Recording which tests were generated from this Journey\n * 2. Tracking when tests were generated\n * 3. Detecting test changes via content hash\n * 4. Linking module dependencies\n *\n * @param options - Update options\n * @returns Update result with previous and new state\n * @throws Error if journey file is invalid or cannot be written\n */\nexport function updateJourneyFrontmatter(\n  options: JourneyUpdateOptions\n): JourneyUpdateResult {\n  const {\n    journeyPath,\n    testPath,\n    testContent,\n    modules = { foundation: [], features: [] },\n  } = options;\n\n  // Read journey file\n  const content = readFileSync(journeyPath, 'utf-8');\n\n  // Split frontmatter and body\n  const { frontmatter, body } = splitJourneyContent(content);\n\n  // Parse YAML frontmatter\n  const parsed = parseYaml(frontmatter) as Record<string, unknown>;\n\n  // Store previous state (deep copy to avoid mutation)\n  const previousTests = Array.isArray(parsed.tests)\n    ? (parsed.tests as JourneyTestEntry[]).map((t) =>\n        typeof t === 'string' ? { path: t, generated: '', hash: '' } : { ...t }\n      )\n    : [];\n\n  // Calculate content hash\n  const hash = calculateContentHash(testContent);\n\n  // Create/update test entry\n  const testEntry: JourneyTestEntry = {\n    path: testPath,\n    generated: new Date().toISOString(),\n    hash,\n  };\n\n  // Ensure tests array exists\n  if (!Array.isArray(parsed.tests)) {\n    parsed.tests = [];\n  }\n\n  // Find existing test entry by path\n  const existingIndex = (parsed.tests as JourneyTestEntry[]).findIndex(\n    (t) =>\n      typeof t === 'string'\n        ? t === testPath\n        : (t as JourneyTestEntry).path === testPath\n  );\n\n  // Update or add test entry\n  if (existingIndex >= 0) {\n    (parsed.tests as JourneyTestEntry[])[existingIndex]! = testEntry;\n  } else {\n    (parsed.tests as JourneyTestEntry[]).push(testEntry);\n  }\n\n  // Update modules\n  const modulesAdded = {\n    foundation: [] as string[],\n    features: [] as string[],\n  };\n\n  // Ensure modules structure exists\n  if (!parsed.modules || typeof parsed.modules !== 'object') {\n    parsed.modules = { foundation: [], features: [] };\n  }\n\n  const parsedModules = parsed.modules as {\n    foundation?: string[];\n    features?: string[];\n  };\n\n  // Ensure foundation and features arrays exist\n  if (!Array.isArray(parsedModules.foundation)) {\n    parsedModules.foundation = [];\n  }\n  if (!Array.isArray(parsedModules.features)) {\n    parsedModules.features = [];\n  }\n\n  // Add foundation modules (deduplicate)\n  if (modules.foundation) {\n    const existingFoundation = new Set(parsedModules.foundation!);\n    for (const mod of modules.foundation) {\n      if (!existingFoundation.has(mod)) {\n        modulesAdded.foundation.push(mod);\n        parsedModules.foundation!.push(mod);\n      }\n    }\n    // Sort for consistency\n    parsedModules.foundation!.sort();\n  }\n\n  // Add feature modules (deduplicate)\n  if (modules.features) {\n    const existingFeatures = new Set(parsedModules.features);\n    for (const mod of modules.features) {\n      if (!existingFeatures.has(mod)) {\n        modulesAdded.features.push(mod);\n        parsedModules.features.push(mod);\n      }\n    }\n    // Sort for consistency\n    parsedModules.features.sort();\n  }\n\n  // Reconstruct file with updated frontmatter\n  const newFrontmatter = stringifyYaml(parsed, {\n    lineWidth: 0, // Prevent line wrapping\n    defaultKeyType: 'PLAIN',\n    defaultStringType: 'QUOTE_DOUBLE',\n  });\n\n  const newContent = `---\\n${newFrontmatter}---\\n${body}`;\n\n  // Write back to file\n  writeFileSync(journeyPath, newContent, 'utf-8');\n\n  return {\n    success: true,\n    previousTests,\n    updatedTests: parsed.tests as JourneyTestEntry[],\n    modulesAdded,\n  };\n}\n\n/**\n * Check if a Journey's test is up-to-date based on content hash\n *\n * @param journeyPath - Path to the journey file\n * @param testPath - Path to the test file to check\n * @param testContent - Current content of the test file\n * @returns True if the test hash matches the recorded hash\n */\nexport function isJourneyTestCurrent(\n  journeyPath: string,\n  testPath: string,\n  testContent: string\n): boolean {\n  const content = readFileSync(journeyPath, 'utf-8');\n  const { frontmatter } = splitJourneyContent(content);\n  const parsed = parseYaml(frontmatter) as Record<string, unknown>;\n\n  if (!Array.isArray(parsed.tests)) {\n    return false;\n  }\n\n  // Find test entry\n  const testEntry = (parsed.tests as JourneyTestEntry[]).find((t) =>\n    typeof t === 'string' ? t === testPath : t.path === testPath\n  );\n\n  if (!testEntry || typeof testEntry === 'string') {\n    return false;\n  }\n\n  // Calculate current hash\n  const currentHash = calculateContentHash(testContent);\n\n  return testEntry.hash === currentHash;\n}\n","/**\n * Cross-module-system path utilities\n *\n * Provides directory resolution that works in both ESM and CJS environments.\n *\n * IMPORTANT: This module uses a dual-strategy approach:\n * - In CJS: Uses __dirname (injected by Node.js module wrapper)\n * - In ESM: Uses import.meta.url (only available in ESM)\n *\n * The TypeScript source uses import.meta.url, which works for ESM builds.\n * For CJS builds, we detect that __dirname is available and use it instead.\n */\nimport { join, dirname } from 'node:path';\nimport { readFileSync, existsSync } from 'node:fs';\nimport { fileURLToPath } from 'node:url';\n\n// CJS-specific globals - these are injected by Node.js module wrapper in CJS context\n// They will be undefined in ESM context\ndeclare const __dirname: string | undefined;\n \ndeclare const require: ((_id: string) => any) & { resolve: (_id: string) => string } | undefined;\n\n/**\n * Cached package root to avoid repeated lookups\n */\nlet cachedPackageRoot: string | undefined;\n\n/**\n * Cached module directory\n */\nlet cachedModuleDir: string | undefined;\n\n/**\n * Get the directory where this module file is located.\n * Works in both ESM and CJS environments.\n */\nfunction getModuleDir(): string {\n  if (cachedModuleDir) {\n    return cachedModuleDir;\n  }\n\n  // In CJS, __dirname is injected by Node.js module wrapper\n  // It will be undefined in ESM context\n  if (typeof __dirname === 'string' && __dirname.length > 0) {\n    cachedModuleDir = __dirname;\n    return cachedModuleDir;\n  }\n\n  // In ESM, use import.meta.url directly\n  // For CJS builds, this block is removed by post-build script (not needed since __dirname works)\n  // __ESM_ONLY_START__\n  try {\n    // @ts-ignore - Valid in ESM, removed from CJS by post-build\n    const metaUrl: string | undefined = import.meta.url;\n    if (metaUrl) {\n      cachedModuleDir = dirname(fileURLToPath(metaUrl));\n      return cachedModuleDir;\n    }\n  } catch {\n    // import.meta not available\n  }\n  // __ESM_ONLY_END__\n\n  // Fallback: try to find via require.resolve (CJS only)\n  try {\n    if (typeof require !== 'undefined' && require?.resolve) {\n      const resolved = require.resolve('@artk/core-autogen/package.json');\n      cachedModuleDir = dirname(resolved);\n      return cachedModuleDir;\n    }\n  } catch {\n    // Package not found via require.resolve\n  }\n\n  // Last resort: use process.cwd()\n  // This is unreliable but better than crashing\n  cachedModuleDir = process.cwd();\n  return cachedModuleDir;\n}\n\n/**\n * Get the package root directory.\n *\n * Strategy:\n * 1. Check ARTK_AUTOGEN_ROOT env var (for testing/override)\n * 2. Use module location to find package root\n * 3. Fallback to cwd-based search\n */\nexport function getPackageRoot(): string {\n  if (cachedPackageRoot) {\n    return cachedPackageRoot;\n  }\n\n  // 1. Check environment variable override\n  const envRoot = process.env['ARTK_AUTOGEN_ROOT'];\n  if (envRoot && existsSync(join(envRoot, 'package.json'))) {\n    cachedPackageRoot = envRoot;\n    return cachedPackageRoot;\n  }\n\n  // 2. Find package root from module location\n  // This file is at: <package-root>/dist[-variant]/utils/paths.js\n  // So we go up 2 levels to find package root\n  const moduleDir = getModuleDir();\n  const possibleRoots = [\n    join(moduleDir, '..', '..'),     // from dist/utils/ or dist-cjs/utils/\n    join(moduleDir, '..'),           // from dist/ directly\n    moduleDir,                        // if already at root\n  ];\n\n  for (const root of possibleRoots) {\n    const pkgPath = join(root, 'package.json');\n    if (existsSync(pkgPath)) {\n      try {\n        const pkg = JSON.parse(readFileSync(pkgPath, 'utf-8'));\n        if (pkg.name === '@artk/core-autogen') {\n          cachedPackageRoot = root;\n          return cachedPackageRoot;\n        }\n      } catch {\n        // Continue searching\n      }\n    }\n  }\n\n  // 3. Fallback to cwd-based search (for vendored installations)\n  const cwdPaths = [\n    join(process.cwd(), 'node_modules', '@artk', 'core-autogen'),\n    join(process.cwd(), 'artk-e2e', 'vendor', 'artk-core-autogen'),\n    process.cwd(),\n  ];\n\n  for (const searchPath of cwdPaths) {\n    const pkgPath = join(searchPath, 'package.json');\n    if (existsSync(pkgPath)) {\n      try {\n        const pkg = JSON.parse(readFileSync(pkgPath, 'utf-8'));\n        if (pkg.name === '@artk/core-autogen') {\n          cachedPackageRoot = searchPath;\n          return cachedPackageRoot;\n        }\n      } catch {\n        // Continue searching\n      }\n    }\n  }\n\n  // Final fallback - use module directory's parent\n  cachedPackageRoot = join(moduleDir, '..', '..');\n  return cachedPackageRoot;\n}\n\n/**\n * Get the templates directory path.\n *\n * Templates are copied to dist/codegen/templates/ during build.\n * When installed, only one dist variant exists.\n */\nexport function getTemplatesDir(): string {\n  const root = getPackageRoot();\n  const moduleDir = getModuleDir();\n\n  // First, try relative to the module itself (most reliable)\n  // Module is at dist[-variant]/utils/paths.js\n  // Templates are at dist[-variant]/codegen/templates/\n  const relativeToModule = join(moduleDir, '..', 'codegen', 'templates');\n  if (existsSync(relativeToModule)) {\n    return relativeToModule;\n  }\n\n  // Fallback: check standard locations from package root\n  const possiblePaths = [\n    join(root, 'dist', 'codegen', 'templates'),\n    join(root, 'dist-cjs', 'codegen', 'templates'),\n    join(root, 'dist-legacy-16', 'codegen', 'templates'),\n    join(root, 'dist-legacy-14', 'codegen', 'templates'),\n  ];\n\n  for (const templatesPath of possiblePaths) {\n    if (existsSync(templatesPath)) {\n      return templatesPath;\n    }\n  }\n\n  // Final fallback\n  return possiblePaths[0] ?? join(root, 'dist', 'codegen', 'templates');\n}\n\n/**\n * Get the path to a specific template file.\n */\nexport function getTemplatePath(templateName: string): string {\n  return join(getTemplatesDir(), templateName);\n}\n\n/**\n * Clear cached paths (for testing)\n */\nexport function clearPathCache(): void {\n  cachedPackageRoot = undefined;\n  cachedModuleDir = undefined;\n}\n","/**\n * Version utilities for generated code branding\n *\n * Supports build-time version injection via:\n * - Environment variable: ARTK_VERSION\n * - Build tool define: __ARTK_VERSION__ (e.g., via esbuild/rollup define)\n *\n * Falls back to runtime package.json reading if not injected.\n */\nimport { readFileSync, existsSync } from 'node:fs';\nimport { join } from 'node:path';\nimport { getPackageRoot } from './paths.js';\n\n/**\n * Build-time injected version (can be replaced by bundlers like esbuild/rollup)\n * Usage: define({ '__ARTK_VERSION__': JSON.stringify('1.0.0') })\n */\ndeclare const __ARTK_VERSION__: string | undefined;\n\n/** Cached version to avoid repeated lookups */\nlet cachedVersion: string | undefined;\n\n/**\n * Get the package version\n *\n * Priority:\n * 1. Build-time define (__ARTK_VERSION__)\n * 2. Environment variable (ARTK_VERSION)\n * 3. Runtime package.json reading (fallback)\n */\nexport function getPackageVersion(): string {\n  // Return cached version if available\n  if (cachedVersion) {\n    return cachedVersion;\n  }\n\n  // 1. Check build-time define (set by bundlers)\n  try {\n    if (typeof __ARTK_VERSION__ !== 'undefined' && __ARTK_VERSION__) {\n      cachedVersion = __ARTK_VERSION__;\n      return cachedVersion;\n    }\n  } catch {\n    // __ARTK_VERSION__ not defined, continue to fallbacks\n  }\n\n  // 2. Check environment variable (useful for CI/CD)\n  const envVersion = process.env['ARTK_VERSION'];\n  if (envVersion) {\n    cachedVersion = envVersion;\n    return cachedVersion;\n  }\n\n  // 3. Fall back to runtime package.json reading\n  try {\n    const packageRoot = getPackageRoot();\n    const pkgPath = join(packageRoot, 'package.json');\n\n    if (existsSync(pkgPath)) {\n      const pkg = JSON.parse(readFileSync(pkgPath, 'utf-8')) as { version?: string };\n      if (pkg.version) {\n        cachedVersion = pkg.version;\n        return cachedVersion;\n      }\n    }\n  } catch {\n    // Package.json lookup failed\n  }\n\n  cachedVersion = 'unknown';\n  return cachedVersion;\n}\n\n/**\n * Get ISO timestamp for generated file headers\n */\nexport function getGeneratedTimestamp(): string {\n  return new Date().toISOString();\n}\n\n/**\n * Generate a standard header comment for generated files\n */\nexport interface GeneratedHeaderOptions {\n  title?: string;\n  journeyId?: string;\n  tags?: string[];\n  tier?: string;\n  scope?: string;\n  actor?: string;\n}\n\nexport function generateFileHeader(options: GeneratedHeaderOptions = {}): string {\n  const version = getPackageVersion();\n  const timestamp = getGeneratedTimestamp();\n\n  const lines = [\n    '/**',\n    options.title ? ` * ${options.title}` : ' * Generated file',\n    options.journeyId ? ` * Journey: ${options.journeyId}` : null,\n    ` *`,\n    ` * @generated by @artk/core-autogen v${version}`,\n    ` * @timestamp ${timestamp}`,\n    ` * @warning Generated regions (ARTK:BEGIN/END GENERATED) will be overwritten.`,\n    ` *          Code outside these blocks is preserved on regeneration.`,\n  ];\n\n  if (options.tags && options.tags.length > 0) {\n    lines.push(` * @tags ${options.tags.join(', ')}`);\n  }\n  if (options.tier) {\n    lines.push(` * @tier ${options.tier}`);\n  }\n  if (options.scope) {\n    lines.push(` * @scope ${options.scope}`);\n  }\n  if (options.actor) {\n    lines.push(` * @actor ${options.actor}`);\n  }\n\n  lines.push(' */');\n\n  return lines.filter(l => l !== null).join('\\n');\n}\n\n/**\n * Branding string for inline comments\n */\nexport function getBrandingComment(): string {\n  const version = getPackageVersion();\n  return `@artk/core-autogen v${version}`;\n}\n","/**\n * Variant detection and feature flags for AutoGen\n */\n\nexport interface VariantInfo {\n  id: 'modern-esm' | 'modern-cjs' | 'legacy-16' | 'legacy-14';\n  nodeVersion: number;\n  moduleSystem: 'esm' | 'cjs';\n  playwrightVersion: string;\n  features: VariantFeatures;\n}\n\nexport interface VariantFeatures {\n  ariaSnapshots: boolean;\n  clockApi: boolean;\n  topLevelAwait: boolean;\n  promiseAny: boolean;\n}\n\n/**\n * Detect the current runtime variant based on Node.js version\n */\nexport function detectVariant(): VariantInfo {\n  const nodeVersionStr = process.version.slice(1);\n  const nodeVersion = parseInt(nodeVersionStr.split('.')[0], 10);\n\n  // Check if running in ESM context\n  const isESM = typeof import.meta !== 'undefined';\n\n  if (nodeVersion >= 18) {\n    return {\n      id: isESM ? 'modern-esm' : 'modern-cjs',\n      nodeVersion,\n      moduleSystem: isESM ? 'esm' : 'cjs',\n      playwrightVersion: '1.57.x',\n      features: {\n        ariaSnapshots: true,\n        clockApi: true,\n        topLevelAwait: true,\n        promiseAny: true,\n      },\n    };\n  } else if (nodeVersion >= 16) {\n    return {\n      id: 'legacy-16',\n      nodeVersion,\n      moduleSystem: 'cjs',\n      playwrightVersion: '1.49.x',\n      features: {\n        ariaSnapshots: true,\n        clockApi: true,\n        topLevelAwait: true,\n        promiseAny: true,\n      },\n    };\n  } else {\n    return {\n      id: 'legacy-14',\n      nodeVersion,\n      moduleSystem: 'cjs',\n      playwrightVersion: '1.33.x',\n      features: {\n        ariaSnapshots: false,\n        clockApi: false,\n        topLevelAwait: false,\n        promiseAny: false,\n      },\n    };\n  }\n}\n\n/**\n * Get feature availability for current variant\n */\nexport function getFeatures(): VariantFeatures {\n  return detectVariant().features;\n}\n\n/**\n * Check if a specific feature is available\n */\nexport function hasFeature(feature: keyof VariantFeatures): boolean {\n  return detectVariant().features[feature];\n}\n","/**\n * Test Generator - Generate Playwright test files from IR\n * @see research/2026-01-02_autogen-refined-plan.md Section 12\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md (variant-aware generation)\n */\nimport { readFileSync, existsSync } from 'node:fs';\nimport { join } from 'node:path';\nimport ejs from 'ejs';\nimport type { IRJourney, IRPrimitive, ValueSpec } from '../ir/types.js';\nimport { toPlaywrightLocator } from '../selectors/priority.js';\nimport { injectManagedBlocks } from './blocks.js';\nimport { updateJourneyFrontmatter } from '../journey/updater.js';\nimport { escapeRegex } from '../utils/escaping.js';\nimport { getPackageVersion, getGeneratedTimestamp } from '../utils/version.js';\nimport { getTemplatePath } from '../utils/paths.js';\nimport { detectVariant, type VariantInfo, type VariantFeatures } from '../variants/index.js';\n\n// Re-export variant types for consumers\nexport type { VariantInfo, VariantFeatures };\n\n/**\n * Import statement for generated test\n */\nexport interface ImportStatement {\n  members: string[];\n  from: string;\n}\n\n/**\n * Options for test generation\n */\nexport interface GenerateTestOptions {\n  /** Custom template path */\n  templatePath?: string;\n  /** Whether to include source comments */\n  includeComments?: boolean;\n  /** Module imports to add */\n  imports?: ImportStatement[];\n  /** Custom test ID attribute */\n  testIdAttribute?: string;\n  /**\n   * Code generation strategy\n   * - 'full': Generate complete file (default)\n   * - 'blocks': Use managed blocks for partial regeneration\n   * - 'ast': Use AST editing to preserve structure\n   */\n  strategy?: 'full' | 'blocks' | 'ast';\n  /** Existing code (required for 'blocks' and 'ast' strategies) */\n  existingCode?: string;\n  /** Whether to update journey frontmatter with test metadata */\n  updateJourney?: boolean;\n  /** Path to the source journey file (required if updateJourney is true) */\n  journeyPath?: string;\n  /** Output path for the generated test file (for journey update) */\n  outputPath?: string;\n  /** LLKB root directory for version tracking (default: .artk/llkb) */\n  llkbRoot?: string;\n  /** Whether to include LLKB version in generated test header (default: true if LLKB exists) */\n  includeLlkbVersion?: boolean;\n  /** Target variant for code generation (auto-detected if not specified) */\n  targetVariant?: VariantInfo;\n  /** Whether to emit warnings for variant-incompatible features (default: true) */\n  warnOnIncompatible?: boolean;\n}\n\n/**\n * Result of test generation\n */\nexport interface GenerateTestResult {\n  /** Generated test code */\n  code: string;\n  /** Journey ID */\n  journeyId: string;\n  /** Suggested filename */\n  filename: string;\n  /** Imports used */\n  imports: ImportStatement[];\n  /** Variant used for generation */\n  variant?: VariantInfo;\n  /** Warnings about variant-incompatible features */\n  variantWarnings?: string[];\n}\n\n/**\n * Context for variant-aware code generation\n */\ninterface VariantContext {\n  /** Variant info for the target environment */\n  variant: VariantInfo;\n  /** Collected warnings for incompatible features */\n  warnings: string[];\n  /** Whether to emit warnings */\n  warnOnIncompatible: boolean;\n}\n\n/**\n * Check if a feature is available in the current variant\n * @internal Reserved for future variant-specific primitive handling\n */\nfunction _checkFeature(\n  ctx: VariantContext,\n  feature: keyof VariantFeatures,\n  featureName: string,\n  primitiveType: string\n): boolean {\n  const available = ctx.variant.features[feature];\n  if (!available && ctx.warnOnIncompatible) {\n    ctx.warnings.push(\n      `Primitive '${primitiveType}' uses ${featureName} which requires ${getFeatureRequirement(feature)}. ` +\n        `Current variant: ${ctx.variant.id} (Playwright ${ctx.variant.playwrightVersion})`\n    );\n  }\n  return available;\n}\n\n// Export for testing (prefixed to avoid unused warning in production)\nexport const __test_checkFeature = _checkFeature;\n\n/**\n * Get human-readable requirement for a feature\n */\nfunction getFeatureRequirement(feature: keyof VariantFeatures): string {\n  switch (feature) {\n    case 'ariaSnapshots':\n      return 'Playwright 1.49+ (Node 16+)';\n    case 'clockApi':\n      return 'Playwright 1.45+ (Node 18+)';\n    case 'topLevelAwait':\n      return 'Node 14.8+ with ESM';\n    case 'promiseAny':\n      return 'Node 15+ or polyfill';\n    default:\n      return 'unknown version';\n  }\n}\n\n/**\n * Escape string for use in generated code\n */\nfunction escapeString(str: string): string {\n  return str\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/'/g, \"\\\\'\")\n    .replace(/\"/g, '\\\\\"')\n    .replace(/\\n/g, '\\\\n')\n    .replace(/\\r/g, '\\\\r');\n}\n\n/**\n * Render a value spec to code\n */\nfunction renderValue(value: ValueSpec): string {\n  switch (value.type) {\n    case 'literal':\n      return `'${escapeString(value.value)}'`;\n    case 'actor':\n      return `actor.${value.value}`;\n    case 'runId':\n      return 'runId';\n    case 'generated':\n      return `\\`${value.value}\\``;\n    case 'testData':\n      return `testData.${value.value}`;\n    default:\n      return `'${escapeString(value.value)}'`;\n  }\n}\n\n/**\n * Render an IR primitive to Playwright code\n * @param primitive The IR primitive to render\n * @param indent Indentation string\n * @param _ctx Optional variant context for compatibility checking (reserved for future use)\n */\nfunction renderPrimitive(primitive: IRPrimitive, indent = '', _ctx?: VariantContext): string {\n  switch (primitive.type) {\n    // Navigation\n    case 'goto':\n      return `${indent}await page.goto('${escapeString(primitive.url)}');`;\n\n    case 'waitForURL':\n      const urlPattern = typeof primitive.pattern === 'string'\n        ? `/${escapeRegex(primitive.pattern)}/`\n        : primitive.pattern.toString();\n      return `${indent}await page.waitForURL(${urlPattern});`;\n\n    case 'waitForResponse':\n      return `${indent}await page.waitForResponse(resp => resp.url().includes('${escapeString(primitive.urlPattern)}'));`;\n\n    case 'waitForLoadingComplete':\n      return `${indent}await page.waitForLoadState('networkidle');`;\n\n    case 'reload':\n      return `${indent}await page.reload();`;\n\n    case 'goBack':\n      return `${indent}await page.goBack();`;\n\n    case 'goForward':\n      return `${indent}await page.goForward();`;\n\n    // Wait primitives\n    case 'waitForVisible':\n      const waitVisibleTimeout = primitive.timeout ? `, timeout: ${primitive.timeout}` : '';\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.waitFor({ state: 'visible'${waitVisibleTimeout} });`;\n\n    case 'waitForHidden':\n      const waitHiddenTimeout = primitive.timeout ? `, timeout: ${primitive.timeout}` : '';\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.waitFor({ state: 'hidden'${waitHiddenTimeout} });`;\n\n    case 'waitForTimeout':\n      return `${indent}await page.waitForTimeout(${primitive.ms});`;\n\n    case 'waitForNetworkIdle':\n      const networkIdleOptions = primitive.timeout ? `, { timeout: ${primitive.timeout} }` : '';\n      return `${indent}await page.waitForLoadState('networkidle'${networkIdleOptions});`;\n\n    // Interactions\n    case 'click':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.click();`;\n\n    case 'dblclick':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.dblclick();`;\n\n    case 'rightClick':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.click({ button: 'right' });`;\n\n    case 'fill':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.fill(${renderValue(primitive.value)});`;\n\n    case 'select':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.selectOption('${escapeString(primitive.option)}');`;\n\n    case 'check':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.check();`;\n\n    case 'uncheck':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.uncheck();`;\n\n    case 'press':\n      if (primitive.locator) {\n        return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.press('${primitive.key}');`;\n      }\n      return `${indent}await page.keyboard.press('${primitive.key}');`;\n\n    case 'hover':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.hover();`;\n\n    case 'focus':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.focus();`;\n\n    case 'clear':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.clear();`;\n\n    case 'upload':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.setInputFiles([${primitive.files.map(f => `'${escapeString(f)}'`).join(', ')}]);`;\n\n    // Assertions\n    case 'expectVisible':\n      const visibleOptions = primitive.timeout ? `{ timeout: ${primitive.timeout} }` : '';\n      return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).toBeVisible(${visibleOptions});`;\n\n    case 'expectNotVisible':\n      return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).not.toBeVisible();`;\n\n    case 'expectHidden':\n      return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).toBeHidden();`;\n\n    case 'expectText':\n      const textPattern = typeof primitive.text === 'string'\n        ? `'${escapeString(primitive.text)}'`\n        : primitive.text.toString();\n      return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).toHaveText(${textPattern});`;\n\n    case 'expectValue':\n      return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).toHaveValue('${escapeString(primitive.value)}');`;\n\n    case 'expectChecked':\n      if (primitive.checked === false) {\n        return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).not.toBeChecked();`;\n      }\n      return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).toBeChecked();`;\n\n    case 'expectEnabled':\n      return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).toBeEnabled();`;\n\n    case 'expectDisabled':\n      return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).toBeDisabled();`;\n\n    case 'expectURL':\n      const urlExpectPattern = typeof primitive.pattern === 'string'\n        ? `/${escapeRegex(primitive.pattern)}/`\n        : primitive.pattern.toString();\n      return `${indent}await expect(page).toHaveURL(${urlExpectPattern});`;\n\n    case 'expectTitle':\n      const titlePattern = typeof primitive.title === 'string'\n        ? `'${escapeString(primitive.title)}'`\n        : primitive.title.toString();\n      return `${indent}await expect(page).toHaveTitle(${titlePattern});`;\n\n    case 'expectCount':\n      return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).toHaveCount(${primitive.count});`;\n\n    case 'expectContainsText':\n      return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).toContainText('${escapeString(primitive.text)}');`;\n\n    // Signals\n    case 'expectToast':\n      const toastSelector = primitive.message\n        ? `getByText('${escapeString(primitive.message)}')`\n        : `getByRole('alert')`;\n      return `${indent}await expect(page.${toastSelector}).toBeVisible();`;\n\n    case 'dismissModal':\n      return `${indent}await page.getByRole('dialog').getByRole('button', { name: /close|cancel|dismiss/i }).click();`;\n\n    case 'acceptAlert':\n      return `${indent}page.on('dialog', dialog => dialog.accept());`;\n\n    case 'dismissAlert':\n      return `${indent}page.on('dialog', dialog => dialog.dismiss());`;\n\n    // Module calls - use factory function to create instance\n    case 'callModule':\n      // Generate factory function name from module name (e.g., LoginModule -> createLoginModule)\n      const factoryName = `create${primitive.module}`;\n      const args = primitive.args ? primitive.args.map(a => JSON.stringify(a)).join(', ') : '';\n      // Create instance via factory and call method\n      return `${indent}await ${factoryName}(page).${primitive.method}(${args});`;\n\n    // Blocked - must throw to fail the test\n    case 'blocked':\n      return `${indent}// ARTK BLOCKED: ${primitive.reason}\\n${indent}// Source: ${escapeString(primitive.sourceText)}\\n${indent}throw new Error('ARTK BLOCKED: ${escapeString(primitive.reason)}');`;\n\n    default:\n      return `${indent}// Unknown primitive type: ${(primitive as { type: string }).type}`;\n  }\n}\n\n/**\n * Create a variant-aware render function for use in templates\n * @internal The ctx parameter is passed through for future variant-specific handling\n */\nfunction createVariantAwareRenderer(ctx: VariantContext): (primitive: IRPrimitive, indent?: string) => string {\n  // Note: ctx is passed to renderPrimitive for future variant-specific code generation\n  // Currently no primitives require variant checking, but the infrastructure is in place\n  return (primitive: IRPrimitive, indent = '') => renderPrimitive(primitive, indent, ctx);\n}\n\n/**\n * Load the default test template\n */\nfunction loadDefaultTemplate(): string {\n  const templatePath = getTemplatePath('test.ejs');\n  return readFileSync(templatePath, 'utf-8');\n}\n\n/**\n * Collect module imports from journey\n *\n * Imports factory functions (e.g., createLoginModule) for module calls.\n * The factory function naming follows the pattern: create{ModuleName}\n */\nfunction collectImports(journey: IRJourney): ImportStatement[] {\n  const imports: ImportStatement[] = [];\n  // Track unique module names to avoid duplicate imports\n  const usedModules = new Set<string>();\n\n  // Collect module calls from all steps\n  for (const step of journey.steps) {\n    for (const action of step.actions) {\n      if (action.type === 'callModule') {\n        usedModules.add(action.module);\n      }\n    }\n  }\n\n  // Convert to import statements - import factory functions\n  for (const module of usedModules) {\n    // Use lowercase-first path convention (e.g., @modules/loginModule for LoginModule)\n    const modulePath = module.charAt(0).toLowerCase() + module.slice(1);\n    // Import the factory function (e.g., createLoginModule)\n    const factoryName = `create${module}`;\n    imports.push({\n      members: [factoryName],\n      from: `@modules/${modulePath}`,\n    });\n  }\n\n  return imports;\n}\n\n/**\n * Get LLKB version and entry count if LLKB exists\n */\nfunction getLlkbInfo(llkbRoot: string): { llkbVersion: string | null; llkbEntries: number | null } {\n  const analyticsPath = join(llkbRoot, 'analytics.json');\n\n  if (!existsSync(analyticsPath)) {\n    return { llkbVersion: null, llkbEntries: null };\n  }\n\n  try {\n    const content = readFileSync(analyticsPath, 'utf-8');\n    const analytics = JSON.parse(content) as {\n      lastUpdated?: string;\n      overview?: { totalLessons?: number; totalComponents?: number };\n    };\n\n    const llkbVersion = analytics.lastUpdated || new Date().toISOString();\n    const totalLessons = analytics.overview?.totalLessons || 0;\n    const totalComponents = analytics.overview?.totalComponents || 0;\n    const llkbEntries = totalLessons + totalComponents;\n\n    return { llkbVersion, llkbEntries };\n  } catch {\n    return { llkbVersion: null, llkbEntries: null };\n  }\n}\n\n/**\n * Generate Playwright test code from IR Journey\n */\nexport function generateTest(\n  journey: IRJourney,\n  options: GenerateTestOptions = {}\n): GenerateTestResult {\n  const {\n    templatePath,\n    imports: additionalImports = [],\n    strategy = 'full',\n    existingCode,\n    llkbRoot = '.artk/llkb',\n    includeLlkbVersion = true,\n    targetVariant,\n    warnOnIncompatible = true,\n  } = options;\n\n  // Detect or use provided variant for variant-aware generation\n  const variant = targetVariant || detectVariant();\n\n  // Create variant context for compatibility checking\n  const variantCtx: VariantContext = {\n    variant,\n    warnings: [],\n    warnOnIncompatible,\n  };\n\n  // Load template\n  const template = templatePath\n    ? readFileSync(templatePath, 'utf-8')\n    : loadDefaultTemplate();\n\n  // Collect imports\n  const imports = [...collectImports(journey), ...additionalImports];\n\n  // Get LLKB version info if enabled\n  let llkbVersion: string | null = null;\n  let llkbEntries: number | null = null;\n\n  if (includeLlkbVersion) {\n    const llkbInfo = getLlkbInfo(llkbRoot);\n    llkbVersion = llkbInfo.llkbVersion;\n    llkbEntries = llkbInfo.llkbEntries;\n  }\n\n  // Create variant-aware renderer\n  const variantAwareRenderPrimitive = createVariantAwareRenderer(variantCtx);\n\n  // Render template with version branding and variant info\n  let code = ejs.render(template, {\n    journey,\n    imports,\n    renderPrimitive: variantAwareRenderPrimitive,\n    escapeString,\n    escapeRegex,\n    version: getPackageVersion(),\n    timestamp: getGeneratedTimestamp(),\n    llkbVersion,\n    llkbEntries,\n    variant: variant.id,\n    playwrightVersion: variant.playwrightVersion,\n  });\n\n  // Apply strategy-specific processing\n  if (strategy === 'blocks' && existingCode) {\n    // Use managed blocks strategy: inject generated code into existing file\n    const testBlock = {\n      id: `test-${journey.id}`,\n      content: code.trim(),\n    };\n\n    code = injectManagedBlocks({\n      existingCode,\n      newBlocks: [testBlock],\n    });\n  } else if (strategy === 'ast' && existingCode) {\n    // AST strategy would use astEdit.ts (not implemented in this task)\n    // For now, fall back to full regeneration\n    console.warn('AST strategy not yet implemented for blocks integration, using full generation');\n  }\n\n  // Generate filename\n  const filename = `${journey.id.toLowerCase()}.spec.ts`;\n\n  // Update journey frontmatter if requested\n  if (options.updateJourney && options.journeyPath) {\n    try {\n      const testPath = options.outputPath || filename;\n\n      // Extract module names from journey metadata\n      const modules = {\n        foundation: journey.moduleDependencies?.foundation || [],\n        features: journey.moduleDependencies?.feature || [], // Note: IR uses 'feature' (singular)\n      };\n\n      updateJourneyFrontmatter({\n        journeyPath: options.journeyPath,\n        testPath,\n        testContent: code,\n        modules,\n      });\n    } catch (error) {\n      // Log error but don't fail test generation\n      console.error(\n        `Warning: Failed to update journey frontmatter: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  return {\n    code,\n    journeyId: journey.id,\n    filename,\n    imports,\n    variant,\n    variantWarnings: variantCtx.warnings.length > 0 ? variantCtx.warnings : undefined,\n  };\n}\n\n/**\n * Generate test code as a string (convenience function)\n */\nexport function generateTestCode(journey: IRJourney): string {\n  return generateTest(journey).code;\n}\n","/**\n * Module Generator - Generate Page Object modules from IR\n * @see research/2026-01-02_autogen-refined-plan.md Section 12\n */\nimport { readFileSync } from 'node:fs';\nimport ejs from 'ejs';\nimport type { IRJourney, IRPrimitive, LocatorSpec } from '../ir/types.js';\nimport { toPlaywrightLocator } from '../selectors/priority.js';\nimport { getPackageVersion, getGeneratedTimestamp } from '../utils/version.js';\nimport { getTemplatePath } from '../utils/paths.js';\n\n/**\n * Locator definition for a module\n */\nexport interface ModuleLocator {\n  /** Property name for the locator */\n  name: string;\n  /** Playwright locator string */\n  playwright: string;\n  /** Original locator spec */\n  spec: LocatorSpec;\n  /** Human-readable description */\n  description?: string;\n}\n\n/**\n * Method parameter definition\n */\nexport interface MethodParam {\n  name: string;\n  type: string;\n  optional?: boolean;\n  defaultValue?: string;\n}\n\n/**\n * Method definition for a module\n */\nexport interface ModuleMethod {\n  /** Method name */\n  name: string;\n  /** Method description */\n  description: string;\n  /** Method parameters */\n  params: MethodParam[];\n  /** Return type */\n  returnType: string;\n  /** Method body lines */\n  body: string[];\n}\n\n/**\n * Module definition\n */\nexport interface ModuleDefinition {\n  /** Module name (PascalCase) */\n  moduleName: string;\n  /** Class name (PascalCase with suffix) */\n  className: string;\n  /** Module scope (feature area) */\n  scope: string;\n  /** Locators used by the module */\n  locators: ModuleLocator[];\n  /** Methods provided by the module */\n  methods: ModuleMethod[];\n}\n\n/**\n * Options for module generation\n */\nexport interface GenerateModuleOptions {\n  /** Custom template path */\n  templatePath?: string;\n  /** Module name suffix (default: 'Page') */\n  suffix?: string;\n  /** Whether to include JSDoc comments */\n  includeJsDoc?: boolean;\n}\n\n/**\n * Result of module generation\n */\nexport interface GenerateModuleResult {\n  /** Generated module code */\n  code: string;\n  /** Module name */\n  moduleName: string;\n  /** Suggested filename */\n  filename: string;\n  /** Locators defined */\n  locators: ModuleLocator[];\n  /** Methods defined */\n  methods: ModuleMethod[];\n}\n\n/**\n * Convert a scope/name to PascalCase class name\n */\nfunction toPascalCase(str: string): string {\n  return str\n    .split(/[-_\\s]+/)\n    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n    .join('');\n}\n\n/**\n * Convert a name to camelCase\n */\nfunction toCamelCase(str: string): string {\n  const pascal = toPascalCase(str);\n  return pascal.charAt(0).toLowerCase() + pascal.slice(1);\n}\n\n/**\n * Generate a unique locator name from a locator spec\n */\nfunction generateLocatorName(spec: LocatorSpec, existingNames: Set<string>): string {\n  let baseName: string;\n\n  // Generate base name from spec\n  switch (spec.strategy) {\n    case 'role':\n      baseName = spec.options?.name\n        ? `${toCamelCase(spec.options.name)}${toPascalCase(spec.value)}`\n        : `${toCamelCase(spec.value)}Element`;\n      break;\n    case 'label':\n    case 'placeholder':\n    case 'text':\n      baseName = `${toCamelCase(spec.value)}Field`;\n      break;\n    case 'testid':\n      baseName = toCamelCase(spec.value);\n      break;\n    case 'css':\n      // Extract meaningful name from CSS selector\n      const match = spec.value.match(/[#.]?([a-zA-Z][a-zA-Z0-9_-]*)/);\n      baseName = match ? toCamelCase(match[1]!) : 'element';\n      break;\n    default:\n      baseName = 'element';\n  }\n\n  // Ensure uniqueness\n  let name = baseName;\n  let counter = 1;\n  while (existingNames.has(name)) {\n    name = `${baseName}${counter}`;\n    counter++;\n  }\n  existingNames.add(name);\n\n  return name;\n}\n\n/**\n * Extract locators from journey primitives\n */\nfunction extractLocators(journey: IRJourney): ModuleLocator[] {\n  const locators: ModuleLocator[] = [];\n  const existingNames = new Set<string>();\n  const seenSpecs = new Map<string, ModuleLocator>();\n\n  // Helper to process a primitive\n  const processPrimitive = (primitive: IRPrimitive) => {\n    // Check if primitive has a locator\n    const locatorSpec = (primitive as { locator?: LocatorSpec }).locator;\n    if (!locatorSpec) return;\n\n    // Create a unique key for the locator spec\n    const specKey = JSON.stringify(locatorSpec);\n    if (seenSpecs.has(specKey)) return;\n\n    const name = generateLocatorName(locatorSpec, existingNames);\n    const playwrightLocator = toPlaywrightLocator(locatorSpec);\n\n    const locator: ModuleLocator = {\n      name,\n      playwright: playwrightLocator,\n      spec: locatorSpec,\n      description: `Locator for ${locatorSpec.strategy}: ${locatorSpec.value}`,\n    };\n\n    locators.push(locator);\n    seenSpecs.set(specKey, locator);\n  };\n\n  // Process setup\n  if (journey.setup) {\n    for (const primitive of journey.setup) {\n      processPrimitive(primitive);\n    }\n  }\n\n  // Process steps\n  for (const step of journey.steps) {\n    for (const action of step.actions) {\n      processPrimitive(action);\n    }\n    for (const assertion of step.assertions) {\n      processPrimitive(assertion);\n    }\n  }\n\n  // Process cleanup\n  if (journey.cleanup) {\n    for (const primitive of journey.cleanup) {\n      processPrimitive(primitive);\n    }\n  }\n\n  return locators;\n}\n\n/**\n * Generate methods from journey steps\n */\nfunction generateMethods(journey: IRJourney, locators: ModuleLocator[]): ModuleMethod[] {\n  const methods: ModuleMethod[] = [];\n  const locatorMap = new Map<string, string>();\n\n  // Build locator lookup map\n  for (const locator of locators) {\n    const specKey = JSON.stringify(locator.spec);\n    locatorMap.set(specKey, locator.name);\n  }\n\n  // Helper to get locator reference\n  const getLocatorRef = (spec: LocatorSpec): string => {\n    const specKey = JSON.stringify(spec);\n    const locatorName = locatorMap.get(specKey);\n    return locatorName ? `this.${locatorName}` : `this.page.${toPlaywrightLocator(spec)}`;\n  };\n\n  // Generate a method for each step\n  for (const step of journey.steps) {\n    const methodName = toCamelCase(step.id.replace(/[^a-zA-Z0-9]/g, '_'));\n    const body: string[] = [];\n\n    // Add actions\n    for (const action of step.actions) {\n      const line = primitiveToMethodLine(action, getLocatorRef);\n      if (line) {\n        body.push(line);\n      }\n    }\n\n    // Add assertions\n    for (const assertion of step.assertions) {\n      const line = primitiveToMethodLine(assertion, getLocatorRef);\n      if (line) {\n        body.push(line);\n      }\n    }\n\n    if (body.length > 0) {\n      methods.push({\n        name: methodName,\n        description: step.description,\n        params: [],\n        returnType: 'void',\n        body,\n      });\n    }\n  }\n\n  return methods;\n}\n\n/**\n * Convert a primitive to a method body line\n */\nfunction primitiveToMethodLine(\n  primitive: IRPrimitive,\n  getLocatorRef: (_spec: LocatorSpec) => string\n): string | null {\n  switch (primitive.type) {\n    // Navigation\n    case 'goto':\n      return `await this.page.goto('${escapeString(primitive.url)}');`;\n\n    case 'waitForURL':\n      const urlPattern = typeof primitive.pattern === 'string'\n        ? `'${escapeString(primitive.pattern)}'`\n        : primitive.pattern.toString();\n      return `await this.page.waitForURL(${urlPattern});`;\n\n    case 'waitForLoadingComplete':\n      return `await this.page.waitForLoadState('networkidle');`;\n\n    // Interactions\n    case 'click':\n      return `await ${getLocatorRef(primitive.locator)}.click();`;\n\n    case 'fill':\n      const value = primitive.value.type === 'literal'\n        ? `'${escapeString(primitive.value.value)}'`\n        : primitive.value.value;\n      return `await ${getLocatorRef(primitive.locator)}.fill(${value});`;\n\n    case 'select':\n      return `await ${getLocatorRef(primitive.locator)}.selectOption('${escapeString(primitive.option)}');`;\n\n    case 'check':\n      return `await ${getLocatorRef(primitive.locator)}.check();`;\n\n    case 'uncheck':\n      return `await ${getLocatorRef(primitive.locator)}.uncheck();`;\n\n    case 'press':\n      if (primitive.locator) {\n        return `await ${getLocatorRef(primitive.locator)}.press('${primitive.key}');`;\n      }\n      return `await this.page.keyboard.press('${primitive.key}');`;\n\n    case 'hover':\n      return `await ${getLocatorRef(primitive.locator)}.hover();`;\n\n    case 'focus':\n      return `await ${getLocatorRef(primitive.locator)}.focus();`;\n\n    case 'clear':\n      return `await ${getLocatorRef(primitive.locator)}.clear();`;\n\n    // Assertions (using expect)\n    case 'expectVisible':\n      return `await expect(${getLocatorRef(primitive.locator)}).toBeVisible();`;\n\n    case 'expectNotVisible':\n      return `await expect(${getLocatorRef(primitive.locator)}).not.toBeVisible();`;\n\n    case 'expectText':\n      const textPattern = typeof primitive.text === 'string'\n        ? `'${escapeString(primitive.text)}'`\n        : primitive.text.toString();\n      return `await expect(${getLocatorRef(primitive.locator)}).toHaveText(${textPattern});`;\n\n    case 'expectValue':\n      return `await expect(${getLocatorRef(primitive.locator)}).toHaveValue('${escapeString(primitive.value)}');`;\n\n    case 'expectEnabled':\n      return `await expect(${getLocatorRef(primitive.locator)}).toBeEnabled();`;\n\n    case 'expectDisabled':\n      return `await expect(${getLocatorRef(primitive.locator)}).toBeDisabled();`;\n\n    // Blocked - must throw to fail the test\n    case 'blocked':\n      return `// ARTK BLOCKED: ${primitive.reason}\\n    throw new Error('ARTK BLOCKED: ${primitive.reason}');`;\n\n    default:\n      return null;\n  }\n}\n\n/**\n * Escape string for code generation\n */\nfunction escapeString(str: string): string {\n  return str\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/'/g, \"\\\\'\")\n    .replace(/\"/g, '\\\\\"')\n    .replace(/\\n/g, '\\\\n')\n    .replace(/\\r/g, '\\\\r');\n}\n\n/**\n * Load the default module template\n */\nfunction loadDefaultTemplate(): string {\n  const templatePath = getTemplatePath('module.ejs');\n  return readFileSync(templatePath, 'utf-8');\n}\n\n/**\n * Generate Page Object module from IR Journey\n */\nexport function generateModule(\n  journey: IRJourney,\n  options: GenerateModuleOptions = {}\n): GenerateModuleResult {\n  const { templatePath, suffix = 'Page' } = options;\n\n  // Load template\n  const template = templatePath\n    ? readFileSync(templatePath, 'utf-8')\n    : loadDefaultTemplate();\n\n  // Generate module/class names\n  const moduleName = toPascalCase(journey.scope);\n  const className = `${moduleName}${suffix}`;\n\n  // Extract locators and generate methods\n  const locators = extractLocators(journey);\n  const methods = generateMethods(journey, locators);\n\n  // Create module definition\n  const moduleDef: ModuleDefinition = {\n    moduleName,\n    className,\n    scope: journey.scope,\n    locators,\n    methods,\n  };\n\n  // Render template with version branding\n  const code = ejs.render(template, {\n    ...moduleDef,\n    version: getPackageVersion(),\n    timestamp: getGeneratedTimestamp(),\n  });\n\n  // Generate filename\n  const filename = `${journey.scope.toLowerCase()}.page.ts`;\n\n  return {\n    code,\n    moduleName,\n    filename,\n    locators,\n    methods,\n  };\n}\n\n/**\n * Generate module code as a string (convenience function)\n */\nexport function generateModuleCode(journey: IRJourney): string {\n  return generateModule(journey).code;\n}\n\n/**\n * Extract module definition from journey without generating code\n */\nexport function extractModuleDefinition(\n  journey: IRJourney,\n  options: GenerateModuleOptions = {}\n): ModuleDefinition {\n  const { suffix = 'Page' } = options;\n\n  const moduleName = toPascalCase(journey.scope);\n  const className = `${moduleName}${suffix}`;\n  const locators = extractLocators(journey);\n  const methods = generateMethods(journey, locators);\n\n  return {\n    moduleName,\n    className,\n    scope: journey.scope,\n    locators,\n    methods,\n  };\n}\n","/**\n * AST-based Code Editing - Safely modify existing TypeScript files\n * @see research/2026-01-02_autogen-refined-plan.md Section 12\n */\nimport {\n  Project,\n  SourceFile,\n  ClassDeclaration,\n  MethodDeclaration,\n  PropertyDeclaration,\n  ImportDeclaration,\n  SyntaxKind,\n  ScriptTarget,\n  ModuleKind,\n} from 'ts-morph';\nimport type { ModuleLocator, ModuleMethod } from './generateModule.js';\n\n/**\n * Result of an AST edit operation\n */\nexport interface AstEditResult {\n  /** Whether any changes were made */\n  modified: boolean;\n  /** List of changes made */\n  changes: string[];\n  /** Updated source code */\n  code: string;\n  /** Any warnings generated */\n  warnings: string[];\n}\n\n/**\n * Options for AST editing\n */\nexport interface AstEditOptions {\n  /** Preserve existing methods (don't overwrite) */\n  preserveExisting?: boolean;\n  /** Add new imports automatically */\n  addImports?: boolean;\n  /** Format code after editing */\n  formatOutput?: boolean;\n}\n\n/**\n * Create a ts-morph project for editing\n */\nexport function createProject(): Project {\n  return new Project({\n    useInMemoryFileSystem: true,\n    compilerOptions: {\n      target: ScriptTarget.ESNext,\n      module: ModuleKind.ESNext,\n      strict: true,\n    },\n  });\n}\n\n/**\n * Load source file from code string\n */\nexport function loadSourceFile(project: Project, code: string, filename = 'temp.ts'): SourceFile {\n  return project.createSourceFile(filename, code, { overwrite: true });\n}\n\n/**\n * Find a class declaration by name\n */\nexport function findClass(sourceFile: SourceFile, className: string): ClassDeclaration | undefined {\n  return sourceFile.getClass(className);\n}\n\n/**\n * Find a method in a class\n */\nexport function findMethod(classDecl: ClassDeclaration, methodName: string): MethodDeclaration | undefined {\n  return classDecl.getMethod(methodName);\n}\n\n/**\n * Find a property in a class\n */\nexport function findProperty(classDecl: ClassDeclaration, propertyName: string): PropertyDeclaration | undefined {\n  return classDecl.getProperty(propertyName);\n}\n\n/**\n * Check if an import exists\n */\nexport function hasImport(sourceFile: SourceFile, moduleSpecifier: string): boolean {\n  return sourceFile.getImportDeclarations().some(\n    imp => imp.getModuleSpecifierValue() === moduleSpecifier\n  );\n}\n\n/**\n * Get import declaration for a module\n */\nexport function getImport(sourceFile: SourceFile, moduleSpecifier: string): ImportDeclaration | undefined {\n  return sourceFile.getImportDeclarations().find(\n    imp => imp.getModuleSpecifierValue() === moduleSpecifier\n  );\n}\n\n/**\n * Add a named import to a file\n */\nexport function addNamedImport(\n  sourceFile: SourceFile,\n  moduleSpecifier: string,\n  namedImport: string\n): boolean {\n  const existingImport = getImport(sourceFile, moduleSpecifier);\n\n  if (existingImport) {\n    // Check if the named import already exists\n    const namedImports = existingImport.getNamedImports();\n    const exists = namedImports.some(ni => ni.getName() === namedImport);\n\n    if (!exists) {\n      existingImport.addNamedImport(namedImport);\n      return true;\n    }\n    return false;\n  }\n\n  // Add new import declaration\n  sourceFile.addImportDeclaration({\n    moduleSpecifier,\n    namedImports: [namedImport],\n  });\n  return true;\n}\n\n/**\n * Result of adding a locator property\n */\nexport interface AddLocatorResult {\n  /** Whether the property was added */\n  added: boolean;\n  /** Whether initialization was complete */\n  initialized: boolean;\n  /** Warning message if initialization was incomplete */\n  warning?: string;\n}\n\n/**\n * Add a locator property to a class\n *\n * @returns Result object with added/initialized status and optional warning\n */\nexport function addLocatorProperty(\n  classDecl: ClassDeclaration,\n  locator: ModuleLocator,\n  options: AstEditOptions = {}\n): AddLocatorResult {\n  const existing = findProperty(classDecl, locator.name);\n\n  if (existing) {\n    if (options.preserveExisting) {\n      return { added: false, initialized: false };\n    }\n    existing.remove();\n  }\n\n  // Add readonly property declaration\n  classDecl.addProperty({\n    name: locator.name,\n    isReadonly: true,\n    type: 'Locator',\n    docs: locator.description ? [{ description: locator.description }] : undefined,\n  });\n\n  const initStatement = `this.${locator.name} = page.${locator.playwright};`;\n\n  // Find or create constructor\n  let constructor = classDecl.getConstructors()[0];\n  if (!constructor) {\n    // Create constructor with page parameter\n    constructor = classDecl.addConstructor({\n      parameters: [{ name: 'page', type: 'Page' }],\n      statements: [`this.page = page;`, initStatement],\n    });\n\n    // Add page property if it doesn't exist\n    if (!findProperty(classDecl, 'page')) {\n      classDecl.insertProperty(0, {\n        name: 'page',\n        isReadonly: true,\n        type: 'Page',\n      });\n    }\n\n    return { added: true, initialized: true };\n  }\n\n  // Ensure constructor has a body\n  let body = constructor.getBody();\n  if (!body) {\n    // Add empty body to constructor\n    constructor.setBodyText('');\n    body = constructor.getBody();\n    if (!body) {\n      return {\n        added: true,\n        initialized: false,\n        warning: `Cannot add body to constructor for '${locator.name}' initialization`,\n      };\n    }\n  }\n\n  // Check if initialization already exists\n  const existingInit = body.getDescendantsOfKind(SyntaxKind.ExpressionStatement)\n    .find(stmt => stmt.getText().includes(`this.${locator.name}`));\n\n  if (!existingInit) {\n    constructor.addStatements(initStatement);\n  }\n\n  return { added: true, initialized: true };\n}\n\n/**\n * Add a method to a class\n */\nexport function addMethod(\n  classDecl: ClassDeclaration,\n  method: ModuleMethod,\n  options: AstEditOptions = {}\n): boolean {\n  const existing = findMethod(classDecl, method.name);\n\n  if (existing) {\n    if (options.preserveExisting) {\n      return false;\n    }\n    existing.remove();\n  }\n\n  // Add the method\n  classDecl.addMethod({\n    name: method.name,\n    isAsync: true,\n    parameters: method.params.map(p => ({\n      name: p.name,\n      type: p.type,\n      hasQuestionToken: p.optional,\n      initializer: p.defaultValue,\n    })),\n    returnType: `Promise<${method.returnType}>`,\n    docs: [{ description: method.description }],\n    statements: method.body.join('\\n'),\n  });\n\n  return true;\n}\n\n/**\n * Update an existing module file with new locators and methods\n */\nexport function updateModuleFile(\n  code: string,\n  className: string,\n  locators: ModuleLocator[],\n  methods: ModuleMethod[],\n  options: AstEditOptions = {}\n): AstEditResult {\n  const project = createProject();\n  const sourceFile = loadSourceFile(project, code);\n  const changes: string[] = [];\n  const warnings: string[] = [];\n\n  // Find the class\n  const classDecl = findClass(sourceFile, className);\n  if (!classDecl) {\n    return {\n      modified: false,\n      changes: [],\n      code,\n      warnings: [`Class '${className}' not found in source file`],\n    };\n  }\n\n  // Ensure Locator import exists\n  if (options.addImports !== false) {\n    if (addNamedImport(sourceFile, '@playwright/test', 'Locator')) {\n      changes.push('Added Locator import');\n    }\n    if (addNamedImport(sourceFile, '@playwright/test', 'expect')) {\n      changes.push('Added expect import');\n    }\n  }\n\n  // Add locators\n  for (const locator of locators) {\n    const result = addLocatorProperty(classDecl, locator, options);\n    if (result.added) {\n      changes.push(`Added locator: ${locator.name}`);\n      if (result.warning) {\n        warnings.push(result.warning);\n      }\n    } else if (options.preserveExisting) {\n      warnings.push(`Skipped existing locator: ${locator.name}`);\n    }\n  }\n\n  // Add methods\n  for (const method of methods) {\n    const added = addMethod(classDecl, method, options);\n    if (added) {\n      changes.push(`Added method: ${method.name}`);\n    } else if (options.preserveExisting) {\n      warnings.push(`Skipped existing method: ${method.name}`);\n    }\n  }\n\n  // Format if requested\n  if (options.formatOutput !== false) {\n    sourceFile.formatText();\n  }\n\n  return {\n    modified: changes.length > 0,\n    changes,\n    code: sourceFile.getFullText(),\n    warnings,\n  };\n}\n\n/**\n * Extract method body text safely\n */\nfunction extractMethodBodyText(method: MethodDeclaration): string {\n  const body = method.getBody();\n  if (!body) return '';\n\n  // Get the text between { and }\n  const fullText = body.getText();\n  // Remove the braces and trim\n  const inner = fullText.slice(1, -1).trim();\n  return inner;\n}\n\n/**\n * Merge two module files, preferring the second for conflicts\n */\nexport function mergeModuleFiles(\n  existingCode: string,\n  newCode: string,\n  className: string,\n  options: AstEditOptions = {}\n): AstEditResult {\n  const project = createProject();\n  const existingFile = loadSourceFile(project, existingCode, 'existing.ts');\n  const newFile = loadSourceFile(project, newCode, 'new.ts');\n  const changes: string[] = [];\n  const warnings: string[] = [];\n\n  // Find classes\n  const existingClass = findClass(existingFile, className);\n  const newClass = findClass(newFile, className);\n\n  if (!existingClass) {\n    return {\n      modified: false,\n      changes: [],\n      code: existingCode,\n      warnings: [`Class '${className}' not found in existing file`],\n    };\n  }\n\n  if (!newClass) {\n    return {\n      modified: false,\n      changes: [],\n      code: existingCode,\n      warnings: [`Class '${className}' not found in new file`],\n    };\n  }\n\n  // Merge imports\n  const newImports = newFile.getImportDeclarations();\n  for (const imp of newImports) {\n    const moduleSpec = imp.getModuleSpecifierValue();\n    for (const namedImp of imp.getNamedImports()) {\n      if (addNamedImport(existingFile, moduleSpec, namedImp.getName())) {\n        changes.push(`Added import: ${namedImp.getName()} from ${moduleSpec}`);\n      }\n    }\n  }\n\n  // Merge properties\n  const newProperties = newClass.getProperties();\n  for (const prop of newProperties) {\n    const propName = prop.getName();\n    const existingProp = findProperty(existingClass, propName);\n\n    if (!existingProp) {\n      existingClass.addProperty({\n        name: propName,\n        isReadonly: prop.isReadonly(),\n        type: prop.getType().getText(),\n      });\n      changes.push(`Added property: ${propName}`);\n    } else if (!options.preserveExisting) {\n      existingProp.remove();\n      existingClass.addProperty({\n        name: propName,\n        isReadonly: prop.isReadonly(),\n        type: prop.getType().getText(),\n      });\n      changes.push(`Updated property: ${propName}`);\n    } else {\n      warnings.push(`Skipped existing property: ${propName}`);\n    }\n  }\n\n  // Merge methods\n  const newMethods = newClass.getMethods();\n  for (const method of newMethods) {\n    const methodName = method.getName();\n    const existingMethod = findMethod(existingClass, methodName);\n\n    if (!existingMethod) {\n      existingClass.addMethod({\n        name: methodName,\n        isAsync: method.isAsync(),\n        parameters: method.getParameters().map(p => ({\n          name: p.getName(),\n          type: p.getType().getText(),\n          hasQuestionToken: p.hasQuestionToken(),\n          initializer: p.getInitializer()?.getText(),\n        })),\n        returnType: method.getReturnType().getText(),\n        statements: extractMethodBodyText(method),\n      });\n      changes.push(`Added method: ${methodName}`);\n    } else if (!options.preserveExisting) {\n      existingMethod.remove();\n      existingClass.addMethod({\n        name: methodName,\n        isAsync: method.isAsync(),\n        parameters: method.getParameters().map(p => ({\n          name: p.getName(),\n          type: p.getType().getText(),\n          hasQuestionToken: p.hasQuestionToken(),\n          initializer: p.getInitializer()?.getText(),\n        })),\n        returnType: method.getReturnType().getText(),\n        statements: extractMethodBodyText(method),\n      });\n      changes.push(`Updated method: ${methodName}`);\n    } else {\n      warnings.push(`Skipped existing method: ${methodName}`);\n    }\n  }\n\n  // Format\n  if (options.formatOutput !== false) {\n    existingFile.formatText();\n  }\n\n  return {\n    modified: changes.length > 0,\n    changes,\n    code: existingFile.getFullText(),\n    warnings,\n  };\n}\n\n/**\n * Extract class structure from source code\n */\nexport function extractClassStructure(code: string, className: string): {\n  properties: string[];\n  methods: string[];\n  imports: string[];\n} | null {\n  const project = createProject();\n  const sourceFile = loadSourceFile(project, code);\n  const classDecl = findClass(sourceFile, className);\n\n  if (!classDecl) {\n    return null;\n  }\n\n  return {\n    properties: classDecl.getProperties().map(p => p.getName()),\n    methods: classDecl.getMethods().map(m => m.getName()),\n    imports: sourceFile.getImportDeclarations()\n      .flatMap(imp => imp.getNamedImports().map(ni => ni.getName())),\n  };\n}\n\n/**\n * Validate TypeScript code syntax\n */\nexport function validateSyntax(code: string): {\n  valid: boolean;\n  errors: string[];\n} {\n  const project = createProject();\n\n  try {\n    const sourceFile = loadSourceFile(project, code);\n    const diagnostics = sourceFile.getPreEmitDiagnostics();\n\n    const errors = diagnostics\n      .filter(d => d.getCategory() === 1) // Error category\n      .map(d => d.getMessageText().toString());\n\n    return {\n      valid: errors.length === 0,\n      errors,\n    };\n  } catch (error) {\n    return {\n      valid: false,\n      errors: [(error as Error).message],\n    };\n  }\n}\n","/**\n * Module Registry - Track and update module index files\n * @see research/2026-01-02_autogen-refined-plan.md Section 12\n */\nimport { readFileSync, writeFileSync, existsSync } from 'node:fs';\nimport { basename, dirname, relative } from 'node:path';\nimport { Project } from 'ts-morph';\nimport type { ModuleDefinition } from './generateModule.js';\n\n/**\n * Module registry entry\n */\nexport interface RegistryEntry {\n  /** Module name (PascalCase) */\n  moduleName: string;\n  /** Class name */\n  className: string;\n  /** File path relative to registry */\n  filePath: string;\n  /** Module scope */\n  scope: string;\n  /** Export type */\n  exportType: 'class' | 'function' | 'const';\n}\n\n/**\n * Module registry state\n */\nexport interface ModuleRegistry {\n  /** Registry file path */\n  registryPath: string;\n  /** Registered modules */\n  entries: RegistryEntry[];\n  /** Last updated timestamp */\n  lastUpdated: Date;\n}\n\n/**\n * Options for registry operations\n */\nexport interface RegistryOptions {\n  /** Create registry file if it doesn't exist */\n  createIfMissing?: boolean;\n  /** Preserve manual exports in index file */\n  preserveManualExports?: boolean;\n  /** Sort exports alphabetically */\n  sortExports?: boolean;\n}\n\n/**\n * Result of registry update\n */\nexport interface RegistryUpdateResult {\n  /** Whether the registry was modified */\n  modified: boolean;\n  /** Entries added */\n  added: string[];\n  /** Entries removed */\n  removed: string[];\n  /** Updated registry content */\n  content: string;\n}\n\n/**\n * Load module registry from an index file\n */\nexport function loadRegistry(indexPath: string): ModuleRegistry | null {\n  if (!existsSync(indexPath)) {\n    return null;\n  }\n\n  const content = readFileSync(indexPath, 'utf-8');\n  const entries = parseIndexFile(content, indexPath);\n\n  return {\n    registryPath: indexPath,\n    entries,\n    lastUpdated: new Date(),\n  };\n}\n\n/**\n * Parse an index.ts file to extract module entries\n */\nexport function parseIndexFile(content: string, _indexPath?: string): RegistryEntry[] {\n  const entries: RegistryEntry[] = [];\n  const project = new Project({ useInMemoryFileSystem: true });\n  const sourceFile = project.createSourceFile('index.ts', content);\n\n  // Parse export declarations\n  const exportDeclarations = sourceFile.getExportDeclarations();\n\n  for (const exportDecl of exportDeclarations) {\n    const moduleSpecifier = exportDecl.getModuleSpecifierValue();\n    if (!moduleSpecifier) continue;\n\n    const namedExports = exportDecl.getNamedExports();\n\n    for (const namedExport of namedExports) {\n      const exportName = namedExport.getName();\n      const aliasNode = namedExport.getAliasNode();\n      const alias = aliasNode ? aliasNode.getText() : exportName;\n\n      // Determine export type from name convention\n      let exportType: 'class' | 'function' | 'const' = 'class';\n      if (exportName.startsWith('create') || exportName.endsWith('Factory')) {\n        exportType = 'function';\n      } else if (exportName === exportName.toUpperCase()) {\n        exportType = 'const';\n      }\n\n      entries.push({\n        moduleName: alias,\n        className: exportName,\n        filePath: moduleSpecifier,\n        scope: extractScope(moduleSpecifier),\n        exportType,\n      });\n    }\n  }\n\n  // Parse re-exports (export * from './module')\n  const starExports = content.match(/export\\s+\\*\\s+from\\s+['\"]([^'\"]+)['\"]/g);\n  if (starExports) {\n    for (const match of starExports) {\n      const pathMatch = match.match(/['\"]([^'\"]+)['\"]/);\n      if (pathMatch) {\n        const modulePath = pathMatch[1]!;\n        entries.push({\n          moduleName: extractModuleName(modulePath),\n          className: '*',\n          filePath: modulePath,\n          scope: extractScope(modulePath),\n          exportType: 'class',\n        });\n      }\n    }\n  }\n\n  return entries;\n}\n\n/**\n * Extract module name from file path\n */\nfunction extractModuleName(filePath: string): string {\n  const base = basename(filePath, '.js').replace('.page', '');\n  return toPascalCase(base);\n}\n\n/**\n * Extract scope from file path\n */\nfunction extractScope(filePath: string): string {\n  // e.g., './auth/login.page.js' -> 'auth'\n  const dir = dirname(filePath);\n  if (dir === '.' || dir === './') {\n    return basename(filePath, '.js').replace('.page', '');\n  }\n  return basename(dir);\n}\n\n/**\n * Convert to PascalCase\n */\nfunction toPascalCase(str: string): string {\n  return str\n    .split(/[-_\\s]+/)\n    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n    .join('');\n}\n\n/**\n * Generate index file content from entries\n */\nexport function generateIndexContent(\n  entries: RegistryEntry[],\n  options: RegistryOptions = {}\n): string {\n  const lines: string[] = [\n    '/**',\n    ' * Module Registry - Auto-generated index',\n    ' * @generated by @artk/core-autogen',\n    ' */',\n  ];\n\n  // Group entries by file path\n  const byFile = new Map<string, RegistryEntry[]>();\n  for (const entry of entries) {\n    const existing = byFile.get(entry.filePath) || [];\n    existing.push(entry);\n    byFile.set(entry.filePath, existing);\n  }\n\n  // Sort if requested\n  let filePaths = Array.from(byFile.keys());\n  if (options.sortExports) {\n    filePaths = filePaths.sort();\n  }\n\n  // Generate exports\n  for (const filePath of filePaths) {\n    const fileEntries = byFile.get(filePath)!;\n\n    // Check if it's a star export\n    if (fileEntries.length === 1 && fileEntries[0]!.className === '*') {\n      lines.push(`export * from '${filePath}';`);\n    } else {\n      // Named exports\n      const exports = fileEntries.map(e => {\n        if (e.moduleName !== e.className) {\n          return `${e.className} as ${e.moduleName}`;\n        }\n        return e.className;\n      });\n\n      if (options.sortExports) {\n        exports.sort();\n      }\n\n      lines.push(`export { ${exports.join(', ')} } from '${filePath}';`);\n    }\n  }\n\n  return lines.join('\\n') + '\\n';\n}\n\n/**\n * Add a module to the registry\n */\nexport function addToRegistry(\n  registry: ModuleRegistry,\n  module: ModuleDefinition,\n  filePath: string\n): RegistryEntry {\n  const entry: RegistryEntry = {\n    moduleName: module.moduleName,\n    className: module.className,\n    filePath,\n    scope: module.scope,\n    exportType: 'class',\n  };\n\n  // Check if already exists\n  const existingIndex = registry.entries.findIndex(\n    e => e.filePath === filePath || e.moduleName === module.moduleName\n  );\n\n  if (existingIndex >= 0) {\n    registry.entries[existingIndex] = entry;\n  } else {\n    registry.entries.push(entry);\n  }\n\n  registry.lastUpdated = new Date();\n  return entry;\n}\n\n/**\n * Remove a module from the registry\n */\nexport function removeFromRegistry(\n  registry: ModuleRegistry,\n  moduleNameOrPath: string\n): boolean {\n  const initialLength = registry.entries.length;\n\n  registry.entries = registry.entries.filter(\n    e => e.moduleName !== moduleNameOrPath && e.filePath !== moduleNameOrPath\n  );\n\n  const removed = registry.entries.length < initialLength;\n  if (removed) {\n    registry.lastUpdated = new Date();\n  }\n\n  return removed;\n}\n\n/**\n * Update index file with new modules\n */\nexport function updateIndexFile(\n  indexPath: string,\n  newModules: Array<{ module: ModuleDefinition; filePath: string }>,\n  options: RegistryOptions = {}\n): RegistryUpdateResult {\n  let registry = loadRegistry(indexPath);\n  const added: string[] = [];\n  const removed: string[] = [];\n\n  if (!registry) {\n    if (!options.createIfMissing) {\n      return {\n        modified: false,\n        added: [],\n        removed: [],\n        content: '',\n      };\n    }\n\n    registry = {\n      registryPath: indexPath,\n      entries: [],\n      lastUpdated: new Date(),\n    };\n  }\n\n  // Track existing entries if preserving\n  const existingNames = new Set(registry.entries.map(e => e.moduleName));\n\n  // Add new modules\n  for (const { module, filePath } of newModules) {\n    const relativePath = filePath.startsWith('.')\n      ? filePath\n      : `./${relative(dirname(indexPath), filePath).replace(/\\\\/g, '/')}`;\n\n    // Remove .ts extension and add .js for ESM\n    const importPath = relativePath.replace(/\\.ts$/, '.js');\n\n    addToRegistry(registry, module, importPath);\n\n    if (!existingNames.has(module.moduleName)) {\n      added.push(module.moduleName);\n    }\n  }\n\n  // Generate updated content\n  const content = generateIndexContent(registry.entries, options);\n\n  return {\n    modified: added.length > 0 || removed.length > 0,\n    added,\n    removed,\n    content,\n  };\n}\n\n/**\n * Scan directory for module files and build registry\n */\nexport function scanModulesDirectory(\n  _dirPath: string,\n  _pattern = '*.page.ts'\n): RegistryEntry[] {\n  // This is a simplified implementation\n  // In production, would use glob to find files\n  // For now, return empty array - actual scanning happens via glob in CLI\n  return [];\n}\n\n/**\n * Create a new empty registry\n */\nexport function createRegistry(indexPath: string): ModuleRegistry {\n  return {\n    registryPath: indexPath,\n    entries: [],\n    lastUpdated: new Date(),\n  };\n}\n\n/**\n * Save registry to disk\n */\nexport function saveRegistry(\n  registry: ModuleRegistry,\n  options: RegistryOptions = {}\n): void {\n  const content = generateIndexContent(registry.entries, options);\n  writeFileSync(registry.registryPath, content, 'utf-8');\n}\n\n/**\n * Find entry by module name\n */\nexport function findEntry(\n  registry: ModuleRegistry,\n  moduleName: string\n): RegistryEntry | undefined {\n  return registry.entries.find(e => e.moduleName === moduleName);\n}\n\n/**\n * Find entry by scope\n */\nexport function findEntriesByScope(\n  registry: ModuleRegistry,\n  scope: string\n): RegistryEntry[] {\n  return registry.entries.filter(e => e.scope === scope);\n}\n\n/**\n * Check if module exists in registry\n */\nexport function hasModule(registry: ModuleRegistry, moduleName: string): boolean {\n  return registry.entries.some(e => e.moduleName === moduleName);\n}\n\n/**\n * Get all module names\n */\nexport function getModuleNames(registry: ModuleRegistry): string[] {\n  return registry.entries.map(e => e.moduleName);\n}\n\n/**\n * Get registry statistics\n */\nexport function getRegistryStats(registry: ModuleRegistry): {\n  totalModules: number;\n  byScope: Record<string, number>;\n  byType: Record<string, number>;\n} {\n  const byScope: Record<string, number> = {};\n  const byType: Record<string, number> = {};\n\n  for (const entry of registry.entries) {\n    byScope[entry.scope] = (byScope[entry.scope] || 0) + 1;\n    byType[entry.exportType] = (byType[entry.exportType] || 0) + 1;\n  }\n\n  return {\n    totalModules: registry.entries.length,\n    byScope,\n    byType,\n  };\n}\n","/**\n * Safe parsing utilities for CLI arguments and configuration values\n *\n * These utilities prevent common issues with parseInt/parseFloat:\n * - NaN propagation from invalid input\n * - Silent failures from unexpected input types\n * - Negative values where only positive are expected\n *\n * @see research/2026-01-15_code_quality_standards.md Category 4\n */\n\n/**\n * Parse integer with validation and fallback\n *\n * @param value - String value to parse (or undefined)\n * @param name - Option name for error messages\n * @param defaultValue - Default value if parsing fails\n * @returns Parsed integer or default value\n *\n * @example\n * ```typescript\n * // Basic usage\n * const timeout = parseIntSafe(args.timeout, 'timeout', 30000);\n *\n * // Handles invalid input gracefully\n * parseIntSafe('abc', 'count', 10); // Returns 10, logs warning\n * parseIntSafe('-5', 'count', 10);  // Returns 10, logs warning\n * parseIntSafe(undefined, 'count', 10); // Returns 10, no warning\n * ```\n */\nexport function parseIntSafe(\n  value: string | undefined,\n  name: string,\n  defaultValue: number\n): number {\n  if (value === undefined) {\n    return defaultValue;\n  }\n\n  // Use Number() instead of parseInt() to reject partial matches like \"42px\"\n  const trimmed = value.trim();\n  const parsed = Number(trimmed);\n\n  if (!Number.isInteger(parsed) || trimmed === '') {\n    console.warn(\n      `Warning: Invalid value '${value}' for --${name}, using default: ${defaultValue}`\n    );\n    return defaultValue;\n  }\n\n  if (parsed < 0) {\n    console.warn(\n      `Warning: Negative value '${value}' for --${name}, using default: ${defaultValue}`\n    );\n    return defaultValue;\n  }\n\n  return parsed;\n}\n\n/**\n * Parse integer allowing negative values\n *\n * @param value - String value to parse (or undefined)\n * @param name - Option name for error messages\n * @param defaultValue - Default value if parsing fails\n * @returns Parsed integer or default value\n */\nexport function parseIntSafeAllowNegative(\n  value: string | undefined,\n  name: string,\n  defaultValue: number\n): number {\n  if (value === undefined) {\n    return defaultValue;\n  }\n\n  // Use Number() instead of parseInt() to reject partial matches like \"42px\"\n  const trimmed = value.trim();\n  const parsed = Number(trimmed);\n\n  if (!Number.isInteger(parsed) || trimmed === '') {\n    console.warn(\n      `Warning: Invalid value '${value}' for --${name}, using default: ${defaultValue}`\n    );\n    return defaultValue;\n  }\n\n  return parsed;\n}\n\n/**\n * Parse float with validation and fallback\n *\n * @param value - String value to parse (or undefined)\n * @param name - Option name for error messages\n * @param defaultValue - Default value if parsing fails\n * @returns Parsed float or default value\n *\n * @example\n * ```typescript\n * const threshold = parseFloatSafe(args.threshold, 'threshold', 0.1);\n * ```\n */\nexport function parseFloatSafe(\n  value: string | undefined,\n  name: string,\n  defaultValue: number\n): number {\n  if (value === undefined) {\n    return defaultValue;\n  }\n\n  // Use Number() instead of parseFloat() to reject partial matches like \"3.14abc\"\n  const trimmed = value.trim();\n  const parsed = Number(trimmed);\n\n  if (isNaN(parsed) || trimmed === '') {\n    console.warn(\n      `Warning: Invalid value '${value}' for --${name}, using default: ${defaultValue}`\n    );\n    return defaultValue;\n  }\n\n  if (parsed < 0) {\n    console.warn(\n      `Warning: Negative value '${value}' for --${name}, using default: ${defaultValue}`\n    );\n    return defaultValue;\n  }\n\n  return parsed;\n}\n\n/**\n * Parse boolean from string with common truthy/falsy values\n *\n * @param value - String value to parse (or undefined)\n * @param defaultValue - Default value if parsing fails\n * @returns Parsed boolean or default value\n *\n * @example\n * ```typescript\n * parseBoolSafe('true', false);  // Returns true\n * parseBoolSafe('yes', false);   // Returns true\n * parseBoolSafe('1', false);     // Returns true\n * parseBoolSafe('false', true);  // Returns false\n * parseBoolSafe('no', true);     // Returns false\n * parseBoolSafe('0', true);      // Returns false\n * parseBoolSafe('invalid', true); // Returns true (default)\n * ```\n */\nexport function parseBoolSafe(\n  value: string | undefined,\n  defaultValue: boolean\n): boolean {\n  if (value === undefined) {\n    return defaultValue;\n  }\n\n  const normalized = value.toLowerCase().trim();\n\n  if (['true', 'yes', '1', 'on'].includes(normalized)) {\n    return true;\n  }\n\n  if (['false', 'no', '0', 'off'].includes(normalized)) {\n    return false;\n  }\n\n  return defaultValue;\n}\n\n/**\n * Parse enum value with validation\n *\n * @param value - String value to parse (or undefined)\n * @param validValues - Array of valid enum values\n * @param name - Option name for error messages\n * @param defaultValue - Default value if parsing fails\n * @returns Parsed enum value or default value\n *\n * @example\n * ```typescript\n * type LogLevel = 'debug' | 'info' | 'warn' | 'error';\n * const level = parseEnumSafe<LogLevel>(\n *   args.level,\n *   ['debug', 'info', 'warn', 'error'],\n *   'level',\n *   'info'\n * );\n * ```\n */\nexport function parseEnumSafe<T extends string>(\n  value: string | undefined,\n  validValues: readonly T[],\n  name: string,\n  defaultValue: T\n): T {\n  if (value === undefined) {\n    return defaultValue;\n  }\n\n  const trimmed = value.trim();\n\n  // Case-insensitive matching: find the valid value that matches\n  const match = validValues.find(\n    v => v.toLowerCase() === trimmed.toLowerCase()\n  );\n\n  if (match !== undefined) {\n    return match; // Return the actual valid value, not the input\n  }\n\n  console.warn(\n    `Warning: Invalid value '${value}' for --${name}, valid values are: ${validValues.join(', ')}. Using default: ${defaultValue}`\n  );\n  return defaultValue;\n}\n\n/**\n * Parse a value with a custom parser function\n *\n * @param value - String value to parse (or undefined)\n * @param parser - Custom parser function\n * @param name - Option name for error messages\n * @param defaultValue - Default value if parsing fails\n * @returns Parsed value or default value\n *\n * @example\n * ```typescript\n * const date = parseWithValidator(\n *   args.date,\n *   (v) => new Date(v),\n *   (d) => !isNaN(d.getTime()),\n *   'date',\n *   new Date()\n * );\n * ```\n */\nexport function parseWithValidator<T>(\n  value: string | undefined,\n  parser: (_value: string) => T,\n  validator: (_parsed: T) => boolean,\n  name: string,\n  defaultValue: T\n): T {\n  if (value === undefined) {\n    return defaultValue;\n  }\n\n  try {\n    const parsed = parser(value);\n    if (validator(parsed)) {\n      return parsed;\n    }\n    console.warn(\n      `Warning: Invalid value '${value}' for --${name}, using default`\n    );\n    return defaultValue;\n  } catch {\n    console.warn(\n      `Warning: Failed to parse '${value}' for --${name}, using default`\n    );\n    return defaultValue;\n  }\n}\n","/**\n * Journey Schema Validation - Validate Journey frontmatter before code generation\n * @see T039 - Journey schema validation (status=clarified check)\n */\nimport type { JourneyFrontmatter } from '../journey/parseJourney.js';\nimport { JourneyFrontmatterSchema, JourneyStatus } from '../journey/parseJourney.js';\n\n/**\n * Validation issue severity\n */\nexport type ValidationSeverity = 'error' | 'warning' | 'info';\n\n/**\n * A single validation issue\n */\nexport interface ValidationIssue {\n  /** Unique code for the issue */\n  code: string;\n  /** Human-readable message */\n  message: string;\n  /** Severity level */\n  severity: ValidationSeverity;\n  /** Field that has the issue, if applicable */\n  field?: string;\n  /** Suggested fix, if available */\n  suggestion?: string;\n}\n\n/**\n * Result of journey validation\n */\nexport interface JourneyValidationResult {\n  /** Whether the journey is valid for code generation */\n  valid: boolean;\n  /** Journey ID from frontmatter */\n  journeyId: string;\n  /** List of validation issues */\n  issues: ValidationIssue[];\n  /** Counts by severity */\n  counts: {\n    errors: number;\n    warnings: number;\n    info: number;\n  };\n}\n\n/**\n * Options for journey validation\n */\nexport interface JourneyValidationOptions {\n  /** Whether to allow draft journeys (status other than clarified) */\n  allowDrafts?: boolean;\n  /** Required tags that must be present */\n  requiredTags?: string[];\n  /** Valid tiers */\n  validTiers?: string[];\n  /** Warn if journey has no acceptance criteria */\n  warnEmptyAC?: boolean;\n}\n\nconst DEFAULT_OPTIONS: JourneyValidationOptions = {\n  allowDrafts: false,\n  requiredTags: [],\n  validTiers: ['smoke', 'release', 'regression'],\n  warnEmptyAC: true,\n};\n\n/**\n * Validate journey frontmatter schema\n */\nexport function validateJourneySchema(\n  frontmatter: unknown\n): { valid: boolean; issues: ValidationIssue[] } {\n  const result = JourneyFrontmatterSchema.safeParse(frontmatter);\n  const issues: ValidationIssue[] = [];\n\n  if (!result.success) {\n    for (const error of result.error.errors) {\n      issues.push({\n        code: 'SCHEMA_INVALID',\n        message: `${error.path.join('.')}: ${error.message}`,\n        severity: 'error',\n        field: error.path.join('.'),\n      });\n    }\n  }\n\n  return { valid: result.success, issues };\n}\n\n/**\n * Validate journey status is appropriate for code generation\n */\nexport function validateJourneyStatus(\n  status: JourneyStatus,\n  options: JourneyValidationOptions = {}\n): ValidationIssue[] {\n  const { allowDrafts = false } = options;\n  const issues: ValidationIssue[] = [];\n\n  // Code generation requires 'clarified' status\n  const validStatuses: JourneyStatus[] = ['clarified', 'implemented'];\n\n  if (!validStatuses.includes(status)) {\n    if (allowDrafts) {\n      issues.push({\n        code: 'STATUS_NOT_READY',\n        message: `Journey status is '${status}', ideally should be 'clarified' for code generation`,\n        severity: 'warning',\n        field: 'status',\n        suggestion: 'Run /journey-clarify to add execution details',\n      });\n    } else {\n      issues.push({\n        code: 'STATUS_NOT_CLARIFIED',\n        message: `Journey status is '${status}', must be 'clarified' for code generation`,\n        severity: 'error',\n        field: 'status',\n        suggestion: 'Run /journey-clarify to add execution details',\n      });\n    }\n  }\n\n  // Warn about quarantined or deprecated\n  if (status === 'quarantined') {\n    issues.push({\n      code: 'STATUS_QUARANTINED',\n      message: 'Journey is quarantined - tests are disabled',\n      severity: 'warning',\n      field: 'status',\n    });\n  }\n\n  if (status === 'deprecated') {\n    issues.push({\n      code: 'STATUS_DEPRECATED',\n      message: 'Journey is deprecated - consider removing',\n      severity: 'warning',\n      field: 'status',\n    });\n  }\n\n  return issues;\n}\n\n/**\n * Validate journey tier is valid\n */\nexport function validateJourneyTier(\n  tier: string,\n  options: JourneyValidationOptions = {}\n): ValidationIssue[] {\n  const { validTiers = ['smoke', 'release', 'regression'] } = options;\n  const issues: ValidationIssue[] = [];\n\n  if (!validTiers.includes(tier)) {\n    issues.push({\n      code: 'TIER_INVALID',\n      message: `Invalid tier '${tier}', expected one of: ${validTiers.join(', ')}`,\n      severity: 'error',\n      field: 'tier',\n    });\n  }\n\n  return issues;\n}\n\n/**\n * Validate journey has required tags\n */\nexport function validateJourneyTags(\n  tags: string[],\n  journeyId: string,\n  options: JourneyValidationOptions = {}\n): ValidationIssue[] {\n  const { requiredTags = [] } = options;\n  const issues: ValidationIssue[] = [];\n\n  // Check for journey ID tag\n  const idTag = `@${journeyId}`;\n  if (!tags.includes(idTag)) {\n    issues.push({\n      code: 'TAG_MISSING_ID',\n      message: `Journey should have ID tag '${idTag}'`,\n      severity: 'warning',\n      field: 'tags',\n      suggestion: `Add '${idTag}' to tags array`,\n    });\n  }\n\n  // Check for required tags\n  for (const requiredTag of requiredTags) {\n    if (!tags.includes(requiredTag)) {\n      issues.push({\n        code: 'TAG_MISSING_REQUIRED',\n        message: `Missing required tag '${requiredTag}'`,\n        severity: 'error',\n        field: 'tags',\n        suggestion: `Add '${requiredTag}' to tags array`,\n      });\n    }\n  }\n\n  return issues;\n}\n\n/**\n * Validate journey frontmatter for code generation\n */\nexport function validateJourneyFrontmatter(\n  frontmatter: JourneyFrontmatter,\n  options: JourneyValidationOptions = {}\n): JourneyValidationResult {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n  const issues: ValidationIssue[] = [];\n\n  // Schema validation\n  const schemaResult = validateJourneySchema(frontmatter);\n  issues.push(...schemaResult.issues);\n\n  // Status validation\n  issues.push(...validateJourneyStatus(frontmatter.status, opts));\n\n  // Tier validation\n  issues.push(...validateJourneyTier(frontmatter.tier, opts));\n\n  // Tags validation\n  issues.push(...validateJourneyTags(frontmatter.tags || [], frontmatter.id, opts));\n\n  // Check for actor\n  if (!frontmatter.actor) {\n    issues.push({\n      code: 'ACTOR_MISSING',\n      message: 'Journey should specify an actor (user role)',\n      severity: 'warning',\n      field: 'actor',\n    });\n  }\n\n  // Check for scope\n  if (!frontmatter.scope) {\n    issues.push({\n      code: 'SCOPE_MISSING',\n      message: 'Journey should specify a scope (feature area)',\n      severity: 'warning',\n      field: 'scope',\n    });\n  }\n\n  // Calculate counts\n  const counts = {\n    errors: issues.filter((i) => i.severity === 'error').length,\n    warnings: issues.filter((i) => i.severity === 'warning').length,\n    info: issues.filter((i) => i.severity === 'info').length,\n  };\n\n  return {\n    valid: counts.errors === 0,\n    journeyId: frontmatter.id,\n    issues,\n    counts,\n  };\n}\n\n/**\n * Quick check if journey is ready for code generation\n */\nexport function isJourneyReady(frontmatter: JourneyFrontmatter): boolean {\n  const result = validateJourneyFrontmatter(frontmatter, { allowDrafts: false });\n  return result.valid;\n}\n","/**\n * Forbidden Pattern Scanner - Detect anti-patterns in generated test code\n * @see T040 - Forbidden pattern scanner (waitForTimeout, force:true, etc.)\n */\nimport type { ValidationIssue, ValidationSeverity } from './journey.js';\n\n/**\n * A forbidden pattern definition\n */\nexport interface ForbiddenPattern {\n  /** Unique identifier */\n  id: string;\n  /** Pattern name */\n  name: string;\n  /** Regex to match the pattern */\n  regex: RegExp;\n  /** Severity of the issue */\n  severity: ValidationSeverity;\n  /** Why this pattern is forbidden */\n  reason: string;\n  /** Suggested alternative */\n  suggestion: string;\n  /** Whether to allow in specific contexts (e.g., setup/cleanup) */\n  allowedContexts?: string[];\n}\n\n/**\n * Result of pattern scanning\n */\nexport interface PatternScanResult {\n  /** Line number (1-based) */\n  line: number;\n  /** Column number (1-based) */\n  column: number;\n  /** The matched text */\n  match: string;\n  /** The full line content */\n  lineContent: string;\n  /** The pattern that was violated */\n  pattern: ForbiddenPattern;\n}\n\n/**\n * Forbidden patterns that indicate flaky or brittle tests\n */\nexport const FORBIDDEN_PATTERNS: ForbiddenPattern[] = [\n  {\n    id: 'WAIT_TIMEOUT',\n    name: 'waitForTimeout',\n    regex: /\\bpage\\.waitForTimeout\\s*\\(\\s*\\d+\\s*\\)/g,\n    severity: 'error',\n    reason: 'Hard-coded waits cause flakiness and slow down tests',\n    suggestion: 'Use waitForSelector, waitForLoadState, or assertion auto-wait',\n  },\n  {\n    id: 'WAIT_ARBITRARY',\n    name: 'arbitrary-wait',\n    regex: /\\bawait\\s+new\\s+Promise\\s*\\(\\s*(?:resolve|r)\\s*=>\\s*setTimeout/g,\n    severity: 'error',\n    reason: 'Custom setTimeout-based waits cause flakiness',\n    suggestion: 'Use Playwright auto-wait assertions instead',\n  },\n  {\n    id: 'FORCE_CLICK',\n    name: 'force-click',\n    regex: /\\.click\\s*\\([^)]*\\{\\s*force\\s*:\\s*true/g,\n    severity: 'warning',\n    reason: 'Force clicking bypasses visibility checks and masks issues',\n    suggestion: 'Ensure element is visible and actionable, or use scrollIntoView',\n  },\n  {\n    id: 'FORCE_FILL',\n    name: 'force-fill',\n    regex: /\\.fill\\s*\\(\\s*[^,]+,\\s*\\{\\s*force\\s*:\\s*true/g,\n    severity: 'warning',\n    reason: 'Force filling bypasses visibility checks',\n    suggestion: 'Ensure input is visible and enabled',\n  },\n  {\n    id: 'CSS_SELECTOR_CLASS',\n    name: 'css-class-selector',\n    regex: /(?:page|locator)\\s*\\.\\s*(?:locator|querySelector)\\s*\\(\\s*['\"][^'\"]*\\.[a-z][a-z0-9_-]*(?:\\s|['\">\\[])/gi,\n    severity: 'warning',\n    reason: 'CSS class selectors are fragile and may change',\n    suggestion: 'Use role, label, placeholder, text, or testid locators',\n  },\n  {\n    id: 'CSS_SELECTOR_TAG',\n    name: 'css-tag-selector',\n    regex: /(?:page|locator)\\s*\\.\\s*locator\\s*\\(\\s*['\"](?:div|span|p|h[1-6]|section|header|footer|main|nav|aside|article)(?:\\s*>|\\s*\\[|['\"])/gi,\n    severity: 'warning',\n    reason: 'Generic tag selectors are too broad and fragile',\n    suggestion: 'Use more specific selectors like role, label, or testid',\n  },\n  {\n    id: 'XPATH_SELECTOR',\n    name: 'xpath-selector',\n    regex: /(?:page|locator)\\s*\\.\\s*locator\\s*\\(\\s*['\"]\\/\\/[^'\"]+['\"]/g,\n    severity: 'warning',\n    reason: 'XPath selectors are verbose and often fragile',\n    suggestion: 'Use role, label, or testid locators instead',\n  },\n  {\n    id: 'NTH_CHILD',\n    name: 'nth-child-selector',\n    regex: /:nth-child\\s*\\(\\s*\\d+\\s*\\)/g,\n    severity: 'warning',\n    reason: 'nth-child selectors break when DOM order changes',\n    suggestion: 'Use unique identifiers like testid or text content',\n  },\n  {\n    id: 'INDEX_LOCATOR',\n    name: 'index-based-locator',\n    regex: /\\.(?:first|last|nth)\\s*\\(\\s*(?:\\d+)?\\s*\\)/g,\n    severity: 'info',\n    reason: 'Index-based locators may break when list order changes',\n    suggestion: 'Consider filtering by unique content or attributes',\n  },\n  {\n    id: 'HARDCODED_URL',\n    name: 'hardcoded-url',\n    regex: /\\bpage\\.goto\\s*\\(\\s*['\"]https?:\\/\\/[^'\"]+['\"]/g,\n    severity: 'warning',\n    reason: 'Hardcoded URLs make tests environment-specific',\n    suggestion: 'Use baseURL from config or relative paths',\n  },\n  {\n    id: 'HARDCODED_CREDENTIALS',\n    name: 'hardcoded-credentials',\n    regex: /(?:password|secret|apikey|api_key|token)\\s*[=:]\\s*['\"][^'\"]+['\"]/gi,\n    severity: 'error',\n    reason: 'Credentials should not be hardcoded in test files',\n    suggestion: 'Use environment variables or secure config',\n  },\n  {\n    id: 'CONSOLE_LOG',\n    name: 'console-log',\n    regex: /\\bconsole\\.(log|info|warn|error)\\s*\\(/g,\n    severity: 'info',\n    reason: 'Console statements should be removed from production tests',\n    suggestion: 'Use test reporter or remove debug statements',\n  },\n  {\n    id: 'MISSING_AWAIT',\n    name: 'missing-await-locator',\n    regex: /(?<!await\\s+)page\\.(?:click|fill|type|check|uncheck|selectOption|press|hover|focus)\\s*\\(/g,\n    severity: 'error',\n    reason: 'Playwright actions must be awaited',\n    suggestion: 'Add await before the action',\n  },\n  {\n    id: 'SKIP_TEST',\n    name: 'test-skip',\n    regex: /\\btest\\.skip\\s*\\(/g,\n    severity: 'info',\n    reason: 'Skipped tests may be forgotten',\n    suggestion: 'Remove skip or convert to fixme with issue link',\n  },\n  {\n    id: 'TEST_ONLY',\n    name: 'test-only',\n    regex: /\\btest\\.only\\s*\\(/g,\n    severity: 'error',\n    reason: 'test.only excludes all other tests',\n    suggestion: 'Remove .only before committing',\n  },\n  {\n    id: 'ELEMENT_HANDLE',\n    name: 'element-handle',\n    regex: /\\.\\$\\s*\\(|\\.\\$\\$\\s*\\(/g,\n    severity: 'warning',\n    reason: 'ElementHandle is deprecated, use locators instead',\n    suggestion: 'Use page.locator() instead of page.$() or page.$$()',\n  },\n  {\n    id: 'EVAL_SELECTOR',\n    name: 'eval-selector',\n    regex: /\\.\\$eval\\s*\\(|\\.\\$\\$eval\\s*\\(/g,\n    severity: 'warning',\n    reason: 'eval methods are fragile and hard to debug',\n    suggestion: 'Use locator methods like textContent(), getAttribute()',\n  },\n  {\n    id: 'SLEEP_IMPORT',\n    name: 'sleep-import',\n    regex: /import\\s*\\{[^}]*sleep[^}]*\\}|require\\s*\\(['\"'][^'\"]*sleep/gi,\n    severity: 'warning',\n    reason: 'Sleep utilities encourage flaky tests',\n    suggestion: 'Use Playwright auto-wait mechanisms',\n  },\n];\n\n/**\n * Scan code for forbidden patterns\n */\nexport function scanForbiddenPatterns(\n  code: string,\n  patterns: ForbiddenPattern[] = FORBIDDEN_PATTERNS\n): PatternScanResult[] {\n  const results: PatternScanResult[] = [];\n  const lines = code.split('\\n');\n\n  for (const pattern of patterns) {\n    // Reset regex state for global patterns\n    pattern.regex.lastIndex = 0;\n\n    for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {\n      const line = lines[lineIndex]!;\n      let match: RegExpExecArray | null;\n\n      // Clone regex to avoid state issues with global flag\n      const regex = new RegExp(pattern.regex.source, pattern.regex.flags);\n\n      while ((match = regex.exec(line)) !== null) {\n        results.push({\n          line: lineIndex + 1,\n          column: match.index + 1,\n          match: match[0]!,\n          lineContent: line!.trim(),\n          pattern,\n        });\n\n        // Prevent infinite loop for zero-length matches\n        if (match.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n      }\n    }\n  }\n\n  // Sort by line number, then column\n  results.sort((a, b) => a.line - b.line || a.column - b.column);\n\n  return results;\n}\n\n/**\n * Convert scan results to validation issues\n */\nexport function scanResultsToIssues(results: PatternScanResult[]): ValidationIssue[] {\n  return results.map((result) => ({\n    code: result.pattern.id,\n    message: `Line ${result.line}: ${result.pattern.name} - ${result.pattern.reason}`,\n    severity: result.pattern.severity,\n    suggestion: result.pattern.suggestion,\n  }));\n}\n\n/**\n * Get pattern statistics\n */\nexport function getPatternStats(\n  results: PatternScanResult[]\n): Record<string, number> {\n  const stats: Record<string, number> = {};\n\n  for (const result of results) {\n    stats[result.pattern.id] = (stats[result.pattern.id] || 0) + 1;\n  }\n\n  return stats;\n}\n\n/**\n * Check if code has any error-level violations\n */\nexport function hasErrorViolations(results: PatternScanResult[]): boolean {\n  return results.some((r) => r.pattern.severity === 'error');\n}\n\n/**\n * Filter results by severity\n */\nexport function filterBySeverity(\n  results: PatternScanResult[],\n  severity: ValidationSeverity\n): PatternScanResult[] {\n  return results.filter((r) => r.pattern.severity === severity);\n}\n\n/**\n * Get a summary of violations by category\n */\nexport function getViolationSummary(results: PatternScanResult[]): {\n  total: number;\n  errors: number;\n  warnings: number;\n  info: number;\n  byPattern: Record<string, number>;\n} {\n  return {\n    total: results.length,\n    errors: filterBySeverity(results, 'error').length,\n    warnings: filterBySeverity(results, 'warning').length,\n    info: filterBySeverity(results, 'info').length,\n    byPattern: getPatternStats(results),\n  };\n}\n","/**\n * ESLint Integration - Run ESLint with Playwright plugin rules\n * @see T041 - ESLint integration with eslint-plugin-playwright\n */\nimport { execSync } from 'node:child_process';\nimport { existsSync, writeFileSync, unlinkSync, mkdirSync } from 'node:fs';\nimport { join, dirname } from 'node:path';\nimport { tmpdir } from 'node:os';\nimport type { ValidationIssue, ValidationSeverity } from './journey.js';\n\n/**\n * ESLint message from JSON output\n */\ninterface ESLintMessage {\n  ruleId: string | null;\n  severity: 1 | 2; // 1 = warning, 2 = error\n  message: string;\n  line: number;\n  column: number;\n  endLine?: number;\n  endColumn?: number;\n  fix?: {\n    range: [number, number];\n    text: string;\n  };\n}\n\n/**\n * ESLint file result from JSON output\n */\ninterface ESLintFileResult {\n  filePath: string;\n  messages: ESLintMessage[];\n  errorCount: number;\n  warningCount: number;\n  fixableErrorCount: number;\n  fixableWarningCount: number;\n  source?: string;\n}\n\n/**\n * Result of linting code\n */\nexport interface LintResult {\n  /** Whether linting passed (no errors) */\n  passed: boolean;\n  /** ESLint output */\n  output: string;\n  /** Parsed issues */\n  issues: ValidationIssue[];\n  /** Error count */\n  errorCount: number;\n  /** Warning count */\n  warningCount: number;\n}\n\n/**\n * Options for ESLint\n */\nexport interface LintOptions {\n  /** Additional ESLint rules to enable */\n  rules?: Record<string, unknown>;\n  /** Whether to fix auto-fixable issues */\n  fix?: boolean;\n  /** Custom ESLint config path */\n  configPath?: string;\n  /** Working directory */\n  cwd?: string;\n}\n\n/**\n * Default Playwright ESLint rules\n */\nexport const PLAYWRIGHT_LINT_RULES: Record<string, unknown> = {\n  // Playwright plugin rules\n  'playwright/missing-playwright-await': 'error',\n  'playwright/no-conditional-in-test': 'warn',\n  'playwright/no-element-handle': 'error',\n  'playwright/no-eval': 'error',\n  'playwright/no-focused-test': 'error',\n  'playwright/no-force-option': 'warn',\n  'playwright/no-nested-step': 'warn',\n  'playwright/no-networkidle': 'warn',\n  'playwright/no-page-pause': 'error',\n  'playwright/no-skipped-test': 'warn',\n  'playwright/no-useless-await': 'warn',\n  'playwright/no-useless-not': 'warn',\n  'playwright/no-wait-for-timeout': 'error',\n  'playwright/prefer-lowercase-title': 'off',\n  'playwright/prefer-strict-equal': 'warn',\n  'playwright/prefer-to-be': 'warn',\n  'playwright/prefer-to-contain': 'warn',\n  'playwright/prefer-to-have-count': 'warn',\n  'playwright/prefer-to-have-length': 'warn',\n  'playwright/prefer-web-first-assertions': 'error',\n  'playwright/require-soft-assertions': 'off',\n  'playwright/valid-describe-callback': 'error',\n  'playwright/valid-expect': 'error',\n  'playwright/valid-expect-in-promise': 'error',\n  'playwright/valid-title': 'warn',\n};\n\n/**\n * Generate ESLint flat config for Playwright tests\n */\nexport function generateESLintConfig(\n  rules: Record<string, unknown> = PLAYWRIGHT_LINT_RULES\n): string {\n  return `import playwright from 'eslint-plugin-playwright';\n\nexport default [\n  {\n    files: ['**/*.spec.ts', '**/*.test.ts'],\n    plugins: {\n      playwright,\n    },\n    rules: ${JSON.stringify(rules, null, 2)},\n  },\n];\n`;\n}\n\n/**\n * Check if ESLint and Playwright plugin are available\n */\nexport function isESLintAvailable(cwd?: string): boolean {\n  try {\n    execSync('npx eslint --version', {\n      cwd,\n      stdio: 'pipe',\n      encoding: 'utf-8',\n    });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Check if eslint-plugin-playwright is installed\n */\nexport function isPlaywrightPluginAvailable(cwd?: string): boolean {\n  try {\n    const result = execSync('npm list eslint-plugin-playwright', {\n      cwd,\n      stdio: 'pipe',\n      encoding: 'utf-8',\n    });\n    return result.includes('eslint-plugin-playwright');\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Convert ESLint severity to ValidationSeverity\n */\nfunction convertSeverity(eslintSeverity: 1 | 2): ValidationSeverity {\n  return eslintSeverity === 2 ? 'error' : 'warning';\n}\n\n/**\n * Parse ESLint JSON output to validation issues\n */\nexport function parseESLintOutput(output: string): ValidationIssue[] {\n  try {\n    const results: ESLintFileResult[] = JSON.parse(output);\n    const issues: ValidationIssue[] = [];\n\n    for (const file of results) {\n      for (const msg of file.messages) {\n        issues.push({\n          code: msg.ruleId || 'ESLINT_ERROR',\n          message: `Line ${msg.line}:${msg.column} - ${msg.message}`,\n          severity: convertSeverity(msg.severity),\n          suggestion: msg.fix ? 'Auto-fixable with --fix' : undefined,\n        });\n      }\n    }\n\n    return issues;\n  } catch {\n    // If JSON parsing fails, return a single error\n    return [\n      {\n        code: 'ESLINT_PARSE_ERROR',\n        message: 'Failed to parse ESLint output',\n        severity: 'error',\n      },\n    ];\n  }\n}\n\n/**\n * Run ESLint on code string\n * Note: This creates a temporary file for linting\n */\nexport async function lintCode(\n  code: string,\n  filename: string = 'test.spec.ts',\n  options: LintOptions = {}\n): Promise<LintResult> {\n  const { cwd = process.cwd(), fix = false, configPath } = options;\n\n  // Check ESLint availability\n  if (!isESLintAvailable(cwd)) {\n    return {\n      passed: true,\n      output: 'ESLint not available - skipping lint check',\n      issues: [\n        {\n          code: 'ESLINT_NOT_AVAILABLE',\n          message: 'ESLint is not installed',\n          severity: 'info',\n          suggestion: 'Run npm install eslint eslint-plugin-playwright',\n        },\n      ],\n      errorCount: 0,\n      warningCount: 0,\n    };\n  }\n\n  // Create temp file for linting\n  const tempDir = join(tmpdir(), 'autogen-lint');\n  mkdirSync(tempDir, { recursive: true });\n  const tempFile = join(tempDir, filename);\n\n  try {\n    writeFileSync(tempFile, code, 'utf-8');\n\n    // Build ESLint command\n    const args = ['eslint', '--format', 'json'];\n\n    if (fix) {\n      args.push('--fix');\n    }\n\n    if (configPath && existsSync(configPath)) {\n      args.push('--config', configPath);\n    }\n\n    args.push(tempFile);\n\n    // Run ESLint\n    const result = execSync(`npx ${args.join(' ')}`, {\n      cwd,\n      stdio: 'pipe',\n      encoding: 'utf-8',\n    });\n\n    return {\n      passed: true,\n      output: result,\n      issues: parseESLintOutput(result),\n      errorCount: 0,\n      warningCount: 0,\n    };\n  } catch (err: unknown) {\n    // ESLint exits with non-zero on errors/warnings\n    const error = err as { stdout?: string; status?: number };\n    const output = error.stdout || '';\n\n    try {\n      const results: ESLintFileResult[] = JSON.parse(output);\n      const issues = parseESLintOutput(output);\n\n      let errorCount = 0;\n      let warningCount = 0;\n\n      for (const file of results) {\n        errorCount += file.errorCount;\n        warningCount += file.warningCount;\n      }\n\n      return {\n        passed: errorCount === 0,\n        output,\n        issues,\n        errorCount,\n        warningCount,\n      };\n    } catch {\n      return {\n        passed: false,\n        output: output || 'ESLint execution failed',\n        issues: [\n          {\n            code: 'ESLINT_EXECUTION_ERROR',\n            message: 'ESLint execution failed',\n            severity: 'error',\n          },\n        ],\n        errorCount: 1,\n        warningCount: 0,\n      };\n    }\n  } finally {\n    // Cleanup temp file\n    try {\n      unlinkSync(tempFile);\n    } catch {\n      // Ignore cleanup errors\n    }\n  }\n}\n\n/**\n * Lint a file directly\n */\nexport async function lintFile(\n  filePath: string,\n  options: LintOptions = {}\n): Promise<LintResult> {\n  const { cwd = dirname(filePath), fix = false, configPath } = options;\n\n  if (!existsSync(filePath)) {\n    return {\n      passed: false,\n      output: `File not found: ${filePath}`,\n      issues: [\n        {\n          code: 'FILE_NOT_FOUND',\n          message: `File not found: ${filePath}`,\n          severity: 'error',\n        },\n      ],\n      errorCount: 1,\n      warningCount: 0,\n    };\n  }\n\n  // Check ESLint availability\n  if (!isESLintAvailable(cwd)) {\n    return {\n      passed: true,\n      output: 'ESLint not available - skipping lint check',\n      issues: [],\n      errorCount: 0,\n      warningCount: 0,\n    };\n  }\n\n  try {\n    const args = ['eslint', '--format', 'json'];\n\n    if (fix) {\n      args.push('--fix');\n    }\n\n    if (configPath && existsSync(configPath)) {\n      args.push('--config', configPath);\n    }\n\n    args.push(filePath);\n\n    const result = execSync(`npx ${args.join(' ')}`, {\n      cwd,\n      stdio: 'pipe',\n      encoding: 'utf-8',\n    });\n\n    return {\n      passed: true,\n      output: result,\n      issues: parseESLintOutput(result),\n      errorCount: 0,\n      warningCount: 0,\n    };\n  } catch (err: unknown) {\n    const error = err as { stdout?: string };\n    const output = error.stdout || '';\n    const issues = parseESLintOutput(output);\n\n    return {\n      passed: issues.filter((i) => i.severity === 'error').length === 0,\n      output,\n      issues,\n      errorCount: issues.filter((i) => i.severity === 'error').length,\n      warningCount: issues.filter((i) => i.severity === 'warning').length,\n    };\n  }\n}\n\n/**\n * Quick check if code has lint errors (without full details)\n */\nexport function hasLintErrors(code: string): boolean {\n  // Simple heuristic check for common errors without running ESLint\n  const patterns = [\n    /test\\.only\\s*\\(/g,\n    /\\.waitForTimeout\\s*\\(/g,\n    /page\\.pause\\s*\\(/g,\n  ];\n\n  for (const pattern of patterns) {\n    if (pattern.test(code)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n","/**\n * Tag Validation - Ensure generated tests have correct Playwright tags\n * @see T042 - Tag validation (required @JRN-####, @tier-*, @scope-*)\n */\nimport type { ValidationIssue } from './journey.js';\n\n/**\n * Tag pattern matchers\n */\nexport const TAG_PATTERNS = {\n  journeyId: /^@JRN-\\d{4}$/,\n  tier: /^@tier-(smoke|release|regression)$/,\n  scope: /^@scope-[a-z][a-z0-9-]*$/,\n  actor: /^@actor-[a-z][a-z0-9-]*$/,\n  custom: /^@[a-z][a-z0-9-]*$/,\n};\n\n/**\n * Tag validation options\n */\nexport interface TagValidationOptions {\n  /** Whether journey ID tag is required */\n  requireJourneyId?: boolean;\n  /** Whether tier tag is required */\n  requireTier?: boolean;\n  /** Whether scope tag is required */\n  requireScope?: boolean;\n  /** Whether actor tag is required */\n  requireActor?: boolean;\n  /** Additional required tags */\n  requiredTags?: string[];\n  /** Forbidden tags */\n  forbiddenTags?: string[];\n  /** Maximum number of tags */\n  maxTags?: number;\n}\n\nconst DEFAULT_OPTIONS: TagValidationOptions = {\n  requireJourneyId: true,\n  requireTier: true,\n  requireScope: true,\n  requireActor: false,\n  requiredTags: [],\n  forbiddenTags: [],\n  maxTags: 10,\n};\n\n/**\n * Tag validation result\n */\nexport interface TagValidationResult {\n  /** Whether tags are valid */\n  valid: boolean;\n  /** Validation issues */\n  issues: ValidationIssue[];\n  /** Parsed tags */\n  parsedTags: {\n    journeyId?: string;\n    tier?: string;\n    scope?: string;\n    actor?: string;\n    custom: string[];\n  };\n}\n\n/**\n * Parse tags from generated test code\n */\nexport function parseTagsFromCode(code: string): string[] {\n  // Match tag array in test.describe\n  const tagArrayMatch = code.match(/tag:\\s*\\[([^\\]]*)\\]/);\n  if (!tagArrayMatch) {\n    return [];\n  }\n\n  // Extract individual tags\n  const tagArrayContent = tagArrayMatch[1]!;\n  const tagMatches = tagArrayContent.match(/'[^']+'/g) || [];\n\n  return tagMatches.map((t) => t.replace(/'/g, ''));\n}\n\n/**\n * Parse tags from frontmatter tags array\n */\nexport function parseTagsFromFrontmatter(tags: string[]): string[] {\n  // Normalize tags - remove quotes if present\n  return tags.map((t) => {\n    const cleaned = t.replace(/^['\"]|['\"]$/g, '');\n    // Ensure @ prefix\n    return cleaned.startsWith('@') ? cleaned : `@${cleaned}`;\n  });\n}\n\n/**\n * Categorize tags by type\n */\nexport function categorizeTags(tags: string[]): {\n  journeyId?: string;\n  tier?: string;\n  scope?: string;\n  actor?: string;\n  custom: string[];\n} {\n  const result: {\n    journeyId?: string;\n    tier?: string;\n    scope?: string;\n    actor?: string;\n    custom: string[];\n  } = { custom: [] };\n\n  for (const tag of tags) {\n    if (TAG_PATTERNS.journeyId.test(tag)) {\n      result.journeyId = tag;\n    } else if (TAG_PATTERNS.tier.test(tag)) {\n      result.tier = tag;\n    } else if (TAG_PATTERNS.scope.test(tag)) {\n      result.scope = tag;\n    } else if (TAG_PATTERNS.actor.test(tag)) {\n      result.actor = tag;\n    } else if (TAG_PATTERNS.custom.test(tag)) {\n      result.custom.push(tag);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Validate tags against requirements\n */\nexport function validateTags(\n  tags: string[],\n  journeyId: string,\n  tier: string,\n  scope: string,\n  options: TagValidationOptions = {}\n): TagValidationResult {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n  const issues: ValidationIssue[] = [];\n  const parsedTags = categorizeTags(tags);\n\n  // Check journey ID tag\n  if (opts.requireJourneyId) {\n    const expectedIdTag = `@${journeyId}`;\n    if (!tags.includes(expectedIdTag) && parsedTags.journeyId !== expectedIdTag) {\n      issues.push({\n        code: 'TAG_MISSING_JOURNEY_ID',\n        message: `Missing journey ID tag '${expectedIdTag}'`,\n        severity: 'error',\n        field: 'tags',\n        suggestion: `Add '${expectedIdTag}' to the tags array`,\n      });\n    }\n  }\n\n  // Check tier tag\n  if (opts.requireTier) {\n    const expectedTierTag = `@tier-${tier}`;\n    if (!tags.includes(expectedTierTag) && parsedTags.tier !== expectedTierTag) {\n      // Check if any tier tag exists\n      if (!parsedTags.tier) {\n        issues.push({\n          code: 'TAG_MISSING_TIER',\n          message: `Missing tier tag, expected '${expectedTierTag}'`,\n          severity: 'warning',\n          field: 'tags',\n          suggestion: `Add '${expectedTierTag}' to the tags array`,\n        });\n      } else if (parsedTags.tier !== expectedTierTag) {\n        issues.push({\n          code: 'TAG_TIER_MISMATCH',\n          message: `Tier tag '${parsedTags.tier}' does not match journey tier '${tier}'`,\n          severity: 'warning',\n          field: 'tags',\n          suggestion: `Change to '${expectedTierTag}' or update journey tier`,\n        });\n      }\n    }\n  }\n\n  // Check scope tag\n  if (opts.requireScope) {\n    const expectedScopeTag = `@scope-${scope}`;\n    if (!tags.includes(expectedScopeTag) && parsedTags.scope !== expectedScopeTag) {\n      // Check if any scope tag exists\n      if (!parsedTags.scope) {\n        issues.push({\n          code: 'TAG_MISSING_SCOPE',\n          message: `Missing scope tag, expected '${expectedScopeTag}'`,\n          severity: 'warning',\n          field: 'tags',\n          suggestion: `Add '${expectedScopeTag}' to the tags array`,\n        });\n      } else if (parsedTags.scope !== expectedScopeTag) {\n        issues.push({\n          code: 'TAG_SCOPE_MISMATCH',\n          message: `Scope tag '${parsedTags.scope}' does not match journey scope '${scope}'`,\n          severity: 'warning',\n          field: 'tags',\n          suggestion: `Change to '${expectedScopeTag}' or update journey scope`,\n        });\n      }\n    }\n  }\n\n  // Check required custom tags\n  for (const requiredTag of opts.requiredTags || []) {\n    if (!tags.includes(requiredTag)) {\n      issues.push({\n        code: 'TAG_MISSING_REQUIRED',\n        message: `Missing required tag '${requiredTag}'`,\n        severity: 'error',\n        field: 'tags',\n        suggestion: `Add '${requiredTag}' to the tags array`,\n      });\n    }\n  }\n\n  // Check forbidden tags\n  for (const forbiddenTag of opts.forbiddenTags || []) {\n    if (tags.includes(forbiddenTag)) {\n      issues.push({\n        code: 'TAG_FORBIDDEN',\n        message: `Forbidden tag '${forbiddenTag}' should not be used`,\n        severity: 'error',\n        field: 'tags',\n        suggestion: `Remove '${forbiddenTag}' from the tags array`,\n      });\n    }\n  }\n\n  // Check max tags\n  if (opts.maxTags && tags.length > opts.maxTags) {\n    issues.push({\n      code: 'TAG_TOO_MANY',\n      message: `Too many tags (${tags.length}), maximum is ${opts.maxTags}`,\n      severity: 'warning',\n      field: 'tags',\n      suggestion: 'Remove unnecessary tags',\n    });\n  }\n\n  // Check for invalid tag format\n  for (const tag of tags) {\n    if (!TAG_PATTERNS.custom.test(tag)) {\n      issues.push({\n        code: 'TAG_INVALID_FORMAT',\n        message: `Invalid tag format '${tag}', tags should start with @ followed by lowercase letters`,\n        severity: 'warning',\n        field: 'tags',\n        suggestion: `Rename to a valid format like '@${tag.replace(/[^a-z0-9-]/gi, '-').toLowerCase()}'`,\n      });\n    }\n  }\n\n  // Check for duplicate tags\n  const duplicates = tags.filter((tag, index) => tags.indexOf(tag) !== index);\n  for (const duplicate of new Set(duplicates)) {\n    issues.push({\n      code: 'TAG_DUPLICATE',\n      message: `Duplicate tag '${duplicate}'`,\n      severity: 'warning',\n      field: 'tags',\n      suggestion: 'Remove duplicate tags',\n    });\n  }\n\n  return {\n    valid: issues.filter((i) => i.severity === 'error').length === 0,\n    issues,\n    parsedTags,\n  };\n}\n\n/**\n * Generate expected tags for a journey\n */\nexport function generateExpectedTags(\n  journeyId: string,\n  tier: string,\n  scope: string,\n  additionalTags: string[] = []\n): string[] {\n  return [\n    `@${journeyId}`,\n    `@tier-${tier}`,\n    `@scope-${scope}`,\n    ...additionalTags,\n  ];\n}\n\n/**\n * Validate tags in generated test code\n */\nexport function validateTagsInCode(\n  code: string,\n  journeyId: string,\n  tier: string,\n  scope: string,\n  options: TagValidationOptions = {}\n): TagValidationResult {\n  const tags = parseTagsFromCode(code);\n  return validateTags(tags, journeyId, tier, scope, options);\n}\n","/**\n * AC Coverage Validation - Check that all acceptance criteria have test steps\n * @see T043 - ACtest.step mapping completeness check\n */\nimport type { ValidationIssue } from './journey.js';\nimport type { AcceptanceCriterion } from '../journey/parseJourney.js';\nimport type { IRJourney, IRStep } from '../ir/types.js';\n\n/**\n * Coverage result for a single AC\n */\nexport interface ACCoverageResult {\n  /** AC identifier */\n  acId: string;\n  /** AC title */\n  acTitle: string;\n  /** Whether the AC has a corresponding test.step */\n  hasCoverage: boolean;\n  /** Number of mapped steps */\n  mappedSteps: number;\n  /** Number of blocked/unmapped steps */\n  blockedSteps: number;\n  /** Coverage percentage (mapped / total) */\n  coveragePercent: number;\n  /** List of unmapped step texts */\n  unmappedSteps: string[];\n}\n\n/**\n * Overall coverage result\n */\nexport interface CoverageResult {\n  /** Whether all ACs are covered */\n  fullCoverage: boolean;\n  /** Total number of ACs */\n  totalACs: number;\n  /** Number of covered ACs */\n  coveredACs: number;\n  /** Overall coverage percentage */\n  overallCoverage: number;\n  /** Coverage details per AC */\n  perAC: ACCoverageResult[];\n  /** Validation issues */\n  issues: ValidationIssue[];\n}\n\n/**\n * Coverage validation options\n */\nexport interface CoverageOptions {\n  /** Minimum coverage percentage required */\n  minCoverage?: number;\n  /** Warn on partial coverage */\n  warnPartialCoverage?: boolean;\n  /** Maximum allowed blocked steps per AC */\n  maxBlockedSteps?: number;\n}\n\nconst DEFAULT_OPTIONS: CoverageOptions = {\n  minCoverage: 80,\n  warnPartialCoverage: true,\n  maxBlockedSteps: 2,\n};\n\n/**\n * Find test.step calls in generated code\n */\nexport function findTestSteps(code: string): Array<{ id: string; description: string }> {\n  const steps: Array<{ id: string; description: string }> = [];\n\n  // Match test.step('ID: Description', async () => { ... })\n  const stepRegex = /test\\.step\\s*\\(\\s*['\"]([^:]+):\\s*([^'\"]+)['\"]/g;\n  let match;\n\n  while ((match = stepRegex.exec(code)) !== null) {\n    steps.push({\n      id: match[1]!.trim(),\n      description: match[2]!.trim(),\n    });\n  }\n\n  return steps;\n}\n\n/**\n * Find AC IDs mentioned in code comments\n */\nexport function findACReferences(code: string): string[] {\n  const references: string[] = [];\n\n  // Match AC-### in comments\n  const acRegex = /\\/\\/\\s*(AC-\\d+)|['\"]?(AC-\\d+)['\"]?/g;\n  let match;\n\n  while ((match = acRegex.exec(code)) !== null) {\n    const acId = match[1] || match[2];\n    if (acId && !references.includes(acId)) {\n      references.push(acId);\n    }\n  }\n\n  return references;\n}\n\n/**\n * Calculate coverage for an IR step\n */\nfunction calculateStepCoverage(step: IRStep): ACCoverageResult {\n  const totalSteps = step.actions.length + step.assertions.length;\n  const blockedSteps = step.actions.filter((a) => a.type === 'blocked').length;\n  const mappedSteps = totalSteps - blockedSteps;\n\n  const unmappedSteps: string[] = [];\n  for (const action of step.actions) {\n    if (action.type === 'blocked' && action.sourceText) {\n      unmappedSteps.push(action.sourceText);\n    }\n  }\n\n  return {\n    acId: step.id,\n    acTitle: step.description,\n    hasCoverage: mappedSteps > 0,\n    mappedSteps,\n    blockedSteps,\n    coveragePercent: totalSteps > 0 ? (mappedSteps / totalSteps) * 100 : 100,\n    unmappedSteps,\n  };\n}\n\n/**\n * Validate AC coverage in IR journey\n */\nexport function validateIRCoverage(\n  journey: IRJourney,\n  options: CoverageOptions = {}\n): CoverageResult {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n  const issues: ValidationIssue[] = [];\n  const perAC: ACCoverageResult[] = [];\n\n  // Calculate coverage for each step (which corresponds to an AC)\n  for (const step of journey.steps) {\n    const coverage = calculateStepCoverage(step);\n    perAC.push(coverage);\n\n    // Check coverage issues\n    if (!coverage.hasCoverage) {\n      issues.push({\n        code: 'AC_NO_COVERAGE',\n        message: `${step.id} has no mapped test steps`,\n        severity: 'error',\n        field: step.id,\n        suggestion: 'Clarify the AC steps or add supported patterns',\n      });\n    } else if (coverage.coveragePercent < (opts.minCoverage! || 80)) {\n      if (opts.warnPartialCoverage) {\n        issues.push({\n          code: 'AC_PARTIAL_COVERAGE',\n          message: `${step.id} has only ${Math.round(coverage.coveragePercent)}% coverage (${coverage.mappedSteps}/${coverage.mappedSteps + coverage.blockedSteps} steps)`,\n          severity: 'warning',\n          field: step.id,\n          suggestion: `Unmapped steps: ${coverage.unmappedSteps.join(', ')}`,\n        });\n      }\n    }\n\n    // Check blocked step count\n    if (opts.maxBlockedSteps! && coverage.blockedSteps > opts.maxBlockedSteps!) {\n      issues.push({\n        code: 'AC_TOO_MANY_BLOCKED',\n        message: `${step.id} has ${coverage.blockedSteps} blocked steps (max: ${opts.maxBlockedSteps})`,\n        severity: 'warning',\n        field: step.id,\n        suggestion: 'Consider clarifying these steps or marking the journey as needing manual implementation',\n      });\n    }\n  }\n\n  // Calculate overall stats\n  const totalACs = perAC.length;\n  const coveredACs = perAC.filter((ac) => ac.hasCoverage).length;\n  const overallCoverage = totalACs > 0 ? (coveredACs / totalACs) * 100 : 100;\n\n  // Overall coverage check\n  if (totalACs > 0 && overallCoverage < (opts.minCoverage || 80)) {\n    issues.push({\n      code: 'JOURNEY_LOW_COVERAGE',\n      message: `Journey has only ${Math.round(overallCoverage)}% AC coverage (${coveredACs}/${totalACs} ACs)`,\n      severity: overallCoverage < 50 ? 'error' : 'warning',\n      suggestion: 'Review and clarify uncovered acceptance criteria',\n    });\n  }\n\n  return {\n    fullCoverage: coveredACs === totalACs && issues.filter((i) => i.severity === 'error').length === 0,\n    totalACs,\n    coveredACs,\n    overallCoverage,\n    perAC,\n    issues,\n  };\n}\n\n/**\n * Validate coverage in generated test code\n */\nexport function validateCodeCoverage(\n  code: string,\n  acceptanceCriteria: AcceptanceCriterion[],\n  _options: CoverageOptions = {}\n): CoverageResult {\n  // Options reserved for future use (e.g., minCoverage threshold)\n  const issues: ValidationIssue[] = [];\n  const perAC: ACCoverageResult[] = [];\n\n  // Find test steps in code\n  const testSteps = findTestSteps(code);\n  const stepIds = testSteps.map((s) => s.id);\n\n  // Check each AC\n  for (const ac of acceptanceCriteria) {\n    const hasCoverage = stepIds.includes(ac.id);\n\n    perAC.push({\n      acId: ac.id,\n      acTitle: ac.title,\n      hasCoverage,\n      mappedSteps: hasCoverage ? ac.steps.length : 0,\n      blockedSteps: hasCoverage ? 0 : ac.steps.length,\n      coveragePercent: hasCoverage ? 100 : 0,\n      unmappedSteps: hasCoverage ? [] : ac.steps,\n    });\n\n    if (!hasCoverage) {\n      issues.push({\n        code: 'AC_NOT_IN_CODE',\n        message: `${ac.id}: ${ac.title} is not covered in generated test`,\n        severity: 'error',\n        field: ac.id,\n        suggestion: 'Regenerate the test or add manual test.step',\n      });\n    }\n  }\n\n  // Check for orphan test steps (not matching any AC)\n  for (const step of testSteps) {\n    if (!acceptanceCriteria.find((ac) => ac.id === step.id)) {\n      issues.push({\n        code: 'ORPHAN_TEST_STEP',\n        message: `test.step '${step.id}' does not match any acceptance criterion`,\n        severity: 'warning',\n        suggestion: 'Remove orphan step or add corresponding AC',\n      });\n    }\n  }\n\n  // Calculate overall stats\n  const totalACs = perAC.length;\n  const coveredACs = perAC.filter((ac) => ac.hasCoverage).length;\n  const overallCoverage = totalACs > 0 ? (coveredACs / totalACs) * 100 : 100;\n\n  return {\n    fullCoverage: coveredACs === totalACs,\n    totalACs,\n    coveredACs,\n    overallCoverage,\n    perAC,\n    issues,\n  };\n}\n\n/**\n * Generate coverage report as markdown\n */\nexport function generateCoverageReport(result: CoverageResult): string {\n  const lines: string[] = [];\n\n  lines.push('# AC Coverage Report');\n  lines.push('');\n  lines.push(`**Overall Coverage**: ${Math.round(result.overallCoverage)}% (${result.coveredACs}/${result.totalACs} ACs)`);\n  lines.push('');\n\n  if (result.fullCoverage) {\n    lines.push(' All acceptance criteria are covered');\n  } else {\n    lines.push(' Some acceptance criteria are missing coverage');\n  }\n\n  lines.push('');\n  lines.push('## Per-AC Coverage');\n  lines.push('');\n  lines.push('| AC ID | Title | Coverage | Status |');\n  lines.push('|-------|-------|----------|--------|');\n\n  for (const ac of result.perAC) {\n    const status = ac.hasCoverage ? (ac.coveragePercent >= 80 ? '' : '') : '';\n    lines.push(\n      `| ${ac.acId} | ${ac.acTitle.slice(0, 30)}${ac.acTitle.length > 30 ? '...' : ''} | ${Math.round(ac.coveragePercent)}% | ${status} |`\n    );\n  }\n\n  if (result.issues.length > 0) {\n    lines.push('');\n    lines.push('## Issues');\n    lines.push('');\n    for (const issue of result.issues) {\n      const icon = issue.severity === 'error' ? '' : issue.severity === 'warning' ? '' : '';\n      lines.push(`- ${icon} **${issue.code}**: ${issue.message}`);\n      if (issue.suggestion) {\n        lines.push(`  - Suggestion: ${issue.suggestion}`);\n      }\n    }\n  }\n\n  return lines.join('\\n');\n}\n","/**\n * Code Validator - Aggregate all validation checks for generated code\n * @see T044 - Generated code validator (aggregates all checks)\n */\nimport type { ValidationIssue, ValidationSeverity, JourneyValidationResult } from './journey.js';\nimport { validateJourneyFrontmatter } from './journey.js';\nimport { scanForbiddenPatterns, scanResultsToIssues, getViolationSummary } from './patterns.js';\nimport { lintCode, type LintResult } from './lint.js';\nimport { validateTagsInCode, type TagValidationResult } from './tags.js';\nimport { validateIRCoverage, type CoverageResult } from './coverage.js';\nimport type { IRJourney } from '../ir/types.js';\nimport type { JourneyFrontmatter } from '../journey/parseJourney.js';\n\n/**\n * Full validation result for generated code\n */\nexport interface CodeValidationResult {\n  /** Overall pass/fail status */\n  valid: boolean;\n  /** Journey ID being validated */\n  journeyId: string;\n  /** All validation issues */\n  issues: ValidationIssue[];\n  /** Issue counts by severity */\n  counts: {\n    errors: number;\n    warnings: number;\n    info: number;\n  };\n  /** Individual validation results */\n  details: {\n    frontmatter?: JourneyValidationResult;\n    patterns: {\n      valid: boolean;\n      violationCount: number;\n    };\n    lint?: LintResult;\n    tags?: TagValidationResult;\n    coverage?: CoverageResult;\n  };\n  /** Validation timestamp */\n  timestamp: string;\n}\n\n/**\n * Options for code validation\n */\nexport interface CodeValidationOptions {\n  /** Whether to run ESLint */\n  runLint?: boolean;\n  /** Whether to validate tags */\n  validateTags?: boolean;\n  /** Whether to validate coverage */\n  validateCoverage?: boolean;\n  /** Whether to validate frontmatter */\n  validateFrontmatter?: boolean;\n  /** Custom forbidden patterns to check */\n  customPatterns?: RegExp[];\n  /** Minimum coverage percentage */\n  minCoverage?: number;\n  /** Allow drafts for generation */\n  allowDrafts?: boolean;\n}\n\nconst DEFAULT_OPTIONS: CodeValidationOptions = {\n  runLint: false, // ESLint requires setup, disabled by default\n  validateTags: true,\n  validateCoverage: true,\n  validateFrontmatter: true,\n  minCoverage: 80,\n  allowDrafts: false,\n};\n\n/**\n * Validate generated test code\n */\nexport async function validateCode(\n  code: string,\n  journey: IRJourney,\n  frontmatter?: JourneyFrontmatter,\n  options: CodeValidationOptions = {}\n): Promise<CodeValidationResult> {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n  const allIssues: ValidationIssue[] = [];\n  const details: CodeValidationResult['details'] = {\n    patterns: { valid: true, violationCount: 0 },\n  };\n\n  // 1. Frontmatter validation\n  if (opts.validateFrontmatter && frontmatter) {\n    const frontmatterResult = validateJourneyFrontmatter(frontmatter, {\n      allowDrafts: opts.allowDrafts,\n    });\n    details.frontmatter = frontmatterResult;\n    allIssues.push(...frontmatterResult.issues);\n  }\n\n  // 2. Forbidden pattern scan\n  const patternResults = scanForbiddenPatterns(code);\n  const patternIssues = scanResultsToIssues(patternResults);\n  allIssues.push(...patternIssues);\n\n  const patternSummary = getViolationSummary(patternResults);\n  details.patterns = {\n    valid: patternSummary.errors === 0,\n    violationCount: patternSummary.total,\n  };\n\n  // 3. ESLint (optional)\n  if (opts.runLint) {\n    const lintResult = await lintCode(code, `${journey.id.toLowerCase()}.spec.ts`);\n    details.lint = lintResult;\n    allIssues.push(...lintResult.issues);\n  }\n\n  // 4. Tag validation\n  if (opts.validateTags) {\n    const tagResult = validateTagsInCode(code, journey.id, journey.tier, journey.scope);\n    details.tags = tagResult;\n    allIssues.push(...tagResult.issues);\n  }\n\n  // 5. Coverage validation\n  if (opts.validateCoverage) {\n    const coverageResult = validateIRCoverage(journey, {\n      minCoverage: opts.minCoverage,\n      warnPartialCoverage: true,\n    });\n    details.coverage = coverageResult;\n    allIssues.push(...coverageResult.issues);\n  }\n\n  // Calculate counts\n  const counts = {\n    errors: allIssues.filter((i) => i.severity === 'error').length,\n    warnings: allIssues.filter((i) => i.severity === 'warning').length,\n    info: allIssues.filter((i) => i.severity === 'info').length,\n  };\n\n  return {\n    valid: counts.errors === 0,\n    journeyId: journey.id,\n    issues: allIssues,\n    counts,\n    details,\n    timestamp: new Date().toISOString(),\n  };\n}\n\n/**\n * Synchronous validation (without ESLint)\n */\nexport function validateCodeSync(\n  code: string,\n  journey: IRJourney,\n  frontmatter?: JourneyFrontmatter,\n  options: Omit<CodeValidationOptions, 'runLint'> = {}\n): CodeValidationResult {\n  const opts = { ...DEFAULT_OPTIONS, ...options, runLint: false };\n  const allIssues: ValidationIssue[] = [];\n  const details: CodeValidationResult['details'] = {\n    patterns: { valid: true, violationCount: 0 },\n  };\n\n  // 1. Frontmatter validation\n  if (opts.validateFrontmatter && frontmatter) {\n    const frontmatterResult = validateJourneyFrontmatter(frontmatter, {\n      allowDrafts: opts.allowDrafts,\n    });\n    details.frontmatter = frontmatterResult;\n    allIssues.push(...frontmatterResult.issues);\n  }\n\n  // 2. Forbidden pattern scan\n  const patternResults = scanForbiddenPatterns(code);\n  const patternIssues = scanResultsToIssues(patternResults);\n  allIssues.push(...patternIssues);\n\n  const patternSummary = getViolationSummary(patternResults);\n  details.patterns = {\n    valid: patternSummary.errors === 0,\n    violationCount: patternSummary.total,\n  };\n\n  // 3. Tag validation\n  if (opts.validateTags) {\n    const tagResult = validateTagsInCode(code, journey.id, journey.tier, journey.scope);\n    details.tags = tagResult;\n    allIssues.push(...tagResult.issues);\n  }\n\n  // 4. Coverage validation\n  if (opts.validateCoverage) {\n    const coverageResult = validateIRCoverage(journey, {\n      minCoverage: opts.minCoverage,\n      warnPartialCoverage: true,\n    });\n    details.coverage = coverageResult;\n    allIssues.push(...coverageResult.issues);\n  }\n\n  // Calculate counts\n  const counts = {\n    errors: allIssues.filter((i) => i.severity === 'error').length,\n    warnings: allIssues.filter((i) => i.severity === 'warning').length,\n    info: allIssues.filter((i) => i.severity === 'info').length,\n  };\n\n  return {\n    valid: counts.errors === 0,\n    journeyId: journey.id,\n    issues: allIssues,\n    counts,\n    details,\n    timestamp: new Date().toISOString(),\n  };\n}\n\n/**\n * Quick pass/fail check\n */\nexport function isCodeValid(\n  code: string,\n  journey: IRJourney,\n  frontmatter?: JourneyFrontmatter\n): boolean {\n  const result = validateCodeSync(code, journey, frontmatter);\n  return result.valid;\n}\n\n/**\n * Generate validation report as markdown\n */\nexport function generateValidationReport(result: CodeValidationResult): string {\n  const lines: string[] = [];\n\n  lines.push('# Code Validation Report');\n  lines.push('');\n  lines.push(`**Journey**: ${result.journeyId}`);\n  lines.push(`**Status**: ${result.valid ? ' PASSED' : ' FAILED'}`);\n  lines.push(`**Timestamp**: ${result.timestamp}`);\n  lines.push('');\n\n  lines.push('## Summary');\n  lines.push('');\n  lines.push(`- Errors: ${result.counts.errors}`);\n  lines.push(`- Warnings: ${result.counts.warnings}`);\n  lines.push(`- Info: ${result.counts.info}`);\n  lines.push('');\n\n  lines.push('## Validation Checks');\n  lines.push('');\n\n  // Frontmatter\n  if (result.details.frontmatter) {\n    const fm = result.details.frontmatter;\n    lines.push(`### Frontmatter: ${fm.valid ? '' : ''}`);\n    lines.push('');\n  }\n\n  // Patterns\n  const patterns = result.details.patterns;\n  lines.push(`### Forbidden Patterns: ${patterns.valid ? '' : ''}`);\n  lines.push(`- Violations found: ${patterns.violationCount}`);\n  lines.push('');\n\n  // ESLint\n  if (result.details.lint) {\n    const lint = result.details.lint;\n    lines.push(`### ESLint: ${lint.passed ? '' : ''}`);\n    lines.push(`- Errors: ${lint.errorCount}`);\n    lines.push(`- Warnings: ${lint.warningCount}`);\n    lines.push('');\n  }\n\n  // Tags\n  if (result.details.tags) {\n    const tags = result.details.tags;\n    lines.push(`### Tags: ${tags.valid ? '' : ''}`);\n    lines.push('');\n  }\n\n  // Coverage\n  if (result.details.coverage) {\n    const coverage = result.details.coverage;\n    lines.push(`### Coverage: ${coverage.fullCoverage ? '' : ''}`);\n    lines.push(`- Overall: ${Math.round(coverage.overallCoverage)}%`);\n    lines.push(`- ACs Covered: ${coverage.coveredACs}/${coverage.totalACs}`);\n    lines.push('');\n  }\n\n  // Issues\n  if (result.issues.length > 0) {\n    lines.push('## Issues');\n    lines.push('');\n\n    const groupedIssues: Record<ValidationSeverity, ValidationIssue[]> = {\n      error: [],\n      warning: [],\n      info: [],\n    };\n\n    for (const issue of result.issues) {\n      groupedIssues[issue.severity].push(issue);\n    }\n\n    if (groupedIssues.error.length > 0) {\n      lines.push('### Errors');\n      for (const issue of groupedIssues.error) {\n        lines.push(`-  **${issue.code}**: ${issue.message}`);\n        if (issue.suggestion) {\n          lines.push(`  -  ${issue.suggestion}`);\n        }\n      }\n      lines.push('');\n    }\n\n    if (groupedIssues.warning.length > 0) {\n      lines.push('### Warnings');\n      for (const issue of groupedIssues.warning) {\n        lines.push(`-  **${issue.code}**: ${issue.message}`);\n        if (issue.suggestion) {\n          lines.push(`  -  ${issue.suggestion}`);\n        }\n      }\n      lines.push('');\n    }\n\n    if (groupedIssues.info.length > 0) {\n      lines.push('### Info');\n      for (const issue of groupedIssues.info) {\n        lines.push(`-  **${issue.code}**: ${issue.message}`);\n        if (issue.suggestion) {\n          lines.push(`  -  ${issue.suggestion}`);\n        }\n      }\n      lines.push('');\n    }\n  }\n\n  return lines.join('\\n');\n}\n","/**\n * Validation module exports\n */\n\n// Journey validation\nexport {\n  type ValidationSeverity,\n  type ValidationIssue,\n  type JourneyValidationResult,\n  type JourneyValidationOptions,\n  validateJourneySchema,\n  validateJourneyStatus,\n  validateJourneyTier,\n  validateJourneyTags,\n  validateJourneyFrontmatter,\n  isJourneyReady,\n} from './journey.js';\n\n// Pattern scanning\nexport {\n  type ForbiddenPattern,\n  type PatternScanResult,\n  FORBIDDEN_PATTERNS,\n  scanForbiddenPatterns,\n  scanResultsToIssues,\n  getPatternStats,\n  hasErrorViolations,\n  filterBySeverity,\n  getViolationSummary,\n} from './patterns.js';\n\n// ESLint integration\nexport {\n  type LintResult,\n  type LintOptions,\n  PLAYWRIGHT_LINT_RULES,\n  generateESLintConfig,\n  isESLintAvailable,\n  isPlaywrightPluginAvailable,\n  parseESLintOutput,\n  lintCode,\n  lintFile,\n  hasLintErrors,\n} from './lint.js';\n\n// Tag validation\nexport {\n  TAG_PATTERNS,\n  type TagValidationOptions,\n  type TagValidationResult,\n  parseTagsFromCode,\n  parseTagsFromFrontmatter,\n  categorizeTags,\n  validateTags,\n  generateExpectedTags,\n  validateTagsInCode,\n} from './tags.js';\n\n// Coverage validation\nexport {\n  type ACCoverageResult,\n  type CoverageResult,\n  type CoverageOptions,\n  findTestSteps,\n  findACReferences,\n  validateIRCoverage,\n  validateCodeCoverage,\n  generateCoverageReport,\n} from './coverage.js';\n\n// Code validation (aggregated)\nexport {\n  type CodeValidationResult,\n  type CodeValidationOptions,\n  validateCode,\n  validateCodeSync,\n  isCodeValid,\n  generateValidationReport,\n} from './code.js';\n","/**\n * Playwright CLI Runner Wrapper - Execute tests and capture results\n * @see T050 - Implement Playwright CLI runner wrapper\n */\nimport { execSync, spawn, type ChildProcess } from 'node:child_process';\nimport { existsSync, mkdirSync, writeFileSync } from 'node:fs';\nimport { join, dirname } from 'node:path';\nimport { tmpdir } from 'node:os';\n\n/**\n * Options for running Playwright tests\n */\nexport interface RunnerOptions {\n  /** Working directory */\n  cwd?: string;\n  /** Test file or pattern to run */\n  testFile?: string;\n  /** Specific test to run (grep pattern) */\n  grep?: string;\n  /** Project to run (from playwright.config.ts) */\n  project?: string;\n  /** Number of workers */\n  workers?: number;\n  /** Retries on failure */\n  retries?: number;\n  /** Repeat each test N times (for flakiness check) */\n  repeatEach?: number;\n  /** Fail on flaky tests */\n  failOnFlaky?: boolean;\n  /** Timeout per test in ms */\n  timeout?: number;\n  /** Reporter to use */\n  reporter?: string;\n  /** Output directory for results */\n  outputDir?: string;\n  /** Environment variables */\n  env?: Record<string, string>;\n  /** Headed mode */\n  headed?: boolean;\n  /** Enable debug mode */\n  debug?: boolean;\n  /** Update snapshots */\n  updateSnapshots?: boolean;\n}\n\n/**\n * Result of running Playwright tests\n */\nexport interface RunnerResult {\n  /** Whether the run succeeded (all tests passed) */\n  success: boolean;\n  /** Exit code from Playwright */\n  exitCode: number;\n  /** Stdout output */\n  stdout: string;\n  /** Stderr output */\n  stderr: string;\n  /** Path to JSON report (if generated) */\n  reportPath?: string;\n  /** Duration in milliseconds */\n  duration: number;\n  /** Command that was executed */\n  command: string;\n}\n\n/**\n * Check if Playwright is available\n */\nexport function isPlaywrightAvailable(cwd?: string): boolean {\n  try {\n    execSync('npx playwright --version', {\n      cwd,\n      stdio: 'pipe',\n      encoding: 'utf-8',\n    });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Get Playwright version\n */\nexport function getPlaywrightVersion(cwd?: string): string | null {\n  try {\n    const result = execSync('npx playwright --version', {\n      cwd,\n      stdio: 'pipe',\n      encoding: 'utf-8',\n    });\n    return result.trim();\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Build Playwright command arguments\n */\nexport function buildPlaywrightArgs(options: RunnerOptions): string[] {\n  const args = ['test'];\n\n  if (options.testFile) {\n    args.push(options.testFile);\n  }\n\n  if (options.grep) {\n    args.push('--grep', options.grep);\n  }\n\n  if (options.project) {\n    args.push('--project', options.project);\n  }\n\n  if (options.workers !== undefined) {\n    args.push('--workers', String(options.workers));\n  }\n\n  if (options.retries !== undefined) {\n    args.push('--retries', String(options.retries));\n  }\n\n  if (options.repeatEach !== undefined) {\n    args.push('--repeat-each', String(options.repeatEach));\n  }\n\n  if (options.failOnFlaky) {\n    args.push('--fail-on-flaky-tests');\n  }\n\n  if (options.timeout !== undefined) {\n    args.push('--timeout', String(options.timeout));\n  }\n\n  if (options.reporter) {\n    args.push('--reporter', options.reporter);\n  }\n\n  if (options.outputDir) {\n    args.push('--output', options.outputDir);\n  }\n\n  if (options.headed) {\n    args.push('--headed');\n  }\n\n  if (options.debug) {\n    args.push('--debug');\n  }\n\n  if (options.updateSnapshots) {\n    args.push('--update-snapshots');\n  }\n\n  return args;\n}\n\n/**\n * Run Playwright tests synchronously\n */\nexport function runPlaywrightSync(options: RunnerOptions = {}): RunnerResult {\n  const { cwd = process.cwd(), env = {} } = options;\n\n  // Ensure Playwright is available\n  if (!isPlaywrightAvailable(cwd)) {\n    return {\n      success: false,\n      exitCode: 1,\n      stdout: '',\n      stderr: 'Playwright is not installed',\n      duration: 0,\n      command: 'npx playwright test',\n    };\n  }\n\n  // Create temp dir for JSON report\n  const tempDir = join(tmpdir(), `autogen-verify-${Date.now()}`);\n  mkdirSync(tempDir, { recursive: true });\n  const reportPath = join(tempDir, 'results.json');\n\n  // Build command\n  const args = buildPlaywrightArgs({\n    ...options,\n    reporter: `json,line`,\n  });\n\n  const command = `npx playwright ${args.join(' ')}`;\n  const startTime = Date.now();\n\n  try {\n    const result = execSync(command, {\n      cwd,\n      stdio: 'pipe',\n      encoding: 'utf-8',\n      env: {\n        ...process.env,\n        ...env,\n        PLAYWRIGHT_JSON_OUTPUT_NAME: reportPath,\n      },\n      timeout: options.timeout ? options.timeout * 10 : 600000, // 10x test timeout or 10 min\n    });\n\n    return {\n      success: true,\n      exitCode: 0,\n      stdout: result,\n      stderr: '',\n      reportPath: existsSync(reportPath) ? reportPath : undefined,\n      duration: Date.now() - startTime,\n      command,\n    };\n  } catch (error: unknown) {\n    const execError = error as {\n      status?: number;\n      stdout?: string;\n      stderr?: string;\n    };\n\n    return {\n      success: false,\n      exitCode: execError.status || 1,\n      stdout: execError.stdout || '',\n      stderr: execError.stderr || String(error),\n      reportPath: existsSync(reportPath) ? reportPath : undefined,\n      duration: Date.now() - startTime,\n      command,\n    };\n  }\n}\n\n/**\n * Run Playwright tests asynchronously\n */\nexport function runPlaywrightAsync(\n  options: RunnerOptions = {}\n): Promise<RunnerResult> {\n  return new Promise((resolve) => {\n    const { cwd = process.cwd(), env = {} } = options;\n\n    // Create temp dir for JSON report\n    const tempDir = join(tmpdir(), `autogen-verify-${Date.now()}`);\n    mkdirSync(tempDir, { recursive: true });\n    const reportPath = join(tempDir, 'results.json');\n\n    // Build command\n    const args = buildPlaywrightArgs({\n      ...options,\n      reporter: 'json,line',\n    });\n\n    const command = `npx playwright ${args.join(' ')}`;\n    const startTime = Date.now();\n\n    let stdout = '';\n    let stderr = '';\n\n    const child: ChildProcess = spawn('npx', ['playwright', ...args], {\n      cwd,\n      env: {\n        ...process.env,\n        ...env,\n        PLAYWRIGHT_JSON_OUTPUT_NAME: reportPath,\n      },\n      shell: true,\n    });\n\n    child.stdout?.on('data', (data: Buffer) => {\n      stdout += data.toString();\n    });\n\n    child.stderr?.on('data', (data: Buffer) => {\n      stderr += data.toString();\n    });\n\n    child.on('close', (code: number | null) => {\n      resolve({\n        success: code === 0,\n        exitCode: code || 1,\n        stdout,\n        stderr,\n        reportPath: existsSync(reportPath) ? reportPath : undefined,\n        duration: Date.now() - startTime,\n        command,\n      });\n    });\n\n    child.on('error', (error: Error) => {\n      resolve({\n        success: false,\n        exitCode: 1,\n        stdout,\n        stderr: error.message,\n        duration: Date.now() - startTime,\n        command,\n      });\n    });\n  });\n}\n\n/**\n * Run a single test file\n */\nexport function runTestFile(\n  testFilePath: string,\n  options: Omit<RunnerOptions, 'testFile'> = {}\n): RunnerResult {\n  if (!existsSync(testFilePath)) {\n    return {\n      success: false,\n      exitCode: 1,\n      stdout: '',\n      stderr: `Test file not found: ${testFilePath}`,\n      duration: 0,\n      command: '',\n    };\n  }\n\n  return runPlaywrightSync({\n    ...options,\n    testFile: testFilePath,\n    cwd: options.cwd || dirname(testFilePath),\n  });\n}\n\n/**\n * Run tests by journey ID tag\n */\nexport function runJourneyTests(\n  journeyId: string,\n  options: Omit<RunnerOptions, 'grep'> = {}\n): RunnerResult {\n  return runPlaywrightSync({\n    ...options,\n    grep: `@${journeyId}`,\n  });\n}\n\n/**\n * Check if a test file compiles (syntax check)\n */\nexport function checkTestSyntax(testFilePath: string, cwd?: string): boolean {\n  if (!existsSync(testFilePath)) {\n    return false;\n  }\n\n  try {\n    execSync(`npx tsc --noEmit ${testFilePath}`, {\n      cwd: cwd || dirname(testFilePath),\n      stdio: 'pipe',\n    });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Write test file and run it\n */\nexport function writeAndRunTest(\n  code: string,\n  filename: string,\n  options: RunnerOptions = {}\n): RunnerResult {\n  const tempDir = join(tmpdir(), `autogen-test-${Date.now()}`);\n  mkdirSync(tempDir, { recursive: true });\n\n  const testPath = join(tempDir, filename);\n  writeFileSync(testPath, code, 'utf-8');\n\n  return runTestFile(testPath, options);\n}\n\n/**\n * Get test count from Playwright\n */\nexport function getTestCount(testFile: string, cwd?: string): number {\n  try {\n    const result = execSync(`npx playwright test --list ${testFile}`, {\n      cwd,\n      stdio: 'pipe',\n      encoding: 'utf-8',\n    });\n\n    // Parse \"Listing X tests\" output\n    const match = result.match(/Listing (\\d+) tests?/);\n    return match ? parseInt(match[1]!, 10) : 0;\n  } catch {\n    return 0;\n  }\n}\n","/**\n * Playwright JSON Report Parser - Parse test results from JSON reporter\n * @see T051 - Implement JSON report parser for test results\n */\nimport { readFileSync, existsSync } from 'node:fs';\n\n/**\n * Test status from Playwright\n */\nexport type TestStatus = 'passed' | 'failed' | 'timedOut' | 'skipped' | 'interrupted';\n\n/**\n * Error attachment from Playwright\n */\nexport interface ErrorAttachment {\n  name: string;\n  contentType: string;\n  path?: string;\n  body?: string;\n}\n\n/**\n * Test error details\n */\nexport interface TestError {\n  message: string;\n  stack?: string;\n  location?: {\n    file: string;\n    line: number;\n    column: number;\n  };\n  snippet?: string;\n}\n\n/**\n * Test step from Playwright report\n */\nexport interface ReportStep {\n  title: string;\n  category: string;\n  duration: number;\n  error?: TestError;\n  steps?: ReportStep[];\n}\n\n/**\n * Single test result from Playwright report\n */\nexport interface TestResult {\n  /** Test title */\n  title: string;\n  /** Full title path */\n  titlePath: string[];\n  /** Test location */\n  location: {\n    file: string;\n    line: number;\n    column: number;\n  };\n  /** Test status */\n  status: TestStatus;\n  /** Test duration in ms */\n  duration: number;\n  /** Retry number (0 = first attempt) */\n  retry: number;\n  /** Errors if failed */\n  errors: TestError[];\n  /** Test steps */\n  steps: ReportStep[];\n  /** Attachments */\n  attachments: ErrorAttachment[];\n  /** Annotations */\n  annotations: Array<{ type: string; description?: string }>;\n  /** Tags */\n  tags: string[];\n}\n\n/**\n * Suite from Playwright report\n */\nexport interface TestSuite {\n  title: string;\n  file: string;\n  line: number;\n  column: number;\n  specs: TestSpec[];\n  suites: TestSuite[];\n}\n\n/**\n * Test spec from Playwright report\n */\nexport interface TestSpec {\n  title: string;\n  ok: boolean;\n  tags: string[];\n  tests: Array<{\n    expectedStatus: TestStatus;\n    status: TestStatus;\n    projectName: string;\n    results: TestResult[];\n  }>;\n}\n\n/**\n * Full Playwright JSON report\n */\nexport interface PlaywrightReport {\n  config: {\n    rootDir: string;\n    projects: Array<{\n      name: string;\n      testDir: string;\n    }>;\n  };\n  suites: TestSuite[];\n  errors: TestError[];\n  stats: {\n    startTime: string;\n    duration: number;\n    expected: number;\n    unexpected: number;\n    flaky: number;\n    skipped: number;\n  };\n}\n\n/**\n * Parsed test summary\n */\nexport interface ParsedSummary {\n  total: number;\n  passed: number;\n  failed: number;\n  skipped: number;\n  flaky: number;\n  duration: number;\n  startTime: Date;\n  files: string[];\n  failedTests: TestResult[];\n  flakyTests: TestResult[];\n}\n\n/**\n * Parse Playwright JSON report from file\n */\nexport function parseReportFile(filePath: string): PlaywrightReport | null {\n  if (!existsSync(filePath)) {\n    return null;\n  }\n\n  try {\n    const content = readFileSync(filePath, 'utf-8');\n    return JSON.parse(content) as PlaywrightReport;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Parse Playwright JSON report from string\n */\nexport function parseReportContent(content: string): PlaywrightReport | null {\n  try {\n    return JSON.parse(content) as PlaywrightReport;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Extract all test results from report\n */\nexport function extractTestResults(report: PlaywrightReport): TestResult[] {\n  const results: TestResult[] = [];\n\n  function extractFromSuite(suite: TestSuite, titlePath: string[] = []): void {\n    const currentPath = [...titlePath, suite.title].filter(Boolean);\n\n    for (const spec of suite.specs) {\n      for (const test of spec.tests) {\n        for (const result of test.results) {\n          results.push({\n            ...result,\n            titlePath: [...currentPath, spec.title],\n          });\n        }\n      }\n    }\n\n    for (const childSuite of suite.suites) {\n      extractFromSuite(childSuite, currentPath);\n    }\n  }\n\n  for (const suite of report.suites) {\n    extractFromSuite(suite);\n  }\n\n  return results;\n}\n\n/**\n * Get summary from Playwright report\n */\nexport function getSummary(report: PlaywrightReport): ParsedSummary {\n  const allResults = extractTestResults(report);\n\n  const failedTests = allResults.filter((r) => r.status === 'failed');\n  const passedTests = allResults.filter((r) => r.status === 'passed');\n  const skippedTests = allResults.filter((r) => r.status === 'skipped');\n\n  // Flaky tests: passed on retry\n  const flakyTests = allResults.filter((r) => r.status === 'passed' && r.retry > 0);\n\n  // Extract unique file paths\n  const files = [...new Set(allResults.map((r) => r.location.file))];\n\n  return {\n    total: allResults.length,\n    passed: passedTests.length,\n    failed: failedTests.length,\n    skipped: skippedTests.length,\n    flaky: flakyTests.length,\n    duration: report.stats.duration,\n    startTime: new Date(report.stats.startTime),\n    files,\n    failedTests,\n    flakyTests,\n  };\n}\n\n/**\n * Get failed test details\n */\nexport function getFailedTests(report: PlaywrightReport): TestResult[] {\n  return extractTestResults(report).filter((r) => r.status === 'failed');\n}\n\n/**\n * Get flaky test details\n */\nexport function getFlakyTests(report: PlaywrightReport): TestResult[] {\n  return extractTestResults(report).filter(\n    (r) => r.status === 'passed' && r.retry > 0\n  );\n}\n\n/**\n * Get test by title pattern\n */\nexport function findTestsByTitle(\n  report: PlaywrightReport,\n  pattern: string | RegExp\n): TestResult[] {\n  const allResults = extractTestResults(report);\n  const regex = typeof pattern === 'string' ? new RegExp(pattern, 'i') : pattern;\n\n  return allResults.filter((r) => regex.test(r.title));\n}\n\n/**\n * Get tests by tag\n */\nexport function findTestsByTag(\n  report: PlaywrightReport,\n  tag: string\n): TestResult[] {\n  const allResults = extractTestResults(report);\n  return allResults.filter((r) => r.tags.includes(tag));\n}\n\n/**\n * Extract error messages from test result\n */\nexport function extractErrorMessages(result: TestResult): string[] {\n  return result.errors.map((e) => e.message);\n}\n\n/**\n * Extract error stack from test result\n */\nexport function extractErrorStacks(result: TestResult): string[] {\n  return result.errors\n    .map((e) => e.stack)\n    .filter((s): s is string => s !== undefined);\n}\n\n/**\n * Get step that failed\n */\nexport function getFailedStep(result: TestResult): ReportStep | null {\n  function findFailedStep(steps: ReportStep[]): ReportStep | null {\n    for (const step of steps) {\n      if (step.error) {\n        return step;\n      }\n      if (step.steps) {\n        const found = findFailedStep(step.steps);\n        if (found) return found;\n      }\n    }\n    return null;\n  }\n\n  return findFailedStep(result.steps);\n}\n\n/**\n * Check if report indicates overall success\n */\nexport function isReportSuccessful(report: PlaywrightReport): boolean {\n  return report.stats.unexpected === 0;\n}\n\n/**\n * Check if report has flaky tests\n */\nexport function reportHasFlaky(report: PlaywrightReport): boolean {\n  return report.stats.flaky > 0;\n}\n\n/**\n * Format test result for display\n */\nexport function formatTestResult(result: TestResult): string {\n  const status = result.status.toUpperCase();\n  const title = result.titlePath.join(' > ');\n  const duration = `${result.duration}ms`;\n  const retry = result.retry > 0 ? ` (retry ${result.retry})` : '';\n\n  let output = `[${status}] ${title} (${duration})${retry}`;\n\n  if (result.errors.length > 0) {\n    output += '\\n  Errors:';\n    for (const error of result.errors) {\n      output += `\\n    - ${error.message}`;\n    }\n  }\n\n  return output;\n}\n\n/**\n * Generate markdown summary\n */\nexport function generateMarkdownSummary(report: PlaywrightReport): string {\n  const summary = getSummary(report);\n  const lines: string[] = [];\n\n  lines.push('# Test Results Summary');\n  lines.push('');\n  lines.push(`**Status**: ${summary.failed === 0 ? ' PASSED' : ' FAILED'}`);\n  lines.push(`**Duration**: ${Math.round(summary.duration / 1000)}s`);\n  lines.push('');\n  lines.push('## Stats');\n  lines.push('');\n  lines.push(`- Total: ${summary.total}`);\n  lines.push(`- Passed: ${summary.passed}`);\n  lines.push(`- Failed: ${summary.failed}`);\n  lines.push(`- Skipped: ${summary.skipped}`);\n  lines.push(`- Flaky: ${summary.flaky}`);\n\n  if (summary.failedTests.length > 0) {\n    lines.push('');\n    lines.push('## Failed Tests');\n    lines.push('');\n    for (const test of summary.failedTests) {\n      lines.push(`### ${test.titlePath.join(' > ')}`);\n      for (const error of test.errors) {\n        lines.push('');\n        lines.push('```');\n        lines.push(error.message);\n        lines.push('```');\n      }\n    }\n  }\n\n  if (summary.flakyTests.length > 0) {\n    lines.push('');\n    lines.push('## Flaky Tests');\n    lines.push('');\n    for (const test of summary.flakyTests) {\n      lines.push(`- ${test.titlePath.join(' > ')} (passed on retry ${test.retry})`);\n    }\n  }\n\n  return lines.join('\\n');\n}\n","/**\n * Failure Classifier - Categorize test failures for actionable remediation\n * @see T052 - Implement failure classifier (selector, timing, navigation, data, auth, env)\n */\nimport type { TestResult, TestError } from './parser.js';\n\n/**\n * Failure category\n */\nexport type FailureCategory =\n  | 'selector'    // Element not found, locator issue\n  | 'timing'      // Timeout, race condition\n  | 'navigation'  // URL mismatch, redirect issue\n  | 'data'        // Test data issue, assertion mismatch\n  | 'auth'        // Authentication failure\n  | 'env'         // Environment issue (network, config)\n  | 'script'      // Test script error (syntax, logic)\n  | 'unknown';    // Cannot classify\n\n/**\n * Failure classification result\n */\nexport interface FailureClassification {\n  /** Primary category */\n  category: FailureCategory;\n  /** Confidence level (0-1) */\n  confidence: number;\n  /** Human-readable explanation */\n  explanation: string;\n  /** Suggested fix */\n  suggestion: string;\n  /** Whether this is likely a test issue vs app issue */\n  isTestIssue: boolean;\n  /** Keywords that triggered classification */\n  matchedKeywords: string[];\n}\n\n/**\n * Classification patterns\n */\ninterface ClassificationPattern {\n  category: FailureCategory;\n  keywords: RegExp[];\n  explanation: string;\n  suggestion: string;\n  isTestIssue: boolean;\n}\n\n/**\n * Patterns for classifying failures\n */\nconst CLASSIFICATION_PATTERNS: ClassificationPattern[] = [\n  // Selector issues\n  {\n    category: 'selector',\n    keywords: [\n      /locator\\s+resolved\\s+to\\s+\\d+\\s+elements/i,\n      /locator\\.click:\\s+Error/i,\n      /waiting\\s+for\\s+locator/i,\n      /element\\s+is\\s+not\\s+visible/i,\n      /element\\s+is\\s+not\\s+attached/i,\n      /element\\s+is\\s+not\\s+enabled/i,\n      /getBy\\w+\\s*\\([^)]+\\)/i,\n      /strict\\s+mode\\s+violation/i,\n      /No\\s+element\\s+matches\\s+selector/i,\n      /Target\\s+closed/i,\n      /element\\s+is\\s+outside\\s+of\\s+the\\s+viewport/i,\n    ],\n    explanation: 'Element locator failed to find or interact with element',\n    suggestion: 'Update selector to use more stable locator strategy (role, label, testid)',\n    isTestIssue: true,\n  },\n\n  // Timing issues\n  {\n    category: 'timing',\n    keywords: [\n      /timeout\\s+\\d+ms\\s+exceeded/i,\n      /exceeded\\s+while\\s+waiting/i,\n      /timed?\\s*out/i,\n      /waiting\\s+for\\s+navigation/i,\n      /waiting\\s+for\\s+load\\s+state/i,\n      /response\\s+took\\s+too\\s+long/i,\n      /expect\\.\\w+:\\s+Timeout/i,\n      /navigation\\s+was\\s+interrupted/i,\n    ],\n    explanation: 'Operation timed out waiting for element or network',\n    suggestion: 'Increase timeout or add explicit wait for expected state',\n    isTestIssue: true,\n  },\n\n  // Navigation issues\n  {\n    category: 'navigation',\n    keywords: [\n      /expected\\s+url.*to.*match/i,\n      /expected.*toHaveURL/i,\n      /page\\s+has\\s+been\\s+closed/i,\n      /navigation\\s+failed/i,\n      /net::ERR_/i,\n      /ERR_CONNECTION/i,\n      /ERR_NAME_NOT_RESOLVED/i,\n      /redirect/i,\n      /page\\.goto:\\s+Error/i,\n      /URL\\s+is\\s+not\\s+valid/i,\n    ],\n    explanation: 'Navigation to URL failed or URL mismatch',\n    suggestion: 'Check URL configuration and network connectivity',\n    isTestIssue: false,\n  },\n\n  // Data/assertion issues\n  {\n    category: 'data',\n    keywords: [\n      /expected.*to\\s+(?:be|equal|match|contain|have)/i,\n      /received.*but\\s+expected/i,\n      /toEqual/i,\n      /toBe\\(/i,\n      /toContain/i,\n      /toHaveText/i,\n      /toHaveValue/i,\n      /assertion\\s+failed/i,\n      /expected\\s+value/i,\n      /does\\s+not\\s+match/i,\n    ],\n    explanation: 'Assertion failed due to unexpected data',\n    suggestion: 'Verify test data matches expected application state',\n    isTestIssue: false,\n  },\n\n  // Auth issues\n  {\n    category: 'auth',\n    keywords: [\n      /401\\s+Unauthorized/i,\n      /403\\s+Forbidden/i,\n      /authentication\\s+failed/i,\n      /login\\s+failed/i,\n      /session\\s+expired/i,\n      /token\\s+invalid/i,\n      /access\\s+denied/i,\n      /not\\s+authenticated/i,\n      /sign\\s*in\\s+required/i,\n      /invalid\\s+credentials/i,\n    ],\n    explanation: 'Authentication or authorization failed',\n    suggestion: 'Check authentication state and credentials',\n    isTestIssue: false,\n  },\n\n  // Environment issues\n  {\n    category: 'env',\n    keywords: [\n      /ECONNREFUSED/i,\n      /ENOTFOUND/i,\n      /ETIMEDOUT/i,\n      /connection\\s+refused/i,\n      /network\\s+error/i,\n      /502\\s+Bad\\s+Gateway/i,\n      /503\\s+Service\\s+Unavailable/i,\n      /504\\s+Gateway\\s+Timeout/i,\n      /server\\s+error/i,\n      /browser\\s+has\\s+been\\s+closed/i,\n      /browser\\s+crash/i,\n      /context\\s+closed/i,\n    ],\n    explanation: 'Environment or infrastructure issue',\n    suggestion: 'Check application availability and environment configuration',\n    isTestIssue: false,\n  },\n\n  // Script errors\n  {\n    category: 'script',\n    keywords: [\n      /SyntaxError/i,\n      /TypeError/i,\n      /ReferenceError/i,\n      /undefined\\s+is\\s+not/i,\n      /is\\s+not\\s+a\\s+function/i,\n      /Cannot\\s+read\\s+propert/i,\n      /null\\s+is\\s+not/i,\n      /is\\s+not\\s+defined/i,\n      /Unexpected\\s+token/i,\n    ],\n    explanation: 'Test script has a code error',\n    suggestion: 'Fix the JavaScript/TypeScript error in the test',\n    isTestIssue: true,\n  },\n];\n\n/**\n * Classify a single error message\n */\nexport function classifyError(error: TestError): FailureClassification {\n  const errorText = `${error.message} ${error.stack || ''}`;\n  const matchedKeywords: string[] = [];\n  let bestMatch: ClassificationPattern | null = null;\n  let maxMatches = 0;\n\n  for (const pattern of CLASSIFICATION_PATTERNS) {\n    let matches = 0;\n    const patternMatches: string[] = [];\n\n    for (const keyword of pattern.keywords) {\n      if (keyword.test(errorText)) {\n        matches++;\n        patternMatches.push(keyword.source);\n      }\n    }\n\n    if (matches > maxMatches) {\n      maxMatches = matches;\n      bestMatch = pattern;\n      matchedKeywords.length = 0;\n      matchedKeywords.push(...patternMatches);\n    }\n  }\n\n  if (bestMatch && maxMatches > 0) {\n    return {\n      category: bestMatch.category,\n      confidence: Math.min(maxMatches / 3, 1), // Normalize to 0-1\n      explanation: bestMatch.explanation,\n      suggestion: bestMatch.suggestion,\n      isTestIssue: bestMatch.isTestIssue,\n      matchedKeywords,\n    };\n  }\n\n  return {\n    category: 'unknown',\n    confidence: 0,\n    explanation: 'Unable to classify failure',\n    suggestion: 'Review error details manually',\n    isTestIssue: false,\n    matchedKeywords: [],\n  };\n}\n\n/**\n * Classify a test result\n */\nexport function classifyTestResult(result: TestResult): FailureClassification {\n  if (result.status !== 'failed' || result.errors.length === 0) {\n    return {\n      category: 'unknown',\n      confidence: 0,\n      explanation: 'Test did not fail or has no errors',\n      suggestion: 'N/A',\n      isTestIssue: false,\n      matchedKeywords: [],\n    };\n  }\n\n  // Classify each error and aggregate\n  const classifications = result.errors.map(classifyError);\n\n  // Find the most confident classification\n  const best = classifications.reduce((prev, curr) =>\n    curr.confidence > prev.confidence ? curr : prev\n  );\n\n  return best;\n}\n\n/**\n * Classify multiple test results\n */\nexport function classifyTestResults(\n  results: TestResult[]\n): Map<string, FailureClassification> {\n  const classified = new Map<string, FailureClassification>();\n\n  for (const result of results) {\n    if (result.status === 'failed') {\n      const key = result.titlePath.join(' > ');\n      classified.set(key, classifyTestResult(result));\n    }\n  }\n\n  return classified;\n}\n\n/**\n * Get failure statistics by category\n */\nexport function getFailureStats(\n  classifications: Map<string, FailureClassification>\n): Record<FailureCategory, number> {\n  const stats: Record<FailureCategory, number> = {\n    selector: 0,\n    timing: 0,\n    navigation: 0,\n    data: 0,\n    auth: 0,\n    env: 0,\n    script: 0,\n    unknown: 0,\n  };\n\n  for (const classification of classifications.values()) {\n    stats[classification.category]++;\n  }\n\n  return stats;\n}\n\n/**\n * Check if failures are likely healable\n */\nexport function isHealable(classification: FailureClassification): boolean {\n  // Selector and timing issues are typically healable\n  return (\n    classification.category === 'selector' ||\n    classification.category === 'timing'\n  );\n}\n\n/**\n * Get healable failures\n */\nexport function getHealableFailures(\n  classifications: Map<string, FailureClassification>\n): Map<string, FailureClassification> {\n  const healable = new Map<string, FailureClassification>();\n\n  for (const [key, classification] of classifications.entries()) {\n    if (isHealable(classification)) {\n      healable.set(key, classification);\n    }\n  }\n\n  return healable;\n}\n\n/**\n * Generate classification report\n */\nexport function generateClassificationReport(\n  classifications: Map<string, FailureClassification>\n): string {\n  const lines: string[] = [];\n  const stats = getFailureStats(classifications);\n\n  lines.push('# Failure Classification Report');\n  lines.push('');\n  lines.push('## Summary');\n  lines.push('');\n\n  for (const [category, count] of Object.entries(stats)) {\n    if (count > 0) {\n      lines.push(`- ${category}: ${count}`);\n    }\n  }\n\n  lines.push('');\n  lines.push('## Detailed Classifications');\n  lines.push('');\n\n  for (const [testName, classification] of classifications.entries()) {\n    lines.push(`### ${testName}`);\n    lines.push('');\n    lines.push(`- **Category**: ${classification.category}`);\n    lines.push(`- **Confidence**: ${Math.round(classification.confidence * 100)}%`);\n    lines.push(`- **Explanation**: ${classification.explanation}`);\n    lines.push(`- **Suggestion**: ${classification.suggestion}`);\n    lines.push(`- **Is Test Issue**: ${classification.isTestIssue ? 'Yes' : 'No'}`);\n    lines.push('');\n  }\n\n  return lines.join('\\n');\n}\n","/**\n * Stability Gate - Check for flaky tests with repeat execution\n * @see T053 - Implement stability gate (--repeat-each, --fail-on-flaky-tests)\n */\nimport { runPlaywrightSync, type RunnerOptions, type RunnerResult } from './runner.js';\nimport { parseReportFile, getSummary, type ParsedSummary } from './parser.js';\n\n/**\n * Stability check options\n */\nexport interface StabilityOptions extends Omit<RunnerOptions, 'repeatEach' | 'failOnFlaky'> {\n  /** Number of times to repeat each test */\n  repeatCount?: number;\n  /** Maximum allowed flaky rate (0-1) */\n  maxFlakyRate?: number;\n  /** Whether to stop on first flaky detection */\n  stopOnFlaky?: boolean;\n}\n\n/**\n * Stability check result\n */\nexport interface StabilityResult {\n  /** Whether all tests are stable */\n  stable: boolean;\n  /** Number of runs completed */\n  runsCompleted: number;\n  /** Flaky tests detected */\n  flakyTests: string[];\n  /** Flaky rate (flaky / total) */\n  flakyRate: number;\n  /** Summary of each run */\n  runSummaries: ParsedSummary[];\n  /** Runner result from final run */\n  runnerResult: RunnerResult;\n}\n\nconst DEFAULT_OPTIONS: Required<Pick<StabilityOptions, 'repeatCount' | 'maxFlakyRate' | 'stopOnFlaky'>> = {\n  repeatCount: 3,\n  maxFlakyRate: 0,\n  stopOnFlaky: false,\n};\n\n/**\n * Run stability check on tests\n */\nexport function checkStability(\n  options: StabilityOptions = {}\n): StabilityResult {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n\n  const result: StabilityResult = {\n    stable: true,\n    runsCompleted: 0,\n    flakyTests: [],\n    flakyRate: 0,\n    runSummaries: [],\n    runnerResult: {\n      success: false,\n      exitCode: 0,\n      stdout: '',\n      stderr: '',\n      duration: 0,\n      command: '',\n    },\n  };\n\n  // Run tests with repeat-each\n  const runnerResult = runPlaywrightSync({\n    ...options,\n    repeatEach: opts.repeatCount,\n    failOnFlaky: true,\n  });\n\n  result.runnerResult = runnerResult;\n  result.runsCompleted = opts.repeatCount;\n\n  // Parse report if available\n  if (runnerResult.reportPath) {\n    const report = parseReportFile(runnerResult.reportPath);\n    if (report) {\n      const summary = getSummary(report);\n      result.runSummaries.push(summary);\n\n      // Extract flaky tests\n      result.flakyTests = summary.flakyTests.map((t) => t.titlePath.join(' > '));\n\n      // Calculate flaky rate\n      result.flakyRate = summary.total > 0 ? summary.flaky / summary.total : 0;\n\n      // Check stability\n      result.stable = result.flakyRate <= opts.maxFlakyRate;\n    }\n  }\n\n  // If runner failed and no report, check stdout for flaky indication\n  if (!runnerResult.success && result.flakyTests.length === 0) {\n    if (runnerResult.stdout.includes('flaky') || runnerResult.stderr.includes('flaky')) {\n      result.stable = false;\n    }\n  }\n\n  return result;\n}\n\n/**\n * Quick stability check (2 runs)\n */\nexport function quickStabilityCheck(\n  options: Omit<StabilityOptions, 'repeatCount'> = {}\n): StabilityResult {\n  return checkStability({\n    ...options,\n    repeatCount: 2,\n  });\n}\n\n/**\n * Thorough stability check (5 runs)\n */\nexport function thoroughStabilityCheck(\n  options: Omit<StabilityOptions, 'repeatCount'> = {}\n): StabilityResult {\n  return checkStability({\n    ...options,\n    repeatCount: 5,\n  });\n}\n\n/**\n * Check if a specific test is stable\n */\nexport function isTestStable(\n  testFile: string,\n  testName: string,\n  repeatCount: number = 3,\n  options: Omit<StabilityOptions, 'repeatCount' | 'testFile' | 'grep'> = {}\n): boolean {\n  const result = checkStability({\n    ...options,\n    testFile,\n    grep: testName,\n    repeatCount,\n  });\n\n  return result.stable;\n}\n\n/**\n * Get flakiness score (0 = stable, 1 = always flaky)\n */\nexport function getFlakinessScore(result: StabilityResult): number {\n  if (result.runsCompleted === 0) return 0;\n  return result.flakyRate;\n}\n\n/**\n * Determine if test should be quarantined based on stability\n */\nexport function shouldQuarantine(\n  result: StabilityResult,\n  threshold: number = 0.3\n): boolean {\n  return result.flakyRate > threshold;\n}\n\n/**\n * Generate stability report\n */\nexport function generateStabilityReport(result: StabilityResult): string {\n  const lines: string[] = [];\n\n  lines.push('# Stability Check Report');\n  lines.push('');\n  lines.push(`**Status**: ${result.stable ? ' STABLE' : ' UNSTABLE'}`);\n  lines.push(`**Runs Completed**: ${result.runsCompleted}`);\n  lines.push(`**Flaky Rate**: ${Math.round(result.flakyRate * 100)}%`);\n  lines.push('');\n\n  if (result.flakyTests.length > 0) {\n    lines.push('## Flaky Tests Detected');\n    lines.push('');\n    for (const test of result.flakyTests) {\n      lines.push(`- ${test}`);\n    }\n    lines.push('');\n    lines.push('### Recommendations');\n    lines.push('');\n    lines.push('1. Review test steps for race conditions');\n    lines.push('2. Add explicit waits for expected states');\n    lines.push('3. Check for shared state between tests');\n    lines.push('4. Consider isolation improvements');\n  } else {\n    lines.push('## All Tests Stable');\n    lines.push('');\n    lines.push('No flakiness detected after repeated runs.');\n  }\n\n  return lines.join('\\n');\n}\n","/**\n * Evidence Capture - ARIA snapshots and screenshots for debugging\n * @see T054 - Implement ARIA snapshot capture helper\n */\nimport { existsSync, mkdirSync, writeFileSync, readFileSync } from 'node:fs';\nimport { join } from 'node:path';\n\n/**\n * ARIA snapshot for an element\n */\nexport interface ARIASnapshot {\n  /** Role of the element */\n  role: string;\n  /** Accessible name */\n  name?: string;\n  /** Current value */\n  value?: string;\n  /** Whether element is disabled */\n  disabled?: boolean;\n  /** Whether element is checked (for checkboxes/radios) */\n  checked?: boolean;\n  /** Whether element is expanded (for accordions/dropdowns) */\n  expanded?: boolean;\n  /** Whether element is pressed (for toggle buttons) */\n  pressed?: boolean;\n  /** Hierarchical level (for headings) */\n  level?: number;\n  /** Child elements */\n  children?: ARIASnapshot[];\n  /** Element's text content */\n  text?: string;\n  /** Additional ARIA attributes */\n  attributes?: Record<string, string>;\n}\n\n/**\n * Evidence collection result\n */\nexport interface Evidence {\n  /** Timestamp of collection */\n  timestamp: string;\n  /** URL where evidence was captured */\n  url: string;\n  /** Page title */\n  title: string;\n  /** ARIA snapshot of the page */\n  ariaSnapshot?: ARIASnapshot;\n  /** Path to screenshot */\n  screenshotPath?: string;\n  /** Path to trace file */\n  tracePath?: string;\n  /** Console messages */\n  consoleMessages?: string[];\n  /** Network errors */\n  networkErrors?: string[];\n  /** Custom metadata */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Evidence collection options\n */\nexport interface EvidenceOptions {\n  /** Directory to save evidence */\n  outputDir?: string;\n  /** Capture screenshot */\n  captureScreenshot?: boolean;\n  /** Capture ARIA snapshot */\n  captureAria?: boolean;\n  /** Capture console logs */\n  captureConsole?: boolean;\n  /** Capture network errors */\n  captureNetwork?: boolean;\n  /** Custom filename prefix */\n  prefix?: string;\n}\n\n/**\n * Generate Playwright code for capturing ARIA snapshot\n */\nexport function generateARIACaptureCode(): string {\n  return `\n// ARIA Snapshot Helper - Insert this in your test for debugging\nasync function captureARIASnapshot(page) {\n  return await page.evaluate(() => {\n    function getSnapshot(element) {\n      const role = element.getAttribute('role') ||\n                   element.tagName.toLowerCase();\n\n      const snapshot = { role };\n\n      // Get accessible name\n      const name = element.getAttribute('aria-label') ||\n                   element.getAttribute('aria-labelledby') ?\n                   document.getElementById(element.getAttribute('aria-labelledby'))?.textContent :\n                   element.textContent?.trim().slice(0, 100);\n      if (name) snapshot.name = name;\n\n      // Get ARIA states\n      if (element.getAttribute('aria-disabled') === 'true') {\n        snapshot.disabled = true;\n      }\n      if (element.getAttribute('aria-checked') === 'true') {\n        snapshot.checked = true;\n      }\n      if (element.getAttribute('aria-expanded') === 'true') {\n        snapshot.expanded = true;\n      }\n      if (element.getAttribute('aria-pressed') === 'true') {\n        snapshot.pressed = true;\n      }\n\n      // Get heading level\n      const levelMatch = element.tagName.match(/^H(\\\\d)$/i);\n      if (levelMatch) {\n        snapshot.level = parseInt(levelMatch[1], 10);\n      }\n\n      // Get children\n      const children = Array.from(element.children)\n        .map(child => getSnapshot(child))\n        .filter(c => c.role !== 'none' && c.role !== 'presentation');\n\n      if (children.length > 0) {\n        snapshot.children = children;\n      }\n\n      return snapshot;\n    }\n\n    return getSnapshot(document.body);\n  });\n}\n`.trim();\n}\n\n/**\n * Generate Playwright code for full evidence capture\n */\nexport function generateEvidenceCaptureCode(options: EvidenceOptions = {}): string {\n  const {\n    captureScreenshot = true,\n    captureAria = true,\n    captureConsole = true,\n  } = options;\n\n  const parts: string[] = [];\n\n  parts.push('// Evidence Capture Helper');\n  parts.push('const evidence = {');\n  parts.push('  timestamp: new Date().toISOString(),');\n  parts.push('  url: page.url(),');\n  parts.push('  title: await page.title(),');\n\n  if (captureAria) {\n    parts.push('  ariaSnapshot: await captureARIASnapshot(page),');\n  }\n\n  if (captureScreenshot) {\n    parts.push('  screenshotPath: await page.screenshot({ path: \"evidence.png\" }),');\n  }\n\n  if (captureConsole) {\n    parts.push('  consoleMessages: [], // Collect from page.on(\"console\")');\n  }\n\n  parts.push('};');\n\n  return parts.join('\\n');\n}\n\n/**\n * Create evidence directory\n */\nexport function createEvidenceDir(basePath: string, testId: string): string {\n  const evidenceDir = join(basePath, 'evidence', testId);\n  mkdirSync(evidenceDir, { recursive: true });\n  return evidenceDir;\n}\n\n/**\n * Save evidence to file\n */\nexport function saveEvidence(\n  evidence: Evidence,\n  outputDir: string,\n  testId: string\n): string {\n  const dir = createEvidenceDir(outputDir, testId);\n  const filename = `evidence-${Date.now()}.json`;\n  const filepath = join(dir, filename);\n\n  writeFileSync(filepath, JSON.stringify(evidence, null, 2), 'utf-8');\n  return filepath;\n}\n\n/**\n * Load evidence from file\n */\nexport function loadEvidence(filepath: string): Evidence | null {\n  if (!existsSync(filepath)) {\n    return null;\n  }\n\n  try {\n    const content = readFileSync(filepath, 'utf-8');\n    return JSON.parse(content) as Evidence;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Compare two ARIA snapshots\n */\nexport function compareARIASnapshots(\n  expected: ARIASnapshot,\n  actual: ARIASnapshot\n): { matches: boolean; differences: string[] } {\n  const differences: string[] = [];\n\n  function compare(\n    path: string,\n    exp: ARIASnapshot,\n    act: ARIASnapshot\n  ): void {\n    if (exp.role !== act.role) {\n      differences.push(`${path}: role mismatch (expected: ${exp.role}, actual: ${act.role})`);\n    }\n\n    if (exp.name !== act.name) {\n      differences.push(`${path}: name mismatch (expected: ${exp.name}, actual: ${act.name})`);\n    }\n\n    if (exp.disabled !== act.disabled) {\n      differences.push(`${path}: disabled state mismatch`);\n    }\n\n    if (exp.checked !== act.checked) {\n      differences.push(`${path}: checked state mismatch`);\n    }\n\n    // Compare children\n    const expChildren = exp.children || [];\n    const actChildren = act.children || [];\n\n    if (expChildren.length !== actChildren.length) {\n      differences.push(`${path}: children count mismatch (expected: ${expChildren.length}, actual: ${actChildren.length})`);\n    }\n\n    const minLen = Math.min(expChildren.length, actChildren.length);\n    for (let i = 0; i < minLen; i++) {\n      compare(`${path}/${expChildren[i]!.role}[${i}]`, expChildren[i]!, actChildren[i]!);\n    }\n  }\n\n  compare('/', expected, actual);\n\n  return {\n    matches: differences.length === 0,\n    differences,\n  };\n}\n\n/**\n * Find element in ARIA snapshot by role and name\n */\nexport function findInSnapshot(\n  snapshot: ARIASnapshot,\n  role: string,\n  name?: string\n): ARIASnapshot | null {\n  if (snapshot.role === role && (!name || snapshot.name === name)) {\n    return snapshot;\n  }\n\n  for (const child of snapshot.children || []) {\n    const found = findInSnapshot(child, role, name);\n    if (found) return found;\n  }\n\n  return null;\n}\n\n/**\n * Generate ARIA tree as text\n */\nexport function formatARIATree(\n  snapshot: ARIASnapshot,\n  indent: number = 0\n): string {\n  const prefix = '  '.repeat(indent);\n  let line = `${prefix}${snapshot.role}`;\n\n  if (snapshot.name) {\n    line += ` \"${snapshot.name}\"`;\n  }\n\n  const states: string[] = [];\n  if (snapshot.disabled) states.push('disabled');\n  if (snapshot.checked) states.push('checked');\n  if (snapshot.expanded) states.push('expanded');\n  if (snapshot.pressed) states.push('pressed');\n  if (snapshot.level) states.push(`level=${snapshot.level}`);\n\n  if (states.length > 0) {\n    line += ` [${states.join(', ')}]`;\n  }\n\n  const lines = [line];\n\n  for (const child of snapshot.children || []) {\n    lines.push(formatARIATree(child, indent + 1));\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Generate evidence report\n */\nexport function generateEvidenceReport(evidence: Evidence): string {\n  const lines: string[] = [];\n\n  lines.push('# Evidence Report');\n  lines.push('');\n  lines.push(`**Captured**: ${evidence.timestamp}`);\n  lines.push(`**URL**: ${evidence.url}`);\n  lines.push(`**Title**: ${evidence.title}`);\n  lines.push('');\n\n  if (evidence.screenshotPath) {\n    lines.push('## Screenshot');\n    lines.push('');\n    lines.push(`![Screenshot](${evidence.screenshotPath})`);\n    lines.push('');\n  }\n\n  if (evidence.ariaSnapshot) {\n    lines.push('## ARIA Snapshot');\n    lines.push('');\n    lines.push('```');\n    lines.push(formatARIATree(evidence.ariaSnapshot));\n    lines.push('```');\n    lines.push('');\n  }\n\n  if (evidence.consoleMessages && evidence.consoleMessages.length > 0) {\n    lines.push('## Console Messages');\n    lines.push('');\n    for (const msg of evidence.consoleMessages) {\n      lines.push(`- ${msg}`);\n    }\n    lines.push('');\n  }\n\n  if (evidence.networkErrors && evidence.networkErrors.length > 0) {\n    lines.push('## Network Errors');\n    lines.push('');\n    for (const err of evidence.networkErrors) {\n      lines.push(`- ${err}`);\n    }\n    lines.push('');\n  }\n\n  return lines.join('\\n');\n}\n","/**\n * Verify Summary Generator - Generate structured JSON summary of test runs\n * @see T055 - Implement verify summary JSON generator\n */\nimport type { RunnerResult } from './runner.js';\nimport type { PlaywrightReport } from './parser.js';\nimport type { FailureClassification } from './classifier.js';\nimport type { StabilityResult } from './stability.js';\nimport { parseReportFile, getSummary, getFailedTests } from './parser.js';\nimport { classifyTestResults, getFailureStats } from './classifier.js';\n\n/**\n * Verification summary\n */\nexport interface VerifySummary {\n  /** Overall verification status */\n  status: 'passed' | 'failed' | 'flaky' | 'error';\n  /** Journey ID if available */\n  journeyId?: string;\n  /** Timestamp */\n  timestamp: string;\n  /** Duration in ms */\n  duration: number;\n  /** Test counts */\n  counts: {\n    total: number;\n    passed: number;\n    failed: number;\n    skipped: number;\n    flaky: number;\n  };\n  /** Failure analysis */\n  failures: {\n    tests: string[];\n    classifications: Record<string, FailureClassification>;\n    stats: Record<string, number>;\n  };\n  /** Stability information */\n  stability?: {\n    stable: boolean;\n    flakyTests: string[];\n    flakyRate: number;\n  };\n  /** Raw runner result */\n  runner: {\n    exitCode: number;\n    command: string;\n  };\n  /** Path to detailed report */\n  reportPath?: string;\n  /** Additional metadata */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Options for generating summary\n */\nexport interface SummaryOptions {\n  /** Journey ID to associate */\n  journeyId?: string;\n  /** Include stability results */\n  stabilityResult?: StabilityResult;\n  /** Additional metadata */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Generate verification summary from runner result\n */\nexport function generateVerifySummary(\n  runnerResult: RunnerResult,\n  options: SummaryOptions = {}\n): VerifySummary {\n  const summary: VerifySummary = {\n    status: 'error',\n    timestamp: new Date().toISOString(),\n    duration: runnerResult.duration,\n    counts: {\n      total: 0,\n      passed: 0,\n      failed: 0,\n      skipped: 0,\n      flaky: 0,\n    },\n    failures: {\n      tests: [],\n      classifications: {},\n      stats: {},\n    },\n    runner: {\n      exitCode: runnerResult.exitCode,\n      command: runnerResult.command,\n    },\n    reportPath: runnerResult.reportPath,\n  };\n\n  if (options.journeyId) {\n    summary.journeyId = options.journeyId;\n  }\n\n  if (options.metadata) {\n    summary.metadata = options.metadata;\n  }\n\n  // Parse report if available\n  if (runnerResult.reportPath) {\n    const report = parseReportFile(runnerResult.reportPath);\n    if (report) {\n      const parsed = getSummary(report);\n\n      // Update counts\n      summary.counts = {\n        total: parsed.total,\n        passed: parsed.passed,\n        failed: parsed.failed,\n        skipped: parsed.skipped,\n        flaky: parsed.flaky,\n      };\n\n      // Get failed tests\n      const failedTests = getFailedTests(report);\n      summary.failures.tests = failedTests.map((t) => t.titlePath.join(' > '));\n\n      // Classify failures\n      const classifications = classifyTestResults(failedTests);\n      summary.failures.classifications = Object.fromEntries(classifications);\n      summary.failures.stats = getFailureStats(classifications);\n\n      // Determine status\n      if (parsed.failed === 0) {\n        summary.status = parsed.flaky > 0 ? 'flaky' : 'passed';\n      } else {\n        summary.status = 'failed';\n      }\n    }\n  } else {\n    // No report - use runner result to determine status\n    summary.status = runnerResult.success ? 'passed' : 'failed';\n  }\n\n  // Add stability info if provided\n  if (options.stabilityResult) {\n    summary.stability = {\n      stable: options.stabilityResult.stable,\n      flakyTests: options.stabilityResult.flakyTests,\n      flakyRate: options.stabilityResult.flakyRate,\n    };\n\n    // Update status if unstable\n    if (!options.stabilityResult.stable && summary.status === 'passed') {\n      summary.status = 'flaky';\n    }\n  }\n\n  return summary;\n}\n\n/**\n * Generate summary from Playwright report directly\n */\nexport function generateSummaryFromReport(\n  report: PlaywrightReport,\n  options: SummaryOptions = {}\n): VerifySummary {\n  const parsed = getSummary(report);\n  const failedTests = getFailedTests(report);\n  const classifications = classifyTestResults(failedTests);\n\n  const summary: VerifySummary = {\n    status: parsed.failed === 0 ? (parsed.flaky > 0 ? 'flaky' : 'passed') : 'failed',\n    timestamp: parsed.startTime.toISOString(),\n    duration: parsed.duration,\n    counts: {\n      total: parsed.total,\n      passed: parsed.passed,\n      failed: parsed.failed,\n      skipped: parsed.skipped,\n      flaky: parsed.flaky,\n    },\n    failures: {\n      tests: failedTests.map((t) => t.titlePath.join(' > ')),\n      classifications: Object.fromEntries(classifications),\n      stats: getFailureStats(classifications),\n    },\n    runner: {\n      exitCode: parsed.failed > 0 ? 1 : 0,\n      command: 'N/A',\n    },\n  };\n\n  if (options.journeyId) {\n    summary.journeyId = options.journeyId;\n  }\n\n  if (options.metadata) {\n    summary.metadata = options.metadata;\n  }\n\n  return summary;\n}\n\n/**\n * Check if verification passed\n */\nexport function isVerificationPassed(summary: VerifySummary): boolean {\n  return summary.status === 'passed';\n}\n\n/**\n * Check if verification has failures\n */\nexport function hasFailures(summary: VerifySummary): boolean {\n  return summary.counts.failed > 0;\n}\n\n/**\n * Check if verification has flaky tests\n */\nexport function summaryHasFlaky(summary: VerifySummary): boolean {\n  return summary.counts.flaky > 0 || summary.stability?.flakyRate !== undefined && summary.stability.flakyRate > 0;\n}\n\n/**\n * Get actionable recommendations based on failures\n */\nexport function getRecommendations(summary: VerifySummary): string[] {\n  const recommendations: string[] = [];\n\n  if (summary.counts.failed > 0) {\n    // Analyze failure categories\n    const stats = summary.failures.stats;\n\n    if (stats.selector! > 0) {\n      recommendations.push(\n        `${stats.selector} selector issue(s): Update locators to use stable selectors (role, label, testid)`\n      );\n    }\n\n    if (stats.timing! > 0) {\n      recommendations.push(\n        `${stats.timing} timing issue(s): Add explicit waits or increase timeout`\n      );\n    }\n\n    if (stats.auth! > 0) {\n      recommendations.push(\n        `${stats.auth} auth issue(s): Check authentication state and credentials`\n      );\n    }\n\n    if (stats.env! > 0) {\n      recommendations.push(\n        `${stats.env} environment issue(s): Verify application is running and accessible`\n      );\n    }\n\n    if (stats.data! > 0) {\n      recommendations.push(\n        `${stats.data} data issue(s): Review test data and expected values`\n      );\n    }\n  }\n\n  if (summary.stability && !summary.stability.stable) {\n    recommendations.push(\n      `${summary.stability.flakyTests.length} flaky test(s) detected: Review for race conditions and add proper waits`\n    );\n  }\n\n  return recommendations;\n}\n\n/**\n * Generate human-readable summary\n */\nexport function formatVerifySummary(summary: VerifySummary): string {\n  const lines: string[] = [];\n\n  // Status header\n  const statusIcon =\n    summary.status === 'passed'\n      ? ''\n      : summary.status === 'flaky'\n      ? ''\n      : '';\n\n  lines.push(`${statusIcon} Verification ${summary.status.toUpperCase()}`);\n  lines.push('');\n\n  // Journey info\n  if (summary.journeyId) {\n    lines.push(`Journey: ${summary.journeyId}`);\n  }\n\n  lines.push(`Duration: ${Math.round(summary.duration / 1000)}s`);\n  lines.push('');\n\n  // Counts\n  lines.push('## Results');\n  lines.push(`- Total: ${summary.counts.total}`);\n  lines.push(`- Passed: ${summary.counts.passed}`);\n  lines.push(`- Failed: ${summary.counts.failed}`);\n  lines.push(`- Skipped: ${summary.counts.skipped}`);\n  lines.push(`- Flaky: ${summary.counts.flaky}`);\n  lines.push('');\n\n  // Failures\n  if (summary.failures.tests.length > 0) {\n    lines.push('## Failed Tests');\n    for (const test of summary.failures.tests) {\n      lines.push(`- ${test}`);\n    }\n    lines.push('');\n  }\n\n  // Stability\n  if (summary.stability) {\n    lines.push('## Stability');\n    lines.push(`- Stable: ${summary.stability.stable ? 'Yes' : 'No'}`);\n    lines.push(`- Flaky Rate: ${Math.round(summary.stability.flakyRate * 100)}%`);\n    lines.push('');\n  }\n\n  // Recommendations\n  const recommendations = getRecommendations(summary);\n  if (recommendations.length > 0) {\n    lines.push('## Recommendations');\n    for (const rec of recommendations) {\n      lines.push(`- ${rec}`);\n    }\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Save summary to JSON file\n */\nexport function saveSummary(summary: VerifySummary, outputPath: string): void {\n  const { writeFileSync, mkdirSync } = require('node:fs');\n  const { dirname } = require('node:path');\n\n  mkdirSync(dirname(outputPath), { recursive: true });\n  writeFileSync(outputPath, JSON.stringify(summary, null, 2), 'utf-8');\n}\n","/**\n * Verification module exports\n */\n\n// Runner\nexport {\n  type RunnerOptions,\n  type RunnerResult,\n  isPlaywrightAvailable,\n  getPlaywrightVersion,\n  buildPlaywrightArgs,\n  runPlaywrightSync,\n  runPlaywrightAsync,\n  runTestFile,\n  runJourneyTests,\n  checkTestSyntax,\n  writeAndRunTest,\n  getTestCount,\n} from './runner.js';\n\n// Parser\nexport {\n  type TestStatus,\n  type ErrorAttachment,\n  type TestError,\n  type ReportStep,\n  type TestResult,\n  type TestSuite,\n  type TestSpec,\n  type PlaywrightReport,\n  type ParsedSummary,\n  parseReportFile,\n  parseReportContent,\n  extractTestResults,\n  getSummary,\n  getFailedTests,\n  getFlakyTests,\n  findTestsByTitle,\n  findTestsByTag,\n  extractErrorMessages,\n  extractErrorStacks,\n  getFailedStep,\n  isReportSuccessful,\n  reportHasFlaky,\n  formatTestResult,\n  generateMarkdownSummary,\n} from './parser.js';\n\n// Classifier\nexport {\n  type FailureCategory,\n  type FailureClassification,\n  classifyError,\n  classifyTestResult,\n  classifyTestResults,\n  getFailureStats,\n  isHealable,\n  getHealableFailures,\n  generateClassificationReport,\n} from './classifier.js';\n\n// Stability\nexport {\n  type StabilityOptions,\n  type StabilityResult,\n  checkStability,\n  quickStabilityCheck,\n  thoroughStabilityCheck,\n  isTestStable,\n  getFlakinessScore,\n  shouldQuarantine,\n  generateStabilityReport,\n} from './stability.js';\n\n// Evidence\nexport {\n  type ARIASnapshot,\n  type Evidence,\n  type EvidenceOptions,\n  generateARIACaptureCode,\n  generateEvidenceCaptureCode,\n  createEvidenceDir,\n  saveEvidence,\n  loadEvidence,\n  compareARIASnapshots,\n  findInSnapshot,\n  formatARIATree,\n  generateEvidenceReport,\n} from './evidence.js';\n\n// Summary\nexport {\n  type VerifySummary,\n  type SummaryOptions,\n  generateVerifySummary,\n  generateSummaryFromReport,\n  isVerificationPassed,\n  hasFailures,\n  summaryHasFlaky,\n  getRecommendations,\n  formatVerifySummary,\n  saveSummary,\n} from './summary.js';\n","/**\n * Healing Rules - Define allowed and forbidden healing operations\n * @see T061 - Define healing rules (allowed/forbidden fixes) per detailed spec Section 16\n */\nimport type { FailureCategory, FailureClassification } from '../verify/classifier.js';\n\n/**\n * Types of healing fixes\n */\nexport type HealFixType =\n  | 'selector-refine'      // Replace CSS with role/label/testid\n  | 'add-exact'            // Add exact: true to locator\n  | 'missing-await'        // Add missing await\n  | 'navigation-wait'      // Add waitForURL/toHaveURL\n  | 'timeout-increase'     // Increase timeout (bounded)\n  | 'web-first-assertion'; // Convert to web-first assertion\n\n/**\n * Forbidden fix types that must never be applied\n */\nexport type ForbiddenFixType =\n  | 'add-sleep'            // Never add waitForTimeout\n  | 'remove-assertion'     // Never remove assertions\n  | 'weaken-assertion'     // Never change toBe to toContain\n  | 'force-click'          // Never add force: true\n  | 'bypass-auth';         // Never skip authentication\n\n/**\n * Healing rule definition\n */\nexport interface HealingRule {\n  /** Fix type identifier */\n  fixType: HealFixType;\n  /** Categories this fix applies to */\n  appliesTo: FailureCategory[];\n  /** Priority (lower = try first) */\n  priority: number;\n  /** Human-readable description */\n  description: string;\n  /** Whether enabled by default */\n  enabledByDefault: boolean;\n}\n\n/**\n * Healing configuration\n */\nexport interface HealingConfig {\n  /** Whether healing is enabled */\n  enabled: boolean;\n  /** Maximum healing attempts */\n  maxAttempts: number;\n  /** Allowed fix types */\n  allowedFixes: HealFixType[];\n  /** Forbidden fix types (always blocked) */\n  forbiddenFixes: ForbiddenFixType[];\n  /** Timeout increase limit in ms */\n  maxTimeoutIncrease: number;\n}\n\n/**\n * Healing rule result\n */\nexport interface HealingRuleResult {\n  /** Whether healing is allowed for this failure */\n  canHeal: boolean;\n  /** Applicable fix types in priority order */\n  applicableFixes: HealFixType[];\n  /** Reason if healing not allowed */\n  reason?: string;\n}\n\n/**\n * Default healing rules\n */\nexport const DEFAULT_HEALING_RULES: HealingRule[] = [\n  {\n    fixType: 'missing-await',\n    appliesTo: ['selector', 'timing', 'script'],\n    priority: 1,\n    description: 'Add missing await to async operations',\n    enabledByDefault: true,\n  },\n  {\n    fixType: 'selector-refine',\n    appliesTo: ['selector'],\n    priority: 2,\n    description: 'Replace CSS selector with role/label/testid',\n    enabledByDefault: true,\n  },\n  {\n    fixType: 'add-exact',\n    appliesTo: ['selector'],\n    priority: 3,\n    description: 'Add exact: true to resolve ambiguous locators',\n    enabledByDefault: true,\n  },\n  {\n    fixType: 'navigation-wait',\n    appliesTo: ['navigation', 'timing'],\n    priority: 4,\n    description: 'Add waitForURL or toHaveURL assertion',\n    enabledByDefault: true,\n  },\n  {\n    fixType: 'web-first-assertion',\n    appliesTo: ['timing', 'data'],\n    priority: 5,\n    description: 'Convert to auto-retrying web-first assertion',\n    enabledByDefault: true,\n  },\n  {\n    fixType: 'timeout-increase',\n    appliesTo: ['timing'],\n    priority: 6,\n    description: 'Increase operation timeout (bounded)',\n    enabledByDefault: false, // Disabled by default as it can mask real issues\n  },\n];\n\n/**\n * Default healing configuration\n */\nexport const DEFAULT_HEALING_CONFIG: HealingConfig = {\n  enabled: true,\n  maxAttempts: 3,\n  allowedFixes: [\n    'selector-refine',\n    'add-exact',\n    'missing-await',\n    'navigation-wait',\n    'web-first-assertion',\n  ],\n  forbiddenFixes: [\n    'add-sleep',\n    'remove-assertion',\n    'weaken-assertion',\n    'force-click',\n    'bypass-auth',\n  ],\n  maxTimeoutIncrease: 30000, // Max 30 seconds\n};\n\n/**\n * Categories that cannot be healed automatically\n */\nexport const UNHEALABLE_CATEGORIES: FailureCategory[] = [\n  'auth',     // Requires credential/session fix\n  'env',      // Requires environment fix\n  'unknown',  // Cannot determine appropriate fix\n];\n\n/**\n * Check if a failure category is healable\n */\nexport function isCategoryHealable(category: FailureCategory): boolean {\n  return !UNHEALABLE_CATEGORIES.includes(category);\n}\n\n/**\n * Get applicable healing rules for a failure classification\n */\nexport function getApplicableRules(\n  classification: FailureClassification,\n  config: HealingConfig = DEFAULT_HEALING_CONFIG\n): HealingRule[] {\n  if (!config.enabled) {\n    return [];\n  }\n\n  if (!isCategoryHealable(classification.category)) {\n    return [];\n  }\n\n  return DEFAULT_HEALING_RULES\n    .filter((rule) => {\n      // Must apply to this failure category\n      if (!rule.appliesTo.includes(classification.category)) {\n        return false;\n      }\n      // Must be in allowed list\n      if (!config.allowedFixes.includes(rule.fixType)) {\n        return false;\n      }\n      return true;\n    })\n    .sort((a, b) => a.priority - b.priority);\n}\n\n/**\n * Evaluate healing possibilities for a failure\n */\nexport function evaluateHealing(\n  classification: FailureClassification,\n  config: HealingConfig = DEFAULT_HEALING_CONFIG\n): HealingRuleResult {\n  if (!config.enabled) {\n    return {\n      canHeal: false,\n      applicableFixes: [],\n      reason: 'Healing is disabled',\n    };\n  }\n\n  if (!isCategoryHealable(classification.category)) {\n    return {\n      canHeal: false,\n      applicableFixes: [],\n      reason: `Category '${classification.category}' cannot be healed automatically`,\n    };\n  }\n\n  const applicableRules = getApplicableRules(classification, config);\n\n  if (applicableRules.length === 0) {\n    return {\n      canHeal: false,\n      applicableFixes: [],\n      reason: 'No applicable healing rules for this failure',\n    };\n  }\n\n  return {\n    canHeal: true,\n    applicableFixes: applicableRules.map((r) => r.fixType),\n  };\n}\n\n/**\n * Get the next fix to try for a failure\n */\nexport function getNextFix(\n  classification: FailureClassification,\n  attemptedFixes: HealFixType[],\n  config: HealingConfig = DEFAULT_HEALING_CONFIG\n): HealFixType | null {\n  const evaluation = evaluateHealing(classification, config);\n\n  if (!evaluation.canHeal) {\n    return null;\n  }\n\n  // Find first fix that hasn't been tried\n  for (const fix of evaluation.applicableFixes) {\n    if (!attemptedFixes.includes(fix)) {\n      return fix;\n    }\n  }\n\n  return null; // All fixes exhausted\n}\n\n/**\n * Validate that a proposed fix is allowed\n */\nexport function isFixAllowed(\n  fixType: HealFixType,\n  config: HealingConfig = DEFAULT_HEALING_CONFIG\n): boolean {\n  return config.enabled && config.allowedFixes.includes(fixType);\n}\n\n/**\n * Validate that a fix is not forbidden\n */\nexport function isFixForbidden(\n  fixType: string\n): fixType is ForbiddenFixType {\n  const forbidden: string[] = [\n    'add-sleep',\n    'remove-assertion',\n    'weaken-assertion',\n    'force-click',\n    'bypass-auth',\n  ];\n  return forbidden.includes(fixType);\n}\n\n/**\n * Get healing recommendation based on failure\n */\nexport function getHealingRecommendation(\n  classification: FailureClassification\n): string {\n  switch (classification.category) {\n    case 'selector':\n      return 'Refine selector to use role, label, or testid locator strategy';\n    case 'timing':\n      return 'Add explicit wait for expected state or use web-first assertion';\n    case 'navigation':\n      return 'Add waitForURL or toHaveURL assertion after navigation';\n    case 'data':\n      return 'Verify test data and consider using expect.poll for dynamic values';\n    case 'auth':\n      return 'Check authentication state; may need to refresh session';\n    case 'env':\n      return 'Verify environment connectivity and application availability';\n    case 'script':\n      return 'Fix the JavaScript/TypeScript error in the test code';\n    default:\n      return 'Review error details manually to determine appropriate fix';\n  }\n}\n\n/**\n * Get next steps after healing exhausted\n */\nexport function getPostHealingRecommendation(\n  classification: FailureClassification,\n  attemptCount: number\n): string {\n  const baseMsg = `Healing exhausted after ${attemptCount} attempts.`;\n\n  switch (classification.category) {\n    case 'selector':\n      return `${baseMsg} Consider adding data-testid to the target element or quarantining the test.`;\n    case 'timing':\n      return `${baseMsg} The application may have a genuine performance issue. Consider quarantining.`;\n    case 'navigation':\n      return `${baseMsg} The navigation flow may have changed. Review Journey steps.`;\n    default:\n      return `${baseMsg} Consider quarantining the test and filing a bug report.`;\n  }\n}\n","/**\n * Healing Attempt Logger - Track healing attempts in heal-log.json\n * @see T066 - Implement healing attempt logger (heal-log.json)\n */\nimport { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs';\nimport { dirname, join } from 'node:path';\nimport type { HealFixType } from './rules.js';\nimport type { FailureCategory } from '../verify/classifier.js';\n\n/**\n * Single healing attempt record\n */\nexport interface HealingAttempt {\n  /** Attempt number (1-based) */\n  attempt: number;\n  /** Timestamp of the attempt */\n  timestamp: string;\n  /** Type of failure being healed */\n  failureType: FailureCategory;\n  /** Fix type applied */\n  fixType: HealFixType;\n  /** File that was modified */\n  file: string;\n  /** Diff or description of the change */\n  change: string;\n  /** Evidence files (traces, screenshots) */\n  evidence: string[];\n  /** Result of the attempt */\n  result: 'pass' | 'fail' | 'error';\n  /** Error message if failed */\n  errorMessage?: string;\n  /** Duration in ms */\n  duration: number;\n}\n\n/**\n * Complete healing log for a journey\n */\nexport interface HealingLog {\n  /** Journey ID */\n  journeyId: string;\n  /** Session start time */\n  sessionStart: string;\n  /** Session end time */\n  sessionEnd?: string;\n  /** Maximum attempts allowed */\n  maxAttempts: number;\n  /** Final status */\n  status: 'in_progress' | 'healed' | 'failed' | 'exhausted';\n  /** All healing attempts */\n  attempts: HealingAttempt[];\n  /** Summary statistics */\n  summary?: HealingSummary;\n}\n\n/**\n * Summary statistics\n */\nexport interface HealingSummary {\n  /** Total attempts made */\n  totalAttempts: number;\n  /** Successful fixes */\n  successfulFixes: number;\n  /** Failed attempts */\n  failedAttempts: number;\n  /** Total healing duration in ms */\n  totalDuration: number;\n  /** Fix types attempted */\n  fixTypesAttempted: HealFixType[];\n  /** Final recommendation if not healed */\n  recommendation?: string;\n}\n\n/**\n * Healing logger class\n */\nexport class HealingLogger {\n  private log: HealingLog;\n  private outputPath: string;\n\n  constructor(journeyId: string, outputDir: string, maxAttempts: number = 3) {\n    this.outputPath = join(outputDir, `${journeyId}.heal-log.json`);\n    this.log = {\n      journeyId,\n      sessionStart: new Date().toISOString(),\n      maxAttempts,\n      status: 'in_progress',\n      attempts: [],\n    };\n  }\n\n  /**\n   * Log a healing attempt\n   */\n  logAttempt(attempt: Omit<HealingAttempt, 'timestamp'>): void {\n    this.log.attempts.push({\n      ...attempt,\n      timestamp: new Date().toISOString(),\n    });\n    this.save();\n  }\n\n  /**\n   * Mark healing as complete (success)\n   */\n  markHealed(): void {\n    this.log.status = 'healed';\n    this.log.sessionEnd = new Date().toISOString();\n    this.calculateSummary();\n    this.save();\n  }\n\n  /**\n   * Mark healing as failed (gave up)\n   */\n  markFailed(recommendation?: string): void {\n    this.log.status = 'failed';\n    this.log.sessionEnd = new Date().toISOString();\n    this.calculateSummary();\n    if (recommendation && this.log.summary) {\n      this.log.summary.recommendation = recommendation;\n    }\n    this.save();\n  }\n\n  /**\n   * Mark healing as exhausted (all attempts used)\n   */\n  markExhausted(recommendation?: string): void {\n    this.log.status = 'exhausted';\n    this.log.sessionEnd = new Date().toISOString();\n    this.calculateSummary();\n    if (recommendation && this.log.summary) {\n      this.log.summary.recommendation = recommendation;\n    }\n    this.save();\n  }\n\n  /**\n   * Get current log\n   */\n  getLog(): HealingLog {\n    return { ...this.log };\n  }\n\n  /**\n   * Get last attempt\n   */\n  getLastAttempt(): HealingAttempt | null {\n    return this.log.attempts[this.log.attempts.length - 1] || null;\n  }\n\n  /**\n   * Get attempt count\n   */\n  getAttemptCount(): number {\n    return this.log.attempts.length;\n  }\n\n  /**\n   * Check if max attempts reached\n   */\n  isMaxAttemptsReached(): boolean {\n    return this.log.attempts.length >= this.log.maxAttempts;\n  }\n\n  /**\n   * Calculate summary statistics\n   */\n  private calculateSummary(): void {\n    const attempts = this.log.attempts;\n\n    this.log.summary = {\n      totalAttempts: attempts.length,\n      successfulFixes: attempts.filter((a) => a.result === 'pass').length,\n      failedAttempts: attempts.filter((a) => a.result === 'fail' || a.result === 'error').length,\n      totalDuration: attempts.reduce((sum, a) => sum + a.duration, 0),\n      fixTypesAttempted: [...new Set(attempts.map((a) => a.fixType))],\n    };\n  }\n\n  /**\n   * Save log to file\n   */\n  private save(): void {\n    const dir = dirname(this.outputPath);\n    if (!existsSync(dir)) {\n      mkdirSync(dir, { recursive: true });\n    }\n    writeFileSync(this.outputPath, JSON.stringify(this.log, null, 2), 'utf-8');\n  }\n\n  /**\n   * Get output path\n   */\n  getOutputPath(): string {\n    return this.outputPath;\n  }\n}\n\n/**\n * Load existing healing log\n */\nexport function loadHealingLog(filePath: string): HealingLog | null {\n  if (!existsSync(filePath)) {\n    return null;\n  }\n\n  try {\n    const content = readFileSync(filePath, 'utf-8');\n    return JSON.parse(content) as HealingLog;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Format healing log for display\n */\nexport function formatHealingLog(log: HealingLog): string {\n  const lines: string[] = [];\n\n  // Header\n  lines.push(`# Healing Log: ${log.journeyId}`);\n  lines.push('');\n  lines.push(`Status: ${log.status.toUpperCase()}`);\n  lines.push(`Started: ${log.sessionStart}`);\n  if (log.sessionEnd) {\n    lines.push(`Ended: ${log.sessionEnd}`);\n  }\n  lines.push('');\n\n  // Attempts\n  lines.push('## Attempts');\n  lines.push('');\n\n  for (const attempt of log.attempts) {\n    const icon = attempt.result === 'pass' ? '' : '';\n    lines.push(`### Attempt ${attempt.attempt} ${icon}`);\n    lines.push('');\n    lines.push(`- **Fix Type**: ${attempt.fixType}`);\n    lines.push(`- **Failure Type**: ${attempt.failureType}`);\n    lines.push(`- **File**: ${attempt.file}`);\n    lines.push(`- **Duration**: ${attempt.duration}ms`);\n    lines.push(`- **Result**: ${attempt.result}`);\n    if (attempt.errorMessage) {\n      lines.push(`- **Error**: ${attempt.errorMessage}`);\n    }\n    if (attempt.change) {\n      lines.push(`- **Change**: ${attempt.change}`);\n    }\n    if (attempt.evidence.length > 0) {\n      lines.push(`- **Evidence**: ${attempt.evidence.join(', ')}`);\n    }\n    lines.push('');\n  }\n\n  // Summary\n  if (log.summary) {\n    lines.push('## Summary');\n    lines.push('');\n    lines.push(`- Total Attempts: ${log.summary.totalAttempts}`);\n    lines.push(`- Successful Fixes: ${log.summary.successfulFixes}`);\n    lines.push(`- Failed Attempts: ${log.summary.failedAttempts}`);\n    lines.push(`- Total Duration: ${log.summary.totalDuration}ms`);\n    lines.push(`- Fix Types Tried: ${log.summary.fixTypesAttempted.join(', ')}`);\n    if (log.summary.recommendation) {\n      lines.push('');\n      lines.push(`**Recommendation**: ${log.summary.recommendation}`);\n    }\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Create healing report summary\n */\nexport function createHealingReport(log: HealingLog): {\n  success: boolean;\n  attemptCount: number;\n  fixApplied?: HealFixType;\n  recommendation?: string;\n} {\n  const lastSuccessfulAttempt = log.attempts.find((a) => a.result === 'pass');\n\n  return {\n    success: log.status === 'healed',\n    attemptCount: log.attempts.length,\n    fixApplied: lastSuccessfulAttempt?.fixType,\n    recommendation: log.summary?.recommendation,\n  };\n}\n\n/**\n * Aggregate healing logs from multiple journeys\n */\nexport function aggregateHealingLogs(logs: HealingLog[]): {\n  totalJourneys: number;\n  healed: number;\n  failed: number;\n  exhausted: number;\n  totalAttempts: number;\n  mostCommonFixes: Array<{ fix: HealFixType; count: number }>;\n  mostCommonFailures: Array<{ failure: FailureCategory; count: number }>;\n} {\n  const fixCounts = new Map<HealFixType, number>();\n  const failureCounts = new Map<FailureCategory, number>();\n  let totalAttempts = 0;\n\n  for (const log of logs) {\n    for (const attempt of log.attempts) {\n      totalAttempts++;\n      fixCounts.set(attempt.fixType, (fixCounts.get(attempt.fixType) || 0) + 1);\n      failureCounts.set(attempt.failureType, (failureCounts.get(attempt.failureType) || 0) + 1);\n    }\n  }\n\n  const mostCommonFixes = [...fixCounts.entries()]\n    .sort((a, b) => b[1] - a[1])\n    .map(([fix, count]) => ({ fix, count }));\n\n  const mostCommonFailures = [...failureCounts.entries()]\n    .sort((a, b) => b[1] - a[1])\n    .map(([failure, count]) => ({ failure, count }));\n\n  return {\n    totalJourneys: logs.length,\n    healed: logs.filter((l) => l.status === 'healed').length,\n    failed: logs.filter((l) => l.status === 'failed').length,\n    exhausted: logs.filter((l) => l.status === 'exhausted').length,\n    totalAttempts,\n    mostCommonFixes,\n    mostCommonFailures,\n  };\n}\n","/**\n * Selector Fix Strategy - Refine CSS selectors to role/label/testid\n * @see T062 - Implement selector refinement fix (CSS  role/label/testid)\n */\n\n/**\n * Selector fix context\n */\nexport interface SelectorFixContext {\n  /** Original code containing the selector */\n  code: string;\n  /** Line number where selector appears */\n  lineNumber: number;\n  /** The failing selector expression */\n  selector: string;\n  /** Error message from Playwright */\n  errorMessage: string;\n  /** Available ARIA information (if captured) */\n  ariaInfo?: ARIANodeInfo;\n}\n\n/**\n * ARIA node information for selector inference\n */\nexport interface ARIANodeInfo {\n  role?: string;\n  name?: string;\n  level?: number;\n  hasTestId?: boolean;\n  testId?: string;\n  label?: string;\n  placeholder?: string;\n}\n\n/**\n * Selector fix result\n */\nexport interface SelectorFixResult {\n  /** Whether a fix was applied */\n  applied: boolean;\n  /** The modified code */\n  code: string;\n  /** Description of the fix */\n  description: string;\n  /** The new locator expression */\n  newLocator?: string;\n  /** Confidence in the fix (0-1) */\n  confidence: number;\n}\n\n/**\n * CSS selector patterns to replace\n */\nconst CSS_SELECTOR_PATTERNS = [\n  // page.locator('.class') or page.locator('#id')\n  /page\\.locator\\s*\\(\\s*['\"`]([.#][^'\"`]+)['\"`]\\s*\\)/g,\n  // page.locator('[attribute]')\n  /page\\.locator\\s*\\(\\s*['\"`](\\[[^\\]]+\\])['\"`]\\s*\\)/g,\n  // page.locator('tag.class')\n  /page\\.locator\\s*\\(\\s*['\"`]([a-z]+[.#][^'\"`]+)['\"`]\\s*\\)/g,\n];\n\n/**\n * Map of common UI patterns to role-based selectors\n */\nconst UI_PATTERN_TO_ROLE: Record<string, { role: string; nameHint?: string }> = {\n  'button': { role: 'button' },\n  'btn': { role: 'button' },\n  'submit': { role: 'button', nameHint: 'submit' },\n  'input': { role: 'textbox' },\n  'textbox': { role: 'textbox' },\n  'checkbox': { role: 'checkbox' },\n  'radio': { role: 'radio' },\n  'select': { role: 'combobox' },\n  'dropdown': { role: 'combobox' },\n  'link': { role: 'link' },\n  'heading': { role: 'heading' },\n  'h1': { role: 'heading' },\n  'h2': { role: 'heading' },\n  'h3': { role: 'heading' },\n  'dialog': { role: 'dialog' },\n  'modal': { role: 'dialog' },\n  'alert': { role: 'alert' },\n  'tab': { role: 'tab' },\n  'menu': { role: 'menu' },\n  'menuitem': { role: 'menuitem' },\n  'table': { role: 'table' },\n  'row': { role: 'row' },\n  'cell': { role: 'cell' },\n  'grid': { role: 'grid' },\n  'list': { role: 'list' },\n  'listitem': { role: 'listitem' },\n  'img': { role: 'img' },\n  'image': { role: 'img' },\n  'nav': { role: 'navigation' },\n  'navigation': { role: 'navigation' },\n  'search': { role: 'search' },\n  'main': { role: 'main' },\n  'banner': { role: 'banner' },\n  'footer': { role: 'contentinfo' },\n};\n\n/**\n * Extract CSS selector from code\n */\nexport function extractCSSSelector(code: string): string | null {\n  for (const pattern of CSS_SELECTOR_PATTERNS) {\n    pattern.lastIndex = 0;\n    const match = pattern.exec(code);\n    if (match) {\n      return match[1] ?? null;\n    }\n  }\n  return null;\n}\n\n/**\n * Check if code contains a CSS selector\n */\nexport function containsCSSSelector(code: string): boolean {\n  return CSS_SELECTOR_PATTERNS.some((pattern) => {\n    pattern.lastIndex = 0;\n    return pattern.test(code);\n  });\n}\n\n/**\n * Infer role from CSS selector class/id names\n */\nexport function inferRoleFromSelector(selector: string): { role: string; name?: string } | null {\n  const lowerSelector = selector.toLowerCase();\n\n  for (const [pattern, roleInfo] of Object.entries(UI_PATTERN_TO_ROLE)) {\n    if (lowerSelector.includes(pattern)) {\n      return roleInfo;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Extract potential name from selector\n */\nexport function extractNameFromSelector(selector: string): string | null {\n  // Extract text between brackets for attribute selectors\n  const attrMatch = selector.match(/\\[(?:aria-label|title|alt|name)=['\"]([^'\"]+)['\"]\\]/);\n  if (attrMatch) {\n    return attrMatch[1] ?? null;\n  }\n\n  // Extract class name parts that might be descriptive\n  const classMatch = selector.match(/\\.([a-zA-Z][-a-zA-Z0-9_]*)/);\n  if (classMatch) {\n    // Convert class name to readable format\n    const className = classMatch[1]!;\n    // Convert kebab-case or snake_case to words\n    const words = className.split(/[-_]/).filter(Boolean);\n    if (words.length > 0 && words[0]!.length > 2) {\n      return words.join(' ');\n    }\n  }\n\n  return null;\n}\n\n/**\n * Generate role-based locator from inferred information\n */\nexport function generateRoleLocator(\n  role: string,\n  name?: string,\n  options?: { exact?: boolean; level?: number }\n): string {\n  const parts: string[] = [];\n\n  if (name) {\n    if (options?.exact) {\n      parts.push(`{ name: '${name}', exact: true }`);\n    } else {\n      parts.push(`{ name: '${name}' }`);\n    }\n  }\n\n  if (options?.level !== undefined && role === 'heading') {\n    if (parts.length > 0) {\n      // Merge with existing options\n      const existing = parts[0]!.slice(0, -2); // Remove ' }'\n      parts[0] = `${existing}, level: ${options.level} }`;\n    } else {\n      parts.push(`{ level: ${options.level} }`);\n    }\n  }\n\n  if (parts.length > 0) {\n    return `page.getByRole('${role}', ${parts[0]})`;\n  }\n\n  return `page.getByRole('${role}')`;\n}\n\n/**\n * Generate label-based locator\n */\nexport function generateLabelLocator(label: string, exact?: boolean): string {\n  if (exact) {\n    return `page.getByLabel('${label}', { exact: true })`;\n  }\n  return `page.getByLabel('${label}')`;\n}\n\n/**\n * Generate text-based locator\n */\nexport function generateTextLocator(text: string, exact?: boolean): string {\n  if (exact) {\n    return `page.getByText('${text}', { exact: true })`;\n  }\n  return `page.getByText('${text}')`;\n}\n\n/**\n * Generate testid-based locator\n */\nexport function generateTestIdLocator(testId: string): string {\n  return `page.getByTestId('${testId}')`;\n}\n\n/**\n * Apply selector fix to code\n */\nexport function applySelectorFix(context: SelectorFixContext): SelectorFixResult {\n  const { code, ariaInfo } = context;\n\n  // If we have ARIA info, use it\n  if (ariaInfo) {\n    return applySelectorFixWithARIA(code, ariaInfo);\n  }\n\n  // Try to infer from CSS selector\n  const cssSelector = extractCSSSelector(code);\n  if (!cssSelector) {\n    return {\n      applied: false,\n      code,\n      description: 'No CSS selector found to refine',\n      confidence: 0,\n    };\n  }\n\n  return applySelectorFixFromCSS(code, cssSelector);\n}\n\n/**\n * Apply selector fix using ARIA information\n */\nfunction applySelectorFixWithARIA(code: string, ariaInfo: ARIANodeInfo): SelectorFixResult {\n  let newLocator: string | null = null;\n  let confidence = 0;\n\n  // Priority: testid > role+name > label > text\n  if (ariaInfo.testId) {\n    newLocator = generateTestIdLocator(ariaInfo.testId);\n    confidence = 1.0;\n  } else if (ariaInfo.role && ariaInfo.name) {\n    newLocator = generateRoleLocator(ariaInfo.role, ariaInfo.name, {\n      exact: true,\n      level: ariaInfo.level,\n    });\n    confidence = 0.9;\n  } else if (ariaInfo.label) {\n    newLocator = generateLabelLocator(ariaInfo.label, true);\n    confidence = 0.85;\n  } else if (ariaInfo.role) {\n    newLocator = generateRoleLocator(ariaInfo.role);\n    confidence = 0.6;\n  }\n\n  if (!newLocator) {\n    return {\n      applied: false,\n      code,\n      description: 'Unable to generate locator from ARIA info',\n      confidence: 0,\n    };\n  }\n\n  // Replace CSS selector in code\n  let modifiedCode = code;\n  for (const pattern of CSS_SELECTOR_PATTERNS) {\n    modifiedCode = modifiedCode.replace(pattern, newLocator);\n  }\n\n  return {\n    applied: modifiedCode !== code,\n    code: modifiedCode,\n    description: `Replaced CSS selector with ${newLocator.split('(')[0]}`,\n    newLocator,\n    confidence,\n  };\n}\n\n/**\n * Apply selector fix by inferring from CSS selector\n */\nfunction applySelectorFixFromCSS(code: string, cssSelector: string): SelectorFixResult {\n  // Try to infer role from selector\n  const roleInfo = inferRoleFromSelector(cssSelector);\n  const extractedName = extractNameFromSelector(cssSelector);\n\n  let newLocator: string | null = null;\n  let confidence = 0;\n\n  if (roleInfo) {\n    const name = extractedName;\n    if (name) {\n      newLocator = generateRoleLocator(roleInfo.role, name);\n      confidence = 0.6;\n    } else {\n      newLocator = generateRoleLocator(roleInfo.role);\n      confidence = 0.4;\n    }\n  } else if (extractedName) {\n    // Fall back to text locator if we have a name but no role\n    newLocator = generateTextLocator(extractedName);\n    confidence = 0.3;\n  }\n\n  if (!newLocator) {\n    return {\n      applied: false,\n      code,\n      description: 'Unable to infer semantic locator from CSS selector',\n      confidence: 0,\n    };\n  }\n\n  // Replace CSS selector in code\n  let modifiedCode = code;\n  for (const pattern of CSS_SELECTOR_PATTERNS) {\n    modifiedCode = modifiedCode.replace(pattern, newLocator);\n  }\n\n  return {\n    applied: modifiedCode !== code,\n    code: modifiedCode,\n    description: `Inferred ${newLocator.split('(')[0]} from CSS selector pattern`,\n    newLocator,\n    confidence,\n  };\n}\n\n/**\n * Add exact: true to existing locator\n */\nexport function addExactToLocator(code: string): SelectorFixResult {\n  let modifiedCode = code;\n  let applied = false;\n\n  // Add exact: true to getByRole\n  modifiedCode = modifiedCode.replace(\n    /page\\.getByRole\\s*\\(\\s*['\"](\\w+)['\"]\\s*,\\s*\\{\\s*name:\\s*['\"]([^'\"]+)['\"]\\s*\\}\\s*\\)/g,\n    (_, role, name) => {\n      applied = true;\n      return `page.getByRole('${role}', { name: '${name}', exact: true })`;\n    }\n  );\n\n  // Add exact: true to getByLabel\n  modifiedCode = modifiedCode.replace(\n    /page\\.getByLabel\\s*\\(\\s*['\"]([^'\"]+)['\"]\\s*\\)/g,\n    (_, label) => {\n      applied = true;\n      return `page.getByLabel('${label}', { exact: true })`;\n    }\n  );\n\n  // Add exact: true to getByText\n  modifiedCode = modifiedCode.replace(\n    /page\\.getByText\\s*\\(\\s*['\"]([^'\"]+)['\"]\\s*\\)/g,\n    (_, text) => {\n      applied = true;\n      return `page.getByText('${text}', { exact: true })`;\n    }\n  );\n\n  return {\n    applied,\n    code: modifiedCode,\n    description: applied ? 'Added exact: true to locator' : 'No locator found to add exact option',\n    confidence: applied ? 0.8 : 0,\n  };\n}\n","/**\n * Navigation Wait Fix - Add waitForURL/toHaveURL assertions\n * @see T063 - Implement navigation wait fix\n */\n\n/**\n * Navigation fix context\n */\nexport interface NavigationFixContext {\n  /** Original code */\n  code: string;\n  /** Line number where navigation issue occurs */\n  lineNumber: number;\n  /** Expected URL pattern (if known) */\n  expectedUrl?: string;\n  /** Error message from Playwright */\n  errorMessage: string;\n}\n\n/**\n * Navigation fix result\n */\nexport interface NavigationFixResult {\n  /** Whether a fix was applied */\n  applied: boolean;\n  /** The modified code */\n  code: string;\n  /** Description of the fix */\n  description: string;\n  /** Confidence in the fix (0-1) */\n  confidence: number;\n}\n\n// Navigation patterns defined for reference, used in pattern matching\n\n/**\n * Patterns for existing waits (to avoid duplicates)\n */\nconst EXISTING_WAIT_PATTERNS = [\n  /await\\s+page\\.waitForURL/,\n  /await\\s+expect\\s*\\(\\s*page\\s*\\)\\.toHaveURL/,\n  /await\\s+page\\.waitForNavigation/,\n  /await\\s+page\\.waitForLoadState/,\n];\n\n/**\n * Check if code already has navigation wait\n */\nexport function hasNavigationWait(code: string): boolean {\n  return EXISTING_WAIT_PATTERNS.some((pattern) => pattern.test(code));\n}\n\n/**\n * Extract URL pattern from error message\n */\nexport function extractUrlFromError(errorMessage: string): string | null {\n  // Pattern: Expected URL to match '/pattern/'\n  const matchPattern = errorMessage.match(/Expected\\s+URL\\s+to\\s+match\\s+['\"]([^'\"]+)['\"]/i);\n  if (matchPattern) {\n    return matchPattern[1] ?? null;\n  }\n\n  // Pattern: expected \"url\" to match\n  const matchUrl = errorMessage.match(/expected\\s+['\"]([^'\"]+)['\"]\\s+to\\s+match/i);\n  if (matchUrl) {\n    return matchUrl[1] ?? null;\n  }\n\n  // Pattern: waiting for URL pattern\n  const waitingPattern = errorMessage.match(/waiting\\s+for\\s+URL\\s+['\"]([^'\"]+)['\"]/i);\n  if (waitingPattern) {\n    return waitingPattern[1] ?? null;\n  }\n\n  return null;\n}\n\n/**\n * Extract URL from goto call\n */\nexport function extractUrlFromGoto(code: string): string | null {\n  const match = code.match(/page\\.goto\\s*\\(\\s*['\"`]([^'\"`]+)['\"`]/);\n  return match ? (match[1] ?? null) : null;\n}\n\n/**\n * Infer expected URL pattern from navigation action\n */\nexport function inferUrlPattern(code: string, errorMessage: string): string | null {\n  // First try to extract from error message\n  const errorUrl = extractUrlFromError(errorMessage);\n  if (errorUrl) {\n    return errorUrl;\n  }\n\n  // Try to extract from goto call\n  const gotoUrl = extractUrlFromGoto(code);\n  if (gotoUrl) {\n    return gotoUrl;\n  }\n\n  return null;\n}\n\n/**\n * Generate waitForURL statement\n */\nexport function generateWaitForURL(urlPattern: string, options?: { timeout?: number }): string {\n  const opts = options?.timeout ? `, { timeout: ${options.timeout} }` : '';\n\n  // Determine if pattern should be regex or string\n  if (urlPattern.includes('*') || urlPattern.includes('\\\\')) {\n    return `await page.waitForURL(/${urlPattern}/${opts})`;\n  }\n\n  return `await page.waitForURL('${urlPattern}'${opts})`;\n}\n\n/**\n * Generate toHaveURL assertion\n */\nexport function generateToHaveURL(urlPattern: string): string {\n  // Determine if pattern should be regex or string\n  if (urlPattern.includes('*') || urlPattern.includes('\\\\')) {\n    return `await expect(page).toHaveURL(/${urlPattern}/)`;\n  }\n\n  return `await expect(page).toHaveURL('${urlPattern}')`;\n}\n\n/**\n * Insert navigation wait after an action\n */\nexport function insertNavigationWait(\n  code: string,\n  lineNumber: number,\n  urlPattern: string\n): NavigationFixResult {\n  const lines = code.split('\\n');\n\n  if (lineNumber < 1 || lineNumber > lines.length) {\n    return {\n      applied: false,\n      code,\n      description: 'Invalid line number',\n      confidence: 0,\n    };\n  }\n\n  // Check if there's already a wait nearby\n  const contextStart = Math.max(0, lineNumber - 2);\n  const contextEnd = Math.min(lines.length, lineNumber + 2);\n  const context = lines.slice(contextStart, contextEnd).join('\\n');\n\n  if (hasNavigationWait(context)) {\n    return {\n      applied: false,\n      code,\n      description: 'Navigation wait already exists in context',\n      confidence: 0,\n    };\n  }\n\n  // Get the line where action occurs\n  const actionLine = lines[lineNumber - 1]!;\n  const indentation = actionLine.match(/^(\\s*)/)?.[1] || '';\n\n  // Insert toHaveURL assertion after the action\n  const waitStatement = `${indentation}${generateToHaveURL(urlPattern)}`;\n  lines.splice(lineNumber, 0, waitStatement);\n\n  return {\n    applied: true,\n    code: lines.join('\\n'),\n    description: `Added toHaveURL assertion for '${urlPattern}'`,\n    confidence: 0.7,\n  };\n}\n\n/**\n * Apply navigation wait fix to code\n */\nexport function applyNavigationFix(context: NavigationFixContext): NavigationFixResult {\n  const { code, lineNumber, expectedUrl, errorMessage } = context;\n\n  // First, try to infer URL pattern\n  const urlPattern = expectedUrl || inferUrlPattern(code, errorMessage);\n\n  if (!urlPattern) {\n    // If we can't determine URL, add waitForLoadState instead\n    return applyLoadStateWait(code, lineNumber);\n  }\n\n  // Check if code already has navigation wait\n  if (hasNavigationWait(code)) {\n    return {\n      applied: false,\n      code,\n      description: 'Navigation wait already exists',\n      confidence: 0,\n    };\n  }\n\n  return insertNavigationWait(code, lineNumber, urlPattern);\n}\n\n/**\n * Apply waitForLoadState as fallback\n */\nfunction applyLoadStateWait(code: string, lineNumber: number): NavigationFixResult {\n  const lines = code.split('\\n');\n\n  if (lineNumber < 1 || lineNumber > lines.length) {\n    return {\n      applied: false,\n      code,\n      description: 'Invalid line number',\n      confidence: 0,\n    };\n  }\n\n  // Get the line where action occurs\n  const actionLine = lines[lineNumber - 1]!;\n  const indentation = actionLine.match(/^(\\s*)/)?.[1] || '';\n\n  // Insert waitForLoadState after the action\n  const waitStatement = `${indentation}await page.waitForLoadState('networkidle')`;\n  lines.splice(lineNumber, 0, waitStatement);\n\n  return {\n    applied: true,\n    code: lines.join('\\n'),\n    description: 'Added waitForLoadState as fallback',\n    confidence: 0.5,\n  };\n}\n\n/**\n * Fix missing await on goto\n */\nexport function fixMissingGotoAwait(code: string): NavigationFixResult {\n  const pattern = /(?<!\\bawait\\s+)(\\bpage\\.goto\\s*\\()/g;\n\n  if (!pattern.test(code)) {\n    return {\n      applied: false,\n      code,\n      description: 'No missing await on goto found',\n      confidence: 0,\n    };\n  }\n\n  const modifiedCode = code.replace(\n    /(?<!\\bawait\\s+)(\\bpage\\.goto\\s*\\()/g,\n    'await $1'\n  );\n\n  return {\n    applied: modifiedCode !== code,\n    code: modifiedCode,\n    description: 'Added missing await to page.goto',\n    confidence: 0.9,\n  };\n}\n\n/**\n * Add navigation wait after click that likely navigates\n */\nexport function addNavigationWaitAfterClick(\n  code: string,\n  clickLineNumber: number,\n  expectedUrl?: string\n): NavigationFixResult {\n  const urlPattern = expectedUrl || '.*';\n\n  return insertNavigationWait(code, clickLineNumber, urlPattern);\n}\n","/**\n * Timing/Async Fix - Handle timeout and async issues\n * @see T064 - Implement timing/async fix\n */\n\n/**\n * Timing fix context\n */\nexport interface TimingFixContext {\n  /** Original code */\n  code: string;\n  /** Line number where timing issue occurs */\n  lineNumber: number;\n  /** Current timeout (if known) */\n  currentTimeout?: number;\n  /** Error message from Playwright */\n  errorMessage: string;\n}\n\n/**\n * Timing fix result\n */\nexport interface TimingFixResult {\n  /** Whether a fix was applied */\n  applied: boolean;\n  /** The modified code */\n  code: string;\n  /** Description of the fix */\n  description: string;\n  /** Confidence in the fix (0-1) */\n  confidence: number;\n}\n\n/**\n * Patterns for missing await detection\n */\nconst MISSING_AWAIT_PATTERNS = [\n  // Playwright actions without await\n  /(?<!\\bawait\\s+)(page\\.(?:click|fill|type|check|uncheck|selectOption|hover|focus|press|dblclick|dragTo)\\s*\\()/g,\n  // Expectations without await\n  /(?<!\\bawait\\s+)(expect\\s*\\([^)]+\\)\\.(?:toBeVisible|toBeHidden|toHaveText|toContainText|toHaveValue|toHaveURL|toHaveTitle)\\s*\\()/g,\n  // Locator actions without await\n  /(?<!\\bawait\\s+)([a-zA-Z_$][a-zA-Z0-9_$]*\\.(?:click|fill|type|check|hover|press)\\s*\\()/g,\n];\n\n// Web-first assertion patterns used in conversion logic below\n\n/**\n * Extract timeout from error message\n */\nexport function extractTimeoutFromError(errorMessage: string): number | null {\n  const match = errorMessage.match(/timeout\\s+(\\d+)ms/i);\n  return match ? parseInt(match[1]!, 10) : null;\n}\n\n/**\n * Calculate suggested timeout increase\n */\nexport function suggestTimeoutIncrease(\n  currentTimeout: number,\n  maxTimeout: number = 30000\n): number {\n  // Increase by 50%, but cap at maxTimeout\n  const suggested = Math.min(Math.round(currentTimeout * 1.5), maxTimeout);\n  return suggested;\n}\n\n/**\n * Fix missing await statements\n */\nexport function fixMissingAwait(code: string): TimingFixResult {\n  let modifiedCode = code;\n  let fixCount = 0;\n\n  for (const pattern of MISSING_AWAIT_PATTERNS) {\n    // Reset lastIndex for global patterns\n    pattern.lastIndex = 0;\n\n    modifiedCode = modifiedCode.replace(pattern, (_match, p1) => {\n      fixCount++;\n      return `await ${p1}`;\n    });\n  }\n\n  return {\n    applied: fixCount > 0,\n    code: modifiedCode,\n    description: fixCount > 0 ? `Added ${fixCount} missing await statement(s)` : 'No missing await found',\n    confidence: fixCount > 0 ? 0.9 : 0,\n  };\n}\n\n/**\n * Convert to web-first assertion\n */\nexport function convertToWebFirstAssertion(code: string): TimingFixResult {\n  let modifiedCode = code;\n  let applied = false;\n\n  // Convert textContent extraction to toHaveText\n  modifiedCode = modifiedCode.replace(\n    /const\\s+(\\w+)\\s*=\\s*await\\s+(\\w+)\\.textContent\\s*\\(\\s*\\)\\s*;?\\s*\\n(\\s*)expect\\s*\\(\\s*\\1\\s*\\)\\.toBe\\s*\\(\\s*(['\"][^'\"]+['\"])\\s*\\)/g,\n    (_, _varName, locator, indent, expected) => {\n      applied = true;\n      return `${indent}await expect(${locator}).toHaveText(${expected})`;\n    }\n  );\n\n  // Convert innerText extraction to toHaveText\n  modifiedCode = modifiedCode.replace(\n    /const\\s+(\\w+)\\s*=\\s*await\\s+(\\w+)\\.innerText\\s*\\(\\s*\\)\\s*;?\\s*\\n(\\s*)expect\\s*\\(\\s*\\1\\s*\\)\\.toBe\\s*\\(\\s*(['\"][^'\"]+['\"])\\s*\\)/g,\n    (_, _varName, locator, indent, expected) => {\n      applied = true;\n      return `${indent}await expect(${locator}).toHaveText(${expected})`;\n    }\n  );\n\n  // Convert isVisible check to toBeVisible\n  modifiedCode = modifiedCode.replace(\n    /const\\s+(\\w+)\\s*=\\s*await\\s+(\\w+)\\.isVisible\\s*\\(\\s*\\)\\s*;?\\s*\\n(\\s*)expect\\s*\\(\\s*\\1\\s*\\)\\.toBe\\s*\\(\\s*true\\s*\\)/g,\n    (_, _varName, locator, indent) => {\n      applied = true;\n      return `${indent}await expect(${locator}).toBeVisible()`;\n    }\n  );\n\n  // Convert isHidden check to toBeHidden\n  modifiedCode = modifiedCode.replace(\n    /const\\s+(\\w+)\\s*=\\s*await\\s+(\\w+)\\.isHidden\\s*\\(\\s*\\)\\s*;?\\s*\\n(\\s*)expect\\s*\\(\\s*\\1\\s*\\)\\.toBe\\s*\\(\\s*true\\s*\\)/g,\n    (_, _varName, locator, indent) => {\n      applied = true;\n      return `${indent}await expect(${locator}).toBeHidden()`;\n    }\n  );\n\n  return {\n    applied,\n    code: modifiedCode,\n    description: applied ? 'Converted to web-first assertion' : 'No conversion needed',\n    confidence: applied ? 0.85 : 0,\n  };\n}\n\n/**\n * Add explicit timeout to action\n */\nexport function addTimeout(\n  code: string,\n  lineNumber: number,\n  timeout: number\n): TimingFixResult {\n  const lines = code.split('\\n');\n\n  if (lineNumber < 1 || lineNumber > lines.length) {\n    return {\n      applied: false,\n      code,\n      description: 'Invalid line number',\n      confidence: 0,\n    };\n  }\n\n  const line = lines[lineNumber - 1]!;\n\n  // Check if line already has timeout\n  if (/\\btimeout\\s*:/i.test(line)) {\n    return {\n      applied: false,\n      code,\n      description: 'Timeout already specified',\n      confidence: 0,\n    };\n  }\n\n  // Add timeout to action patterns\n  let modifiedLine = line;\n\n  // Pattern: .click(), .fill(), etc. with empty options\n  modifiedLine = modifiedLine.replace(\n    /\\.(click|fill|press|type|hover|focus|check|uncheck)\\s*\\(\\s*\\)/g,\n    `.$1({ timeout: ${timeout} })`\n  );\n\n  // Pattern: .click('text'), .fill('selector', 'value')\n  modifiedLine = modifiedLine.replace(\n    /\\.(click|fill|press|type|hover|focus|check|uncheck)\\s*\\(\\s*(['\"][^'\"]*['\"])\\s*\\)/g,\n    `.$1($2, { timeout: ${timeout} })`\n  );\n\n  // Pattern: .click({ options })\n  modifiedLine = modifiedLine.replace(\n    /\\.(click|fill|press|type|hover|focus|check|uncheck)\\s*\\(\\s*\\{([^}]*)\\}\\s*\\)/g,\n    (_, action, options) => {\n      if (options.includes('timeout')) {\n        return _; // Already has timeout\n      }\n      return `.${action}({ ${options.trim()}, timeout: ${timeout} })`;\n    }\n  );\n\n  // Pattern: expect().toBeVisible() etc.\n  modifiedLine = modifiedLine.replace(\n    /\\.(toBeVisible|toBeHidden|toHaveText|toContainText|toHaveValue)\\s*\\(\\s*\\)/g,\n    `.$1({ timeout: ${timeout} })`\n  );\n\n  const applied = modifiedLine !== line;\n  lines[lineNumber - 1] = modifiedLine;\n\n  return {\n    applied,\n    code: lines.join('\\n'),\n    description: applied ? `Added timeout: ${timeout}ms` : 'Unable to add timeout',\n    confidence: applied ? 0.6 : 0,\n  };\n}\n\n/**\n * Apply timing fix to code\n */\nexport function applyTimingFix(context: TimingFixContext): TimingFixResult {\n  const { code, lineNumber, currentTimeout, errorMessage } = context;\n\n  // First, try to fix missing await (most common cause)\n  const awaitFix = fixMissingAwait(code);\n  if (awaitFix.applied) {\n    return awaitFix;\n  }\n\n  // Try converting to web-first assertion\n  const webFirstFix = convertToWebFirstAssertion(code);\n  if (webFirstFix.applied) {\n    return webFirstFix;\n  }\n\n  // As last resort, increase timeout\n  const timeout = currentTimeout || extractTimeoutFromError(errorMessage) || 5000;\n  const newTimeout = suggestTimeoutIncrease(timeout);\n\n  return addTimeout(code, lineNumber, newTimeout);\n}\n\n/**\n * Wrap with expect.toPass for complex conditions\n */\nexport function wrapWithExpectToPass(\n  code: string,\n  lineStart: number,\n  lineEnd: number,\n  options?: { timeout?: number; intervals?: number[] }\n): TimingFixResult {\n  const lines = code.split('\\n');\n\n  if (lineStart < 1 || lineEnd > lines.length || lineStart > lineEnd) {\n    return {\n      applied: false,\n      code,\n      description: 'Invalid line range',\n      confidence: 0,\n    };\n  }\n\n  // Extract the code block to wrap\n  const blockLines = lines.slice(lineStart - 1, lineEnd);\n  const indentation = blockLines[0]!.match(/^(\\s*)/)?.[1] || '';\n\n  // Build options string\n  const optParts: string[] = [];\n  if (options?.timeout) {\n    optParts.push(`timeout: ${options.timeout}`);\n  }\n  if (options?.intervals) {\n    optParts.push(`intervals: [${options.intervals.join(', ')}]`);\n  }\n  const optString = optParts.length > 0 ? `, { ${optParts.join(', ')} }` : '';\n\n  // Wrap with expect.toPass\n  const wrapped = [\n    `${indentation}await expect(async () => {`,\n    ...blockLines.map((line) => `  ${line}`),\n    `${indentation}}).toPass(${optString.slice(2)})`,\n  ];\n\n  lines.splice(lineStart - 1, lineEnd - lineStart + 1, ...wrapped);\n\n  return {\n    applied: true,\n    code: lines.join('\\n'),\n    description: 'Wrapped with expect.toPass for retry behavior',\n    confidence: 0.7,\n  };\n}\n\n/**\n * Wrap with expect.poll for dynamic values\n */\nexport function wrapWithExpectPoll(\n  _code: string,\n  _lineNumber: number,\n  getter: string,\n  expected: string,\n  options?: { timeout?: number; intervals?: number[] }\n): string {\n  const optParts: string[] = [];\n  if (options?.timeout) {\n    optParts.push(`timeout: ${options.timeout}`);\n  }\n  if (options?.intervals) {\n    optParts.push(`intervals: [${options.intervals.join(', ')}]`);\n  }\n  const optString = optParts.length > 0 ? `, { ${optParts.join(', ')} }` : '';\n\n  return `await expect.poll(async () => ${getter}${optString}).toBe(${expected})`;\n}\n","/**\n * Bounded Healing Loop Controller - Orchestrate healing attempts\n * @see T067 - Implement bounded healing loop controller\n */\nimport { readFileSync, writeFileSync, existsSync } from 'node:fs';\nimport type { HealFixType, HealingConfig } from './rules.js';\nimport {\n  DEFAULT_HEALING_CONFIG,\n  evaluateHealing,\n  getNextFix,\n  getPostHealingRecommendation,\n} from './rules.js';\nimport { HealingLogger, type HealingAttempt } from './logger.js';\nimport { applySelectorFix, addExactToLocator } from './fixes/selector.js';\nimport { applyNavigationFix } from './fixes/navigation.js';\nimport { applyTimingFix, fixMissingAwait, convertToWebFirstAssertion } from './fixes/timing.js';\nimport type { FailureClassification } from '../verify/classifier.js';\nimport type { VerifySummary } from '../verify/summary.js';\n\n/**\n * Healing loop options\n */\nexport interface HealingLoopOptions {\n  /** Journey ID */\n  journeyId: string;\n  /** Path to test file */\n  testFile: string;\n  /** Output directory for logs */\n  outputDir: string;\n  /** Healing configuration */\n  config?: HealingConfig;\n  /** Function to verify the test */\n  verifyFn: () => Promise<VerifySummary>;\n  /** Optional ARIA info for selector fixes */\n  ariaInfo?: Record<string, unknown>;\n}\n\n/**\n * Healing loop result\n */\nexport interface HealingLoopResult {\n  /** Whether healing succeeded */\n  success: boolean;\n  /** Final status */\n  status: 'healed' | 'failed' | 'exhausted' | 'not_healable';\n  /** Number of attempts made */\n  attempts: number;\n  /** Fix that worked (if any) */\n  appliedFix?: HealFixType;\n  /** Path to heal log */\n  logPath: string;\n  /** Recommendation if not healed */\n  recommendation?: string;\n  /** Modified code (if any changes) */\n  modifiedCode?: string;\n}\n\n/**\n * Apply a specific fix to code\n */\nfunction applyFix(\n  code: string,\n  fixType: HealFixType,\n  context: {\n    lineNumber: number;\n    errorMessage: string;\n    classification: FailureClassification;\n    ariaInfo?: Record<string, unknown>;\n  }\n): { applied: boolean; code: string; description: string } {\n  const { lineNumber, errorMessage, ariaInfo } = context;\n\n  switch (fixType) {\n    case 'selector-refine':\n      return applySelectorFix({\n        code,\n        lineNumber,\n        selector: '', // Will be extracted from code\n        errorMessage,\n        ariaInfo: ariaInfo as never,\n      });\n\n    case 'add-exact':\n      return addExactToLocator(code);\n\n    case 'missing-await':\n      return fixMissingAwait(code);\n\n    case 'navigation-wait':\n      return applyNavigationFix({\n        code,\n        lineNumber,\n        errorMessage,\n      });\n\n    case 'web-first-assertion':\n      return convertToWebFirstAssertion(code);\n\n    case 'timeout-increase':\n      return applyTimingFix({\n        code,\n        lineNumber,\n        errorMessage,\n      });\n\n    default:\n      return {\n        applied: false,\n        code,\n        description: `Unknown fix type: ${fixType}`,\n      };\n  }\n}\n\n/**\n * Extract line number from verification summary\n */\nfunction extractLineNumber(summary: VerifySummary): number {\n  // Try to extract from first failure test name or error message\n  const firstTest = summary.failures.tests[0];\n  if (firstTest) {\n    // Try to extract line number from error message patterns like:\n    // \"at /path/to/file.ts:42:10\"\n    // \"Error: ... at line 42\"\n    const lineMatch = firstTest.match(/:(\\d+)(?::\\d+)?(?:\\)|$)/);\n    if (lineMatch) {\n      return parseInt(lineMatch[1]!, 10);\n    }\n\n    // Try \"at line N\" pattern\n    const atLineMatch = firstTest.match(/at line (\\d+)/i);\n    if (atLineMatch) {\n      return parseInt(atLineMatch[1]!, 10);\n    }\n  }\n\n  // Check classifications for error messages\n  for (const [, classification] of Object.entries(summary.failures.classifications)) {\n    if (classification && typeof classification === 'object' && 'explanation' in classification) {\n      const explanation = (classification as { explanation: string }).explanation;\n      const lineMatch = explanation.match(/:(\\d+)(?::\\d+)?/);\n      if (lineMatch) {\n        return parseInt(lineMatch[1]!, 10);\n      }\n    }\n  }\n\n  // Default to line 1 if we can't determine\n  return 1;\n}\n\n/**\n * Extract failure classification from verification summary\n */\nfunction extractClassification(summary: VerifySummary): FailureClassification | null {\n  const classifications = summary.failures.classifications;\n  const firstKey = Object.keys(classifications)[0];\n\n  if (firstKey && classifications[firstKey]) {\n    return classifications[firstKey] as FailureClassification;\n  }\n\n  return null;\n}\n\n/**\n * Run the bounded healing loop\n */\nexport async function runHealingLoop(options: HealingLoopOptions): Promise<HealingLoopResult> {\n  const {\n    journeyId,\n    testFile,\n    outputDir,\n    config = DEFAULT_HEALING_CONFIG,\n    verifyFn,\n    ariaInfo,\n  } = options;\n\n  // Initialize logger\n  const logger = new HealingLogger(journeyId, outputDir, config.maxAttempts);\n  const attemptedFixes: HealFixType[] = [];\n\n  // Read original code\n  if (!existsSync(testFile)) {\n    logger.markFailed('Test file not found');\n    return {\n      success: false,\n      status: 'failed',\n      attempts: 0,\n      logPath: logger.getOutputPath(),\n      recommendation: 'Test file not found',\n    };\n  }\n\n  let currentCode = readFileSync(testFile, 'utf-8');\n  let lastSummary: VerifySummary | null = null;\n\n  // Initial verification to get failure info\n  try {\n    lastSummary = await verifyFn();\n    if (lastSummary.status === 'passed') {\n      logger.markHealed();\n      return {\n        success: true,\n        status: 'healed',\n        attempts: 0,\n        logPath: logger.getOutputPath(),\n      };\n    }\n  } catch (error) {\n    logger.markFailed(`Initial verification failed: ${error}`);\n    return {\n      success: false,\n      status: 'failed',\n      attempts: 0,\n      logPath: logger.getOutputPath(),\n      recommendation: 'Initial verification failed',\n    };\n  }\n\n  // Get classification from initial failure\n  const classification = extractClassification(lastSummary);\n  if (!classification) {\n    logger.markFailed('Unable to classify failure');\n    return {\n      success: false,\n      status: 'failed',\n      attempts: 0,\n      logPath: logger.getOutputPath(),\n      recommendation: 'Unable to classify failure for healing',\n    };\n  }\n\n  // Check if healable\n  const evaluation = evaluateHealing(classification, config);\n  if (!evaluation.canHeal) {\n    logger.markFailed(evaluation.reason);\n    return {\n      success: false,\n      status: 'not_healable',\n      attempts: 0,\n      logPath: logger.getOutputPath(),\n      recommendation: evaluation.reason,\n    };\n  }\n\n  // Healing loop\n  while (!logger.isMaxAttemptsReached()) {\n    const attemptNumber = logger.getAttemptCount() + 1;\n    const startTime = Date.now();\n\n    // Get next fix to try\n    const nextFix = getNextFix(classification, attemptedFixes, config);\n    if (!nextFix) {\n      logger.markExhausted(getPostHealingRecommendation(classification, attemptNumber));\n      return {\n        success: false,\n        status: 'exhausted',\n        attempts: attemptNumber - 1,\n        logPath: logger.getOutputPath(),\n        recommendation: getPostHealingRecommendation(classification, attemptNumber),\n      };\n    }\n\n    attemptedFixes.push(nextFix);\n\n    // Apply the fix\n    const fixResult = applyFix(currentCode, nextFix, {\n      lineNumber: extractLineNumber(lastSummary),\n      errorMessage: lastSummary.failures.tests[0] || '',\n      classification,\n      ariaInfo,\n    });\n\n    if (!fixResult.applied) {\n      // Log skipped attempt\n      logger.logAttempt({\n        attempt: attemptNumber,\n        failureType: classification.category,\n        fixType: nextFix,\n        file: testFile,\n        change: fixResult.description,\n        evidence: [],\n        result: 'fail',\n        errorMessage: 'Fix not applied',\n        duration: Date.now() - startTime,\n      });\n      continue;\n    }\n\n    // Write fixed code\n    writeFileSync(testFile, fixResult.code, 'utf-8');\n    currentCode = fixResult.code;\n\n    // Verify the fix\n    try {\n      lastSummary = await verifyFn();\n\n      const attempt: Omit<HealingAttempt, 'timestamp'> = {\n        attempt: attemptNumber,\n        failureType: classification.category,\n        fixType: nextFix,\n        file: testFile,\n        change: fixResult.description,\n        evidence: lastSummary.reportPath ? [lastSummary.reportPath] : [],\n        result: lastSummary.status === 'passed' ? 'pass' : 'fail',\n        duration: Date.now() - startTime,\n      };\n\n      if (lastSummary.status !== 'passed') {\n        attempt.errorMessage = lastSummary.failures.tests[0] || 'Unknown error';\n\n        // Re-classify after failed attempt - failure category may have changed\n        const newClassification = extractClassification(lastSummary);\n        if (newClassification && newClassification.category !== classification.category) {\n          // Update classification for next iteration\n          Object.assign(classification, newClassification);\n        }\n      }\n\n      logger.logAttempt(attempt);\n\n      if (lastSummary.status === 'passed') {\n        logger.markHealed();\n        return {\n          success: true,\n          status: 'healed',\n          attempts: attemptNumber,\n          appliedFix: nextFix,\n          logPath: logger.getOutputPath(),\n          modifiedCode: currentCode,\n        };\n      }\n    } catch (error) {\n      logger.logAttempt({\n        attempt: attemptNumber,\n        failureType: classification.category,\n        fixType: nextFix,\n        file: testFile,\n        change: fixResult.description,\n        evidence: [],\n        result: 'error',\n        errorMessage: String(error),\n        duration: Date.now() - startTime,\n      });\n    }\n  }\n\n  // Max attempts reached\n  logger.markExhausted(getPostHealingRecommendation(classification, config.maxAttempts));\n  return {\n    success: false,\n    status: 'exhausted',\n    attempts: config.maxAttempts,\n    logPath: logger.getOutputPath(),\n    recommendation: getPostHealingRecommendation(classification, config.maxAttempts),\n  };\n}\n\n/**\n * Dry run healing to preview fixes without applying\n */\nexport function previewHealingFixes(\n  code: string,\n  classification: FailureClassification,\n  config: HealingConfig = DEFAULT_HEALING_CONFIG\n): Array<{ fixType: HealFixType; preview: string; confidence: number }> {\n  const previews: Array<{ fixType: HealFixType; preview: string; confidence: number }> = [];\n  const evaluation = evaluateHealing(classification, config);\n\n  if (!evaluation.canHeal) {\n    return previews;\n  }\n\n  for (const fixType of evaluation.applicableFixes) {\n    const result = applyFix(code, fixType, {\n      lineNumber: 1,\n      errorMessage: '',\n      classification,\n    });\n\n    if (result.applied) {\n      previews.push({\n        fixType,\n        preview: result.description,\n        confidence: 0.5, // Could be enhanced with actual confidence scores\n      });\n    }\n  }\n\n  return previews;\n}\n\n/**\n * Check if a specific fix type would apply to code\n */\nexport function wouldFixApply(\n  code: string,\n  fixType: HealFixType,\n  classification: FailureClassification\n): boolean {\n  const result = applyFix(code, fixType, {\n    lineNumber: 1,\n    errorMessage: '',\n    classification,\n  });\n  return result.applied;\n}\n","/**\n * Data Isolation Fix - Namespace test data with runId\n * @see T065 - Implement data isolation fix (runId namespace)\n */\nimport { randomBytes } from 'node:crypto';\n\n/**\n * Data fix context\n */\nexport interface DataFixContext {\n  /** Original code */\n  code: string;\n  /** Test file path */\n  testFile: string;\n  /** Journey ID */\n  journeyId: string;\n}\n\n/**\n * Data fix result\n */\nexport interface DataFixResult {\n  /** Whether a fix was applied */\n  applied: boolean;\n  /** The modified code */\n  code: string;\n  /** Description of the fix */\n  description: string;\n  /** Confidence in the fix (0-1) */\n  confidence: number;\n}\n\n/**\n * Generate unique run ID\n */\nexport function generateRunId(): string {\n  const timestamp = Date.now().toString(36);\n  const random = randomBytes(4).toString('hex');\n  return `${timestamp}-${random}`;\n}\n\n// Note: Patterns defined for reference, may be used in future enhancements\n\n/**\n * Check if code has data isolation\n */\nexport function hasDataIsolation(code: string): boolean {\n  // Check for runId pattern\n  if (/\\brunId\\b/i.test(code)) {\n    return true;\n  }\n\n  // Check for testInfo.testId usage\n  if (/testInfo\\.testId/i.test(code)) {\n    return true;\n  }\n\n  // Check for dynamic data generation\n  if (/Date\\.now\\(\\)|Math\\.random\\(\\)|crypto|uuid/i.test(code)) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Add runId variable to test\n */\nexport function addRunIdVariable(code: string): DataFixResult {\n  // Check if runId already exists\n  if (/\\bconst\\s+runId\\b/.test(code)) {\n    return {\n      applied: false,\n      code,\n      description: 'runId already defined',\n      confidence: 0,\n    };\n  }\n\n  // Find the test function start\n  const testMatch = code.match(/test\\s*\\(\\s*['\"`][^'\"`]+['\"`]\\s*,\\s*async\\s*\\(\\s*\\{[^}]*\\}\\s*\\)\\s*=>\\s*\\{/);\n  if (!testMatch) {\n    return {\n      applied: false,\n      code,\n      description: 'Unable to find test function',\n      confidence: 0,\n    };\n  }\n\n  // Insert runId after the test function opening brace\n  const insertIndex = testMatch.index! + testMatch[0].length;\n  const indentation = '    ';\n  const runIdDeclaration = `\\n${indentation}const runId = \\`\\${Date.now()}-\\${Math.random().toString(36).slice(2, 8)}\\`;`;\n\n  const modifiedCode = code.slice(0, insertIndex) + runIdDeclaration + code.slice(insertIndex);\n\n  return {\n    applied: true,\n    code: modifiedCode,\n    description: 'Added runId variable for data isolation',\n    confidence: 0.8,\n  };\n}\n\n/**\n * Namespace email with runId\n */\nexport function namespaceEmail(email: string, runId: string): string {\n  const [local, domain] = email.split('@');\n  if (!domain) return `${email}-${runId}`;\n  return `${local}+${runId}@${domain}`;\n}\n\n/**\n * Namespace name with runId\n */\nexport function namespaceName(name: string, runId: string): string {\n  return `${name} ${runId}`;\n}\n\n/**\n * Replace hardcoded email with namespaced version\n */\nexport function replaceHardcodedEmail(code: string): DataFixResult {\n  const emailPattern = /(['\"`])([\\w.+-]+@[\\w.-]+\\.[\\w]{2,})(['\"`])/g;\n\n  let applied = false;\n  const modifiedCode = code.replace(emailPattern, (match, _q1, email, _q2) => {\n    // Don't replace if already using template literals with runId\n    if (code.includes('`') && code.includes('${runId}')) {\n      return match;\n    }\n\n    // Check if this is in a fill() or similar\n    const before = code.slice(Math.max(0, code.indexOf(match) - 50), code.indexOf(match));\n    if (/\\.fill\\s*\\([^,]*$/.test(before)) {\n      applied = true;\n      const [local, domain] = email.split('@');\n      return `\\`${local}+\\${runId}@${domain}\\``;\n    }\n\n    return match;\n  });\n\n  return {\n    applied,\n    code: modifiedCode,\n    description: applied ? 'Namespaced email with runId' : 'No hardcoded email to namespace',\n    confidence: applied ? 0.7 : 0,\n  };\n}\n\n/**\n * Replace hardcoded test data with namespaced version\n */\nexport function replaceHardcodedTestData(code: string): DataFixResult {\n  let modifiedCode = code;\n  let applied = false;\n\n  // Replace test names\n  modifiedCode = modifiedCode.replace(\n    /(['\"`])(Test\\s*(?:User|Name|Account|Client|Customer))\\s*(['\"`])/gi,\n    (_match, _q1, name, _q2) => {\n      applied = true;\n      return `\\`${name} \\${runId}\\``;\n    }\n  );\n\n  // Replace test- prefixed strings in fill operations\n  modifiedCode = modifiedCode.replace(\n    /\\.fill\\s*\\([^,]+,\\s*['\"`](test[-_]?\\w+)['\"`]\\s*\\)/gi,\n    (match, value) => {\n      applied = true;\n      return match.replace(`'${value}'`, `\\`${value}-\\${runId}\\``).replace(`\"${value}\"`, `\\`${value}-\\${runId}\\``);\n    }\n  );\n\n  return {\n    applied,\n    code: modifiedCode,\n    description: applied ? 'Namespaced test data with runId' : 'No hardcoded test data found',\n    confidence: applied ? 0.6 : 0,\n  };\n}\n\n/**\n * Apply data isolation fix\n */\nexport function applyDataFix(context: DataFixContext): DataFixResult {\n  const { code } = context;\n\n  // Check if already has isolation\n  if (hasDataIsolation(code)) {\n    return {\n      applied: false,\n      code,\n      description: 'Data isolation already present',\n      confidence: 0,\n    };\n  }\n\n  // First, add runId variable\n  let result = addRunIdVariable(code);\n  if (!result.applied) {\n    return result;\n  }\n\n  let modifiedCode = result.code;\n  let fixCount = 1;\n\n  // Then namespace emails\n  const emailResult = replaceHardcodedEmail(modifiedCode);\n  if (emailResult.applied) {\n    modifiedCode = emailResult.code;\n    fixCount++;\n  }\n\n  // Then namespace test data\n  const dataResult = replaceHardcodedTestData(modifiedCode);\n  if (dataResult.applied) {\n    modifiedCode = dataResult.code;\n    fixCount++;\n  }\n\n  return {\n    applied: true,\n    code: modifiedCode,\n    description: `Applied ${fixCount} data isolation fix(es)`,\n    confidence: 0.7,\n  };\n}\n\n/**\n * Add cleanup hook for test data\n */\nexport function addCleanupHook(code: string, cleanupCode: string): DataFixResult {\n  // Check if afterEach already exists\n  if (/test\\.afterEach\\s*\\(/.test(code)) {\n    return {\n      applied: false,\n      code,\n      description: 'afterEach hook already exists',\n      confidence: 0,\n    };\n  }\n\n  // Find test.describe or test block\n  const describeMatch = code.match(/test\\.describe\\s*\\(\\s*['\"`][^'\"`]+['\"`]\\s*,\\s*\\(\\s*\\)\\s*=>\\s*\\{/);\n\n  if (describeMatch) {\n    // Add after describe opening\n    const insertIndex = describeMatch.index! + describeMatch[0].length;\n    const indentation = '  ';\n    const hookCode = `\\n${indentation}test.afterEach(async () => {\\n${indentation}  ${cleanupCode}\\n${indentation}});\\n`;\n\n    const modifiedCode = code.slice(0, insertIndex) + hookCode + code.slice(insertIndex);\n\n    return {\n      applied: true,\n      code: modifiedCode,\n      description: 'Added afterEach cleanup hook',\n      confidence: 0.7,\n    };\n  }\n\n  return {\n    applied: false,\n    code,\n    description: 'Unable to find suitable location for cleanup hook',\n    confidence: 0,\n  };\n}\n\n/**\n * Extract test data patterns from code\n */\nexport function extractTestDataPatterns(code: string): string[] {\n  const patterns: string[] = [];\n\n  // Find fill operations\n  const fillMatches = code.matchAll(/\\.fill\\s*\\([^,]+,\\s*['\"`]([^'\"`]+)['\"`]\\s*\\)/g);\n  for (const match of fillMatches) {\n    patterns.push(match[1]!);\n  }\n\n  // Find email patterns\n  const emailMatches = code.matchAll(/['\"`]([\\w.+-]+@[\\w.-]+\\.[\\w]{2,})['\"`]/g);\n  for (const match of emailMatches) {\n    patterns.push(match[1]!);\n  }\n\n  return patterns;\n}\n","/**\n * Healing Module Exports\n * @see Phase 6 - User Story 4: Developer Heals Failing Tests Safely\n */\n\n// Rules\nexport {\n  type HealFixType,\n  type ForbiddenFixType,\n  type HealingRule,\n  type HealingConfig,\n  type HealingRuleResult,\n  DEFAULT_HEALING_RULES,\n  DEFAULT_HEALING_CONFIG,\n  UNHEALABLE_CATEGORIES,\n  isCategoryHealable,\n  getApplicableRules,\n  evaluateHealing,\n  getNextFix,\n  isFixAllowed,\n  isFixForbidden,\n  getHealingRecommendation,\n  getPostHealingRecommendation,\n} from './rules.js';\n\n// Logger\nexport {\n  type HealingAttempt,\n  type HealingLog,\n  type HealingSummary,\n  HealingLogger,\n  loadHealingLog,\n  formatHealingLog,\n  createHealingReport,\n  aggregateHealingLogs,\n} from './logger.js';\n\n// Loop Controller\nexport {\n  type HealingLoopOptions,\n  type HealingLoopResult,\n  runHealingLoop,\n  previewHealingFixes,\n  wouldFixApply,\n} from './loop.js';\n\n// Fix Strategies\nexport {\n  type SelectorFixContext,\n  type SelectorFixResult,\n  type ARIANodeInfo,\n  extractCSSSelector,\n  containsCSSSelector,\n  inferRoleFromSelector,\n  extractNameFromSelector,\n  generateRoleLocator,\n  generateLabelLocator,\n  generateTextLocator,\n  generateTestIdLocator,\n  applySelectorFix,\n  addExactToLocator,\n} from './fixes/selector.js';\n\nexport {\n  type NavigationFixContext,\n  type NavigationFixResult,\n  hasNavigationWait,\n  extractUrlFromError,\n  extractUrlFromGoto,\n  inferUrlPattern,\n  generateWaitForURL,\n  generateToHaveURL,\n  insertNavigationWait,\n  applyNavigationFix,\n  fixMissingGotoAwait,\n  addNavigationWaitAfterClick,\n} from './fixes/navigation.js';\n\nexport {\n  type TimingFixContext,\n  type TimingFixResult,\n  extractTimeoutFromError,\n  suggestTimeoutIncrease,\n  fixMissingAwait,\n  convertToWebFirstAssertion,\n  addTimeout,\n  applyTimingFix,\n  wrapWithExpectToPass,\n  wrapWithExpectPoll,\n} from './fixes/timing.js';\n\nexport {\n  type DataFixContext,\n  type DataFixResult,\n  generateRunId,\n  hasDataIsolation,\n  addRunIdVariable,\n  namespaceEmail,\n  namespaceName,\n  replaceHardcodedEmail,\n  replaceHardcodedTestData,\n  applyDataFix,\n  addCleanupHook,\n  extractTestDataPatterns,\n} from './fixes/data.js';\n","import { existsSync, mkdirSync, writeFileSync } from 'node:fs';\nimport { join } from 'node:path';\nimport { stringify as stringifyYaml } from 'yaml';\n\n// Get CURRENT_CONFIG_VERSION from config schema\nconst CURRENT_CONFIG_VERSION = 1;\n\nexport interface InstallOptions {\n  /** Root directory to install into */\n  rootDir: string;\n  /** Project name (for config) */\n  projectName?: string;\n  /** Base URL for tests */\n  baseUrl?: string;\n  /** Test ID attribute */\n  testIdAttribute?: string;\n  /** Skip if already installed */\n  skipIfExists?: boolean;\n  /** Include example Journey */\n  includeExample?: boolean;\n  /** Force overwrite existing files */\n  force?: boolean;\n}\n\nexport interface InstallResult {\n  success: boolean;\n  created: string[];\n  skipped: string[];\n  errors: string[];\n}\n\n/**\n * Install ARTK autogen instance in a project\n */\nexport async function installAutogenInstance(\n  options: InstallOptions\n): Promise<InstallResult> {\n  const {\n    rootDir,\n    projectName = 'my-project',\n    baseUrl = 'http://localhost:3000',\n    testIdAttribute = 'data-testid',\n    skipIfExists = false,\n    includeExample = true,\n    force = false,\n  } = options;\n\n  const result: InstallResult = {\n    success: true,\n    created: [],\n    skipped: [],\n    errors: [],\n  };\n\n  try {\n    // 1. Create directory structure\n    const directories = [\n      'journeys',\n      'tests/journeys',\n      'tests/modules',\n      '.artk',\n    ];\n\n    for (const dir of directories) {\n      const fullPath = join(rootDir, dir);\n      if (existsSync(fullPath)) {\n        if (skipIfExists && !force) {\n          result.skipped.push(dir);\n          continue;\n        }\n      } else {\n        mkdirSync(fullPath, { recursive: true });\n        result.created.push(dir);\n      }\n    }\n\n    // 2. Create config file\n    const configPath = join(rootDir, 'autogen.config.yml');\n    if (!existsSync(configPath) || force) {\n      const config = {\n        version: CURRENT_CONFIG_VERSION,\n        project: projectName,\n        baseUrl,\n        testIdAttribute,\n        paths: {\n          journeys: 'journeys',\n          tests: 'tests/journeys',\n          modules: 'tests/modules',\n        },\n        healing: {\n          enabled: true,\n          maxAttempts: 3,\n        },\n        validation: {\n          requireClarified: true,\n          forbiddenPatterns: [\n            'page\\\\.waitForTimeout',\n            'force:\\\\s*true',\n          ],\n        },\n      };\n\n      writeFileSync(configPath, stringifyYaml(config));\n      result.created.push('autogen.config.yml');\n    } else if (skipIfExists) {\n      result.skipped.push('autogen.config.yml');\n    }\n\n    // 3. Create .artk/.gitignore\n    const gitignorePath = join(rootDir, '.artk/.gitignore');\n    if (!existsSync(gitignorePath) || force) {\n      writeFileSync(gitignorePath, [\n        '# ARTK temporary files',\n        'heal-logs/',\n        '*.heal.json',\n        'selector-catalog.local.json',\n      ].join('\\n'));\n      result.created.push('.artk/.gitignore');\n    } else if (skipIfExists) {\n      result.skipped.push('.artk/.gitignore');\n    }\n\n    // 4. Create glossary.yml\n    const glossaryPath = join(rootDir, '.artk/glossary.yml');\n    if (!existsSync(glossaryPath) || force) {\n      const glossary = {\n        terms: [],\n        aliases: {},\n      };\n      writeFileSync(glossaryPath, stringifyYaml(glossary));\n      result.created.push('.artk/glossary.yml');\n    } else if (skipIfExists) {\n      result.skipped.push('.artk/glossary.yml');\n    }\n\n    // 5. Create example Journey (optional)\n    if (includeExample) {\n      const examplePath = join(rootDir, 'journeys/EXAMPLE-001.md');\n      if (!existsSync(examplePath) || force) {\n        const exampleJourney = `---\nid: EXAMPLE-001\ntitle: Example Journey\nstatus: proposed\ntier: smoke\nscope: example\nactor: user\ntags:\n  - example\n  - smoke\ntests: []\nmodules: []\n---\n\n# Example Journey\n\n## Overview\nThis is an example Journey to demonstrate the format.\n\n## Preconditions\n- User is on the home page\n\n## Acceptance Criteria\n- [ ] AC1: User can see the welcome message\n\n## Steps\n1. Navigate to the home page\n2. Verify the welcome message is visible\n`;\n        writeFileSync(examplePath, exampleJourney);\n        result.created.push('journeys/EXAMPLE-001.md');\n      } else if (skipIfExists) {\n        result.skipped.push('journeys/EXAMPLE-001.md');\n      }\n    }\n\n    // 6. Create VS Code settings (optional)\n    const vscodePath = join(rootDir, '.vscode');\n    if (!existsSync(vscodePath)) {\n      mkdirSync(vscodePath, { recursive: true });\n    }\n\n    const settingsPath = join(vscodePath, 'settings.json');\n    if (!existsSync(settingsPath) || force) {\n      const settings = {\n        'files.associations': {\n          '*.journey.md': 'markdown',\n        },\n        'editor.quickSuggestions': {\n          strings: true,\n        },\n        'chat.promptFilesRecommendations': {\n          'artk.init-playbook': true,\n          'artk.discover-foundation': true,\n          'artk.journey-propose': true,\n          'artk.journey-define': true,\n          'artk.journey-clarify': true,\n          'artk.testid-audit': true,\n          'artk.journey-implement': true,\n          'artk.journey-validate': true,\n          'artk.journey-verify': true,\n        },\n      };\n      writeFileSync(settingsPath, JSON.stringify(settings, null, 2));\n      result.created.push('.vscode/settings.json');\n    } else if (skipIfExists) {\n      result.skipped.push('.vscode/settings.json');\n    }\n\n  } catch (error) {\n    result.success = false;\n    result.errors.push(String(error));\n  }\n\n  return result;\n}\n","import { existsSync, readFileSync, writeFileSync } from 'node:fs';\nimport { join } from 'node:path';\nimport { parse as parseYaml, stringify as stringifyYaml } from 'yaml';\n\n// Get CURRENT_CONFIG_VERSION - this should eventually come from config schema\nconst CURRENT_CONFIG_VERSION = 1;\n\nexport interface UpgradeOptions {\n  /** Root directory of ARTK instance */\n  rootDir: string;\n  /** Target version (default: current) */\n  toVersion?: number;\n  /** Create backup before upgrade */\n  backup?: boolean;\n  /** Dry run - don't write changes */\n  dryRun?: boolean;\n}\n\nexport interface UpgradeResult {\n  success: boolean;\n  fromVersion: number;\n  toVersion: number;\n  changes: UpgradeChange[];\n  backupPath?: string;\n  errors: string[];\n}\n\nexport interface UpgradeChange {\n  type: 'config' | 'file' | 'directory';\n  path: string;\n  description: string;\n}\n\ninterface VersionUpgrade {\n  type: 'config' | 'file' | 'directory';\n  path: string;\n  description: string;\n  apply: (_rootDir: string) => Promise<void>;\n}\n\n/**\n * Upgrade ARTK autogen instance to new version\n */\nexport async function upgradeAutogenInstance(\n  options: UpgradeOptions\n): Promise<UpgradeResult> {\n  const {\n    rootDir,\n    toVersion = CURRENT_CONFIG_VERSION,\n    backup = true,\n    dryRun = false,\n  } = options;\n\n  const result: UpgradeResult = {\n    success: true,\n    fromVersion: 0,\n    toVersion,\n    changes: [],\n    errors: [],\n  };\n\n  try {\n    // 1. Load current config\n    const configPath = join(rootDir, 'autogen.config.yml');\n    if (!existsSync(configPath)) {\n      throw new Error('No autogen.config.yml found. Run install first.');\n    }\n\n    const configContent = readFileSync(configPath, 'utf-8');\n    const config = parseYaml(configContent) as Record<string, unknown>;\n    result.fromVersion = (config.version as number) || 0;\n\n    // 2. Check if upgrade needed\n    if (result.fromVersion >= toVersion) {\n      result.changes.push({\n        type: 'config',\n        path: configPath,\n        description: `Already at version ${result.fromVersion}, no upgrade needed`,\n      });\n      return result;\n    }\n\n    // 3. Create backup\n    if (backup && !dryRun) {\n      const backupPath = `${configPath}.backup-v${result.fromVersion}`;\n      writeFileSync(backupPath, configContent);\n      result.backupPath = backupPath;\n      result.changes.push({\n        type: 'file',\n        path: backupPath,\n        description: 'Created config backup',\n      });\n    }\n\n    // 4. Migrate config\n    const migrationResult = migrateConfig(config, toVersion);\n\n    for (const migration of migrationResult.migrationsApplied) {\n      result.changes.push({\n        type: 'config',\n        path: configPath,\n        description: migration,\n      });\n    }\n\n    // 5. Write migrated config\n    if (!dryRun) {\n      writeFileSync(configPath, stringifyYaml(migrationResult.config));\n    }\n\n    result.changes.push({\n      type: 'config',\n      path: configPath,\n      description: `Upgraded config from v${result.fromVersion} to v${toVersion}`,\n    });\n\n    // 6. Version-specific upgrades\n    const versionUpgrades = getVersionUpgrades(result.fromVersion, toVersion);\n\n    for (const upgrade of versionUpgrades) {\n      if (!dryRun) {\n        await upgrade.apply(rootDir);\n      }\n      result.changes.push({\n        type: upgrade.type,\n        path: upgrade.path,\n        description: upgrade.description,\n      });\n    }\n\n  } catch (error) {\n    result.success = false;\n    result.errors.push(String(error));\n  }\n\n  return result;\n}\n\n/**\n * Migration interface\n */\ninterface Migration {\n  fromVersion: number;\n  toVersion: number;\n  description: string;\n  migrate: (_config: Record<string, unknown>) => Record<string, unknown>;\n}\n\n/**\n * Registry of all migrations\n */\nconst MIGRATIONS: Migration[] = [\n  // Future migrations go here\n  // {\n  //   fromVersion: 1,\n  //   toVersion: 2,\n  //   description: 'Rename selectorPolicy to locatorPolicy',\n  //   migrate: (config) => {\n  //     if (config.selectorPolicy) {\n  //       config.locatorPolicy = config.selectorPolicy;\n  //       delete config.selectorPolicy;\n  //     }\n  //     return config;\n  //   },\n  // },\n];\n\ninterface MigrationResult {\n  migrated: boolean;\n  fromVersion: number;\n  toVersion: number;\n  migrationsApplied: string[];\n  config: Record<string, unknown>;\n}\n\n/**\n * Migrate config to target version\n */\nfunction migrateConfig(\n  config: Record<string, unknown>,\n  toVersion: number = CURRENT_CONFIG_VERSION\n): MigrationResult {\n  const fromVersion = (config.version as number) || 0;\n  let currentConfig = { ...config };\n  const migrationsApplied: string[] = [];\n\n  if (fromVersion === toVersion) {\n    return {\n      migrated: false,\n      fromVersion,\n      toVersion: fromVersion,\n      migrationsApplied: [],\n      config: currentConfig,\n    };\n  }\n\n  // Apply migrations in order\n  for (const migration of MIGRATIONS) {\n    if (migration.fromVersion >= fromVersion &&\n        migration.toVersion <= toVersion) {\n      currentConfig = migration.migrate(currentConfig);\n      migrationsApplied.push(migration.description);\n    }\n  }\n\n  // Set target version\n  currentConfig.version = toVersion;\n\n  return {\n    migrated: true,\n    fromVersion,\n    toVersion,\n    migrationsApplied,\n    config: currentConfig,\n  };\n}\n\n/**\n * Get version-specific upgrade tasks\n */\nfunction getVersionUpgrades(\n  _fromVersion: number,\n  _toVersion: number\n): VersionUpgrade[] {\n  const upgrades: VersionUpgrade[] = [];\n\n  // Future version upgrades go here\n  // if (fromVersion < 2 && toVersion >= 2) {\n  //   upgrades.push({\n  //     type: 'directory',\n  //     path: 'tests/fixtures',\n  //     description: 'Create fixtures directory for v2',\n  //     apply: async (rootDir) => {\n  //       mkdirSync(join(rootDir, 'tests/fixtures'), { recursive: true });\n  //     },\n  //   });\n  // }\n\n  return upgrades;\n}\n\n/**\n * Check if config needs migration\n */\nexport function needsMigration(config: Record<string, unknown>): boolean {\n  const version = (config.version as number) || 0;\n  return version < CURRENT_CONFIG_VERSION;\n}\n\n/**\n * Validate config version is supported\n */\nexport function isVersionSupported(version: number): boolean {\n  return version >= 1 && version <= CURRENT_CONFIG_VERSION;\n}\n","/**\n * @artk/core-autogen - Deterministic Test Generation Engine\n *\n * Transforms clarified Journey markdown files into Playwright E2E tests.\n *\n * @packageDocumentation\n * @module @artk/core-autogen\n */\n\n// Core types\nexport * from './ir/types.js';\n\n// IR builders and serialization\nexport * from './ir/builder.js';\nexport * from './ir/serialize.js';\n\n// Configuration\nexport * from './config/schema.js';\nexport * from './config/loader.js';\n\n// Journey parsing\nexport * from './journey/parseJourney.js';\nexport * from './journey/normalize.js';\nexport * from './journey/hintPatterns.js';\nexport * from './journey/parseHints.js';\n\n// Mapping\nexport * from './mapping/patterns.js';\nexport * from './mapping/glossary.js';\nexport * from './mapping/stepMapper.js';\n\n// Selectors\nexport * from './selectors/priority.js';\nexport * from './selectors/infer.js';\nexport * from './selectors/catalogSchema.js';\nexport * from './selectors/catalog.js';\nexport * from './selectors/scanner.js';\nexport * from './selectors/debt.js';\n\n// Code generation\nexport * from './codegen/generateTest.js';\nexport * from './codegen/generateModule.js';\nexport * from './codegen/astEdit.js';\nexport * from './codegen/registry.js';\nexport * from './codegen/blocks.js';\n\n// Utilities\nexport * from './utils/escaping.js';\nexport * from './utils/version.js';\nexport * from './utils/parsing.js';\nexport * from './utils/result.js';\n\n// Validation\nexport * from './validate/index.js';\n\n// Verification\nexport * from './verify/index.js';\n\n// Healing\nexport * from './heal/index.js';\n\n// Instance lifecycle\nexport * from './instance/install.js';\nexport * from './instance/upgrade.js';\n\n// Main API\nimport { parseJourney, parseJourneyContent } from './journey/parseJourney.js';\nimport { normalizeJourney } from './journey/normalize.js';\nimport { generateTest, type GenerateTestOptions, type GenerateTestResult } from './codegen/generateTest.js';\nimport { generateModule, type GenerateModuleOptions, type GenerateModuleResult } from './codegen/generateModule.js';\nimport { loadConfig } from './config/loader.js';\nimport { initializeLlkb, isLlkbAvailable } from './mapping/stepMapper.js';\nimport type { AutogenConfig } from './config/schema.js';\nimport type { IRJourney } from './ir/types.js';\n\n/**\n * Options for the main generation pipeline\n */\nexport interface GenerateJourneyTestsOptions {\n  /** Journey file paths or content */\n  journeys: string[];\n  /** Whether inputs are file paths (true) or content (false) */\n  isFilePaths?: boolean;\n  /** Output directory for generated files */\n  outputDir?: string;\n  /** Configuration object or path to config file */\n  config?: AutogenConfig | string;\n  /** Generate modules alongside tests */\n  generateModules?: boolean;\n  /** Test generation options */\n  testOptions?: GenerateTestOptions;\n  /** Module generation options */\n  moduleOptions?: GenerateModuleOptions;\n  /** Whether to use LLKB patterns for step mapping (default: true) */\n  useLlkb?: boolean;\n  /** LLKB root directory (default: .artk/llkb) */\n  llkbRoot?: string;\n}\n\n/**\n * Result of the generation pipeline\n */\nexport interface GenerateJourneyTestsResult {\n  /** Generated test files */\n  tests: Array<{\n    journeyId: string;\n    filename: string;\n    code: string;\n  }>;\n  /** Generated module files (if requested) */\n  modules: Array<{\n    moduleName: string;\n    filename: string;\n    code: string;\n  }>;\n  /** Warnings encountered during generation */\n  warnings: string[];\n  /** Errors encountered (generation continues on non-fatal errors) */\n  errors: string[];\n  /** Whether LLKB patterns were used */\n  llkbEnabled?: boolean;\n}\n\n// Re-export LLKB availability check\nexport { initializeLlkb, isLlkbAvailable };\n\n/**\n * Main API: Generate Playwright tests from Journey files\n *\n * @example\n * ```typescript\n * import { generateJourneyTests } from '@artk/core-autogen';\n *\n * const result = await generateJourneyTests({\n *   journeys: ['journeys/login.md', 'journeys/checkout.md'],\n *   isFilePaths: true,\n *   generateModules: true,\n * });\n *\n * for (const test of result.tests) {\n *   console.log(`Generated: ${test.filename}`);\n * }\n * ```\n */\nexport async function generateJourneyTests(\n  options: GenerateJourneyTestsOptions\n): Promise<GenerateJourneyTestsResult> {\n  const {\n    journeys,\n    isFilePaths = true,\n    config,\n    generateModules = false,\n    testOptions = {},\n    moduleOptions = {},\n    useLlkb = true,\n  } = options;\n\n  const result: GenerateJourneyTestsResult = {\n    tests: [],\n    modules: [],\n    warnings: [],\n    errors: [],\n  };\n\n  // Initialize LLKB if enabled (Phase 4 integration)\n  if (useLlkb) {\n    const llkbLoaded = await initializeLlkb();\n    if (llkbLoaded) {\n      result.warnings.push('LLKB patterns enabled for step mapping');\n    }\n  }\n\n  // Load config if provided (reserved for future use)\n  let resolvedConfig: AutogenConfig | undefined;\n  void resolvedConfig; // Reserved for future path resolution\n  if (config) {\n    if (typeof config === 'string') {\n      try {\n        resolvedConfig = loadConfig(config);\n      } catch (err) {\n        result.errors.push(`Failed to load config: ${err instanceof Error ? err.message : String(err)}`);\n      }\n    } else {\n      resolvedConfig = config;\n    }\n  }\n\n  // Process each journey\n  for (const journey of journeys) {\n    try {\n      // Parse journey\n      const parsed = isFilePaths\n        ? parseJourney(journey)\n        : parseJourneyContent(journey, 'inline');\n\n      // Normalize to IR\n      const normalized = normalizeJourney(parsed);\n\n      // Add any mapping warnings\n      result.warnings.push(...normalized.warnings);\n\n      // Generate test\n      const testResult = generateTest(normalized.journey, testOptions);\n      result.tests.push({\n        journeyId: testResult.journeyId,\n        filename: testResult.filename,\n        code: testResult.code,\n      });\n\n      // Generate module if requested\n      if (generateModules) {\n        const moduleResult = generateModule(normalized.journey, moduleOptions);\n        result.modules.push({\n          moduleName: moduleResult.moduleName,\n          filename: moduleResult.filename,\n          code: moduleResult.code,\n        });\n      }\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      result.errors.push(`Failed to process journey ${journey}: ${errorMessage}`);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Generate a single test from an IR Journey\n */\nexport function generateTestFromIR(\n  journey: IRJourney,\n  options?: GenerateTestOptions\n): GenerateTestResult {\n  return generateTest(journey, options);\n}\n\n/**\n * Regenerate a test using managed blocks strategy\n *\n * This preserves user code outside of ARTK:BEGIN/END GENERATED markers\n * while updating the generated portions.\n *\n * @example\n * ```typescript\n * import { regenerateTestWithBlocks, parseAndNormalize } from '@artk/core-autogen';\n *\n * const { journey } = parseAndNormalize('journeys/login.md');\n * const existingCode = readFileSync('tests/login.spec.ts', 'utf-8');\n *\n * const result = regenerateTestWithBlocks(journey, existingCode);\n * writeFileSync('tests/login.spec.ts', result.code);\n *\n * // User code outside ARTK markers is preserved\n * // Generated code inside markers is updated\n * ```\n */\nexport function regenerateTestWithBlocks(\n  journey: IRJourney,\n  existingCode: string,\n  options?: Omit<GenerateTestOptions, 'strategy' | 'existingCode'>\n): GenerateTestResult {\n  return generateTest(journey, {\n    ...options,\n    strategy: 'blocks',\n    existingCode,\n  });\n}\n\n/**\n * Generate a single module from an IR Journey\n */\nexport function generateModuleFromIR(\n  journey: IRJourney,\n  options?: GenerateModuleOptions\n): GenerateModuleResult {\n  return generateModule(journey, options);\n}\n\n/**\n * Parse and normalize a journey file\n */\nexport function parseAndNormalize(filePath: string): {\n  journey: IRJourney;\n  warnings: string[];\n} {\n  const parsed = parseJourney(filePath);\n  const normalized = normalizeJourney(parsed);\n  return {\n    journey: normalized.journey,\n    warnings: normalized.warnings,\n  };\n}\n\n/**\n * Version of the autogen engine\n */\nexport const VERSION = '1.0.0';\n\n// Validation API\nimport {\n  validateCode,\n  validateCodeSync,\n  type CodeValidationResult,\n  type CodeValidationOptions,\n} from './validate/code.js';\n\n/**\n * Options for validating a journey\n */\nexport interface ValidateJourneyOptions extends CodeValidationOptions {\n  /** Journey ID to validate */\n  journeyId?: string;\n  /** Whether inputs are file paths (true) or content (false) */\n  isFilePath?: boolean;\n}\n\n/**\n * Result of journey validation\n */\nexport interface ValidateJourneyResult extends CodeValidationResult {\n  /** The generated code that was validated */\n  generatedCode?: string;\n}\n\n/**\n * Validate a generated journey test\n *\n * @example\n * ```typescript\n * import { validateJourney } from '@artk/core-autogen';\n *\n * const result = await validateJourney('journeys/login.md', {\n *   isFilePath: true,\n *   runLint: true,\n * });\n *\n * if (result.valid) {\n *   console.log('Journey passes validation');\n * } else {\n *   console.log('Issues:', result.issues);\n * }\n * ```\n */\nexport async function validateJourney(\n  journeyInput: string,\n  options: ValidateJourneyOptions = {}\n): Promise<ValidateJourneyResult> {\n  const { isFilePath = true, runLint = false, ...validationOptions } = options;\n\n  try {\n    // Parse journey\n    const parsed = isFilePath\n      ? parseJourney(journeyInput)\n      : parseJourneyContent(journeyInput, 'inline');\n\n    // Normalize to IR\n    const normalized = normalizeJourney(parsed);\n\n    // Generate test code\n    const testResult = generateTest(normalized.journey);\n\n    // Validate the generated code\n    const validationResult = runLint\n      ? await validateCode(testResult.code, normalized.journey, parsed.frontmatter, validationOptions)\n      : validateCodeSync(testResult.code, normalized.journey, parsed.frontmatter, validationOptions);\n\n    return {\n      ...validationResult,\n      generatedCode: testResult.code,\n    };\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    return {\n      valid: false,\n      journeyId: options.journeyId || 'unknown',\n      issues: [\n        {\n          code: 'JOURNEY_PARSE_ERROR',\n          message: `Failed to parse or generate: ${errorMessage}`,\n          severity: 'error',\n        },\n      ],\n      counts: { errors: 1, warnings: 0, info: 0 },\n      details: {\n        patterns: { valid: false, violationCount: 0 },\n      },\n      timestamp: new Date().toISOString(),\n    };\n  }\n}\n\n/**\n * Validate multiple journeys\n */\nexport async function validateJourneys(\n  journeys: string[],\n  options: ValidateJourneyOptions = {}\n): Promise<Map<string, ValidateJourneyResult>> {\n  const results = new Map<string, ValidateJourneyResult>();\n\n  for (const journey of journeys) {\n    const result = await validateJourney(journey, options);\n    results.set(result.journeyId, result);\n  }\n\n  return results;\n}\n\n// Verification API\nimport {\n  runPlaywrightSync,\n  type RunnerOptions,\n} from './verify/runner.js';\nimport {\n  generateVerifySummary,\n  type VerifySummary,\n} from './verify/summary.js';\nimport { writeFileSync, mkdirSync } from 'node:fs';\nimport { join } from 'node:path';\nimport { tmpdir } from 'node:os';\n\n/**\n * Options for verifying a journey\n */\nexport interface VerifyJourneyOptions extends RunnerOptions {\n  /** Journey ID to verify */\n  journeyId?: string;\n  /** Whether input is a file path (true) or content (false) */\n  isFilePath?: boolean;\n  /** Output directory for generated test */\n  outputDir?: string;\n  /** Whether to check stability (repeat runs) */\n  checkStability?: boolean;\n  /** Number of stability runs */\n  stabilityRuns?: number;\n  /** Whether to attempt healing on failure */\n  heal?: boolean;\n  /** Maximum healing attempts */\n  maxHealAttempts?: number;\n}\n\n/**\n * Result of journey verification\n */\nexport interface VerifyJourneyResult extends VerifySummary {\n  /** The generated test code */\n  generatedCode?: string;\n  /** Path to generated test file */\n  testFilePath?: string;\n  /** Healing result (if heal was enabled) */\n  healing?: {\n    attempted: boolean;\n    success: boolean;\n    attempts: number;\n    appliedFix?: string;\n    logPath?: string;\n  };\n}\n\n/**\n * Verify a journey by generating and running tests\n *\n * @example\n * ```typescript\n * import { verifyJourney } from '@artk/core-autogen';\n *\n * const result = await verifyJourney('journeys/login.md', {\n *   isFilePath: true,\n *   checkStability: true,\n * });\n *\n * if (result.status === 'passed') {\n *   console.log('Journey verification passed!');\n * } else {\n *   console.log('Failures:', result.failures.tests);\n * }\n * ```\n */\nexport async function verifyJourney(\n  journeyInput: string,\n  options: VerifyJourneyOptions = {}\n): Promise<VerifyJourneyResult> {\n  const {\n    isFilePath = true,\n    outputDir,\n    checkStability = false,\n    stabilityRuns = 3,\n    heal = false,\n    maxHealAttempts = 3,\n    ...runnerOptions\n  } = options;\n\n  try {\n    // Parse journey\n    const parsed = isFilePath\n      ? parseJourney(journeyInput)\n      : parseJourneyContent(journeyInput, 'inline');\n\n    const journeyId = parsed.frontmatter.id;\n\n    // Normalize to IR\n    const normalized = normalizeJourney(parsed);\n\n    // Generate test code\n    const testResult = generateTest(normalized.journey);\n\n    // Write test to file\n    const testDir = outputDir || join(tmpdir(), `autogen-verify-${Date.now()}`);\n    mkdirSync(testDir, { recursive: true });\n    const testFilePath = join(testDir, testResult.filename);\n    writeFileSync(testFilePath, testResult.code, 'utf-8');\n\n    // Run the test\n    const runResult = runPlaywrightSync({\n      ...runnerOptions,\n      testFile: testFilePath,\n      cwd: testDir,\n      repeatEach: checkStability ? stabilityRuns : undefined,\n      failOnFlaky: checkStability,\n    });\n\n    // Generate summary\n    let summary = generateVerifySummary(runResult, {\n      journeyId,\n    });\n\n    let healingResult: VerifyJourneyResult['healing'];\n\n    // Attempt healing if test failed and heal is enabled\n    if (heal && summary.status === 'failed') {\n      const { runHealingLoop, DEFAULT_HEALING_CONFIG } = await import('./heal/index.js');\n\n      const healResult = await runHealingLoop({\n        journeyId,\n        testFile: testFilePath,\n        outputDir: testDir,\n        config: {\n          ...DEFAULT_HEALING_CONFIG,\n          maxAttempts: maxHealAttempts,\n        },\n        verifyFn: async () => {\n          const rerunResult = runPlaywrightSync({\n            ...runnerOptions,\n            testFile: testFilePath,\n            cwd: testDir,\n          });\n          return generateVerifySummary(rerunResult, { journeyId });\n        },\n      });\n\n      healingResult = {\n        attempted: true,\n        success: healResult.success,\n        attempts: healResult.attempts,\n        appliedFix: healResult.appliedFix,\n        logPath: healResult.logPath,\n      };\n\n      // If healed, update summary\n      if (healResult.success) {\n        const finalResult = runPlaywrightSync({\n          ...runnerOptions,\n          testFile: testFilePath,\n          cwd: testDir,\n        });\n        summary = generateVerifySummary(finalResult, { journeyId });\n      }\n    }\n\n    return {\n      ...summary,\n      generatedCode: testResult.code,\n      testFilePath,\n      healing: healingResult,\n    };\n  } catch {\n    return {\n      status: 'error',\n      journeyId: options.journeyId,\n      timestamp: new Date().toISOString(),\n      duration: 0,\n      counts: { total: 0, passed: 0, failed: 0, skipped: 0, flaky: 0 },\n      failures: {\n        tests: [],\n        classifications: {},\n        stats: {},\n      },\n      runner: { exitCode: 1, command: '' },\n    };\n  }\n}\n\n/**\n * Verify multiple journeys\n */\nexport async function verifyJourneys(\n  journeys: string[],\n  options: VerifyJourneyOptions = {}\n): Promise<Map<string, VerifyJourneyResult>> {\n  const results = new Map<string, VerifyJourneyResult>();\n\n  for (const journey of journeys) {\n    const result = await verifyJourney(journey, options);\n    results.set(result.journeyId || journey, result);\n  }\n\n  return results;\n}\n","import { parseArgs } from 'node:util';\nimport { installAutogenInstance } from '../instance/install.js';\n\nexport async function runInstall(args: string[]): Promise<void> {\n  const { values } = parseArgs({\n    args,\n    options: {\n      dir: { type: 'string', short: 'd', default: '.' },\n      name: { type: 'string', short: 'n' },\n      'base-url': { type: 'string' },\n      'skip-existing': { type: 'boolean', default: false },\n      'no-example': { type: 'boolean', default: false },\n      force: { type: 'boolean', short: 'f', default: false },\n    },\n    allowPositionals: true,\n  });\n\n  console.log('Installing ARTK autogen...\\n');\n\n  const result = await installAutogenInstance({\n    rootDir: values.dir as string,\n    projectName: values.name as string | undefined,\n    baseUrl: values['base-url'] as string | undefined,\n    skipIfExists: values['skip-existing'] as boolean,\n    includeExample: !values['no-example'],\n    force: values.force as boolean,\n  });\n\n  if (result.success) {\n    console.log(' Installation complete\\n');\n\n    if (result.created.length > 0) {\n      console.log('Created:');\n      for (const path of result.created) {\n        console.log(`  + ${path}`);\n      }\n    }\n\n    if (result.skipped.length > 0) {\n      console.log('\\nSkipped (already exists):');\n      for (const path of result.skipped) {\n        console.log(`  - ${path}`);\n      }\n    }\n\n    console.log('\\nNext steps:');\n    console.log('  1. Edit autogen.config.yml with your project settings');\n    console.log('  2. Create Journeys in journeys/ directory');\n    console.log('  3. Run: npx artk-autogen generate <journey.md>');\n  } else {\n    console.error(' Installation failed:\\n');\n    for (const error of result.errors) {\n      console.error(`  ${error}`);\n    }\n    process.exit(1);\n  }\n}\n","import { parseArgs } from 'node:util';\nimport { upgradeAutogenInstance } from '../instance/upgrade.js';\n\nexport async function runUpgrade(args: string[]): Promise<void> {\n  const { values } = parseArgs({\n    args,\n    options: {\n      dir: { type: 'string', short: 'd', default: '.' },\n      'dry-run': { type: 'boolean', default: false },\n      'no-backup': { type: 'boolean', default: false },\n    },\n    allowPositionals: true,\n  });\n\n  console.log('Upgrading ARTK autogen...\\n');\n\n  const result = await upgradeAutogenInstance({\n    rootDir: values.dir as string,\n    dryRun: values['dry-run'] as boolean,\n    backup: !values['no-backup'],\n  });\n\n  if (values['dry-run']) {\n    console.log('[DRY RUN] No changes written\\n');\n  }\n\n  console.log(`Version: ${result.fromVersion}  ${result.toVersion}\\n`);\n\n  if (result.changes.length > 0) {\n    console.log('Changes:');\n    for (const change of result.changes) {\n      console.log(`  ${change.description}`);\n      console.log(`     ${change.path}`);\n    }\n  }\n\n  if (result.backupPath) {\n    console.log(`\\nBackup: ${result.backupPath}`);\n  }\n\n  if (!result.success) {\n    console.error('\\n Upgrade failed:');\n    for (const error of result.errors) {\n      console.error(`  ${error}`);\n    }\n    process.exit(1);\n  }\n\n  console.log('\\n Upgrade complete');\n}\n","/**\n * Pattern distance calculation for finding nearest matching patterns\n */\n\nimport type { StepPattern } from './patterns.js';\n\n/**\n * Extended pattern definition with examples for distance calculation\n */\nexport interface PatternDefinition extends StepPattern {\n  examples?: string[];\n  requiredKeywords?: string[];\n}\n\nexport interface NearestPatternResult {\n  name: string;\n  distance: number;\n  exampleMatch: string;\n  mismatchReason: string;\n}\n\n/**\n * Calculate Levenshtein distance between two strings\n */\nexport function levenshteinDistance(a: string, b: string): number {\n  const matrix: number[][] = [];\n\n  for (let i = 0; i <= b.length; i++) {\n    matrix[i] = [i];\n  }\n\n  for (let j = 0; j <= a.length; j++) {\n    matrix[0]![j] = j;\n  }\n\n  for (let i = 1; i <= b.length; i++) {\n    for (let j = 1; j <= a.length; j++) {\n      if (b.charAt(i - 1) === a.charAt(j - 1)) {\n        matrix[i]![j] = matrix[i - 1]![j - 1]!;\n      } else {\n        matrix[i]![j] = Math.min(\n          matrix[i - 1]![j - 1]! + 1, // substitution\n          matrix[i]![j - 1]! + 1,     // insertion\n          matrix[i - 1]![j]! + 1      // deletion\n        );\n      }\n    }\n  }\n\n  return matrix[b.length]![a.length]!;\n}\n\n/**\n * Calculate normalized similarity between two strings (0-1)\n */\nexport function calculateSimilarity(a: string, b: string): number {\n  const distance = levenshteinDistance(a.toLowerCase(), b.toLowerCase());\n  const maxLength = Math.max(a.length, b.length);\n  if (maxLength === 0) return 1;\n  return 1 - distance / maxLength;\n}\n\n/**\n * Extract example text from a regex pattern\n * This is a heuristic - it tries to create a plausible example from the regex\n */\nfunction generateExampleFromRegex(regex: RegExp, patternName: string): string {\n  // Reserved for future regex-based example generation\n  void regex.source;\n\n  // Navigation patterns\n  if (patternName.includes('navigate')) {\n    return 'User navigates to /path';\n  }\n\n  // Click patterns\n  if (patternName.includes('click')) {\n    return 'User clicks \"Button\" button';\n  }\n\n  // Fill patterns\n  if (patternName.includes('fill') || patternName.includes('enter') || patternName.includes('type')) {\n    return 'User enters \"value\" in \"Field\" field';\n  }\n\n  // Assertion patterns\n  if (patternName.includes('see') || patternName.includes('visible') || patternName.includes('expect')) {\n    return 'User should see \"Content\"';\n  }\n\n  // Wait patterns\n  if (patternName.includes('wait')) {\n    return 'Wait for network idle';\n  }\n\n  // Generic fallback\n  return `Step matching ${patternName}`;\n}\n\n/**\n * Find the nearest pattern for a given step text\n */\nexport function findNearestPattern(\n  text: string,\n  patterns: Map<string, PatternDefinition> | StepPattern[]\n): NearestPatternResult | null {\n  let nearest: NearestPatternResult | null = null;\n  let minDistance = Infinity;\n\n  const normalizedText = text.toLowerCase().trim();\n\n  // Convert to array if it's a Map\n  const patternArray: Array<[string, PatternDefinition | StepPattern]> =\n    patterns instanceof Map\n      ? Array.from(patterns.entries())\n      : patterns.map(p => [p.name, p] as [string, PatternDefinition | StepPattern]);\n\n  for (const [name, pattern] of patternArray) {\n    // Get examples - either from PatternDefinition or generate from regex\n    const examples = 'examples' in pattern && pattern.examples\n      ? pattern.examples\n      : [generateExampleFromRegex(pattern.regex, pattern.name)];\n\n    // Compare against pattern examples\n    for (const example of examples) {\n      const distance = levenshteinDistance(normalizedText, example.toLowerCase());\n      if (distance < minDistance) {\n        minDistance = distance;\n        nearest = {\n          name,\n          distance,\n          exampleMatch: example,\n          mismatchReason: explainMismatch(text, pattern),\n        };\n      }\n    }\n  }\n\n  // Only return if similarity is above threshold (> 50%)\n  if (nearest && nearest.exampleMatch) {\n    const similarity = calculateSimilarity(text, nearest.exampleMatch);\n    if (similarity > 0.5) {\n      return nearest;\n    }\n  }\n\n  return nearest;\n}\n\n/**\n * Explain why a pattern didn't match\n */\nexport function explainMismatch(text: string, pattern: StepPattern | PatternDefinition): string {\n  const reasons: string[] = [];\n  const lowerText = text.toLowerCase();\n\n  // Check for missing keywords based on pattern type\n  const requiredKeywords = 'requiredKeywords' in pattern\n    ? pattern.requiredKeywords\n    : inferRequiredKeywords(pattern);\n\n  if (requiredKeywords) {\n    const missing = requiredKeywords.filter(\n      kw => !lowerText.includes(kw.toLowerCase())\n    );\n    if (missing.length > 0) {\n      reasons.push(`Missing keywords: ${missing.join(', ')}`);\n    }\n  }\n\n  // Check for missing locator hints\n  if (!text.includes('(') && !text.includes('testid=') && !text.includes('role=')) {\n    reasons.push('Missing locator hint (e.g., testid=..., role=button)');\n  }\n\n  // Check for ambiguous target based on pattern type\n  if (pattern.primitiveType === 'click' && !text.match(/['\"].+?['\"]/)) {\n    reasons.push('Target element name not quoted');\n  }\n\n  return reasons.length > 0 ? reasons.join('; ') : 'Pattern format mismatch';\n}\n\n/**\n * Infer required keywords from a pattern\n */\nfunction inferRequiredKeywords(pattern: StepPattern): string[] | undefined {\n  const name = pattern.name.toLowerCase();\n\n  if (name.includes('navigate')) {\n    return ['navigate', 'go', 'open'];\n  }\n\n  if (name.includes('click')) {\n    return ['click', 'press', 'tap'];\n  }\n\n  if (name.includes('fill') || name.includes('enter')) {\n    return ['enter', 'type', 'fill', 'input'];\n  }\n\n  if (name.includes('see') || name.includes('visible')) {\n    return ['see', 'visible', 'shown'];\n  }\n\n  if (name.includes('wait')) {\n    return ['wait'];\n  }\n\n  return undefined;\n}\n","/**\n * Enhanced analysis of blocked steps for AI-assisted fixing\n */\n\nimport { findNearestPattern, type NearestPatternResult, type PatternDefinition } from './patternDistance.js';\nimport type { StepPattern } from './patterns.js';\n\nexport type StepCategory = 'navigation' | 'interaction' | 'assertion' | 'wait' | 'unknown';\n\nexport interface StepSuggestion {\n  priority: number;\n  text: string;\n  explanation: string;\n  confidence: number;\n}\n\nexport interface BlockedStepAnalysis {\n  step: string;\n  reason: string;\n  suggestions: StepSuggestion[];\n  nearestPattern?: NearestPatternResult;\n  machineHintSuggestion?: string;\n  category: StepCategory;\n}\n\n/**\n * Categorize a step based on its text\n */\nexport function categorizeStep(text: string): StepCategory {\n  const lowerText = text.toLowerCase();\n\n  if (lowerText.includes('navigate') || lowerText.includes('go to') ||\n      lowerText.includes('open') || lowerText.includes('visit')) {\n    return 'navigation';\n  }\n\n  if (lowerText.includes('click') || lowerText.includes('fill') ||\n      lowerText.includes('enter') || lowerText.includes('type') ||\n      lowerText.includes('select') || lowerText.includes('check') ||\n      lowerText.includes('press')) {\n    return 'interaction';\n  }\n\n  if (lowerText.includes('see') || lowerText.includes('visible') ||\n      lowerText.includes('verify') || lowerText.includes('assert') ||\n      lowerText.includes('confirm') || lowerText.includes('should') ||\n      lowerText.includes('expect')) {\n    return 'assertion';\n  }\n\n  if (lowerText.includes('wait') || lowerText.includes('load') ||\n      lowerText.includes('until') || lowerText.includes('appear')) {\n    return 'wait';\n  }\n\n  return 'unknown';\n}\n\n/**\n * Infer a machine hint from step text\n */\nexport function inferMachineHint(text: string): string | undefined {\n  const lowerText = text.toLowerCase();\n\n  // Extract element name from quotes\n  const quotedMatch = text.match(/['\"]([^'\"]+)['\"]/);\n  const elementName = quotedMatch?.[1];\n\n  if (!elementName) return undefined;\n\n  // Suggest hint based on context (check more specific terms first)\n  if (lowerText.includes('link')) {\n    return `(role=link, name=${elementName})`;\n  }\n\n  if (lowerText.includes('button') || lowerText.includes('click')) {\n    return `(role=button, name=${elementName})`;\n  }\n\n  if (lowerText.includes('field') || lowerText.includes('input') ||\n      lowerText.includes('enter') || lowerText.includes('type')) {\n    return `(role=textbox, name=${elementName})`;\n  }\n\n  if (lowerText.includes('heading')) {\n    return `(role=heading, name=${elementName})`;\n  }\n\n  if (lowerText.includes('checkbox')) {\n    return `(role=checkbox, name=${elementName})`;\n  }\n\n  return `(text=${elementName})`;\n}\n\n/**\n * Get suggestions for navigation steps\n */\nexport function getNavigationSuggestions(text: string): StepSuggestion[] {\n  const suggestions: StepSuggestion[] = [];\n  const urlMatch = text.match(/\\/[a-zA-Z0-9/_-]+/);\n\n  if (urlMatch) {\n    suggestions.push({\n      priority: 1,\n      text: `User navigates to ${urlMatch[0]}`,\n      explanation: 'Standard navigation pattern',\n      confidence: 0.9,\n    });\n  } else {\n    suggestions.push({\n      priority: 1,\n      text: 'User navigates to /[path]',\n      explanation: 'Add explicit URL path',\n      confidence: 0.5,\n    });\n  }\n\n  return suggestions;\n}\n\n/**\n * Get suggestions for interaction steps\n */\nexport function getInteractionSuggestions(text: string): StepSuggestion[] {\n  const suggestions: StepSuggestion[] = [];\n  const quotedMatch = text.match(/['\"]([^'\"]+)['\"]/);\n  const elementName = quotedMatch?.[1] || '[element]';\n  const lowerText = text.toLowerCase();\n\n  if (lowerText.includes('click')) {\n    suggestions.push({\n      priority: 1,\n      text: `User clicks '${elementName}' button \\`(role=button, name=${elementName})\\``,\n      explanation: 'Add role=button locator hint',\n      confidence: 0.85,\n    });\n  }\n\n  if (lowerText.includes('fill') || lowerText.includes('enter') ||\n      lowerText.includes('type')) {\n    // Try to extract value being entered\n    const valueMatch = text.match(/['\"]([^'\"]+)['\"]/);\n    const value = valueMatch?.[1] || 'value';\n    suggestions.push({\n      priority: 1,\n      text: `User enters '${value}' in '${elementName}' field \\`(role=textbox, name=${elementName})\\``,\n      explanation: 'Add role=textbox locator hint',\n      confidence: 0.85,\n    });\n  }\n\n  return suggestions;\n}\n\n/**\n * Get suggestions for assertion steps\n */\nexport function getAssertionSuggestions(text: string): StepSuggestion[] {\n  const suggestions: StepSuggestion[] = [];\n  const quotedMatch = text.match(/['\"]([^'\"]+)['\"]/);\n  const content = quotedMatch?.[1] || '[content]';\n\n  suggestions.push({\n    priority: 1,\n    text: `User should see '${content}' \\`(text=${content})\\``,\n    explanation: 'Standard visibility assertion',\n    confidence: 0.8,\n  });\n\n  suggestions.push({\n    priority: 2,\n    text: `**Assert**: '${content}' is visible \\`(role=heading, name=${content})\\``,\n    explanation: 'Structured assertion format with heading role',\n    confidence: 0.7,\n  });\n\n  return suggestions;\n}\n\n/**\n * Get suggestions for wait steps\n */\nexport function getWaitSuggestions(_text: string): StepSuggestion[] {\n  const suggestions: StepSuggestion[] = [];\n\n  suggestions.push({\n    priority: 1,\n    text: 'Wait for network idle `(signal=networkidle)`',\n    explanation: 'Standard network wait pattern',\n    confidence: 0.8,\n  });\n\n  suggestions.push({\n    priority: 2,\n    text: 'Wait for page to load `(signal=load)`',\n    explanation: 'Wait for load event',\n    confidence: 0.7,\n  });\n\n  return suggestions;\n}\n\n/**\n * Get generic suggestions for unknown step categories\n */\nexport function getGenericSuggestions(text: string): StepSuggestion[] {\n  return [{\n    priority: 1,\n    text: `**Action**: ${text}`,\n    explanation: 'Use structured format with Action prefix',\n    confidence: 0.5,\n  }];\n}\n\n/**\n * Analyze a blocked step and generate suggestions\n */\nexport function analyzeBlockedStep(\n  step: string,\n  reason: string,\n  patterns?: Map<string, PatternDefinition> | StepPattern[]\n): BlockedStepAnalysis {\n  const category = categorizeStep(step);\n\n  const analysis: BlockedStepAnalysis = {\n    step,\n    reason,\n    suggestions: [],\n    category,\n  };\n\n  // Find nearest pattern if patterns provided\n  if (patterns) {\n    const nearest = findNearestPattern(step, patterns);\n    if (nearest) {\n      analysis.nearestPattern = nearest;\n    }\n  }\n\n  // Generate category-specific suggestions\n  switch (category) {\n    case 'navigation':\n      analysis.suggestions = getNavigationSuggestions(step);\n      break;\n    case 'interaction':\n      analysis.suggestions = getInteractionSuggestions(step);\n      analysis.machineHintSuggestion = inferMachineHint(step);\n      break;\n    case 'assertion':\n      analysis.suggestions = getAssertionSuggestions(step);\n      break;\n    case 'wait':\n      analysis.suggestions = getWaitSuggestions(step);\n      break;\n    default:\n      analysis.suggestions = getGenericSuggestions(step);\n  }\n\n  return analysis;\n}\n\n/**\n * Format a blocked step analysis for console output\n */\nexport function formatBlockedStepAnalysis(analysis: BlockedStepAnalysis): string {\n  const lines: string[] = [];\n\n  lines.push(`\\n  Step: \"${analysis.step}\"`);\n  lines.push(`  Category: ${analysis.category}`);\n  lines.push(`  Reason: ${analysis.reason}`);\n\n  if (analysis.nearestPattern) {\n    lines.push(`  Nearest pattern: ${analysis.nearestPattern.name}`);\n    lines.push(`  Example that works: \"${analysis.nearestPattern.exampleMatch}\"`);\n    lines.push(`  Why it didn't match: ${analysis.nearestPattern.mismatchReason}`);\n  }\n\n  lines.push('  Suggestions:');\n  for (const suggestion of analysis.suggestions) {\n    lines.push(`    ${suggestion.priority}. ${suggestion.text}`);\n    lines.push(`       (${suggestion.explanation}, confidence: ${(suggestion.confidence * 100).toFixed(0)}%)`);\n  }\n\n  if (analysis.machineHintSuggestion) {\n    lines.push(`  Suggested hint: ${analysis.machineHintSuggestion}`);\n  }\n\n  return lines.join('\\n');\n}\n","/**\n * CLI Generate Command - Generate Playwright tests from Journey files\n * @see T094 - Create CLI entry point for generation\n * @see research/2026-01-23_llkb-autogen-integration-specification.md (LLKB integration)\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md (telemetry)\n */\nimport { parseArgs } from 'node:util';\nimport { writeFileSync, mkdirSync, existsSync } from 'node:fs';\nimport { join, dirname, basename } from 'node:path';\nimport fg from 'fast-glob';\nimport { generateJourneyTests, type GenerateJourneyTestsOptions } from '../index.js';\nimport { loadConfigs } from '../config/loader.js';\nimport { loadExtendedGlossary, getGlossaryStats } from '../mapping/glossary.js';\nimport { recordBlockedStep } from '../mapping/telemetry.js';\nimport { analyzeBlockedStep, formatBlockedStepAnalysis } from '../mapping/blockedStepAnalysis.js';\n\nconst USAGE = `\nUsage: artk-autogen generate [options] <journey-files...>\n\nGenerate Playwright tests from Journey markdown files.\n\nArguments:\n  journey-files    Journey file paths or glob patterns\n\nOptions:\n  -o, --output <dir>       Output directory for generated files (default: ./tests/generated)\n  -m, --modules            Also generate module files\n  -c, --config <file>      Path to autogen config file\n  --dry-run                Preview generation without writing files\n  -q, --quiet              Suppress output except errors\n  -h, --help               Show this help message\n\nLLKB Integration Options:\n  --llkb-config <file>     Path to LLKB-generated config file\n  --llkb-glossary <file>   Path to LLKB-generated glossary file\n  --no-llkb                Disable LLKB integration even if config enables it\n\nExamples:\n  artk-autogen generate journeys/login.md\n  artk-autogen generate \"journeys/*.md\" -o tests/e2e -m\n  artk-autogen generate journeys/*.md --dry-run\n  artk-autogen generate journeys/*.md --llkb-config autogen-llkb.config.yml --llkb-glossary llkb-glossary.ts\n`;\n\nexport async function runGenerate(args: string[]): Promise<void> {\n  const { values, positionals } = parseArgs({\n    args,\n    options: {\n      output: { type: 'string', short: 'o' },\n      modules: { type: 'boolean', short: 'm', default: false },\n      config: { type: 'string', short: 'c' },\n      'dry-run': { type: 'boolean', default: false },\n      quiet: { type: 'boolean', short: 'q', default: false },\n      help: { type: 'boolean', short: 'h', default: false },\n      // LLKB integration options\n      'llkb-config': { type: 'string' },\n      'llkb-glossary': { type: 'string' },\n      'no-llkb': { type: 'boolean', default: false },\n    },\n    allowPositionals: true,\n  });\n\n  if (values.help) {\n    console.log(USAGE);\n    return;\n  }\n\n  if (positionals.length === 0) {\n    console.error('Error: No journey files specified');\n    console.log(USAGE);\n    process.exit(1);\n  }\n\n  const outputDir = values.output || './tests/generated';\n  const dryRun = values['dry-run'];\n  const quiet = values.quiet;\n\n  // Load configs (base + LLKB if provided)\n  const configPaths: string[] = [];\n  if (values.config) {\n    configPaths.push(values.config);\n  }\n  if (values['llkb-config'] && !values['no-llkb']) {\n    configPaths.push(values['llkb-config']);\n  }\n\n  // Load merged config if multiple paths provided\n  const configPath = values.config;\n  if (configPaths.length > 1) {\n    // When we have multiple configs, merge them and log\n    // The merged config includes LLKB settings\n    loadConfigs(configPaths);\n    if (!quiet) {\n      console.log(`Loaded ${configPaths.length} config file(s)`);\n    }\n  }\n\n  // Load LLKB glossary if provided\n  if (values['llkb-glossary'] && !values['no-llkb']) {\n    const glossaryResult = await loadExtendedGlossary(values['llkb-glossary']);\n    if (glossaryResult.loaded) {\n      if (!quiet) {\n        console.log(\n          `Loaded LLKB glossary: ${glossaryResult.entryCount} entries` +\n            (glossaryResult.exportedAt ? ` (exported: ${glossaryResult.exportedAt})` : '')\n        );\n      }\n    } else if (!quiet) {\n      console.warn(`Warning: Failed to load LLKB glossary: ${glossaryResult.error}`);\n    }\n  }\n\n  // Expand glob patterns\n  const journeyFiles = await fg(positionals, {\n    absolute: true,\n  });\n\n  if (journeyFiles.length === 0) {\n    console.error('Error: No journey files found matching the patterns');\n    process.exit(1);\n  }\n\n  if (!quiet) {\n    console.log(`Found ${journeyFiles.length} journey file(s)`);\n    // Show LLKB stats if glossary is loaded\n    const stats = getGlossaryStats();\n    if (stats.extendedEntries > 0) {\n      console.log(`LLKB glossary active: ${stats.extendedEntries} extended entries`);\n    }\n  }\n\n  // Generate tests\n  const options: GenerateJourneyTestsOptions = {\n    journeys: journeyFiles,\n    isFilePaths: true,\n    outputDir,\n    generateModules: values.modules,\n  };\n\n  if (configPath) {\n    options.config = configPath;\n  }\n\n  const result = await generateJourneyTests(options);\n\n  // Analyze and record blocked steps for telemetry\n  // Extract blocked steps from warnings (they contain \"BLOCKED:\" prefix)\n  const blockedStepWarnings = result.warnings.filter((w) => w.includes('BLOCKED:'));\n  const blockedStepAnalyses: ReturnType<typeof analyzeBlockedStep>[] = [];\n\n  if (blockedStepWarnings.length > 0) {\n    if (!quiet) {\n      console.log(`\\n Blocked Step Analysis (${blockedStepWarnings.length} blocked steps):\\n`);\n    }\n\n    for (const warning of blockedStepWarnings) {\n      // Extract step text and reason from warning\n      const match = warning.match(/BLOCKED:\\s*(.+?)(?:\\s*-\\s*(.+))?$/);\n      if (match) {\n        const reason = match[1] || 'Unknown reason';\n        const stepText = match[2] || match[1] || warning;\n\n        // Analyze the blocked step\n        const analysis = analyzeBlockedStep(stepText, reason);\n        blockedStepAnalyses.push(analysis);\n\n        // Record to telemetry (for pattern gap analysis)\n        const journeyId = journeyFiles.length === 1 ? basename(journeyFiles[0]!, '.md') : 'multiple';\n        recordBlockedStep({\n          journeyId,\n          stepText,\n          reason,\n          suggestedFix: analysis.suggestions[0]?.text,\n          nearestPattern: analysis.nearestPattern?.name,\n          nearestDistance: analysis.nearestPattern?.distance,\n        });\n\n        // Print analysis (unless quiet)\n        if (!quiet) {\n          console.log(formatBlockedStepAnalysis(analysis));\n          console.log();\n        }\n      }\n    }\n\n    // Write blocked step analysis JSON for AI consumption\n    if (process.env.ARTK_JSON_OUTPUT || !dryRun) {\n      const analysisPath = join(outputDir, 'blocked-steps-analysis.json');\n      if (!dryRun) {\n        mkdirSync(dirname(analysisPath), { recursive: true });\n        writeFileSync(analysisPath, JSON.stringify(blockedStepAnalyses, null, 2), 'utf-8');\n        if (!quiet) {\n          console.log(`\\n Blocked step analysis saved to: ${analysisPath}`);\n          console.log('   Use this file to auto-fix journey steps.\\n');\n        }\n      }\n    }\n  }\n\n  // Output results\n  if (result.errors.length > 0) {\n    console.error('\\nErrors:');\n    for (const error of result.errors) {\n      console.error(`  - ${error}`);\n    }\n  }\n\n  // Filter out blocked step warnings from display (already shown above)\n  const otherWarnings = result.warnings.filter((w) => !w.includes('BLOCKED:'));\n  if (otherWarnings.length > 0 && !quiet) {\n    console.warn('\\nWarnings:');\n    for (const warning of otherWarnings) {\n      console.warn(`  - ${warning}`);\n    }\n  }\n\n  // Write files (unless dry-run)\n  if (!dryRun) {\n    // Ensure output directory exists\n    if (!existsSync(outputDir)) {\n      mkdirSync(outputDir, { recursive: true });\n    }\n\n    // Write test files\n    for (const test of result.tests) {\n      const filePath = join(outputDir, test.filename);\n      mkdirSync(dirname(filePath), { recursive: true });\n      writeFileSync(filePath, test.code, 'utf-8');\n      if (!quiet) {\n        console.log(`Generated: ${filePath}`);\n      }\n    }\n\n    // Write module files\n    for (const mod of result.modules) {\n      const filePath = join(outputDir, 'modules', mod.filename);\n      mkdirSync(dirname(filePath), { recursive: true });\n      writeFileSync(filePath, mod.code, 'utf-8');\n      if (!quiet) {\n        console.log(`Generated: ${filePath}`);\n      }\n    }\n  } else {\n    if (!quiet) {\n      console.log('\\n[Dry run] Would generate:');\n      for (const test of result.tests) {\n        console.log(`  - ${join(outputDir, test.filename)}`);\n      }\n      for (const mod of result.modules) {\n        console.log(`  - ${join(outputDir, 'modules', mod.filename)}`);\n      }\n    }\n  }\n\n  // Summary\n  if (!quiet) {\n    console.log(`\\nSummary:`);\n    console.log(`  Tests: ${result.tests.length}`);\n    console.log(`  Modules: ${result.modules.length}`);\n    console.log(`  Blocked steps: ${blockedStepAnalyses.length}`);\n    console.log(`  Errors: ${result.errors.length}`);\n    console.log(`  Warnings: ${otherWarnings.length}`);\n\n    if (blockedStepAnalyses.length > 0) {\n      console.log(`\\n Run 'artk-autogen patterns gaps' to see pattern improvement suggestions.`);\n    }\n  }\n\n  // Exit with error if there were errors\n  if (result.errors.length > 0) {\n    process.exit(1);\n  }\n}\n","/**\n * CLI Validate Command - Validate generated test code\n * @see T095 - Create CLI entry point for validation\n */\nimport { parseArgs } from 'node:util';\nimport fg from 'fast-glob';\nimport { validateJourneys, type ValidateJourneyResult } from '../index.js';\n\nconst USAGE = `\nUsage: artk-autogen validate [options] <files...>\n\nValidate journey files or generated test code.\n\nArguments:\n  files    Journey files or test files to validate\n\nOptions:\n  --lint             Run ESLint checks (slower but more thorough)\n  --format <type>    Output format: text, json, or summary (default: text)\n  --strict           Fail on warnings too\n  -q, --quiet        Only show errors\n  -h, --help         Show this help message\n\nExamples:\n  artk-autogen validate journeys/login.md\n  artk-autogen validate \"journeys/*.md\" --lint\n  artk-autogen validate journeys/*.md --format json\n`;\n\nexport async function runValidate(args: string[]): Promise<void> {\n  const { values, positionals } = parseArgs({\n    args,\n    options: {\n      lint: { type: 'boolean', default: false },\n      format: { type: 'string', default: 'text' },\n      strict: { type: 'boolean', default: false },\n      quiet: { type: 'boolean', short: 'q', default: false },\n      help: { type: 'boolean', short: 'h', default: false },\n    },\n    allowPositionals: true,\n  });\n\n  if (values.help) {\n    console.log(USAGE);\n    return;\n  }\n\n  if (positionals.length === 0) {\n    console.error('Error: No files specified');\n    console.log(USAGE);\n    process.exit(1);\n  }\n\n  // Expand glob patterns\n  const files = await fg(positionals, {\n    absolute: true,\n  });\n\n  if (files.length === 0) {\n    console.error('Error: No files found matching the patterns');\n    process.exit(1);\n  }\n\n  if (!values.quiet && values.format === 'text') {\n    console.log(`Validating ${files.length} file(s)...`);\n  }\n\n  // Validate each file\n  const results = await validateJourneys(files, {\n    runLint: values.lint,\n  });\n\n  // Format output\n  if (values.format === 'json') {\n    const output: Record<string, ValidateJourneyResult> = {};\n    for (const [id, result] of results) {\n      output[id] = result;\n    }\n    console.log(JSON.stringify(output, null, 2));\n  } else if (values.format === 'summary') {\n    let totalErrors = 0;\n    let totalWarnings = 0;\n    let passed = 0;\n    let failed = 0;\n\n    for (const [, result] of results) {\n      totalErrors += result.counts.errors;\n      totalWarnings += result.counts.warnings;\n      if (result.valid) {\n        passed++;\n      } else {\n        failed++;\n      }\n    }\n\n    console.log(`\\nValidation Summary:`);\n    console.log(`  Passed: ${passed}`);\n    console.log(`  Failed: ${failed}`);\n    console.log(`  Total Errors: ${totalErrors}`);\n    console.log(`  Total Warnings: ${totalWarnings}`);\n  } else {\n    // Text format\n    for (const [journeyId, result] of results) {\n      const status = result.valid ? '' : '';\n      if (!values.quiet || !result.valid) {\n        console.log(`\\n${status} ${journeyId}`);\n      }\n\n      if (!result.valid || (result.counts.warnings > 0 && !values.quiet)) {\n        for (const issue of result.issues) {\n          const icon = issue.severity === 'error' ? '  ' : issue.severity === 'warning' ? '  ' : '  ';\n          if (!values.quiet || issue.severity === 'error') {\n            console.log(`${icon} [${issue.code}] ${issue.message}`);\n            if (issue.field) {\n              console.log(`    field: ${issue.field}`);\n            }\n            if (issue.suggestion) {\n              console.log(`     ${issue.suggestion}`);\n            }\n          }\n        }\n      }\n    }\n\n    // Summary\n    if (!values.quiet) {\n      let passed = 0;\n      let failed = 0;\n      for (const [, result] of results) {\n        if (result.valid) {\n          passed++;\n        } else {\n          failed++;\n        }\n      }\n      console.log(`\\n${passed} passed, ${failed} failed`);\n    }\n  }\n\n  // Determine exit code\n  let hasErrors = false;\n  let hasWarnings = false;\n  for (const [, result] of results) {\n    if (!result.valid) {\n      hasErrors = true;\n    }\n    if (result.counts.warnings > 0) {\n      hasWarnings = true;\n    }\n  }\n\n  if (hasErrors) {\n    process.exit(1);\n  }\n  if (values.strict && hasWarnings) {\n    process.exit(1);\n  }\n}\n","/**\n * CLI Verify Command - Run and verify generated tests\n * @see T096 - Create CLI entry point for verification\n */\nimport { parseArgs } from 'node:util';\nimport fg from 'fast-glob';\nimport { verifyJourneys, type VerifyJourneyResult } from '../index.js';\nimport { parseIntSafe } from '../utils/parsing.js';\n\nconst USAGE = `\nUsage: artk-autogen verify [options] <journey-files...>\n\nGenerate and run Playwright tests from Journey files to verify they work.\n\nArguments:\n  journey-files    Journey file paths or glob patterns\n\nOptions:\n  -o, --output <dir>       Output directory for generated tests\n  --heal                   Attempt to heal failing tests\n  --max-heal <n>           Maximum healing attempts (default: 3)\n  --stability              Run stability checks (repeat tests)\n  --stability-runs <n>     Number of stability runs (default: 3)\n  --format <type>          Output format: text, json (default: text)\n  --reporter <name>        Playwright reporter (default: list)\n  --timeout <ms>           Test timeout in milliseconds\n  -q, --quiet              Suppress output except errors\n  -h, --help               Show this help message\n\nExamples:\n  artk-autogen verify journeys/login.md\n  artk-autogen verify \"journeys/*.md\" --heal\n  artk-autogen verify journeys/login.md --stability --stability-runs 5\n`;\n\nexport async function runVerify(args: string[]): Promise<void> {\n  const { values, positionals } = parseArgs({\n    args,\n    options: {\n      output: { type: 'string', short: 'o' },\n      heal: { type: 'boolean', default: false },\n      'max-heal': { type: 'string', default: '3' },\n      stability: { type: 'boolean', default: false },\n      'stability-runs': { type: 'string', default: '3' },\n      format: { type: 'string', default: 'text' },\n      reporter: { type: 'string', default: 'list' },\n      timeout: { type: 'string' },\n      quiet: { type: 'boolean', short: 'q', default: false },\n      help: { type: 'boolean', short: 'h', default: false },\n    },\n    allowPositionals: true,\n  });\n\n  if (values.help) {\n    console.log(USAGE);\n    return;\n  }\n\n  if (positionals.length === 0) {\n    console.error('Error: No journey files specified');\n    console.log(USAGE);\n    process.exit(1);\n  }\n\n  // Expand glob patterns\n  const journeyFiles = await fg(positionals, {\n    absolute: true,\n  });\n\n  if (journeyFiles.length === 0) {\n    console.error('Error: No journey files found matching the patterns');\n    process.exit(1);\n  }\n\n  if (!values.quiet && values.format === 'text') {\n    console.log(`Verifying ${journeyFiles.length} journey(s)...`);\n  }\n\n  // Verify each journey\n  const results = await verifyJourneys(journeyFiles, {\n    outputDir: values.output,\n    heal: values.heal,\n    maxHealAttempts: parseIntSafe(values['max-heal'], 'max-heal', 3),\n    checkStability: values.stability,\n    stabilityRuns: parseIntSafe(values['stability-runs'], 'stability-runs', 3),\n    reporter: values.reporter,\n    timeout: values.timeout ? parseIntSafe(values.timeout, 'timeout', 30000) : undefined,\n  });\n\n  // Format output\n  if (values.format === 'json') {\n    const output: Record<string, VerifyJourneyResult> = {};\n    for (const [id, result] of results) {\n      output[id] = result;\n    }\n    console.log(JSON.stringify(output, null, 2));\n  } else {\n    // Text format\n    for (const [journeyId, result] of results) {\n      const statusIcon = result.status === 'passed' ? '' : result.status === 'failed' ? '' : '';\n\n      if (!values.quiet || result.status !== 'passed') {\n        console.log(`\\n${statusIcon} ${journeyId}`);\n        console.log(`  Status: ${result.status}`);\n        console.log(`  Duration: ${result.duration}ms`);\n        console.log(`  Tests: ${result.counts.passed}/${result.counts.total} passed`);\n\n        if (result.counts.flaky > 0) {\n          console.log(`  Flaky: ${result.counts.flaky}`);\n        }\n\n        if (result.healing) {\n          console.log(`  Healing:`);\n          console.log(`    Attempted: ${result.healing.attempted}`);\n          console.log(`    Success: ${result.healing.success}`);\n          console.log(`    Attempts: ${result.healing.attempts}`);\n          if (result.healing.appliedFix) {\n            console.log(`    Applied: ${result.healing.appliedFix}`);\n          }\n        }\n\n        if (result.failures.tests.length > 0) {\n          console.log(`  Failures:`);\n          for (const testName of result.failures.tests.slice(0, 5)) {\n            const classification = result.failures.classifications[testName];\n            console.log(`    - ${testName}`);\n            if (classification) {\n              console.log(`      ${classification.category}: ${classification.explanation.substring(0, 100)}`);\n            }\n          }\n          if (result.failures.tests.length > 5) {\n            console.log(`    ... and ${result.failures.tests.length - 5} more`);\n          }\n        }\n\n        if (result.testFilePath && !values.quiet) {\n          console.log(`  Test file: ${result.testFilePath}`);\n        }\n      }\n    }\n\n    // Summary\n    if (!values.quiet) {\n      let passed = 0;\n      let failed = 0;\n      let healed = 0;\n\n      for (const [, result] of results) {\n        if (result.status === 'passed') {\n          passed++;\n        } else {\n          failed++;\n        }\n        if (result.healing?.success) {\n          healed++;\n        }\n      }\n\n      console.log(`\\nSummary:`);\n      console.log(`  Passed: ${passed}`);\n      console.log(`  Failed: ${failed}`);\n      if (healed > 0) {\n        console.log(`  Healed: ${healed}`);\n      }\n    }\n  }\n\n  // Determine exit code\n  let hasFailures = false;\n  for (const [, result] of results) {\n    if (result.status === 'failed' || result.status === 'error') {\n      hasFailures = true;\n      break;\n    }\n  }\n\n  if (hasFailures) {\n    process.exit(1);\n  }\n}\n","/**\n * ARTK AutoGen CLI - Pattern Analysis Command\n * Analyzes blocked step telemetry to identify pattern gaps\n *\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md Phase 3\n */\nimport { parseArgs } from 'node:util';\nimport {\n  analyzeBlockedPatterns,\n  getTelemetryStats,\n  readBlockedStepRecords,\n  clearTelemetry,\n  type PatternGap,\n  type TelemetryStats,\n} from '../mapping/telemetry.js';\nimport { PATTERN_VERSION, getAllPatternNames } from '../mapping/patterns.js';\n\nconst PATTERNS_USAGE = `\nUsage: artk-autogen patterns <subcommand> [options]\n\nSubcommands:\n  gaps        Analyze blocked steps and show pattern gaps\n  stats       Show telemetry statistics\n  list        List all available patterns\n  export      Export gaps as JSON for pattern development\n  clear       Clear telemetry data (use with caution)\n\nOptions:\n  --dir, -d <path>    Base directory (default: current directory)\n  --limit, -n <num>   Limit number of results (default: 20)\n  --json              Output as JSON\n  --category, -c      Filter by category (navigation|interaction|assertion|wait|unknown)\n  -h, --help          Show this help message\n\nExamples:\n  artk-autogen patterns gaps                    # Show top 20 pattern gaps\n  artk-autogen patterns gaps --limit 50         # Show top 50 pattern gaps\n  artk-autogen patterns gaps --category click   # Show only click-related gaps\n  artk-autogen patterns stats                   # Show telemetry statistics\n  artk-autogen patterns list                    # List all patterns\n  artk-autogen patterns export --json           # Export gaps as JSON\n`;\n\n/**\n * Format a pattern gap for console output\n */\nfunction formatPatternGap(gap: PatternGap, index: number): string {\n  const lines: string[] = [];\n  lines.push(`  ${index + 1}. [${gap.count}x] \"${gap.exampleText}\"`);\n  lines.push(`     Category: ${gap.category}`);\n  lines.push(`     First seen: ${new Date(gap.firstSeen).toLocaleDateString()}`);\n\n  if (gap.variants.length > 1) {\n    lines.push(`     Variants: ${gap.variants.length} unique phrasings`);\n    // Show first 3 variants\n    for (const variant of gap.variants.slice(0, 3)) {\n      if (variant !== gap.exampleText) {\n        lines.push(`       - \"${variant}\"`);\n      }\n    }\n    if (gap.variants.length > 3) {\n      lines.push(`       ... and ${gap.variants.length - 3} more`);\n    }\n  }\n\n  if (gap.suggestedPattern) {\n    lines.push(`     Suggested pattern: ${gap.suggestedPattern}`);\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Format telemetry stats for console output\n */\nfunction formatStats(stats: TelemetryStats): string {\n  const lines: string[] = [];\n  lines.push('\\n Blocked Steps Telemetry Statistics\\n');\n  lines.push(`  Total Records: ${stats.totalRecords}`);\n  lines.push(`  Unique Patterns: ${stats.uniquePatterns}`);\n\n  if (stats.totalRecords > 0) {\n    lines.push('\\n  By Category:');\n    for (const [category, count] of Object.entries(stats.byCategory)) {\n      const percentage = ((count / stats.totalRecords) * 100).toFixed(1);\n      lines.push(`    ${category}: ${count} (${percentage}%)`);\n    }\n\n    lines.push('\\n  Date Range:');\n    lines.push(`    Earliest: ${new Date(stats.dateRange.earliest).toLocaleString()}`);\n    lines.push(`    Latest: ${new Date(stats.dateRange.latest).toLocaleString()}`);\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Run the patterns gaps subcommand\n */\nasync function runGaps(options: {\n  baseDir?: string;\n  limit: number;\n  json: boolean;\n  category?: string;\n}): Promise<void> {\n  let gaps = analyzeBlockedPatterns({\n    baseDir: options.baseDir,\n    limit: options.category ? undefined : options.limit, // Don't limit before filtering\n  });\n\n  // Filter by category if specified\n  if (options.category) {\n    gaps = gaps.filter((g) => g.category.toLowerCase().includes(options.category!.toLowerCase()));\n    gaps = gaps.slice(0, options.limit);\n  }\n\n  if (gaps.length === 0) {\n    console.log('\\n No blocked step gaps found. Either no blocked steps have been recorded,');\n    console.log('   or all steps have been successfully matched to patterns.\\n');\n    return;\n  }\n\n  if (options.json) {\n    console.log(JSON.stringify(gaps, null, 2));\n    return;\n  }\n\n  console.log(`\\n Top ${gaps.length} Pattern Gaps (from blocked steps)\\n`);\n  console.log(`Pattern Version: ${PATTERN_VERSION}\\n`);\n\n  for (let i = 0; i < gaps.length; i++) {\n    console.log(formatPatternGap(gaps[i]!, i));\n    console.log();\n  }\n\n  console.log(' To add these patterns, edit: autogen/src/mapping/patterns.ts');\n  console.log('   Use the suggested patterns as starting points.\\n');\n}\n\n/**\n * Run the patterns stats subcommand\n */\nasync function runStats(options: { baseDir?: string; json: boolean }): Promise<void> {\n  const stats = getTelemetryStats({ baseDir: options.baseDir });\n\n  if (options.json) {\n    console.log(JSON.stringify(stats, null, 2));\n    return;\n  }\n\n  console.log(formatStats(stats));\n  console.log();\n}\n\n/**\n * Run the patterns list subcommand\n */\nasync function runList(options: { json: boolean }): Promise<void> {\n  const patternNames = getAllPatternNames();\n\n  if (options.json) {\n    console.log(\n      JSON.stringify(\n        {\n          version: PATTERN_VERSION,\n          count: patternNames.length,\n          patterns: patternNames,\n        },\n        null,\n        2\n      )\n    );\n    return;\n  }\n\n  console.log(`\\n Available Patterns (v${PATTERN_VERSION})\\n`);\n  console.log(`Total: ${patternNames.length} patterns\\n`);\n\n  // Group by category\n  const groups: Record<string, string[]> = {};\n  for (const name of patternNames) {\n    const category = name.split('-')[0] || 'other';\n    if (!groups[category]) {\n      groups[category] = [];\n    }\n    groups[category].push(name);\n  }\n\n  for (const [category, names] of Object.entries(groups).sort()) {\n    console.log(`  ${category}:`);\n    for (const name of names) {\n      console.log(`    - ${name}`);\n    }\n    console.log();\n  }\n}\n\n/**\n * Run the patterns export subcommand\n */\nasync function runExport(options: { baseDir?: string }): Promise<void> {\n  const gaps = analyzeBlockedPatterns({ baseDir: options.baseDir });\n  const stats = getTelemetryStats({ baseDir: options.baseDir });\n  const records = readBlockedStepRecords({ baseDir: options.baseDir });\n\n  const exportData = {\n    exportedAt: new Date().toISOString(),\n    patternVersion: PATTERN_VERSION,\n    statistics: stats,\n    gaps,\n    rawRecords: records,\n  };\n\n  console.log(JSON.stringify(exportData, null, 2));\n}\n\n/**\n * Run the patterns clear subcommand\n */\nasync function runClear(options: { baseDir?: string }): Promise<void> {\n  const stats = getTelemetryStats({ baseDir: options.baseDir });\n\n  if (stats.totalRecords === 0) {\n    console.log('\\n No telemetry data to clear.\\n');\n    return;\n  }\n\n  console.log(`\\n  This will delete ${stats.totalRecords} blocked step records.`);\n  console.log('   This action cannot be undone.\\n');\n\n  // In CLI context, we proceed (user should have been warned by the help)\n  clearTelemetry({ baseDir: options.baseDir });\n  console.log(' Telemetry data cleared.\\n');\n}\n\n/**\n * Main entry point for patterns command\n */\nexport async function runPatterns(args: string[]): Promise<void> {\n  // Parse arguments\n  const { values, positionals } = parseArgs({\n    args,\n    options: {\n      dir: { type: 'string', short: 'd' },\n      limit: { type: 'string', short: 'n', default: '20' },\n      json: { type: 'boolean', default: false },\n      category: { type: 'string', short: 'c' },\n      help: { type: 'boolean', short: 'h' },\n    },\n    allowPositionals: true,\n  });\n\n  if (values.help || positionals.length === 0) {\n    console.log(PATTERNS_USAGE);\n    return;\n  }\n\n  const subcommand = positionals[0];\n  const options = {\n    baseDir: values.dir,\n    limit: parseInt(values.limit as string, 10) || 20,\n    json: values.json as boolean,\n    category: values.category as string | undefined,\n  };\n\n  switch (subcommand) {\n    case 'gaps':\n      await runGaps(options);\n      break;\n    case 'stats':\n      await runStats(options);\n      break;\n    case 'list':\n      await runList(options);\n      break;\n    case 'export':\n      await runExport(options);\n      break;\n    case 'clear':\n      await runClear(options);\n      break;\n    default:\n      console.error(`Unknown subcommand: ${subcommand}`);\n      console.log(PATTERNS_USAGE);\n      process.exit(1);\n  }\n}\n","/**\n * ARTK AutoGen CLI - LLKB Patterns Command\n * Manage learned patterns from LLKB integration\n *\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md Phase 4\n */\nimport { parseArgs } from 'node:util';\nimport {\n  loadLearnedPatterns,\n  getPromotablePatterns,\n  markPatternsPromoted,\n  prunePatterns,\n  getPatternStats,\n  exportPatternsToConfig,\n  clearLearnedPatterns,\n  type LearnedPattern,\n  type PromotedPattern,\n} from '../llkb/patternExtension.js';\n\nconst LLKB_PATTERNS_USAGE = `\nUsage: artk-autogen llkb-patterns <subcommand> [options]\n\nSubcommands:\n  list        List all learned patterns\n  stats       Show pattern statistics\n  promote     Check and display patterns ready for promotion\n  export      Export patterns to LLKB config format\n  prune       Remove low-quality patterns\n  clear       Clear all learned patterns (use with caution)\n\nOptions:\n  --llkb-root, -r <path>    LLKB root directory (default: .artk/llkb)\n  --limit, -n <num>         Limit number of results (default: 20)\n  --min-confidence <num>    Minimum confidence threshold (default: varies by command)\n  --json                    Output as JSON\n  -h, --help                Show this help message\n\nExamples:\n  artk-autogen llkb-patterns list                    # List top 20 learned patterns\n  artk-autogen llkb-patterns list --limit 50         # List top 50 patterns\n  artk-autogen llkb-patterns stats                   # Show statistics\n  artk-autogen llkb-patterns promote                 # Show promotable patterns\n  artk-autogen llkb-patterns export                  # Export to config file\n  artk-autogen llkb-patterns prune --min-confidence 0.3  # Remove low-confidence patterns\n`;\n\n/**\n * Format a learned pattern for console output\n */\nfunction formatPattern(pattern: LearnedPattern, index: number): string {\n  const lines: string[] = [];\n  const confidenceStr = (pattern.confidence * 100).toFixed(0);\n  const status = pattern.promotedToCore ? '[PROMOTED]' : '';\n\n  lines.push(`  ${index + 1}. [${confidenceStr}%] \"${pattern.originalText}\" ${status}`);\n  lines.push(`     ID: ${pattern.id}`);\n  lines.push(`     Type: ${pattern.mappedPrimitive.type}`);\n  lines.push(`     Success: ${pattern.successCount}, Fail: ${pattern.failCount}`);\n  lines.push(`     Sources: ${pattern.sourceJourneys.length} journey(s)`);\n  lines.push(`     Last used: ${new Date(pattern.lastUsed).toLocaleDateString()}`);\n\n  return lines.join('\\n');\n}\n\n/**\n * Format a promotable pattern for console output\n */\nfunction formatPromotablePattern(promoted: PromotedPattern, index: number): string {\n  const lines: string[] = [];\n  const { pattern } = promoted;\n\n  lines.push(`  ${index + 1}. \"${pattern.originalText}\"`);\n  lines.push(`     ID: ${pattern.id}`);\n  lines.push(`     Confidence: ${(pattern.confidence * 100).toFixed(0)}%`);\n  lines.push(`     Priority: ${promoted.priority.toFixed(1)}`);\n  lines.push(`     Generated regex: ${promoted.generatedRegex}`);\n  lines.push(`     Primitive: ${JSON.stringify(pattern.mappedPrimitive)}`);\n\n  return lines.join('\\n');\n}\n\n/**\n * Run the list subcommand\n */\nasync function runList(options: {\n  llkbRoot?: string;\n  limit: number;\n  json: boolean;\n}): Promise<void> {\n  const patterns = loadLearnedPatterns({ llkbRoot: options.llkbRoot });\n\n  if (patterns.length === 0) {\n    console.log('\\n No learned patterns found.');\n    console.log('   Patterns are learned when tests pass after manual fixes.\\n');\n    return;\n  }\n\n  // Sort by confidence descending\n  const sorted = patterns.sort((a, b) => b.confidence - a.confidence).slice(0, options.limit);\n\n  if (options.json) {\n    console.log(JSON.stringify(sorted, null, 2));\n    return;\n  }\n\n  console.log(`\\n Learned Patterns (${sorted.length} of ${patterns.length})\\n`);\n\n  for (let i = 0; i < sorted.length; i++) {\n    console.log(formatPattern(sorted[i]!, i));\n    console.log();\n  }\n}\n\n/**\n * Run the stats subcommand\n */\nasync function runStats(options: { llkbRoot?: string; json: boolean }): Promise<void> {\n  const stats = getPatternStats({ llkbRoot: options.llkbRoot });\n\n  if (options.json) {\n    console.log(JSON.stringify(stats, null, 2));\n    return;\n  }\n\n  console.log('\\n LLKB Pattern Statistics\\n');\n  console.log(`  Total patterns: ${stats.total}`);\n  console.log(`  Promoted to core: ${stats.promoted}`);\n  console.log(`  High confidence (70%): ${stats.highConfidence}`);\n  console.log(`  Low confidence (<30%): ${stats.lowConfidence}`);\n  console.log(`  Average confidence: ${(stats.avgConfidence * 100).toFixed(1)}%`);\n  console.log(`  Total successes: ${stats.totalSuccesses}`);\n  console.log(`  Total failures: ${stats.totalFailures}`);\n  console.log();\n}\n\n/**\n * Run the promote subcommand\n */\nasync function runPromote(options: {\n  llkbRoot?: string;\n  json: boolean;\n  apply: boolean;\n}): Promise<void> {\n  const promotable = getPromotablePatterns({ llkbRoot: options.llkbRoot });\n\n  if (promotable.length === 0) {\n    console.log('\\n No patterns ready for promotion.');\n    console.log('   Patterns need 90% confidence, 5 successes, and 2 source journeys.\\n');\n    return;\n  }\n\n  if (options.json) {\n    console.log(JSON.stringify(promotable, null, 2));\n    return;\n  }\n\n  console.log(`\\n Patterns Ready for Promotion (${promotable.length})\\n`);\n\n  for (let i = 0; i < promotable.length; i++) {\n    console.log(formatPromotablePattern(promotable[i]!, i));\n    console.log();\n  }\n\n  if (options.apply) {\n    const ids = promotable.map((p) => p.pattern.id);\n    markPatternsPromoted(ids, { llkbRoot: options.llkbRoot });\n    console.log(`\\n Marked ${ids.length} patterns as promoted.\\n`);\n  } else {\n    console.log(' Run with --apply to mark these patterns as promoted.\\n');\n  }\n}\n\n/**\n * Run the export subcommand\n */\nasync function runExport(options: {\n  llkbRoot?: string;\n  outputPath?: string;\n  minConfidence: number;\n}): Promise<void> {\n  const result = exportPatternsToConfig({\n    llkbRoot: options.llkbRoot,\n    outputPath: options.outputPath,\n    minConfidence: options.minConfidence,\n  });\n\n  console.log(`\\n Exported ${result.exported} patterns to: ${result.path}\\n`);\n}\n\n/**\n * Run the prune subcommand\n */\nasync function runPrune(options: {\n  llkbRoot?: string;\n  minConfidence: number;\n  minSuccess: number;\n  maxAgeDays: number;\n}): Promise<void> {\n  const result = prunePatterns({\n    llkbRoot: options.llkbRoot,\n    minConfidence: options.minConfidence,\n    minSuccess: options.minSuccess,\n    maxAgeDays: options.maxAgeDays,\n  });\n\n  console.log(`\\n Pruned ${result.removed} low-quality patterns.`);\n  console.log(`   Remaining: ${result.remaining} patterns.\\n`);\n}\n\n/**\n * Run the clear subcommand\n */\nasync function runClear(options: { llkbRoot?: string }): Promise<void> {\n  const stats = getPatternStats({ llkbRoot: options.llkbRoot });\n\n  if (stats.total === 0) {\n    console.log('\\n No patterns to clear.\\n');\n    return;\n  }\n\n  console.log(`\\n  This will delete ${stats.total} learned patterns.`);\n  console.log('   This action cannot be undone.\\n');\n\n  clearLearnedPatterns({ llkbRoot: options.llkbRoot });\n  console.log(' All learned patterns cleared.\\n');\n}\n\n/**\n * Main entry point for llkb-patterns command\n */\nexport async function runLlkbPatterns(args: string[]): Promise<void> {\n  const { values, positionals } = parseArgs({\n    args,\n    options: {\n      'llkb-root': { type: 'string', short: 'r' },\n      limit: { type: 'string', short: 'n', default: '20' },\n      'min-confidence': { type: 'string', default: '0.7' },\n      'min-success': { type: 'string', default: '1' },\n      'max-age-days': { type: 'string', default: '90' },\n      output: { type: 'string', short: 'o' },\n      json: { type: 'boolean', default: false },\n      apply: { type: 'boolean', default: false },\n      help: { type: 'boolean', short: 'h' },\n    },\n    allowPositionals: true,\n  });\n\n  if (values.help || positionals.length === 0) {\n    console.log(LLKB_PATTERNS_USAGE);\n    return;\n  }\n\n  const subcommand = positionals[0];\n  const baseOptions = {\n    llkbRoot: values['llkb-root'] as string | undefined,\n    json: values.json as boolean,\n  };\n\n  switch (subcommand) {\n    case 'list':\n      await runList({\n        ...baseOptions,\n        limit: parseInt(values.limit as string, 10) || 20,\n      });\n      break;\n\n    case 'stats':\n      await runStats(baseOptions);\n      break;\n\n    case 'promote':\n      await runPromote({\n        ...baseOptions,\n        apply: values.apply as boolean,\n      });\n      break;\n\n    case 'export':\n      await runExport({\n        llkbRoot: baseOptions.llkbRoot,\n        outputPath: values.output as string | undefined,\n        minConfidence: parseFloat(values['min-confidence'] as string) || 0.7,\n      });\n      break;\n\n    case 'prune':\n      await runPrune({\n        llkbRoot: baseOptions.llkbRoot,\n        minConfidence: parseFloat(values['min-confidence'] as string) || 0.3,\n        minSuccess: parseInt(values['min-success'] as string, 10) || 1,\n        maxAgeDays: parseInt(values['max-age-days'] as string, 10) || 90,\n      });\n      break;\n\n    case 'clear':\n      await runClear({ llkbRoot: baseOptions.llkbRoot });\n      break;\n\n    default:\n      console.error(`Unknown subcommand: ${subcommand}`);\n      console.log(LLKB_PATTERNS_USAGE);\n      process.exit(1);\n  }\n}\n","#!/usr/bin/env node\n/**\n * ARTK AutoGen CLI - Command-line interface for test generation\n */\nimport { VERSION } from '../index.js';\n\nconst USAGE = `\nUsage: artk-autogen <command> [options]\n\nCommands:\n  install        Install ARTK autogen instance in a project\n  upgrade        Upgrade ARTK autogen instance to new version\n  generate       Generate Playwright tests from Journey files\n  validate       Validate generated test code\n  verify         Run and verify generated tests\n  patterns       Analyze blocked step telemetry and pattern gaps\n  llkb-patterns  Manage learned patterns from LLKB integration\n\nOptions:\n  -h, --help      Show this help message\n  -v, --version   Show version\n\nExamples:\n  artk-autogen install --dir ./my-project\n  artk-autogen upgrade --dir ./my-project\n  artk-autogen generate journeys/login.md\n  artk-autogen validate tests/login.spec.ts\n  artk-autogen verify journeys/login.md --heal\n  artk-autogen patterns gaps --limit 20\n  artk-autogen patterns stats\n  artk-autogen llkb-patterns list\n  artk-autogen llkb-patterns promote\n`;\n\nasync function main(): Promise<void> {\n  const args = process.argv.slice(2);\n\n  if (args.length === 0) {\n    console.log(USAGE);\n    process.exit(0);\n  }\n\n  const command = args[0];\n\n  // Check for global flags\n  if (command === '-h' || command === '--help') {\n    console.log(USAGE);\n    process.exit(0);\n  }\n\n  if (command === '-v' || command === '--version') {\n    console.log(`@artk/core-autogen v${VERSION}`);\n    process.exit(0);\n  }\n\n  // Route to subcommands\n  const subArgs = args.slice(1);\n\n  try {\n    switch (command) {\n      case 'install': {\n        const { runInstall } = await import('./install.js');\n        await runInstall(subArgs);\n        break;\n      }\n      case 'upgrade': {\n        const { runUpgrade } = await import('./upgrade.js');\n        await runUpgrade(subArgs);\n        break;\n      }\n      case 'generate': {\n        const { runGenerate } = await import('./generate.js');\n        await runGenerate(subArgs);\n        break;\n      }\n      case 'validate': {\n        const { runValidate } = await import('./validate.js');\n        await runValidate(subArgs);\n        break;\n      }\n      case 'verify': {\n        const { runVerify } = await import('./verify.js');\n        await runVerify(subArgs);\n        break;\n      }\n      case 'patterns': {\n        const { runPatterns } = await import('./patterns.js');\n        await runPatterns(subArgs);\n        break;\n      }\n      case 'llkb-patterns': {\n        const { runLlkbPatterns } = await import('./llkb-patterns.js');\n        await runLlkbPatterns(subArgs);\n        break;\n      }\n      default:\n        console.error(`Unknown command: ${command}`);\n        console.log(USAGE);\n        process.exit(1);\n    }\n  } catch (error) {\n    console.error('Error:', error instanceof Error ? error.message : String(error));\n    process.exit(1);\n  }\n}\n\nmain();\n"]}
{"version":3,"sources":["../../src/mapping/glossary.ts","../../src/llkb/patternExtension.ts","../../src/journey/schema.ts","../../src/mapping/patterns.ts","../../src/utils/result.ts","../../src/journey/parseJourney.ts","../../src/mapping/stepMapper.ts","../../src/journey/hintPatterns.ts","../../src/journey/parseHints.ts","../../src/utils/escaping.ts","../../src/journey/normalize.ts","../../src/journey/updater.ts"],"names":["z","existsSync","readFileSync","err","parseYaml","isAssertion","stringifyYaml","writeFileSync"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Glossary Loader - Load and resolve synonyms for step text normalization\n * @see research/2026-01-02_autogen-refined-plan.md Section 10\n * @see research/2026-01-23_llkb-autogen-integration-specification.md (LLKB integration)\n */\nimport { readFileSync, existsSync } from 'node:fs';\nimport { resolve } from 'node:path';\nimport { pathToFileURL } from 'node:url';\nimport { parse as parseYaml } from 'yaml';\nimport { z } from 'zod';\nimport type { IRPrimitive } from '../ir/types.js';\n\n/**\n * Glossary entry schema\n */\nconst GlossaryEntrySchema = z.object({\n  canonical: z.string(),\n  synonyms: z.array(z.string()),\n});\n\n/**\n * Label alias entry schema (maps display labels to testids/selectors)\n * @see T082 - Extend glossary schema for labelAliases\n */\nconst LabelAliasSchema = z.object({\n  label: z.string(),\n  testid: z.string().optional(),\n  role: z.string().optional(),\n  selector: z.string().optional(),\n});\n\n/**\n * Module method mapping schema (maps phrases to module.method calls)\n * @see T082 - Module method resolution\n */\nconst ModuleMethodMappingSchema = z.object({\n  phrase: z.string(),\n  module: z.string(),\n  method: z.string(),\n  params: z.record(z.string()).optional(),\n});\n\n/**\n * Glossary file schema\n */\nconst GlossarySchema = z.object({\n  version: z.number().default(1),\n  entries: z.array(GlossaryEntrySchema),\n  labelAliases: z.array(LabelAliasSchema).default([]),\n  moduleMethods: z.array(ModuleMethodMappingSchema).default([]),\n});\n\nexport type LabelAlias = z.infer<typeof LabelAliasSchema>;\nexport type ModuleMethodMapping = z.infer<typeof ModuleMethodMappingSchema>;\n\nexport type GlossaryEntry = z.infer<typeof GlossaryEntrySchema>;\nexport type Glossary = z.infer<typeof GlossarySchema>;\n\n/**\n * Default glossary entries for common terms\n */\nexport const defaultGlossary: Glossary = {\n  version: 1,\n  labelAliases: [\n    // Common label-to-selector mappings\n    { label: 'email', testid: 'email-input', role: 'textbox' },\n    { label: 'password', testid: 'password-input', role: 'textbox' },\n    { label: 'username', testid: 'username-input', role: 'textbox' },\n    { label: 'search', testid: 'search-input', role: 'searchbox' },\n    { label: 'submit', testid: 'submit-button', role: 'button' },\n    { label: 'cancel', testid: 'cancel-button', role: 'button' },\n    { label: 'close', testid: 'close-button', role: 'button' },\n  ],\n  moduleMethods: [\n    // Common phrase-to-module mappings\n    { phrase: 'log in', module: 'auth', method: 'login' },\n    { phrase: 'login', module: 'auth', method: 'login' },\n    { phrase: 'sign in', module: 'auth', method: 'login' },\n    { phrase: 'log out', module: 'auth', method: 'logout' },\n    { phrase: 'logout', module: 'auth', method: 'logout' },\n    { phrase: 'sign out', module: 'auth', method: 'logout' },\n    { phrase: 'navigate to', module: 'navigation', method: 'goToPath' },\n    { phrase: 'go to', module: 'navigation', method: 'goToPath' },\n    { phrase: 'open', module: 'navigation', method: 'goToPath' },\n    { phrase: 'fill form', module: 'forms', method: 'fillForm' },\n    { phrase: 'submit form', module: 'forms', method: 'submitForm' },\n    { phrase: 'wait for', module: 'waits', method: 'waitForSignal' },\n  ],\n  entries: [\n    {\n      canonical: 'click',\n      synonyms: ['press', 'tap', 'select', 'hit'],\n    },\n    {\n      canonical: 'enter',\n      synonyms: ['type', 'fill', 'input', 'write'],\n    },\n    {\n      canonical: 'navigate',\n      synonyms: ['go', 'open', 'visit', 'browse'],\n    },\n    {\n      canonical: 'see',\n      synonyms: ['view', 'observe', 'notice', 'find'],\n    },\n    {\n      canonical: 'visible',\n      synonyms: ['displayed', 'shown', 'present'],\n    },\n    {\n      canonical: 'button',\n      synonyms: ['btn', 'action', 'cta'],\n    },\n    {\n      canonical: 'field',\n      synonyms: ['input', 'textbox', 'text field', 'text input'],\n    },\n    {\n      canonical: 'dropdown',\n      synonyms: ['select', 'combo', 'combobox', 'selector', 'picker'],\n    },\n    {\n      canonical: 'checkbox',\n      synonyms: ['check', 'tick', 'toggle'],\n    },\n    {\n      canonical: 'login',\n      synonyms: ['log in', 'sign in', 'authenticate'],\n    },\n    {\n      canonical: 'logout',\n      synonyms: ['log out', 'sign out', 'exit'],\n    },\n    {\n      canonical: 'submit',\n      synonyms: ['send', 'save', 'confirm', 'ok'],\n    },\n    {\n      canonical: 'cancel',\n      synonyms: ['close', 'dismiss', 'abort', 'back'],\n    },\n    {\n      canonical: 'success',\n      synonyms: ['passed', 'completed', 'done', 'finished'],\n    },\n    {\n      canonical: 'error',\n      synonyms: ['failure', 'failed', 'problem', 'issue'],\n    },\n    {\n      canonical: 'toast',\n      synonyms: ['notification', 'message', 'alert', 'snackbar'],\n    },\n    {\n      canonical: 'modal',\n      synonyms: ['dialog', 'popup', 'overlay', 'lightbox'],\n    },\n    {\n      canonical: 'user',\n      synonyms: ['customer', 'visitor', 'member', 'client'],\n    },\n    {\n      canonical: 'page',\n      synonyms: ['screen', 'view', 'section'],\n    },\n    {\n      canonical: 'form',\n      synonyms: ['questionnaire', 'survey', 'wizard'],\n    },\n  ],\n};\n\n/**\n * Loaded glossary cache\n */\nlet glossaryCache: Glossary | null = null;\nlet synonymMap: Map<string, string> | null = null;\n\n/**\n * Build a synonym lookup map from glossary\n */\nfunction buildSynonymMap(glossary: Glossary): Map<string, string> {\n  const map = new Map<string, string>();\n\n  for (const entry of glossary.entries) {\n    // Map canonical to itself\n    map.set(entry.canonical.toLowerCase(), entry.canonical);\n\n    // Map all synonyms to canonical\n    for (const synonym of entry.synonyms) {\n      map.set(synonym.toLowerCase(), entry.canonical);\n    }\n  }\n\n  return map;\n}\n\n/**\n * Load glossary from file\n * @param glossaryPath - Path to glossary YAML file\n */\nexport function loadGlossary(glossaryPath: string): Glossary {\n  const resolvedPath = resolve(glossaryPath);\n\n  if (!existsSync(resolvedPath)) {\n    console.warn(`Glossary file not found at ${resolvedPath}, using defaults`);\n    return defaultGlossary;\n  }\n\n  try {\n    const content = readFileSync(resolvedPath, 'utf-8');\n    const parsed = parseYaml(content);\n    const result = GlossarySchema.safeParse(parsed);\n\n    if (!result.success) {\n      console.warn(`Invalid glossary file at ${resolvedPath}, using defaults`);\n      return defaultGlossary;\n    }\n\n    // Merge with defaults\n    return mergeGlossaries(defaultGlossary, result.data);\n  } catch {\n    console.warn(`Failed to load glossary from ${resolvedPath}, using defaults`);\n    return defaultGlossary;\n  }\n}\n\n/**\n * Merge two glossaries (user glossary extends defaults)\n */\nexport function mergeGlossaries(base: Glossary, extension: Glossary): Glossary {\n  const merged: Glossary = {\n    version: Math.max(base.version, extension.version),\n    entries: [...base.entries],\n    labelAliases: [...(base.labelAliases ?? [])],\n    moduleMethods: [...(base.moduleMethods ?? [])],\n  };\n\n  // Add or extend entries from extension\n  for (const extEntry of extension.entries) {\n    const existing = merged.entries.find(\n      (e) => e.canonical.toLowerCase() === extEntry.canonical.toLowerCase()\n    );\n\n    if (existing) {\n      // Merge synonyms\n      const allSynonyms = new Set([...existing.synonyms, ...extEntry.synonyms]);\n      existing.synonyms = Array.from(allSynonyms);\n    } else {\n      // Add new entry\n      merged.entries.push(extEntry);\n    }\n  }\n\n  // Add or extend label aliases from extension\n  for (const extAlias of extension.labelAliases ?? []) {\n    const existing = merged.labelAliases.find(\n      (a) => a.label.toLowerCase() === extAlias.label.toLowerCase()\n    );\n\n    if (!existing) {\n      merged.labelAliases.push(extAlias);\n    } else {\n      // Override with extension values\n      Object.assign(existing, extAlias);\n    }\n  }\n\n  // Add or extend module methods from extension\n  for (const extMethod of extension.moduleMethods ?? []) {\n    const existing = merged.moduleMethods.find(\n      (m) => m.phrase.toLowerCase() === extMethod.phrase.toLowerCase()\n    );\n\n    if (!existing) {\n      merged.moduleMethods.push(extMethod);\n    } else {\n      // Override with extension values\n      Object.assign(existing, extMethod);\n    }\n  }\n\n  return merged;\n}\n\n/**\n * Initialize the glossary (call once at startup)\n * @param glossaryPath - Optional path to custom glossary\n */\nexport function initGlossary(glossaryPath?: string): void {\n  if (glossaryPath) {\n    glossaryCache = loadGlossary(glossaryPath);\n  } else {\n    glossaryCache = defaultGlossary;\n  }\n  synonymMap = buildSynonymMap(glossaryCache);\n}\n\n/**\n * Get the current glossary\n */\nexport function getGlossary(): Glossary {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n  return glossaryCache!;\n}\n\n/**\n * Resolve a term to its canonical form\n * @param term - Term to resolve\n * @returns Canonical form or original term if not found\n */\nexport function resolveCanonical(term: string): string {\n  if (!synonymMap) {\n    initGlossary();\n  }\n  return synonymMap!.get(term.toLowerCase()) ?? term;\n}\n\n/**\n * Normalize step text by replacing synonyms with canonical terms\n * @param text - Step text to normalize\n * @returns Normalized text\n */\nexport function normalizeStepText(text: string): string {\n  if (!synonymMap) {\n    initGlossary();\n  }\n\n  // Split into words, preserving quoted strings\n  const parts: string[] = [];\n  const regex = /(['\"][^'\"]+['\"])|(\\S+)/g;\n  let match;\n\n  while ((match = regex.exec(text)) !== null) {\n    const part = match[0];\n\n    // Don't normalize quoted strings\n    if (part.startsWith('\"') || part.startsWith(\"'\")) {\n      parts.push(part);\n    } else {\n      // Check if this word has a canonical form\n      // Lowercase for consistent matching (LLKB pattern matching requires this)\n      const lowerPart = part.toLowerCase();\n      const canonical = synonymMap!.get(lowerPart);\n      parts.push(canonical ?? lowerPart);\n    }\n  }\n\n  return parts.join(' ');\n}\n\n/**\n * Get all synonyms for a canonical term\n */\nexport function getSynonyms(canonical: string): string[] {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n\n  const entry = glossaryCache!.entries.find(\n    (e) => e.canonical.toLowerCase() === canonical.toLowerCase()\n  );\n\n  return entry?.synonyms ?? [];\n}\n\n/**\n * Check if a term is a synonym of a canonical term\n */\nexport function isSynonymOf(term: string, canonical: string): boolean {\n  const resolved = resolveCanonical(term);\n  return resolved.toLowerCase() === canonical.toLowerCase();\n}\n\n/**\n * Reset the glossary cache (for testing)\n */\nexport function resetGlossaryCache(): void {\n  glossaryCache = null;\n  synonymMap = null;\n}\n\n/**\n * Find a label alias by label text\n * @see T082 - Label alias matching\n */\nexport function findLabelAlias(label: string): LabelAlias | null {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n\n  const normalizedLabel = label.toLowerCase().trim();\n\n  return (\n    glossaryCache!.labelAliases?.find(\n      (alias) => alias.label.toLowerCase() === normalizedLabel\n    ) ?? null\n  );\n}\n\n/**\n * Get locator info from label alias\n */\nexport function getLocatorFromLabel(label: string): { strategy: string; value: string } | null {\n  const alias = findLabelAlias(label);\n  if (!alias) return null;\n\n  // Priority: testid > role > selector\n  if (alias.testid) {\n    return { strategy: 'testid', value: alias.testid };\n  }\n  if (alias.role) {\n    return { strategy: 'role', value: alias.role };\n  }\n  if (alias.selector) {\n    return { strategy: 'css', value: alias.selector };\n  }\n\n  return null;\n}\n\n/**\n * Find a module method mapping by phrase\n * @see T083 - Module method resolution in step mapper\n */\nexport function findModuleMethod(text: string): ModuleMethodMapping | null {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n\n  const normalizedText = text.toLowerCase().trim();\n\n  // Find the best matching phrase (longest match wins)\n  let bestMatch: ModuleMethodMapping | null = null;\n  let bestMatchLength = 0;\n\n  for (const mapping of glossaryCache!.moduleMethods ?? []) {\n    const phrase = mapping.phrase.toLowerCase();\n    if (normalizedText.includes(phrase) && phrase.length > bestMatchLength) {\n      bestMatch = mapping;\n      bestMatchLength = phrase.length;\n    }\n  }\n\n  return bestMatch;\n}\n\n/**\n * Resolve a step to a module method call if it matches\n */\nexport function resolveModuleMethod(\n  text: string\n): { module: string; method: string; params?: Record<string, string> } | null {\n  const mapping = findModuleMethod(text);\n  if (!mapping) return null;\n\n  return {\n    module: mapping.module,\n    method: mapping.method,\n    params: mapping.params,\n  };\n}\n\n/**\n * Get all label aliases\n */\nexport function getLabelAliases(): LabelAlias[] {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n  return glossaryCache!.labelAliases ?? [];\n}\n\n/**\n * Get all module method mappings\n */\nexport function getModuleMethods(): ModuleMethodMapping[] {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n  return glossaryCache!.moduleMethods ?? [];\n}\n\n// ============================================================================\n// LLKB Extended Glossary Support\n// @see research/2026-01-23_llkb-autogen-integration-specification.md\n// ============================================================================\n\n/**\n * Extended glossary metadata from LLKB export\n */\nexport interface ExtendedGlossaryMeta {\n  exportedAt: string;\n  entryCount: number;\n  minConfidence?: number;\n  sourceComponents?: string[];\n  sourceLessons?: string[];\n}\n\n/**\n * Extended glossary loaded from LLKB export\n */\nlet extendedGlossary: Map<string, IRPrimitive> | null = null;\nlet extendedGlossaryMeta: ExtendedGlossaryMeta | null = null;\n\n/**\n * Load extended glossary from LLKB export file\n * @param glossaryPath - Path to the LLKB-generated glossary TypeScript file\n * @returns Loading result with entry count and metadata\n */\nexport async function loadExtendedGlossary(glossaryPath: string): Promise<{\n  loaded: boolean;\n  entryCount: number;\n  exportedAt: string | null;\n  error?: string;\n}> {\n  try {\n    const resolvedPath = resolve(glossaryPath);\n\n    if (!existsSync(resolvedPath)) {\n      return {\n        loaded: false,\n        entryCount: 0,\n        exportedAt: null,\n        error: `Glossary file not found: ${resolvedPath}`,\n      };\n    }\n\n    // Dynamic import of the generated glossary file\n    // Use file:// URL for Windows compatibility\n    const fileUrl = pathToFileURL(resolvedPath).href;\n    const module = await import(fileUrl);\n\n    if (module.llkbGlossary instanceof Map) {\n      const glossaryMap: Map<string, IRPrimitive> = module.llkbGlossary;\n      extendedGlossary = glossaryMap;\n      extendedGlossaryMeta = module.llkbGlossaryMeta ?? null;\n\n      return {\n        loaded: true,\n        entryCount: glossaryMap.size,\n        exportedAt: extendedGlossaryMeta?.exportedAt ?? null,\n      };\n    }\n\n    // If llkbGlossary is a plain object, convert to Map\n    if (module.llkbGlossary && typeof module.llkbGlossary === 'object') {\n      const glossaryMap = new Map<string, IRPrimitive>(\n        Object.entries(module.llkbGlossary) as [string, IRPrimitive][]\n      );\n      extendedGlossary = glossaryMap;\n      extendedGlossaryMeta = module.llkbGlossaryMeta ?? null;\n\n      return {\n        loaded: true,\n        entryCount: glossaryMap.size,\n        exportedAt: extendedGlossaryMeta?.exportedAt ?? null,\n      };\n    }\n\n    return {\n      loaded: false,\n      entryCount: 0,\n      exportedAt: null,\n      error: 'Invalid glossary format: llkbGlossary not found or not a Map/object',\n    };\n  } catch (err) {\n    return {\n      loaded: false,\n      entryCount: 0,\n      exportedAt: null,\n      error: `Failed to load glossary: ${err instanceof Error ? err.message : String(err)}`,\n    };\n  }\n}\n\n/**\n * Clear extended glossary (for testing)\n */\nexport function clearExtendedGlossary(): void {\n  extendedGlossary = null;\n  extendedGlossaryMeta = null;\n}\n\n/**\n * Check if a term exactly matches a core glossary phrase\n * (not just a partial/substring match)\n */\nfunction isExactCoreMatch(term: string): boolean {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n\n  const normalizedTerm = term.toLowerCase().trim();\n\n  // Check if any module method phrase exactly matches the term\n  for (const mapping of glossaryCache!.moduleMethods ?? []) {\n    if (mapping.phrase.toLowerCase() === normalizedTerm) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Lookup a term in both core glossary and extended LLKB glossary\n * Core glossary takes precedence for exact matches (LLKB only extends, never overrides)\n * @param term - Term to look up\n * @returns IR primitive if found, undefined otherwise\n */\nexport function lookupGlossary(term: string): IRPrimitive | undefined {\n  const normalizedTerm = term.toLowerCase().trim();\n\n  // First check if core glossary has an EXACT match for this term\n  // Core always wins for exact matches (LLKB never overrides core)\n  if (isExactCoreMatch(normalizedTerm)) {\n    const coreMapping = findModuleMethod(normalizedTerm);\n    if (coreMapping) {\n      return {\n        type: 'callModule',\n        module: coreMapping.module,\n        method: coreMapping.method,\n        args: coreMapping.params ? [coreMapping.params] : undefined,\n      };\n    }\n  }\n\n  // Then check extended glossary for exact match\n  // LLKB extends core glossary with new terms\n  if (extendedGlossary) {\n    const extendedMatch = extendedGlossary.get(normalizedTerm);\n    if (extendedMatch) {\n      return extendedMatch;\n    }\n  }\n\n  // Finally, check core glossary for partial/substring matches\n  // This allows core patterns like \"wait for\" to match \"wait for something\"\n  const coreMapping = findModuleMethod(normalizedTerm);\n  if (coreMapping) {\n    return {\n      type: 'callModule',\n      module: coreMapping.module,\n      method: coreMapping.method,\n      args: coreMapping.params ? [coreMapping.params] : undefined,\n    };\n  }\n\n  return undefined;\n}\n\n/**\n * Lookup a term in core glossary only (for priority enforcement)\n * Used when LLKB should NOT override core mappings\n * @param term - Term to look up\n * @returns IR primitive if found, undefined otherwise\n */\nexport function lookupCoreGlossary(term: string): IRPrimitive | undefined {\n  const normalizedTerm = term.toLowerCase().trim();\n\n  const coreMapping = findModuleMethod(normalizedTerm);\n  if (coreMapping) {\n    return {\n      type: 'callModule',\n      module: coreMapping.module,\n      method: coreMapping.method,\n      args: coreMapping.params ? [coreMapping.params] : undefined,\n    };\n  }\n\n  return undefined;\n}\n\n/**\n * Get glossary statistics\n */\nexport function getGlossaryStats(): {\n  coreEntries: number;\n  extendedEntries: number;\n  extendedExportedAt: string | null;\n  extendedMeta: ExtendedGlossaryMeta | null;\n} {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n\n  return {\n    coreEntries: glossaryCache!.moduleMethods?.length ?? 0,\n    extendedEntries: extendedGlossary?.size ?? 0,\n    extendedExportedAt: extendedGlossaryMeta?.exportedAt ?? null,\n    extendedMeta: extendedGlossaryMeta,\n  };\n}\n\n/**\n * Check if extended glossary is loaded\n */\nexport function hasExtendedGlossary(): boolean {\n  return extendedGlossary !== null && extendedGlossary.size > 0;\n}\n","/**\n * LLKB Pattern Extension - Learning and promotion of patterns from LLKB\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md Phase 4\n */\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { join, dirname } from 'node:path';\nimport type { IRPrimitive } from '../ir/types.js';\n// Use the same normalizer as stepMapper for consistent pattern matching\n// This ensures patterns learned during recording match during lookup\nimport { normalizeStepText } from '../mapping/glossary.js';\n\n/**\n * A pattern learned from successful step mappings\n */\nexport interface LearnedPattern {\n  /** Unique identifier */\n  id: string;\n  /** Original step text that was learned from */\n  originalText: string;\n  /** Normalized form for matching */\n  normalizedText: string;\n  /** The IR primitive this text maps to */\n  mappedPrimitive: IRPrimitive;\n  /** Confidence score (0-1) */\n  confidence: number;\n  /** Journey IDs where this pattern was used */\n  sourceJourneys: string[];\n  /** Number of successful uses */\n  successCount: number;\n  /** Number of failed uses */\n  failCount: number;\n  /** Timestamp of last use */\n  lastUsed: string;\n  /** Timestamp when created */\n  createdAt: string;\n  /** Whether this pattern has been promoted to core */\n  promotedToCore: boolean;\n  /** Promotion timestamp if promoted */\n  promotedAt?: string;\n}\n\n/**\n * Pattern ready for promotion to core\n */\nexport interface PromotedPattern {\n  /** The learned pattern being promoted */\n  pattern: LearnedPattern;\n  /** Generated regex string for the pattern */\n  generatedRegex: string;\n  /** Priority score for ordering */\n  priority: number;\n}\n\n/**\n * LLKB pattern match result\n */\nexport interface LlkbPatternMatch {\n  /** Pattern ID that matched */\n  patternId: string;\n  /** The IR primitive */\n  primitive: IRPrimitive;\n  /** Confidence of the match */\n  confidence: number;\n}\n\n/**\n * Options for pruning patterns\n */\nexport interface PruneOptions {\n  /** Minimum confidence to keep */\n  minConfidence?: number;\n  /** Minimum success count to keep */\n  minSuccess?: number;\n  /** Maximum age in days to keep */\n  maxAgeDays?: number;\n}\n\n/**\n * Storage file for learned patterns\n */\nconst PATTERNS_FILE = 'learned-patterns.json';\nconst DEFAULT_LLKB_ROOT = '.artk/llkb';\n\n/**\n * Pattern cache for performance optimization\n * Avoids repeated file reads during step mapping\n */\ninterface PatternCache {\n  patterns: LearnedPattern[];\n  llkbRoot: string;\n  loadedAt: number;\n}\n\nlet patternCache: PatternCache | null = null;\nconst CACHE_TTL_MS = 5000; // 5 second cache TTL\n\n/**\n * Invalidate the pattern cache\n * Call this after any write operation\n */\nexport function invalidatePatternCache(): void {\n  patternCache = null;\n}\n\n/**\n * Get the path to the patterns file\n */\nexport function getPatternsFilePath(llkbRoot?: string): string {\n  const root = llkbRoot || join(process.cwd(), DEFAULT_LLKB_ROOT);\n  return join(root, PATTERNS_FILE);\n}\n\n/**\n * Generate a unique pattern ID\n */\nexport function generatePatternId(): string {\n  return `LP${Date.now().toString(36)}${Math.random().toString(36).slice(2, 6)}`.toUpperCase();\n}\n\n/**\n * Load learned patterns from storage (with caching for performance)\n */\nexport function loadLearnedPatterns(options: { llkbRoot?: string; bypassCache?: boolean } = {}): LearnedPattern[] {\n  const llkbRoot = options.llkbRoot || join(process.cwd(), DEFAULT_LLKB_ROOT);\n  const now = Date.now();\n\n  // Check cache validity (same llkbRoot and not expired)\n  if (\n    !options.bypassCache &&\n    patternCache &&\n    patternCache.llkbRoot === llkbRoot &&\n    now - patternCache.loadedAt < CACHE_TTL_MS\n  ) {\n    return patternCache.patterns;\n  }\n\n  const filePath = getPatternsFilePath(options.llkbRoot);\n\n  if (!existsSync(filePath)) {\n    // Cache empty result\n    patternCache = { patterns: [], llkbRoot, loadedAt: now };\n    return [];\n  }\n\n  try {\n    const content = readFileSync(filePath, 'utf-8');\n    const data = JSON.parse(content);\n    const patterns = Array.isArray(data.patterns) ? data.patterns : [];\n\n    // Update cache\n    patternCache = { patterns, llkbRoot, loadedAt: now };\n    return patterns;\n  } catch {\n    // Cache empty result on error\n    patternCache = { patterns: [], llkbRoot, loadedAt: now };\n    return [];\n  }\n}\n\n/**\n * Save learned patterns to storage\n */\nexport function saveLearnedPatterns(\n  patterns: LearnedPattern[],\n  options: { llkbRoot?: string } = {}\n): void {\n  const filePath = getPatternsFilePath(options.llkbRoot);\n  const dir = dirname(filePath);\n\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n\n  const data = {\n    version: '1.0.0',\n    lastUpdated: new Date().toISOString(),\n    patterns,\n  };\n\n  writeFileSync(filePath, JSON.stringify(data, null, 2), 'utf-8');\n\n  // Invalidate cache after write\n  invalidatePatternCache();\n}\n\n/**\n * Calculate confidence from success/fail counts\n * Uses Wilson score interval for small sample sizes\n */\nexport function calculateConfidence(successCount: number, failCount: number): number {\n  const total = successCount + failCount;\n  if (total === 0) return 0.5;\n\n  const p = successCount / total;\n  const z = 1.96; // 95% confidence\n  const n = total;\n\n  // Wilson score lower bound\n  const denominator = 1 + (z * z) / n;\n  const center = p + (z * z) / (2 * n);\n  const spread = z * Math.sqrt((p * (1 - p) + (z * z) / (4 * n)) / n);\n\n  return Math.max(0, Math.min(1, (center - spread) / denominator));\n}\n\n/**\n * Record a successful pattern transformation\n */\nexport function recordPatternSuccess(\n  originalText: string,\n  primitive: IRPrimitive,\n  journeyId: string,\n  options: { llkbRoot?: string } = {}\n): LearnedPattern {\n  const patterns = loadLearnedPatterns(options);\n  const normalizedText = normalizeStepText(originalText);\n\n  // Find existing pattern\n  let pattern = patterns.find((p) => p.normalizedText === normalizedText);\n\n  if (pattern) {\n    // Update existing\n    pattern.successCount++;\n    pattern.confidence = calculateConfidence(pattern.successCount, pattern.failCount);\n    pattern.lastUsed = new Date().toISOString();\n    if (!pattern.sourceJourneys.includes(journeyId)) {\n      pattern.sourceJourneys.push(journeyId);\n    }\n  } else {\n    // Create new\n    pattern = {\n      id: generatePatternId(),\n      originalText,\n      normalizedText,\n      mappedPrimitive: primitive,\n      confidence: 0.5, // Initial confidence\n      sourceJourneys: [journeyId],\n      successCount: 1,\n      failCount: 0,\n      lastUsed: new Date().toISOString(),\n      createdAt: new Date().toISOString(),\n      promotedToCore: false,\n    };\n    patterns.push(pattern);\n  }\n\n  saveLearnedPatterns(patterns, options);\n  return pattern;\n}\n\n/**\n * Record a failed pattern use\n */\nexport function recordPatternFailure(\n  originalText: string,\n  journeyId: string,\n  options: { llkbRoot?: string } = {}\n): LearnedPattern | null {\n  const patterns = loadLearnedPatterns(options);\n  const normalizedText = normalizeStepText(originalText);\n\n  const pattern = patterns.find((p) => p.normalizedText === normalizedText);\n\n  if (pattern) {\n    pattern.failCount++;\n    pattern.confidence = calculateConfidence(pattern.successCount, pattern.failCount);\n    pattern.lastUsed = new Date().toISOString();\n    saveLearnedPatterns(patterns, options);\n    return pattern;\n  }\n\n  return null;\n}\n\n/**\n * Match text against learned LLKB patterns\n */\nexport function matchLlkbPattern(\n  text: string,\n  options: { llkbRoot?: string; minConfidence?: number } = {}\n): LlkbPatternMatch | null {\n  const patterns = loadLearnedPatterns(options);\n  const normalizedText = normalizeStepText(text);\n  const minConfidence = options.minConfidence ?? 0.7;\n\n  // Find exact normalized match with sufficient confidence\n  const match = patterns.find(\n    (p) => p.normalizedText === normalizedText && p.confidence >= minConfidence && !p.promotedToCore\n  );\n\n  if (match) {\n    return {\n      patternId: match.id,\n      primitive: match.mappedPrimitive,\n      confidence: match.confidence,\n    };\n  }\n\n  return null;\n}\n\n/**\n * Generate a regex pattern from a learned text pattern\n * This is a heuristic approach - complex patterns may need manual refinement\n */\nexport function generateRegexFromText(text: string): string {\n  let pattern = text\n    .toLowerCase()\n    // Escape special regex chars\n    .replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n    // Replace quoted values with capture groups\n    .replace(/\"[^\"]+\"/g, '\"([^\"]+)\"')\n    .replace(/'[^']+'/g, \"'([^']+)'\")\n    // Make articles optional\n    .replace(/\\b(the|a|an)\\b/g, '(?:$1\\\\s+)?')\n    // Make \"user\" prefix optional\n    .replace(/^user\\s+/, '(?:user\\\\s+)?')\n    // Handle common verbs\n    .replace(/\\bclicks?\\b/g, 'clicks?')\n    .replace(/\\bfills?\\b/g, 'fills?')\n    .replace(/\\bselects?\\b/g, 'selects?')\n    .replace(/\\btypes?\\b/g, 'types?')\n    .replace(/\\bsees?\\b/g, 'sees?')\n    .replace(/\\bwaits?\\b/g, 'waits?');\n\n  return `^${pattern}$`;\n}\n\n/**\n * Get patterns ready for promotion to core\n */\nexport function getPromotablePatterns(options: { llkbRoot?: string } = {}): PromotedPattern[] {\n  const patterns = loadLearnedPatterns(options);\n\n  const promotable = patterns.filter(\n    (p) =>\n      p.confidence >= 0.9 &&\n      p.successCount >= 5 &&\n      p.sourceJourneys.length >= 2 &&\n      !p.promotedToCore\n  );\n\n  return promotable.map((pattern) => ({\n    pattern,\n    generatedRegex: generateRegexFromText(pattern.originalText),\n    priority: pattern.successCount * pattern.confidence,\n  }));\n}\n\n/**\n * Mark patterns as promoted\n */\nexport function markPatternsPromoted(\n  patternIds: string[],\n  options: { llkbRoot?: string } = {}\n): void {\n  const patterns = loadLearnedPatterns(options);\n  const now = new Date().toISOString();\n\n  for (const pattern of patterns) {\n    if (patternIds.includes(pattern.id)) {\n      pattern.promotedToCore = true;\n      pattern.promotedAt = now;\n    }\n  }\n\n  saveLearnedPatterns(patterns, options);\n}\n\n/**\n * Prune low-quality patterns\n */\nexport function prunePatterns(options: PruneOptions & { llkbRoot?: string } = {}): {\n  removed: number;\n  remaining: number;\n} {\n  const patterns = loadLearnedPatterns(options);\n  const now = Date.now();\n  const maxAge = (options.maxAgeDays ?? 90) * 24 * 60 * 60 * 1000;\n  const minConfidence = options.minConfidence ?? 0.3;\n  const minSuccess = options.minSuccess ?? 1;\n\n  const filtered = patterns.filter((p) => {\n    // Keep if already promoted\n    if (p.promotedToCore) return true;\n\n    // Remove if below minimum confidence\n    if (p.confidence < minConfidence) return false;\n\n    // Remove if no successes and required\n    if (minSuccess > 0 && p.successCount < minSuccess) return false;\n\n    // Remove if too old and never successful\n    const age = now - new Date(p.createdAt).getTime();\n    if (age > maxAge && p.successCount === 0) return false;\n\n    return true;\n  });\n\n  const removed = patterns.length - filtered.length;\n\n  if (removed > 0) {\n    saveLearnedPatterns(filtered, options);\n  }\n\n  return {\n    removed,\n    remaining: filtered.length,\n  };\n}\n\n/**\n * Get pattern statistics\n */\nexport function getPatternStats(options: { llkbRoot?: string } = {}): {\n  total: number;\n  promoted: number;\n  highConfidence: number;\n  lowConfidence: number;\n  avgConfidence: number;\n  totalSuccesses: number;\n  totalFailures: number;\n} {\n  const patterns = loadLearnedPatterns(options);\n\n  if (patterns.length === 0) {\n    return {\n      total: 0,\n      promoted: 0,\n      highConfidence: 0,\n      lowConfidence: 0,\n      avgConfidence: 0,\n      totalSuccesses: 0,\n      totalFailures: 0,\n    };\n  }\n\n  const promoted = patterns.filter((p) => p.promotedToCore).length;\n  const highConfidence = patterns.filter((p) => p.confidence >= 0.7).length;\n  const lowConfidence = patterns.filter((p) => p.confidence < 0.3).length;\n  const totalConfidence = patterns.reduce((sum, p) => sum + p.confidence, 0);\n  const totalSuccesses = patterns.reduce((sum, p) => sum + p.successCount, 0);\n  const totalFailures = patterns.reduce((sum, p) => sum + p.failCount, 0);\n\n  return {\n    total: patterns.length,\n    promoted,\n    highConfidence,\n    lowConfidence,\n    avgConfidence: totalConfidence / patterns.length,\n    totalSuccesses,\n    totalFailures,\n  };\n}\n\n/**\n * Export learned patterns to LLKB config format\n */\nexport function exportPatternsToConfig(options: {\n  llkbRoot?: string;\n  outputPath?: string;\n  minConfidence?: number;\n}): { exported: number; path: string } {\n  const patterns = loadLearnedPatterns(options);\n  const minConfidence = options.minConfidence ?? 0.7;\n\n  const exportable = patterns.filter((p) => p.confidence >= minConfidence && !p.promotedToCore);\n\n  const config = {\n    version: '1.0.0',\n    exportedAt: new Date().toISOString(),\n    patterns: exportable.map((p) => ({\n      id: p.id,\n      trigger: generateRegexFromText(p.originalText),\n      primitive: p.mappedPrimitive,\n      confidence: p.confidence,\n      sourceCount: p.sourceJourneys.length,\n    })),\n  };\n\n  const outputPath =\n    options.outputPath || join(dirname(getPatternsFilePath(options.llkbRoot)), 'autogen-patterns.json');\n\n  writeFileSync(outputPath, JSON.stringify(config, null, 2), 'utf-8');\n\n  return {\n    exported: exportable.length,\n    path: outputPath,\n  };\n}\n\n/**\n * Clear all learned patterns (for testing)\n */\nexport function clearLearnedPatterns(options: { llkbRoot?: string } = {}): void {\n  const filePath = getPatternsFilePath(options.llkbRoot);\n  if (existsSync(filePath)) {\n    const { unlinkSync } = require('node:fs');\n    unlinkSync(filePath);\n  }\n}\n","/**\n * Journey Frontmatter Zod Schema\n * @see research/2026-01-02_autogen-refined-plan.md Section 8\n */\nimport { z } from 'zod';\n\n/**\n * Journey status enum\n */\nexport const JourneyStatusSchema = z.enum([\n  'proposed',\n  'defined',\n  'clarified',\n  'implemented',\n  'quarantined',\n  'deprecated',\n]);\n\n/**\n * Journey tier enum\n */\nexport const JourneyTierSchema = z.enum(['smoke', 'release', 'regression']);\n\n/**\n * Data strategy enum\n */\nexport const DataStrategySchema = z.enum(['seed', 'create', 'reuse']);\n\n/**\n * Cleanup strategy enum\n */\nexport const CleanupStrategySchema = z.enum(['required', 'best-effort', 'none']);\n\n/**\n * Completion signal type enum\n */\nexport const CompletionTypeSchema = z.enum(['url', 'toast', 'element', 'text', 'title', 'api']);\n\n/**\n * Element state enum for completion signals\n */\nexport const ElementStateSchema = z.enum(['visible', 'hidden', 'attached', 'detached']);\n\n/**\n * Completion signal schema\n */\nexport const CompletionSignalSchema = z.object({\n  type: CompletionTypeSchema,\n  value: z.string().min(1, 'Completion signal value is required'),\n  options: z.object({\n    timeout: z.number().positive().optional(),\n    exact: z.boolean().optional(),\n    state: ElementStateSchema.optional(),\n    method: z.string().optional(),\n    status: z.number().int().positive().optional(),\n  }).optional(),\n});\n\n/**\n * Data configuration schema\n */\nexport const DataConfigSchema = z.object({\n  strategy: DataStrategySchema.default('create'),\n  cleanup: CleanupStrategySchema.default('best-effort'),\n});\n\n/**\n * Module dependencies schema\n */\nexport const ModulesSchema = z.object({\n  foundation: z.array(z.string()).default([]),\n  features: z.array(z.string()).default([]),\n});\n\n/**\n * Test reference schema\n */\nexport const TestRefSchema = z.object({\n  file: z.string(),\n  line: z.number().optional(),\n});\n\n/**\n * Link schema\n */\nexport const LinksSchema = z.object({\n  issues: z.array(z.string()).optional(),\n  prs: z.array(z.string()).optional(),\n  docs: z.array(z.string()).optional(),\n});\n\n/**\n * Negative path schema for error scenario testing\n */\nexport const NegativePathSchema = z.object({\n  name: z.string().min(1, 'Negative path name is required'),\n  input: z.record(z.any()),\n  expectedError: z.string().min(1, 'Expected error message is required'),\n  expectedElement: z.string().optional(),\n});\n\n/**\n * Visual regression configuration schema\n */\nexport const VisualRegressionSchema = z.object({\n  enabled: z.boolean(),\n  snapshots: z.array(z.string()).optional(),\n  threshold: z.number().min(0).max(1).optional(),\n});\n\n/**\n * Accessibility timing mode enum\n */\nexport const AccessibilityTimingSchema = z.enum(['afterEach', 'inTest']);\n\n/**\n * Accessibility configuration schema\n */\nexport const AccessibilitySchema = z.object({\n  enabled: z.boolean(),\n  rules: z.array(z.string()).optional(),\n  exclude: z.array(z.string()).optional(),\n  /**\n   * When to run accessibility checks:\n   * - 'afterEach': Run after each test (default, catches issues but doesn't fail individual tests)\n   * - 'inTest': Run within test steps (fails immediately, better for CI)\n   */\n  timing: AccessibilityTimingSchema.default('afterEach'),\n});\n\n/**\n * Performance budgets schema\n */\nexport const PerformanceSchema = z.object({\n  enabled: z.boolean(),\n  budgets: z\n    .object({\n      lcp: z.number().positive().optional(),\n      fid: z.number().positive().optional(),\n      cls: z.number().min(0).optional(),\n      ttfb: z.number().positive().optional(),\n    })\n    .optional(),\n  /** Timeout for collecting performance metrics in ms (default: 3000) */\n  collectTimeout: z.number().positive().optional(),\n});\n\n/**\n * Test data set schema for parameterized/data-driven tests\n */\nexport const TestDataSetSchema = z.object({\n  name: z.string().min(1, 'Test data set name is required'),\n  description: z.string().optional(),\n  data: z.record(z.string(), z.any()),\n});\n\n/**\n * Complete Journey frontmatter schema\n */\nexport const JourneyFrontmatterSchema = z.object({\n  id: z\n    .string()\n    .regex(/^JRN-\\d{4}$/, 'Journey ID must be in format JRN-XXXX'),\n  title: z.string().min(1, 'Title is required'),\n  status: JourneyStatusSchema,\n  tier: JourneyTierSchema,\n  scope: z.string().min(1, 'Scope is required'),\n  actor: z.string().min(1, 'Actor is required'),\n  revision: z.number().int().positive().default(1),\n  owner: z.string().optional(),\n  statusReason: z.string().optional(),\n  modules: ModulesSchema.default({ foundation: [], features: [] }),\n  tests: z.array(z.union([z.string(), TestRefSchema])).default([]),\n  data: DataConfigSchema.optional(),\n  completion: z.array(CompletionSignalSchema).optional(),\n  links: LinksSchema.optional(),\n  tags: z.array(z.string()).optional(),\n  flags: z\n    .object({\n      required: z.array(z.string()).optional(),\n      forbidden: z.array(z.string()).optional(),\n    })\n    .optional(),\n  prerequisites: z\n    .array(z.string())\n    .optional()\n    .describe('Array of Journey IDs that must run first'),\n  negativePaths: z\n    .array(NegativePathSchema)\n    .optional()\n    .describe('Error scenarios to test'),\n  testData: z\n    .array(TestDataSetSchema)\n    .optional()\n    .describe('Parameterized test data sets for data-driven testing'),\n  visualRegression: VisualRegressionSchema.optional(),\n  accessibility: AccessibilitySchema.optional(),\n  performance: PerformanceSchema.optional(),\n});\n\n/**\n * Schema specifically for clarified journeys (required for AutoGen)\n */\nexport const ClarifiedJourneyFrontmatterSchema = JourneyFrontmatterSchema.extend({\n  status: z.literal('clarified'),\n}).refine(\n  (data) => {\n    // Clarified journeys should have completion signals\n    return data.completion && data.completion.length > 0;\n  },\n  {\n    message: 'Clarified journeys must have at least one completion signal',\n    path: ['completion'],\n  }\n);\n\n/**\n * Schema for implemented journeys (must have tests)\n */\nexport const ImplementedJourneyFrontmatterSchema = JourneyFrontmatterSchema.extend({\n  status: z.literal('implemented'),\n}).refine(\n  (data) => {\n    return data.tests && data.tests.length > 0;\n  },\n  {\n    message: 'Implemented journeys must have at least one test reference',\n    path: ['tests'],\n  }\n);\n\n/**\n * Schema for quarantined journeys (must have owner and reason)\n */\nexport const QuarantinedJourneyFrontmatterSchema = JourneyFrontmatterSchema.extend({\n  status: z.literal('quarantined'),\n  owner: z.string().min(1, 'Quarantined journeys require an owner'),\n  statusReason: z.string().min(1, 'Quarantined journeys require a status reason'),\n}).refine(\n  (data) => {\n    return data.links?.issues && data.links.issues.length > 0;\n  },\n  {\n    message: 'Quarantined journeys must have at least one linked issue',\n    path: ['links', 'issues'],\n  }\n);\n\n/**\n * TypeScript types\n */\nexport type JourneyStatus = z.infer<typeof JourneyStatusSchema>;\nexport type JourneyTier = z.infer<typeof JourneyTierSchema>;\nexport type DataStrategy = z.infer<typeof DataStrategySchema>;\nexport type CleanupStrategy = z.infer<typeof CleanupStrategySchema>;\nexport type CompletionType = z.infer<typeof CompletionTypeSchema>;\nexport type CompletionSignal = z.infer<typeof CompletionSignalSchema>;\nexport type DataConfig = z.infer<typeof DataConfigSchema>;\nexport type Modules = z.infer<typeof ModulesSchema>;\nexport type TestRef = z.infer<typeof TestRefSchema>;\nexport type Links = z.infer<typeof LinksSchema>;\nexport type NegativePath = z.infer<typeof NegativePathSchema>;\nexport type TestDataSet = z.infer<typeof TestDataSetSchema>;\nexport type VisualRegression = z.infer<typeof VisualRegressionSchema>;\nexport type Accessibility = z.infer<typeof AccessibilitySchema>;\nexport type Performance = z.infer<typeof PerformanceSchema>;\nexport type JourneyFrontmatter = z.infer<typeof JourneyFrontmatterSchema>;\n\n/**\n * Validate that a journey is ready for AutoGen (must be clarified)\n */\nexport function validateForAutoGen(\n  frontmatter: JourneyFrontmatter\n): { valid: boolean; errors: string[] } {\n  const errors: string[] = [];\n\n  if (frontmatter.status !== 'clarified') {\n    errors.push(\n      `Journey status must be \"clarified\" for AutoGen, got \"${frontmatter.status}\"`\n    );\n  }\n\n  if (!frontmatter.completion || frontmatter.completion.length === 0) {\n    errors.push('Journey must have completion signals defined');\n  }\n\n  if (!frontmatter.actor) {\n    errors.push('Journey must have an actor defined');\n  }\n\n  if (!frontmatter.scope) {\n    errors.push('Journey must have a scope defined');\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n","/**\n * Step Mapping Patterns - Regex patterns for parsing step text into IR primitives\n * @see research/2026-01-02_autogen-refined-plan.md Section 10\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md Phase 3\n */\nimport type { IRPrimitive, LocatorSpec, ValueSpec, LocatorStrategy } from '../ir/types.js';\n\n/**\n * Pattern version - increment when patterns change\n * Format: MAJOR.MINOR.PATCH\n * - MAJOR: Breaking changes to pattern behavior\n * - MINOR: New patterns added\n * - PATCH: Bug fixes to existing patterns\n */\nexport const PATTERN_VERSION = '1.1.0';\n\n/**\n * Pattern metadata for tracking\n */\nexport interface PatternMetadata {\n  name: string;\n  version: string;\n  addedDate: string;\n  source: 'core' | 'llkb' | 'telemetry';\n  category: string;\n}\n\n/**\n * Pattern result with match groups\n */\nexport interface PatternMatch {\n  type: IRPrimitive['type'];\n  groups: Record<string, string>;\n}\n\n/**\n * Pattern definition\n */\nexport interface StepPattern {\n  /** Pattern name for debugging */\n  name: string;\n  /** Regex pattern with named groups */\n  regex: RegExp;\n  /** IR primitive type this pattern produces */\n  primitiveType: IRPrimitive['type'];\n  /** Extract IR primitive from match (prefix with _ if unused) */\n  extract: (_match: RegExpMatchArray) => IRPrimitive | null;\n}\n\n/**\n * Create a locator spec from pattern match\n */\nexport function createLocatorFromMatch(\n  strategy: LocatorStrategy,\n  value: string,\n  name?: string\n): LocatorSpec {\n  const locator: LocatorSpec = { strategy, value };\n  if (name) {\n    locator.options = { name };\n  }\n  return locator;\n}\n\n/**\n * Create a value spec from text\n */\nexport function createValueFromText(text: string): ValueSpec {\n  // Actor reference: {{email}}, {{password}}, etc.\n  if (/^\\{\\{.+\\}\\}$/.test(text)) {\n    const path = text.slice(2, -2).trim();\n    return { type: 'actor', value: path };\n  }\n\n  // Test data reference: $user.email, $testData.field\n  if (/^\\$.+/.test(text)) {\n    return { type: 'testData', value: text.slice(1) };\n  }\n\n  // Generated value: ${runId}, ${timestamp}\n  if (/\\$\\{.+\\}/.test(text)) {\n    return { type: 'generated', value: text };\n  }\n\n  // Literal value\n  return { type: 'literal', value: text };\n}\n\n/**\n * Navigation patterns\n */\nexport const navigationPatterns: StepPattern[] = [\n  {\n    name: 'navigate-to-url',\n    regex: /^(?:user\\s+)?(?:navigates?|go(?:es)?|opens?)\\s+(?:to\\s+)?(?:the\\s+)?[\"']?([^\"'\\s]+)[\"']?$/i,\n    primitiveType: 'goto',\n    extract: (match) => ({\n      type: 'goto',\n      url: match[1]!,\n      waitForLoad: true,\n    }),\n  },\n  {\n    name: 'navigate-to-page',\n    regex: /^(?:user\\s+)?(?:navigates?|go(?:es)?|opens?)\\s+(?:to\\s+)?(?:the\\s+)?(.+?)\\s+page$/i,\n    primitiveType: 'goto',\n    extract: (match) => ({\n      type: 'goto',\n      url: `/${match[1]!.toLowerCase().replace(/\\s+/g, '-')}`,\n      waitForLoad: true,\n    }),\n  },\n];\n\n/**\n * Click patterns\n */\nexport const clickPatterns: StepPattern[] = [\n  {\n    name: 'click-button-quoted',\n    regex: /^(?:user\\s+)?(?:clicks?|presses?|taps?)\\s+(?:on\\s+)?(?:the\\s+)?[\"']([^\"']+)[\"']\\s+button$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('role', 'button', match[1]!),\n    }),\n  },\n  {\n    name: 'click-link-quoted',\n    regex: /^(?:user\\s+)?(?:clicks?|presses?|taps?)\\s+(?:on\\s+)?(?:the\\s+)?[\"']([^\"']+)[\"']\\s+link$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('role', 'link', match[1]!),\n    }),\n  },\n  {\n    name: 'click-element-quoted',\n    regex: /^(?:user\\s+)?(?:clicks?|presses?|taps?)\\s+(?:on\\s+)?(?:the\\s+)?[\"']([^\"']+)[\"']$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'click-element-generic',\n    regex: /^(?:user\\s+)?(?:clicks?|presses?|taps?)\\s+(?:on\\s+)?(?:the\\s+)?(.+?)\\s+(?:button|link|icon|menu|tab)$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n];\n\n/**\n * Fill/Input patterns\n */\nexport const fillPatterns: StepPattern[] = [\n  {\n    name: 'fill-field-quoted-value',\n    regex: /^(?:user\\s+)?(?:enters?|types?|fills?\\s+in?|inputs?)\\s+[\"']([^\"']+)[\"']\\s+(?:in|into)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']\\s*(?:field|input)?$/i,\n    primitiveType: 'fill',\n    extract: (match) => ({\n      type: 'fill',\n      locator: createLocatorFromMatch('label', match[2]!),\n      value: createValueFromText(match[1]!),\n    }),\n  },\n  {\n    name: 'fill-field-actor-value',\n    regex: /^(?:user\\s+)?(?:enters?|types?|fills?\\s+in?|inputs?)\\s+(\\{\\{[^}]+\\}\\})\\s+(?:in|into)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']\\s*(?:field|input)?$/i,\n    primitiveType: 'fill',\n    extract: (match) => ({\n      type: 'fill',\n      locator: createLocatorFromMatch('label', match[2]!),\n      value: createValueFromText(match[1]!),\n    }),\n  },\n  {\n    name: 'fill-field-generic',\n    regex: /^(?:user\\s+)?(?:enters?|types?|fills?\\s+in?|inputs?)\\s+(.+?)\\s+(?:in|into)\\s+(?:the\\s+)?(.+?)\\s*(?:field|input)?$/i,\n    primitiveType: 'fill',\n    extract: (match) => ({\n      type: 'fill',\n      locator: createLocatorFromMatch('label', match[2]!.replace(/[\"']/g, '')),\n      value: createValueFromText(match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n];\n\n/**\n * Select patterns\n */\nexport const selectPatterns: StepPattern[] = [\n  {\n    name: 'select-option',\n    regex: /^(?:user\\s+)?(?:selects?|chooses?)\\s+[\"']([^\"']+)[\"']\\s+(?:from|in)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']\\s*(?:dropdown|select|menu)?$/i,\n    primitiveType: 'select',\n    extract: (match) => ({\n      type: 'select',\n      locator: createLocatorFromMatch('label', match[2]!),\n      option: match[1]!,\n    }),\n  },\n];\n\n/**\n * Check/Uncheck patterns\n */\nexport const checkPatterns: StepPattern[] = [\n  {\n    name: 'check-checkbox',\n    regex: /^(?:user\\s+)?(?:checks?|enables?|ticks?)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']\\s*(?:checkbox|option)?$/i,\n    primitiveType: 'check',\n    extract: (match) => ({\n      type: 'check',\n      locator: createLocatorFromMatch('label', match[1]!),\n    }),\n  },\n  {\n    name: 'uncheck-checkbox',\n    regex: /^(?:user\\s+)?(?:unchecks?|disables?|unticks?)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']\\s*(?:checkbox|option)?$/i,\n    primitiveType: 'uncheck',\n    extract: (match) => ({\n      type: 'uncheck',\n      locator: createLocatorFromMatch('label', match[1]!),\n    }),\n  },\n];\n\n/**\n * Visibility assertion patterns\n */\nexport const visibilityPatterns: StepPattern[] = [\n  {\n    name: 'should-see-text',\n    regex: /^(?:user\\s+)?(?:should\\s+)?(?:sees?|views?)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'is-visible',\n    regex: /^[\"']?([^\"']+)[\"']?\\s+(?:is\\s+)?(?:visible|displayed|shown)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'should-see-element',\n    regex: /^(?:user\\s+)?(?:should\\s+)?(?:sees?|views?)\\s+(?:the\\s+)?(.+?)\\s+(?:heading|button|link|form|page|element)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'page-displayed',\n    regex: /^(?:the\\s+)?(.+?)\\s+(?:page|screen|view)\\s+(?:is\\s+)?(?:displayed|shown|visible)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n];\n\n/**\n * Toast/notification patterns\n */\nexport const toastPatterns: StepPattern[] = [\n  {\n    name: 'success-toast-message',\n    regex: /^(?:a\\s+)?success\\s+toast\\s+(?:with\\s+)?[\"']([^\"']+)[\"']\\s*(?:message\\s+)?(?:appears?|is\\s+shown|displays?)$/i,\n    primitiveType: 'expectToast',\n    extract: (match) => ({\n      type: 'expectToast',\n      toastType: 'success',\n      message: match[1]!,\n    }),\n  },\n  {\n    name: 'error-toast-message',\n    regex: /^(?:an?\\s+)?error\\s+toast\\s+(?:with\\s+)?[\"']([^\"']+)[\"']\\s*(?:message\\s+)?(?:appears?|is\\s+shown|displays?)$/i,\n    primitiveType: 'expectToast',\n    extract: (match) => ({\n      type: 'expectToast',\n      toastType: 'error',\n      message: match[1]!,\n    }),\n  },\n  {\n    name: 'toast-appears',\n    regex: /^(?:a\\s+)?(success|error|info|warning)\\s+toast\\s+(?:appears?|is\\s+shown|displays?)$/i,\n    primitiveType: 'expectToast',\n    extract: (match) => ({\n      type: 'expectToast',\n      toastType: match[1]!.toLowerCase() as 'success' | 'error' | 'info' | 'warning',\n    }),\n  },\n  {\n    name: 'toast-with-text',\n    regex: /^(?:toast|notification)\\s+(?:with\\s+)?[\"']([^\"']+)[\"']\\s+(?:appears?|is\\s+shown|displays?)$/i,\n    primitiveType: 'expectToast',\n    extract: (match) => ({\n      type: 'expectToast',\n      toastType: 'info',\n      message: match[1]!,\n    }),\n  },\n];\n\n/**\n * URL assertion patterns\n */\nexport const urlPatterns: StepPattern[] = [\n  {\n    name: 'url-contains',\n    regex: /^(?:the\\s+)?url\\s+(?:should\\s+)?(?:contains?|includes?)\\s+[\"']?([^\"'\\s]+)[\"']?$/i,\n    primitiveType: 'expectURL',\n    extract: (match) => ({\n      type: 'expectURL',\n      pattern: match[1]!,\n    }),\n  },\n  {\n    name: 'url-is',\n    regex: /^(?:the\\s+)?url\\s+(?:should\\s+)?(?:is|equals?|be)\\s+[\"']?([^\"'\\s]+)[\"']?$/i,\n    primitiveType: 'expectURL',\n    extract: (match) => ({\n      type: 'expectURL',\n      pattern: match[1]!,\n    }),\n  },\n  {\n    name: 'redirected-to',\n    regex: /^(?:user\\s+)?(?:is\\s+)?redirected\\s+to\\s+[\"']?([^\"'\\s]+)[\"']?$/i,\n    primitiveType: 'expectURL',\n    extract: (match) => ({\n      type: 'expectURL',\n      pattern: match[1]!,\n    }),\n  },\n];\n\n/**\n * Module call patterns (authentication)\n */\nexport const authPatterns: StepPattern[] = [\n  {\n    name: 'user-login',\n    regex: /^(?:user\\s+)?(?:logs?\\s*in|login\\s+is\\s+performed|authenticates?)$/i,\n    primitiveType: 'callModule',\n    extract: (_match) => ({\n      type: 'callModule',\n      module: 'auth',\n      method: 'login',\n    }),\n  },\n  {\n    name: 'user-logout',\n    regex: /^(?:user\\s+)?(?:logs?\\s*out|logout\\s+is\\s+performed|signs?\\s*out)$/i,\n    primitiveType: 'callModule',\n    extract: (_match) => ({\n      type: 'callModule',\n      module: 'auth',\n      method: 'logout',\n    }),\n  },\n  {\n    name: 'login-as-role',\n    regex: /^(?:user\\s+)?logs?\\s*in\\s+as\\s+(?:an?\\s+)?(.+?)(?:\\s+user)?$/i,\n    primitiveType: 'callModule',\n    extract: (match) => ({\n      type: 'callModule',\n      module: 'auth',\n      method: 'loginAs',\n      args: [match[1]!.toLowerCase()],\n    }),\n  },\n];\n\n/**\n * Wait patterns\n */\nexport const waitPatterns: StepPattern[] = [\n  {\n    name: 'wait-for-navigation',\n    regex: /^(?:user\\s+)?(?:waits?\\s+)?(?:for\\s+)?navigation\\s+to\\s+[\"']?([^\"'\\s]+)[\"']?$/i,\n    primitiveType: 'waitForURL',\n    extract: (match) => ({\n      type: 'waitForURL',\n      pattern: match[1]!,\n    }),\n  },\n  {\n    name: 'wait-for-page',\n    regex: /^(?:user\\s+)?(?:waits?\\s+)?(?:for\\s+)?(?:the\\s+)?(.+?)\\s+(?:page|screen)\\s+to\\s+load$/i,\n    primitiveType: 'waitForLoadingComplete',\n    extract: (_match) => ({\n      type: 'waitForLoadingComplete',\n    }),\n  },\n];\n\n/**\n * Helper function to convert natural language selectors to Playwright locator strategies\n */\nexport function parseSelectorToLocator(selector: string): { strategy: LocatorStrategy; value: string; name?: string } {\n  // Remove leading \"the\" if present\n  let cleanSelector = selector.replace(/^the\\s+/i, '').trim();\n\n  // Match button patterns\n  if (/button$/i.test(cleanSelector)) {\n    const buttonName = cleanSelector.replace(/\\s*button$/i, '').trim();\n    return { strategy: 'role', value: 'button', name: buttonName };\n  }\n\n  // Match link patterns\n  if (/link$/i.test(cleanSelector)) {\n    const linkName = cleanSelector.replace(/\\s*link$/i, '').trim();\n    return { strategy: 'role', value: 'link', name: linkName };\n  }\n\n  // Match input/field patterns\n  if (/(?:input|field)$/i.test(cleanSelector)) {\n    const labelName = cleanSelector.replace(/\\s*(?:input|field)$/i, '').trim();\n    return { strategy: 'label', value: labelName };\n  }\n\n  // Default to text locator\n  return { strategy: 'text', value: cleanSelector };\n}\n\n/**\n * Structured step patterns for Journey markdown format\n * Matches patterns like:\n * - **Action**: Click the login button\n * - **Wait for**: Dashboard to load\n * - **Assert**: User name is visible\n */\nexport const structuredPatterns: StepPattern[] = [\n  // Action patterns\n  {\n    name: 'structured-action-click',\n    regex: /^\\*\\*Action\\*\\*:\\s*[Cc]lick\\s+(?:the\\s+)?['\"]?(.+?)['\"]?\\s*(?:button|link)?$/i,\n    primitiveType: 'click',\n    extract: (match) => {\n      const target = match[1]!;\n      const locatorInfo = parseSelectorToLocator(target + ' button');\n      return {\n        type: 'click',\n        locator: locatorInfo.name\n          ? createLocatorFromMatch(locatorInfo.strategy, locatorInfo.value, locatorInfo.name)\n          : { strategy: locatorInfo.strategy, value: locatorInfo.value },\n      };\n    },\n  },\n  {\n    name: 'structured-action-fill',\n    regex: /^\\*\\*Action\\*\\*:\\s*[Ff]ill\\s+(?:in\\s+)?['\"]?(.+?)['\"]?\\s+with\\s+['\"]?(.+?)['\"]?$/i,\n    primitiveType: 'fill',\n    extract: (match) => {\n      const target = match[1]!;\n      const value = match[2]!;\n      const locatorInfo = parseSelectorToLocator(target);\n      return {\n        type: 'fill',\n        locator: locatorInfo.name\n          ? createLocatorFromMatch(locatorInfo.strategy, locatorInfo.value, locatorInfo.name)\n          : { strategy: locatorInfo.strategy, value: locatorInfo.value },\n        value: createValueFromText(value),\n      };\n    },\n  },\n  {\n    name: 'structured-action-navigate',\n    regex: /^\\*\\*Action\\*\\*:\\s*[Nn]avigate\\s+to\\s+['\"]?(.+?)['\"]?$/i,\n    primitiveType: 'goto',\n    extract: (match) => ({\n      type: 'goto',\n      url: match[1]!,\n      waitForLoad: true,\n    }),\n  },\n\n  // Wait patterns\n  {\n    name: 'structured-wait-for-visible',\n    regex: /^\\*\\*Wait for\\*\\*:\\s*(.+?)\\s+(?:to\\s+)?(?:be\\s+)?(?:visible|appear|load)/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => {\n      const target = match[1]!;\n      const locatorInfo = parseSelectorToLocator(target);\n      return {\n        type: 'expectVisible',\n        locator: locatorInfo.name\n          ? createLocatorFromMatch(locatorInfo.strategy, locatorInfo.value, locatorInfo.name)\n          : { strategy: locatorInfo.strategy, value: locatorInfo.value },\n      };\n    },\n  },\n\n  // Assert patterns\n  {\n    name: 'structured-assert-visible',\n    regex: /^\\*\\*Assert\\*\\*:\\s*(.+?)\\s+(?:is\\s+)?visible$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => {\n      const target = match[1]!;\n      const locatorInfo = parseSelectorToLocator(target);\n      return {\n        type: 'expectVisible',\n        locator: locatorInfo.name\n          ? createLocatorFromMatch(locatorInfo.strategy, locatorInfo.value, locatorInfo.name)\n          : { strategy: locatorInfo.strategy, value: locatorInfo.value },\n      };\n    },\n  },\n  {\n    name: 'structured-assert-text',\n    regex: /^\\*\\*Assert\\*\\*:\\s*(.+?)\\s+(?:contains|has text)\\s+['\"]?(.+?)['\"]?$/i,\n    primitiveType: 'expectText',\n    extract: (match) => {\n      const target = match[1]!;\n      const text = match[2]!;\n      const locatorInfo = parseSelectorToLocator(target);\n      return {\n        type: 'expectText',\n        locator: locatorInfo.name\n          ? createLocatorFromMatch(locatorInfo.strategy, locatorInfo.value, locatorInfo.name)\n          : { strategy: locatorInfo.strategy, value: locatorInfo.value },\n        text,\n      };\n    },\n  },\n];\n\n/**\n * Extended click patterns - Common variations missed by core patterns\n * Added in v1.1.0 based on telemetry analysis\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md Phase 3\n */\nexport const extendedClickPatterns: StepPattern[] = [\n  {\n    name: 'click-on-element',\n    // \"Click on Submit\" or \"Click on the Submit button\"\n    regex: /^(?:user\\s+)?clicks?\\s+on\\s+(?:the\\s+)?(.+?)(?:\\s+button|\\s+link)?$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('text', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n  {\n    name: 'press-enter-key',\n    // \"Press Enter\" or \"Press the Enter key\" or \"Hit Enter\"\n    regex: /^(?:user\\s+)?(?:press(?:es)?|hits?)\\s+(?:the\\s+)?(?:enter|return)(?:\\s+key)?$/i,\n    primitiveType: 'press',\n    extract: () => ({\n      type: 'press',\n      key: 'Enter',\n    }),\n  },\n  {\n    name: 'press-tab-key',\n    // \"Press Tab\" or \"Press the Tab key\"\n    regex: /^(?:user\\s+)?(?:press(?:es)?|hits?)\\s+(?:the\\s+)?tab(?:\\s+key)?$/i,\n    primitiveType: 'press',\n    extract: () => ({\n      type: 'press',\n      key: 'Tab',\n    }),\n  },\n  {\n    name: 'press-escape-key',\n    // \"Press Escape\" or \"Press Esc\"\n    regex: /^(?:user\\s+)?(?:press(?:es)?|hits?)\\s+(?:the\\s+)?(?:escape|esc)(?:\\s+key)?$/i,\n    primitiveType: 'press',\n    extract: () => ({\n      type: 'press',\n      key: 'Escape',\n    }),\n  },\n  {\n    name: 'double-click',\n    // \"Double click on\" or \"Double-click the\"\n    regex: /^(?:user\\s+)?double[-\\s]?clicks?\\s+(?:on\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?$/i,\n    primitiveType: 'dblclick',\n    extract: (match) => ({\n      type: 'dblclick',\n      locator: createLocatorFromMatch('text', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n  {\n    name: 'right-click',\n    // \"Right click on\" or \"Right-click the\"\n    regex: /^(?:user\\s+)?right[-\\s]?clicks?\\s+(?:on\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?$/i,\n    primitiveType: 'rightClick',\n    extract: (match) => ({\n      type: 'rightClick',\n      locator: createLocatorFromMatch('text', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n  {\n    name: 'submit-form',\n    // \"Submit the form\" or \"Submits form\"\n    regex: /^(?:user\\s+)?submits?\\s+(?:the\\s+)?form$/i,\n    primitiveType: 'click',\n    extract: () => ({\n      type: 'click',\n      locator: createLocatorFromMatch('role', 'button', 'Submit'),\n    }),\n  },\n];\n\n/**\n * Extended fill patterns - Common variations missed by core patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const extendedFillPatterns: StepPattern[] = [\n  {\n    name: 'type-into-field',\n    // \"Type 'password' into the Password field\"\n    regex: /^(?:user\\s+)?types?\\s+['\"](.+?)['\"]\\s+into\\s+(?:the\\s+)?[\"']?(.+?)[\"']?\\s*(?:field|input)?$/i,\n    primitiveType: 'fill',\n    extract: (match) => ({\n      type: 'fill',\n      locator: createLocatorFromMatch('label', match[2]!),\n      value: createValueFromText(match[1]!),\n    }),\n  },\n  {\n    name: 'fill-in-field-no-value',\n    // \"Fill in the email address\" (without explicit value - uses actor data)\n    regex: /^(?:user\\s+)?fills?\\s+in\\s+(?:the\\s+)?[\"']?(.+?)[\"']?\\s*(?:field|input)?$/i,\n    primitiveType: 'fill',\n    extract: (match) => {\n      const fieldName = match[1]!.replace(/[\"']/g, '');\n      return {\n        type: 'fill',\n        locator: createLocatorFromMatch('label', fieldName),\n        value: { type: 'actor', value: fieldName.toLowerCase().replace(/\\s+/g, '_') },\n      };\n    },\n  },\n  {\n    name: 'clear-field',\n    // \"Clear the email field\" or \"Clears the input\"\n    regex: /^(?:user\\s+)?clears?\\s+(?:the\\s+)?[\"']?(.+?)[\"']?\\s*(?:field|input)?$/i,\n    primitiveType: 'clear',\n    extract: (match) => ({\n      type: 'clear',\n      locator: createLocatorFromMatch('label', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n  {\n    name: 'set-value',\n    // \"Set the value to 'test'\" or \"Sets field to 'value'\"\n    regex: /^(?:user\\s+)?sets?\\s+(?:the\\s+)?(?:value\\s+)?(?:of\\s+)?[\"']?(.+?)[\"']?\\s+to\\s+['\"](.+?)['\"]$/i,\n    primitiveType: 'fill',\n    extract: (match) => ({\n      type: 'fill',\n      locator: createLocatorFromMatch('label', match[1]!),\n      value: createValueFromText(match[2]!),\n    }),\n  },\n];\n\n/**\n * Extended assertion patterns - Common variations missed by core patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const extendedAssertionPatterns: StepPattern[] = [\n  {\n    name: 'verify-element-showing',\n    // \"Verify the dashboard is showing/displayed\"\n    regex: /^(?:verify|confirm|ensure)\\s+(?:that\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:is\\s+)?(?:showing|displayed|visible)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'page-should-show',\n    // \"The page should show 'Welcome'\" or \"Page should display 'text'\"\n    regex: /^(?:the\\s+)?page\\s+should\\s+(?:show|display|contain)\\s+['\"](.+?)['\"]$/i,\n    primitiveType: 'expectText',\n    extract: (match) => ({\n      type: 'expectText',\n      locator: { strategy: 'role', value: 'main' },\n      text: match[1]!,\n    }),\n  },\n  {\n    name: 'make-sure-assertion',\n    // \"Make sure the button is visible\" or \"Make sure user sees 'text'\"\n    regex: /^make\\s+sure\\s+(?:that\\s+)?(?:the\\s+)?(.+?)\\s+(?:is\\s+)?(?:visible|displayed|shown)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'confirm-that-assertion',\n    // \"Confirm that the message appears\" or \"Confirm the error is shown\"\n    regex: /^confirm\\s+(?:that\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:appears?|is\\s+shown|displays?)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'check-element-exists',\n    // \"Check that the element exists\" or \"Check the button is present\"\n    regex: /^check\\s+(?:that\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:exists?|is\\s+present)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'element-should-not-be-visible',\n    // \"The error should not be visible\" or \"Error message is not displayed\"\n    regex: /^(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:should\\s+)?(?:not\\s+be|is\\s+not)\\s+(?:visible|displayed|shown)$/i,\n    primitiveType: 'expectHidden',\n    extract: (match) => ({\n      type: 'expectHidden',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'element-contains-text',\n    // \"The header contains 'Welcome'\" or \"Element should contain 'text'\"\n    regex: /^(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:should\\s+)?contains?\\s+['\"](.+?)['\"]$/i,\n    primitiveType: 'expectText',\n    extract: (match) => ({\n      type: 'expectText',\n      locator: createLocatorFromMatch('text', match[1]!),\n      text: match[2]!,\n    }),\n  },\n];\n\n/**\n * Extended wait patterns - Common variations missed by core patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const extendedWaitPatterns: StepPattern[] = [\n  {\n    name: 'wait-for-element-visible',\n    // \"Wait for the loading spinner to disappear\"\n    regex: /^(?:user\\s+)?waits?\\s+(?:for\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+to\\s+(?:disappear|be\\s+hidden)$/i,\n    primitiveType: 'waitForHidden',\n    extract: (match) => ({\n      type: 'waitForHidden',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'wait-for-element-appear',\n    // \"Wait for the modal to appear\" or \"Wait for dialog to show\"\n    regex: /^(?:user\\s+)?waits?\\s+(?:for\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+to\\s+(?:appear|show|be\\s+visible)$/i,\n    primitiveType: 'waitForVisible',\n    extract: (match) => ({\n      type: 'waitForVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'wait-until-loaded',\n    // \"Wait until the page is loaded\" or \"Wait until content loads\"\n    regex: /^(?:user\\s+)?waits?\\s+until\\s+(?:the\\s+)?(?:page|content|data)\\s+(?:is\\s+)?loaded$/i,\n    primitiveType: 'waitForLoadingComplete',\n    extract: () => ({\n      type: 'waitForLoadingComplete',\n    }),\n  },\n  {\n    name: 'wait-seconds',\n    // \"Wait for 2 seconds\" or \"Wait 3 seconds\"\n    regex: /^(?:user\\s+)?waits?\\s+(?:for\\s+)?(\\d+)\\s+seconds?$/i,\n    primitiveType: 'waitForTimeout',\n    extract: (match) => ({\n      type: 'waitForTimeout',\n      ms: parseInt(match[1]!, 10) * 1000,\n    }),\n  },\n  {\n    name: 'wait-for-network',\n    // \"Wait for network to be idle\" or \"Wait for network idle\"\n    regex: /^(?:user\\s+)?waits?\\s+(?:for\\s+)?(?:the\\s+)?network\\s+(?:to\\s+be\\s+)?idle$/i,\n    primitiveType: 'waitForNetworkIdle',\n    extract: () => ({\n      type: 'waitForNetworkIdle',\n    }),\n  },\n];\n\n/**\n * Extended navigation patterns - Common variations missed by core patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const extendedNavigationPatterns: StepPattern[] = [\n  {\n    name: 'refresh-page',\n    // \"Refresh the page\" or \"Reload the page\"\n    regex: /^(?:user\\s+)?(?:refresh(?:es)?|reloads?)\\s+(?:the\\s+)?page$/i,\n    primitiveType: 'reload',\n    extract: () => ({\n      type: 'reload',\n    }),\n  },\n  {\n    name: 'go-back',\n    // \"Go back\" or \"Navigate back\" or \"User goes back\"\n    regex: /^(?:user\\s+)?(?:go(?:es)?|navigates?)\\s+back$/i,\n    primitiveType: 'goBack',\n    extract: () => ({\n      type: 'goBack',\n    }),\n  },\n  {\n    name: 'go-forward',\n    // \"Go forward\" or \"Navigate forward\"\n    regex: /^(?:user\\s+)?(?:go(?:es)?|navigates?)\\s+forward$/i,\n    primitiveType: 'goForward',\n    extract: () => ({\n      type: 'goForward',\n    }),\n  },\n];\n\n/**\n * Extended select/dropdown patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const extendedSelectPatterns: StepPattern[] = [\n  {\n    name: 'select-from-dropdown',\n    // \"Select 'Option' from dropdown\" or \"Choose 'Value' from the dropdown\"\n    regex: /^(?:user\\s+)?(?:selects?|chooses?)\\s+['\"](.+?)['\"]\\s+from\\s+(?:the\\s+)?dropdown$/i,\n    primitiveType: 'select',\n    extract: (match) => ({\n      type: 'select',\n      locator: { strategy: 'role', value: 'combobox' },\n      option: match[1]!,\n    }),\n  },\n  {\n    name: 'select-option-named',\n    // \"Select option 'Value'\" or \"Choose the 'Option' option\"\n    regex: /^(?:user\\s+)?(?:selects?|chooses?)\\s+(?:the\\s+)?(?:option\\s+)?['\"](.+?)['\"](?:\\s+option)?$/i,\n    primitiveType: 'select',\n    extract: (match) => ({\n      type: 'select',\n      locator: { strategy: 'role', value: 'combobox' },\n      option: match[1]!,\n    }),\n  },\n];\n\n/**\n * Hover patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const hoverPatterns: StepPattern[] = [\n  {\n    name: 'hover-over-element',\n    // \"Hover over the menu\" or \"User hovers on button\"\n    regex: /^(?:user\\s+)?hovers?\\s+(?:over|on)\\s+(?:the\\s+)?[\"']?(.+?)[\"']?$/i,\n    primitiveType: 'hover',\n    extract: (match) => ({\n      type: 'hover',\n      locator: createLocatorFromMatch('text', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n  {\n    name: 'mouse-over',\n    // \"Mouse over the element\" or \"Mouseover the button\"\n    regex: /^(?:user\\s+)?mouse\\s*over\\s+(?:the\\s+)?[\"']?(.+?)[\"']?$/i,\n    primitiveType: 'hover',\n    extract: (match) => ({\n      type: 'hover',\n      locator: createLocatorFromMatch('text', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n];\n\n/**\n * Focus patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const focusPatterns: StepPattern[] = [\n  {\n    name: 'focus-on-element',\n    // \"Focus on the input\" or \"User focuses the field\"\n    regex: /^(?:user\\s+)?focus(?:es)?\\s+(?:on\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?$/i,\n    primitiveType: 'focus',\n    extract: (match) => ({\n      type: 'focus',\n      locator: createLocatorFromMatch('label', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n];\n\n/**\n * All patterns in priority order (more specific patterns first)\n * Structured patterns come first to prioritize the Journey markdown format\n */\nexport const allPatterns: StepPattern[] = [\n  ...structuredPatterns,\n  ...authPatterns,\n  ...toastPatterns,\n  // Extended patterns come BEFORE base patterns to match more specific cases first\n  ...extendedNavigationPatterns, // Must be before navigationPatterns (e.g., \"Go back\" vs \"Go to\")\n  ...navigationPatterns,\n  ...extendedClickPatterns, // Must be before clickPatterns (e.g., \"Click on\" vs \"Click\")\n  ...clickPatterns,\n  ...extendedFillPatterns,\n  ...fillPatterns,\n  ...extendedSelectPatterns,\n  ...selectPatterns,\n  ...checkPatterns,\n  ...extendedAssertionPatterns, // Must be before visibilityPatterns (e.g., \"not be visible\")\n  ...visibilityPatterns,\n  ...urlPatterns,\n  ...extendedWaitPatterns,\n  ...waitPatterns,\n  ...hoverPatterns,\n  ...focusPatterns,\n];\n\n/**\n * Match text against all patterns and return the first matching primitive\n */\nexport function matchPattern(text: string): IRPrimitive | null {\n  const trimmedText = text.trim();\n\n  for (const pattern of allPatterns) {\n    const match = trimmedText.match(pattern.regex);\n    if (match) {\n      const primitive = pattern.extract(match);\n      if (primitive) {\n        return primitive;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Get all pattern matches for debugging\n */\nexport function getPatternMatches(text: string): Array<{ pattern: string; match: IRPrimitive }> {\n  const trimmedText = text.trim();\n  const matches: Array<{ pattern: string; match: IRPrimitive }> = [];\n\n  for (const pattern of allPatterns) {\n    const match = trimmedText.match(pattern.regex);\n    if (match) {\n      const primitive = pattern.extract(match);\n      if (primitive) {\n        matches.push({ pattern: pattern.name, match: primitive });\n      }\n    }\n  }\n\n  return matches;\n}\n\n/**\n * Get all pattern names for CLI listing\n */\nexport function getAllPatternNames(): string[] {\n  return allPatterns.map((p) => p.name);\n}\n\n/**\n * Get pattern count by category\n */\nexport function getPatternCountByCategory(): Record<string, number> {\n  const counts: Record<string, number> = {};\n\n  for (const pattern of allPatterns) {\n    const category = pattern.name.split('-')[0] || 'other';\n    counts[category] = (counts[category] || 0) + 1;\n  }\n\n  return counts;\n}\n\n/**\n * Get pattern metadata for a specific pattern\n */\nexport function getPatternMetadata(patternName: string): PatternMetadata | null {\n  const pattern = allPatterns.find((p) => p.name === patternName);\n  if (!pattern) return null;\n\n  // Determine version based on pattern name prefix\n  const isExtended =\n    patternName.includes('extended') ||\n    patternName.startsWith('hover') ||\n    patternName.startsWith('focus') ||\n    patternName.startsWith('press-') ||\n    patternName.startsWith('double-') ||\n    patternName.startsWith('right-');\n\n  return {\n    name: pattern.name,\n    version: isExtended ? '1.1.0' : '1.0.0',\n    addedDate: isExtended ? '2026-01-27' : '2026-01-02',\n    source: 'core',\n    category: pattern.name.split('-')[0] || 'other',\n  };\n}\n\n/**\n * Find patterns that match a given text (for debugging)\n */\nexport function findMatchingPatterns(text: string): string[] {\n  const trimmedText = text.trim();\n  const matchingNames: string[] = [];\n\n  for (const pattern of allPatterns) {\n    if (pattern.regex.test(trimmedText)) {\n      matchingNames.push(pattern.name);\n    }\n  }\n\n  return matchingNames;\n}\n","/**\n * Result type pattern for structured error handling\n *\n * Replaces boolean returns with structured results that include:\n * - Success/failure status\n * - Value on success\n * - Error information on failure\n * - Optional warnings for partial success cases\n *\n * @see research/2026-01-15_code_quality_standards.md Category 2 (Silent Failures)\n */\n\n/**\n * A Result type representing either success with a value or failure with an error\n *\n * @example\n * ```typescript\n * function parseConfig(path: string): Result<Config, ConfigError> {\n *   if (!fileExists(path)) {\n *     return { success: false, error: { code: 'NOT_FOUND', message: 'Config file not found' } };\n *   }\n *   const config = JSON.parse(readFile(path));\n *   return { success: true, value: config };\n * }\n *\n * const result = parseConfig('config.json');\n * if (result.success) {\n *   console.log(result.value); // Config object\n * } else {\n *   console.error(result.error); // ConfigError\n * }\n * ```\n */\nexport type Result<T, E = string> =\n  | { success: true; value: T; warnings?: string[] }\n  | { success: false; error: E };\n\n/**\n * Create a successful result\n *\n * @param value - The success value\n * @param warnings - Optional warnings to include\n * @returns A success Result\n *\n * @example\n * ```typescript\n * return ok({ name: 'test', count: 5 });\n * return ok(true, ['Some warning about the operation']);\n * ```\n */\nexport function ok<T>(value: T, warnings?: string[]): Result<T, never> {\n  return warnings?.length\n    ? { success: true, value, warnings }\n    : { success: true, value };\n}\n\n/**\n * Create a failed result\n *\n * @param error - The error information\n * @returns A failure Result\n *\n * @example\n * ```typescript\n * return err('File not found');\n * return err({ code: 'NOT_FOUND', path: '/missing.txt' });\n * ```\n */\nexport function err<E>(error: E): Result<never, E> {\n  return { success: false, error };\n}\n\n/**\n * Check if a result is successful\n *\n * @param result - The result to check\n * @returns True if the result is successful\n */\nexport function isOk<T, E>(result: Result<T, E>): result is { success: true; value: T; warnings?: string[] } {\n  return result.success;\n}\n\n/**\n * Check if a result is a failure\n *\n * @param result - The result to check\n * @returns True if the result is a failure\n */\nexport function isErr<T, E>(result: Result<T, E>): result is { success: false; error: E } {\n  return !result.success;\n}\n\n/**\n * Unwrap a result, throwing if it's a failure\n *\n * @param result - The result to unwrap\n * @param errorMessage - Optional custom error message\n * @returns The success value\n * @throws Error if the result is a failure\n *\n * @example\n * ```typescript\n * const config = unwrap(parseConfig('config.json'));\n * // Throws if parsing failed\n * ```\n */\nexport function unwrap<T, E>(result: Result<T, E>, errorMessage?: string): T {\n  if (result.success) {\n    return result.value;\n  }\n  const message = errorMessage\n    ? `${errorMessage}: ${String(result.error)}`\n    : String(result.error);\n  throw new Error(message);\n}\n\n/**\n * Unwrap a result or return a default value\n *\n * @param result - The result to unwrap\n * @param defaultValue - The default value to return on failure\n * @returns The success value or default\n *\n * @example\n * ```typescript\n * const config = unwrapOr(parseConfig('config.json'), defaultConfig);\n * ```\n */\nexport function unwrapOr<T, E>(result: Result<T, E>, defaultValue: T): T {\n  return result.success ? result.value : defaultValue;\n}\n\n/**\n * Map a successful result to a new value\n *\n * @param result - The result to map\n * @param fn - The mapping function\n * @returns A new result with the mapped value\n *\n * @example\n * ```typescript\n * const nameResult = map(parseConfig('config.json'), config => config.name);\n * ```\n */\nexport function map<T, U, E>(result: Result<T, E>, fn: (_value: T) => U): Result<U, E> {\n  if (result.success) {\n    return ok(fn(result.value), result.warnings);\n  }\n  return result;\n}\n\n/**\n * Map a failed result to a new error\n *\n * @param result - The result to map\n * @param fn - The error mapping function\n * @returns A new result with the mapped error\n */\nexport function mapErr<T, E, F>(result: Result<T, E>, fn: (_error: E) => F): Result<T, F> {\n  if (!result.success) {\n    return err(fn(result.error));\n  }\n  return result;\n}\n\n/**\n * Chain result operations (flatMap)\n *\n * @param result - The result to chain from\n * @param fn - The function returning a new result\n * @returns The chained result\n *\n * @example\n * ```typescript\n * const result = andThen(\n *   parseConfig('config.json'),\n *   config => validateConfig(config)\n * );\n * ```\n */\nexport function andThen<T, U, E>(\n  result: Result<T, E>,\n  fn: (_value: T) => Result<U, E>\n): Result<U, E> {\n  if (result.success) {\n    const newResult = fn(result.value);\n    // Merge warnings\n    if (newResult.success && result.warnings?.length) {\n      return ok(newResult.value, [\n        ...result.warnings,\n        ...(newResult.warnings || []),\n      ]);\n    }\n    return newResult;\n  }\n  return result;\n}\n\n/**\n * Collect an array of results into a result of an array\n *\n * @param results - Array of results to collect\n * @returns A single result containing all values or the first error\n *\n * @example\n * ```typescript\n * const configs = collect([\n *   parseConfig('a.json'),\n *   parseConfig('b.json'),\n *   parseConfig('c.json'),\n * ]);\n * // Either Result<Config[], E> with all configs or first error\n * ```\n */\nexport function collect<T, E>(results: Result<T, E>[]): Result<T[], E> {\n  const values: T[] = [];\n  const allWarnings: string[] = [];\n\n  for (const result of results) {\n    if (!result.success) {\n      return result;\n    }\n    values.push(result.value);\n    if (result.warnings) {\n      allWarnings.push(...result.warnings);\n    }\n  }\n\n  return allWarnings.length > 0\n    ? ok(values, allWarnings)\n    : ok(values);\n}\n\n/**\n * Partition an array of results into successes and failures\n *\n * @param results - Array of results to partition\n * @returns Object with values and errors arrays\n *\n * @example\n * ```typescript\n * const { values, errors } = partition([\n *   parseConfig('a.json'),\n *   parseConfig('b.json'),\n *   parseConfig('c.json'),\n * ]);\n * console.log(`${values.length} succeeded, ${errors.length} failed`);\n * ```\n */\nexport function partition<T, E>(\n  results: Result<T, E>[]\n): { values: T[]; errors: E[]; warnings: string[] } {\n  const values: T[] = [];\n  const errors: E[] = [];\n  const warnings: string[] = [];\n\n  for (const result of results) {\n    if (result.success) {\n      values.push(result.value);\n      if (result.warnings) {\n        warnings.push(...result.warnings);\n      }\n    } else {\n      errors.push(result.error);\n    }\n  }\n\n  return { values, errors, warnings };\n}\n\n/**\n * Try to execute a function and wrap the result\n *\n * @param fn - Function to execute\n * @returns Result with the return value or caught error\n *\n * @example\n * ```typescript\n * const result = tryCatch(() => JSON.parse(jsonString));\n * if (result.success) {\n *   console.log(result.value);\n * } else {\n *   console.error('Parse failed:', result.error);\n * }\n * ```\n */\nexport function tryCatch<T>(fn: () => T): Result<T, Error> {\n  try {\n    return ok(fn());\n  } catch (error) {\n    return err(error instanceof Error ? error : new Error(String(error)));\n  }\n}\n\n/**\n * Try to execute an async function and wrap the result\n *\n * @param fn - Async function to execute\n * @returns Promise of Result with the return value or caught error\n *\n * @example\n * ```typescript\n * const result = await tryCatchAsync(() => fetch('/api/data').then(r => r.json()));\n * ```\n */\nexport async function tryCatchAsync<T>(fn: () => Promise<T>): Promise<Result<T, Error>> {\n  try {\n    return ok(await fn());\n  } catch (error) {\n    return err(error instanceof Error ? error : new Error(String(error)));\n  }\n}\n\n/**\n * Error class with code, message, and optional details.\n *\n * Can be used both with Result type and thrown directly.\n * Extends Error to provide proper stack traces and instanceof checks.\n *\n * @example\n * ```typescript\n * // With Result type\n * return err(new CodedError('NOT_FOUND', 'File not found', { path: '/missing.txt' }));\n *\n * // Thrown directly\n * throw new CodedError('VALIDATION_ERROR', 'Invalid input');\n *\n * // Caught with instanceof\n * try {\n *   riskyOperation();\n * } catch (error) {\n *   if (error instanceof CodedError) {\n *     console.error(`[${error.code}] ${error.message}`);\n *   }\n * }\n * ```\n */\nexport class CodedError extends Error {\n  readonly code: string;\n  readonly details?: Record<string, unknown>;\n\n  constructor(code: string, message: string, details?: Record<string, unknown>) {\n    super(message);\n    this.name = 'CodedError';\n    this.code = code;\n    this.details = details;\n\n    // Maintains proper stack trace in V8 environments (Node.js, Chrome)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, CodedError);\n    }\n  }\n\n  /**\n   * Create a CodedError (convenience factory, same as constructor)\n   */\n  static create(code: string, message: string, details?: Record<string, unknown>): CodedError {\n    return new CodedError(code, message, details);\n  }\n\n  /**\n   * Convert to plain object (for serialization/logging)\n   */\n  toJSON(): { code: string; message: string; details?: Record<string, unknown>; stack?: string } {\n    return {\n      code: this.code,\n      message: this.message,\n      ...(this.details && { details: this.details }),\n      ...(this.stack && { stack: this.stack }),\n    };\n  }\n\n  /**\n   * Format error for display\n   */\n  toString(): string {\n    const base = `[${this.code}] ${this.message}`;\n    if (this.details) {\n      return `${base} ${JSON.stringify(this.details)}`;\n    }\n    return base;\n  }\n}\n\n/**\n * Create a coded error (convenience factory function)\n *\n * @param code - Error code (e.g., 'NOT_FOUND', 'VALIDATION_ERROR')\n * @param message - Human-readable error message\n * @param details - Optional additional details\n * @returns A CodedError instance\n *\n * @example\n * ```typescript\n * return err(codedError('PARSE_ERROR', 'Invalid JSON', { line: 42 }));\n * ```\n */\nexport function codedError(\n  code: string,\n  message: string,\n  details?: Record<string, unknown>\n): CodedError {\n  return new CodedError(code, message, details);\n}\n","/**\n * Journey Parser - Parse YAML frontmatter + markdown body\n * @see research/2026-01-02_autogen-refined-plan.md Section 8\n */\nimport { readFileSync, existsSync } from 'node:fs';\nimport { resolve } from 'node:path';\nimport { parse as parseYaml } from 'yaml';\nimport {\n  JourneyFrontmatterSchema,\n  JourneyStatusSchema,\n  type JourneyFrontmatter,\n  type JourneyStatus,\n  validateForAutoGen,\n} from './schema.js';\nimport { matchPattern } from '../mapping/patterns.js';\nimport { type Result, ok, err, CodedError } from '../utils/result.js';\n\n// Re-export for convenience\nexport { JourneyFrontmatterSchema, JourneyStatusSchema };\nexport type { JourneyFrontmatter, JourneyStatus };\n\n/**\n * Error thrown when journey parsing fails\n */\nexport class JourneyParseError extends Error {\n  public readonly filePath: string;\n  public readonly cause?: unknown;\n\n  constructor(\n    message: string,\n    filePath: string,\n    cause?: unknown\n  ) {\n    super(message);\n    this.name = 'JourneyParseError';\n    this.filePath = filePath;\n    this.cause = cause;\n  }\n}\n\n/**\n * Parsed journey structure\n */\nexport interface ParsedJourney {\n  /** Journey frontmatter (validated) */\n  frontmatter: JourneyFrontmatter;\n  /** Raw markdown body (everything after frontmatter) */\n  body: string;\n  /** Acceptance Criteria section */\n  acceptanceCriteria: AcceptanceCriterion[];\n  /** Procedural Steps section */\n  proceduralSteps: ProceduralStep[];\n  /** Data/Environment notes */\n  dataNotes: string[];\n  /** Source file path */\n  sourcePath: string;\n}\n\n/**\n * Acceptance criterion from journey body\n */\nexport interface AcceptanceCriterion {\n  /** Criterion ID (e.g., 'AC-1') */\n  id: string;\n  /** Title/description */\n  title: string;\n  /** Bullet points under this criterion */\n  steps: string[];\n  /** Raw markdown content */\n  rawContent: string;\n}\n\n/**\n * Procedural step from journey body\n */\nexport interface ProceduralStep {\n  /** Step number */\n  number: number;\n  /** Step text */\n  text: string;\n  /** Associated AC (if any) */\n  linkedAC?: string;\n}\n\n/**\n * Structured step action from journey body\n */\nexport interface StructuredStepAction {\n  /** Action type: 'action', 'wait', or 'assert' */\n  type: 'action' | 'wait' | 'assert';\n  /** The parsed action string */\n  action: string;\n  /** Target element or condition */\n  target: string;\n  /** Optional value for the action */\n  value?: string;\n}\n\n/**\n * Structured step from journey body\n */\nexport interface StructuredStep {\n  /** Step number */\n  stepNumber: number;\n  /** Step name/title */\n  stepName: string;\n  /** Array of parsed actions */\n  actions: StructuredStepAction[];\n}\n\n/**\n * Regex patterns for parsing\n */\nconst FRONTMATTER_REGEX = /^---\\r?\\n([\\s\\S]*?)\\r?\\n---/;\n\n/**\n * Extract frontmatter from markdown content\n */\nfunction extractFrontmatter(content: string): {\n  frontmatter: string;\n  body: string;\n} {\n  const match = FRONTMATTER_REGEX.exec(content);\n  if (!match) {\n    throw new Error('No YAML frontmatter found (content should start with ---)');\n  }\n\n  return {\n    frontmatter: match[1]!,\n    body: content.slice(match[0]!.length).trim(),\n  };\n}\n\n/**\n * Parse acceptance criteria from markdown body\n */\nfunction parseAcceptanceCriteria(body: string): AcceptanceCriterion[] {\n  const criteria: AcceptanceCriterion[] = [];\n\n  // Find the Acceptance Criteria section\n  const acSectionMatch = body.match(/##\\s*Acceptance\\s*Criteria\\s*\\n([\\s\\S]*?)(?=\\n##\\s[^#]|$)/i);\n  if (!acSectionMatch) {\n    return criteria;\n  }\n\n  const acSection = acSectionMatch[1]!;\n\n  // Split by AC headers (### AC-N or ## AC-N)\n  const acPattern = /^###?\\s*(AC-\\d+)[:\\s]*(.*?)$/gim;\n  const parts: Array<{ id: string; title: string; startIndex: number }> = [];\n\n  let match;\n  while ((match = acPattern.exec(acSection)) !== null) {\n    parts.push({\n      id: match[1]!.toUpperCase(),\n      title: match[2]!.trim(),\n      startIndex: match.index + match[0]!.length,\n    });\n  }\n\n  // Extract content for each AC\n  for (let i = 0; i < parts.length; i++) {\n    const part = parts[i]!;\n\n    // Get content between this AC header and the next\n    const contentStart = part.startIndex;\n    const contentEnd = i + 1 < parts.length\n      ? acSection.lastIndexOf('###', parts[i + 1]!.startIndex)\n      : acSection.length;\n\n    const content = acSection.slice(contentStart, contentEnd > contentStart ? contentEnd : acSection.length);\n\n    // Extract bullet points as steps\n    const steps: string[] = [];\n    const bulletPattern = /^[-*]\\s+(.+)$/gm;\n    let bulletMatch;\n    while ((bulletMatch = bulletPattern.exec(content)) !== null) {\n      steps.push(bulletMatch[1]!.trim());\n    }\n\n    // Build raw content\n    const headerMatch = acSection.match(new RegExp(`###?\\\\s*${part.id}[:\\\\s]*${part.title.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}`, 'i'));\n    const rawContent = headerMatch\n      ? headerMatch[0]! + content.slice(0, content.indexOf('\\n###') > 0 ? content.indexOf('\\n###') : content.length)\n      : content;\n\n    criteria.push({\n      id: part.id,\n      title: part.title,\n      steps,\n      rawContent: rawContent.trim(),\n    });\n  }\n\n  return criteria;\n}\n\n/**\n * Parse procedural steps from markdown body\n */\nfunction parseProceduralSteps(body: string): ProceduralStep[] {\n  const steps: ProceduralStep[] = [];\n\n  // Find the Procedural Steps section\n  const psMatch = body.match(\n    /##\\s*Procedural\\s*Steps?\\s*\\n([\\s\\S]*?)(?=\\n##\\s[^#]|$)/i\n  );\n  if (!psMatch) {\n    return steps;\n  }\n\n  const psSection = psMatch[1]!;\n\n  // Parse numbered steps\n  const numberedPattern = /^\\d+\\.\\s+(.+)$/gm;\n  let match;\n  let stepNumber = 1;\n\n  while ((match = numberedPattern.exec(psSection)) !== null) {\n    const text = match[1]!.trim();\n\n    // Check for AC reference in text (e.g., \"(AC-1)\")\n    const acRef = text.match(/\\(AC-(\\d+)\\)/i);\n\n    steps.push({\n      number: stepNumber++,\n      text: text.replace(/\\s*\\(AC-\\d+\\)\\s*/gi, '').trim(),\n      linkedAC: acRef ? `AC-${acRef[1]!}` : undefined,\n    });\n  }\n\n  // Also parse bullet points if no numbered steps\n  if (steps.length === 0) {\n    const bulletPattern = /^[-*]\\s+(.+)$/gm;\n    while ((match = bulletPattern.exec(psSection)) !== null) {\n      const text = match[1]!.trim();\n      const acRef = text.match(/\\(AC-(\\d+)\\)/i);\n\n      steps.push({\n        number: stepNumber++,\n        text: text.replace(/\\s*\\(AC-\\d+\\)\\s*/gi, '').trim(),\n        linkedAC: acRef ? `AC-${acRef[1]!}` : undefined,\n      });\n    }\n  }\n\n  return steps;\n}\n\n/**\n * Parse data/environment notes from markdown body\n */\nfunction parseDataNotes(body: string): string[] {\n  const notes: string[] = [];\n\n  // Find Data/Environment section\n  const dataMatch = body.match(\n    /##\\s*(Data|Environment|Data\\/Environment)\\s*(Notes?)?\\s*\\n([\\s\\S]*?)(?=\\n##\\s[^#]|$)/i\n  );\n  if (!dataMatch) {\n    return notes;\n  }\n\n  const dataSection = dataMatch[3]!;\n\n  // Extract bullet points\n  const bulletPattern = /^[-*]\\s+(.+)$/gm;\n  let match;\n  while ((match = bulletPattern.exec(dataSection)) !== null) {\n    notes.push(match[1]!.trim());\n  }\n\n  return notes;\n}\n\n/**\n * Parse structured steps from markdown content\n * Parses the new structured format with Action/Wait for/Assert bullets\n * @param content - The markdown content containing structured steps\n * @returns Array of parsed structured steps\n */\nexport function parseStructuredSteps(content: string): StructuredStep[] {\n  const steps: StructuredStep[] = [];\n\n  // Split content by step headers\n  const sections = content.split(/(?=^###\\s*Step\\s+\\d+:)/m);\n\n  for (const section of sections) {\n    // Match the step header\n    const headerMatch = section.match(/^###\\s*Step\\s+(\\d+):\\s*(.+)$/m);\n    if (!headerMatch) continue;\n\n    const step: StructuredStep = {\n      stepNumber: parseInt(headerMatch[1]!, 10),\n      stepName: headerMatch[2]!.trim(),\n      actions: [],\n    };\n\n    // Parse bullet points in this section\n    let bulletMatch: RegExpExecArray | null;\n    // Create a fresh regex for each section to reset lastIndex\n    const sectionBulletRegex = /^-\\s*\\*\\*(Action|Wait for|Assert)\\*\\*:\\s*(.+)$/gm;\n\n    while ((bulletMatch = sectionBulletRegex.exec(section)) !== null) {\n      const [, type, text] = bulletMatch;\n\n      // Determine action type\n      const actionType = type!.toLowerCase() === 'action' ? 'action'\n        : type!.toLowerCase() === 'wait for' ? 'wait'\n        : 'assert';\n\n      // Try to parse the text using pattern matching\n      const primitive = matchPattern(text!.trim());\n\n      if (primitive) {\n        // Extract meaningful info from the primitive\n        let action = '';\n        let target = '';\n        let value: string | undefined;\n\n        switch (primitive.type) {\n          case 'goto':\n            action = 'navigate';\n            target = primitive.url;\n            break;\n          case 'click':\n            action = 'click';\n            target = primitive.locator.value;\n            break;\n          case 'fill':\n            action = 'fill';\n            target = primitive.locator.value;\n            value = primitive.value.value;\n            break;\n          case 'select':\n            action = 'select';\n            target = primitive.locator.value;\n            value = primitive.option;\n            break;\n          case 'check':\n            action = 'check';\n            target = primitive.locator.value;\n            break;\n          case 'uncheck':\n            action = 'uncheck';\n            target = primitive.locator.value;\n            break;\n          case 'expectVisible':\n            action = 'expectVisible';\n            target = primitive.locator.value;\n            break;\n          case 'expectToast':\n            action = 'expectToast';\n            target = primitive.toastType || 'info';\n            value = primitive.message;\n            break;\n          case 'expectURL':\n            action = 'expectURL';\n            target = typeof primitive.pattern === 'string' ? primitive.pattern : primitive.pattern.source;\n            break;\n          case 'callModule':\n            action = `${primitive.module}.${primitive.method}`;\n            target = primitive.args?.join(', ') || '';\n            break;\n          case 'waitForURL':\n            action = 'waitForURL';\n            target = typeof primitive.pattern === 'string' ? primitive.pattern : primitive.pattern.source;\n            break;\n          case 'waitForLoadingComplete':\n            action = 'waitForLoadingComplete';\n            target = '';\n            break;\n          default:\n            // Fallback for unknown primitive types\n            action = text!.trim();\n            target = '';\n        }\n\n        step.actions.push({\n          type: actionType,\n          action,\n          target,\n          value,\n        });\n      } else {\n        // If pattern matching fails, store the raw text\n        step.actions.push({\n          type: actionType,\n          action: text!.trim(),\n          target: '',\n          value: undefined,\n        });\n      }\n    }\n\n    // Only add steps that have actions\n    if (step.actions.length > 0) {\n      steps.push(step);\n    }\n  }\n\n  return steps;\n}\n\n/**\n * Parse a journey markdown file\n * @param filePath - Path to the journey file\n * @returns Parsed journey structure\n * @throws JourneyParseError if parsing fails\n */\nexport function parseJourney(filePath: string): ParsedJourney {\n  const resolvedPath = resolve(filePath);\n\n  if (!existsSync(resolvedPath)) {\n    throw new JourneyParseError(\n      `Journey file not found: ${resolvedPath}`,\n      resolvedPath\n    );\n  }\n\n  let content: string;\n  try {\n    content = readFileSync(resolvedPath, 'utf-8');\n  } catch (err) {\n    throw new JourneyParseError(\n      `Failed to read journey file: ${resolvedPath}`,\n      resolvedPath,\n      err\n    );\n  }\n\n  // Extract frontmatter and body\n  let frontmatterStr: string;\n  let body: string;\n  try {\n    const extracted = extractFrontmatter(content);\n    frontmatterStr = extracted.frontmatter;\n    body = extracted.body;\n  } catch (err) {\n    throw new JourneyParseError(\n      `Invalid frontmatter in journey file: ${resolvedPath}`,\n      resolvedPath,\n      err\n    );\n  }\n\n  // Parse YAML frontmatter\n  let rawFrontmatter: unknown;\n  try {\n    rawFrontmatter = parseYaml(frontmatterStr);\n  } catch (err) {\n    throw new JourneyParseError(\n      `Invalid YAML in journey frontmatter: ${resolvedPath}`,\n      resolvedPath,\n      err\n    );\n  }\n\n  // Validate frontmatter with Zod\n  const result = JourneyFrontmatterSchema.safeParse(rawFrontmatter);\n  if (!result.success) {\n    const issues = result.error.issues\n      .map((i) => `  - ${i.path.join('.')}: ${i.message}`)\n      .join('\\n');\n    throw new JourneyParseError(\n      `Invalid journey frontmatter in ${resolvedPath}:\\n${issues}`,\n      resolvedPath,\n      result.error\n    );\n  }\n\n  // Parse body sections\n  const acceptanceCriteria = parseAcceptanceCriteria(body);\n  const proceduralSteps = parseProceduralSteps(body);\n  const dataNotes = parseDataNotes(body);\n\n  return {\n    frontmatter: result.data,\n    body,\n    acceptanceCriteria,\n    proceduralSteps,\n    dataNotes,\n    sourcePath: resolvedPath,\n  };\n}\n\n/**\n * Parse and validate a journey for AutoGen (must be clarified)\n */\nexport function parseJourneyForAutoGen(filePath: string): ParsedJourney {\n  const parsed = parseJourney(filePath);\n\n  const validation = validateForAutoGen(parsed.frontmatter);\n  if (!validation.valid) {\n    throw new JourneyParseError(\n      `Journey not ready for AutoGen:\\n${validation.errors.map((e) => `  - ${e}`).join('\\n')}`,\n      filePath\n    );\n  }\n\n  return parsed;\n}\n\n/**\n * Parse journey from string content (for testing)\n */\nexport function parseJourneyContent(\n  content: string,\n  virtualPath = 'virtual.journey.md'\n): ParsedJourney {\n  // Extract frontmatter and body\n  const { frontmatter: frontmatterStr, body } = extractFrontmatter(content);\n\n  // Parse YAML frontmatter\n  const rawFrontmatter = parseYaml(frontmatterStr);\n\n  // Validate frontmatter with Zod\n  const result = JourneyFrontmatterSchema.safeParse(rawFrontmatter);\n  if (!result.success) {\n    const issues = result.error.issues\n      .map((i) => `  - ${i.path.join('.')}: ${i.message}`)\n      .join('\\n');\n    throw new JourneyParseError(\n      `Invalid journey frontmatter:\\n${issues}`,\n      virtualPath,\n      result.error\n    );\n  }\n\n  // Parse body sections\n  const acceptanceCriteria = parseAcceptanceCriteria(body);\n  const proceduralSteps = parseProceduralSteps(body);\n  const dataNotes = parseDataNotes(body);\n\n  return {\n    frontmatter: result.data,\n    body,\n    acceptanceCriteria,\n    proceduralSteps,\n    dataNotes,\n    sourcePath: virtualPath,\n  };\n}\n\n/**\n * Parse journey from string content with Result type (no exceptions)\n *\n * This is the recommended way to parse journey content as it returns\n * structured errors via Result type instead of throwing exceptions.\n *\n * @param content - Raw markdown content to parse\n * @param virtualPath - Virtual path for error reporting (default: 'virtual.journey.md')\n * @returns Result with ParsedJourney on success or CodedError on failure\n *\n * @example\n * ```typescript\n * const result = tryParseJourneyContent(markdownContent);\n * if (result.success) {\n *   console.log('Parsed:', result.value.frontmatter.id);\n * } else {\n *   console.error(`[${result.error.code}] ${result.error.message}`);\n * }\n * ```\n */\nexport function tryParseJourneyContent(\n  content: string,\n  virtualPath = 'virtual.journey.md'\n): Result<ParsedJourney, CodedError> {\n  // Extract frontmatter and body\n  const frontmatterMatch = FRONTMATTER_REGEX.exec(content);\n  if (!frontmatterMatch) {\n    return err(new CodedError(\n      'FRONTMATTER_NOT_FOUND',\n      'No YAML frontmatter found (content should start with ---)',\n      { path: virtualPath }\n    ));\n  }\n\n  const frontmatterStr = frontmatterMatch[1]!;\n  const body = content.slice(frontmatterMatch[0]!.length).trim();\n\n  // Parse YAML frontmatter\n  let rawFrontmatter: unknown;\n  try {\n    rawFrontmatter = parseYaml(frontmatterStr);\n  } catch (yamlError) {\n    return err(new CodedError(\n      'YAML_PARSE_ERROR',\n      'Invalid YAML in journey frontmatter',\n      {\n        path: virtualPath,\n        cause: yamlError instanceof Error ? yamlError.message : String(yamlError)\n      }\n    ));\n  }\n\n  // Validate frontmatter with Zod\n  const zodResult = JourneyFrontmatterSchema.safeParse(rawFrontmatter);\n  if (!zodResult.success) {\n    const issues = zodResult.error.issues\n      .map((i) => `${i.path.join('.')}: ${i.message}`)\n      .join('; ');\n    return err(new CodedError(\n      'FRONTMATTER_VALIDATION_ERROR',\n      `Invalid journey frontmatter: ${issues}`,\n      {\n        path: virtualPath,\n        issues: zodResult.error.issues.map((i) => ({\n          path: i.path.join('.'),\n          message: i.message,\n          code: i.code,\n        }))\n      }\n    ));\n  }\n\n  // Parse body sections\n  const acceptanceCriteria = parseAcceptanceCriteria(body);\n  const proceduralSteps = parseProceduralSteps(body);\n  const dataNotes = parseDataNotes(body);\n\n  return ok({\n    frontmatter: zodResult.data,\n    body,\n    acceptanceCriteria,\n    proceduralSteps,\n    dataNotes,\n    sourcePath: virtualPath,\n  });\n}\n","/**\n * Step Mapper - Convert step text to IR primitives\n * @see research/2026-01-02_autogen-refined-plan.md Section 10\n * @see T073 - Update step mapper to prioritize explicit hints over inference\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md Phase 4 - LLKB integration\n */\nimport type {\n  IRPrimitive,\n  IRStep,\n  LocatorSpec,\n} from '../ir/types.js';\nimport type { AcceptanceCriterion, ProceduralStep } from '../journey/parseJourney.js';\nimport { matchPattern } from './patterns.js';\nimport { normalizeStepText } from './glossary.js';\nimport {\n  extractHints,\n  hasLocatorHints,\n  hasBehaviorHints,\n  parseModuleHint,\n  type ExtractedHints,\n} from '../journey/parseHints.js';\n\n// LLKB integration types - imported dynamically to avoid hard dependency\ntype LlkbPatternMatch = {\n  patternId: string;\n  primitive: IRPrimitive;\n  confidence: number;\n};\n\n// LLKB module reference - loaded lazily\nlet llkbModule: {\n  matchLlkbPattern: (text: string, options?: { llkbRoot?: string; minConfidence?: number }) => LlkbPatternMatch | null;\n  recordPatternSuccess: (text: string, primitive: IRPrimitive, journeyId: string, options?: { llkbRoot?: string }) => void;\n} | null = null;\n\n// Track if we've attempted to load LLKB\nlet llkbLoadAttempted = false;\n\n/**\n * Lazily load LLKB module (graceful degradation if not available)\n */\nasync function loadLlkbModule(): Promise<typeof llkbModule> {\n  if (llkbLoadAttempted) return llkbModule;\n  llkbLoadAttempted = true;\n\n  try {\n    const mod = await import('../llkb/patternExtension.js');\n    llkbModule = {\n      matchLlkbPattern: mod.matchLlkbPattern,\n      recordPatternSuccess: mod.recordPatternSuccess,\n    };\n  } catch {\n    // LLKB not available - this is fine, graceful degradation\n    llkbModule = null;\n  }\n\n  return llkbModule;\n}\n\n/**\n * Synchronously check LLKB (for non-async contexts)\n * Uses previously loaded module if available.\n *\n * NOTE: initializeLlkb() should be called before using mapStepText with useLlkb=true.\n * If not initialized, LLKB matching will be skipped silently (graceful degradation).\n */\nfunction tryLlkbMatch(text: string, options?: { llkbRoot?: string; minConfidence?: number }): LlkbPatternMatch | null {\n  if (!llkbModule) {\n    // If module not loaded, attempt lazy initialization (non-blocking)\n    // This won't block, but will start loading for future calls\n    if (!llkbLoadAttempted) {\n      void loadLlkbModule();\n    }\n    return null;\n  }\n  return llkbModule.matchLlkbPattern(text, options);\n}\n\n/**\n * Options for step mapping\n */\nexport interface StepMapperOptions {\n  /** Whether to normalize text before matching */\n  normalizeText?: boolean;\n  /** Whether to include blocked steps for unmatched text */\n  includeBlocked?: boolean;\n  /** Default timeout for assertions */\n  defaultTimeout?: number;\n  /** Whether to use LLKB patterns as fallback (default: true) */\n  useLlkb?: boolean;\n  /** LLKB root directory (default: .artk/llkb) */\n  llkbRoot?: string;\n  /** Minimum confidence for LLKB pattern matches (default: 0.7) */\n  llkbMinConfidence?: number;\n  /** Journey ID for LLKB recording (optional) */\n  journeyId?: string;\n}\n\n/**\n * Result of mapping a single step\n */\nexport interface StepMappingResult {\n  /** The parsed primitive, or null if not matched */\n  primitive: IRPrimitive | null;\n  /** Original text that was mapped */\n  sourceText: string;\n  /** Whether this is an assertion (expect*) or action */\n  isAssertion: boolean;\n  /** Warning or error message if any */\n  message?: string;\n  /** Source of the match */\n  matchSource?: 'pattern' | 'llkb' | 'hints' | 'none';\n  /** LLKB pattern ID if matched via LLKB */\n  llkbPatternId?: string;\n  /** LLKB match confidence if matched via LLKB */\n  llkbConfidence?: number;\n}\n\n/**\n * Result of mapping an acceptance criterion\n */\nexport interface ACMappingResult {\n  /** The mapped IR step */\n  step: IRStep;\n  /** Individual step mapping results */\n  mappings: StepMappingResult[];\n  /** Number of successfully mapped steps */\n  mappedCount: number;\n  /** Number of blocked/unmatched steps */\n  blockedCount: number;\n}\n\n/**\n * Check if a primitive is an assertion\n */\nfunction isAssertion(primitive: IRPrimitive): boolean {\n  return primitive.type.startsWith('expect');\n}\n\n/**\n * Map a single text step to an IR primitive\n */\nexport function mapStepText(\n  text: string,\n  options: StepMapperOptions = {}\n): StepMappingResult {\n  const {\n    normalizeText = true,\n    useLlkb = true,\n    llkbRoot,\n    llkbMinConfidence = 0.7,\n  } = options;\n\n  // Extract machine hints first (T073 - hints take priority)\n  const hints = extractHints(text);\n  const cleanText = hints.hasHints ? hints.cleanText : text;\n\n  // Normalize text if enabled\n  const processedText = normalizeText ? normalizeStepText(cleanText) : cleanText;\n\n  // Try to match against core patterns first\n  let primitive = matchPattern(processedText);\n  let matchSource: 'pattern' | 'llkb' | 'hints' | 'none' = primitive ? 'pattern' : 'none';\n\n  // If we have hints, enhance or override the primitive\n  if (primitive && hints.hasHints) {\n    primitive = applyHintsToPrimitive(primitive, hints);\n  }\n\n  // If no core pattern match, try LLKB patterns (Phase 4 integration)\n  let llkbPatternId: string | undefined;\n  let llkbConfidence: number | undefined;\n\n  if (!primitive && useLlkb) {\n    const llkbMatch = tryLlkbMatch(processedText, {\n      llkbRoot,\n      minConfidence: llkbMinConfidence,\n    });\n\n    if (llkbMatch) {\n      primitive = llkbMatch.primitive;\n      matchSource = 'llkb';\n      llkbPatternId = llkbMatch.patternId;\n      llkbConfidence = llkbMatch.confidence;\n\n      // Record successful pattern match to close the learning loop\n      // This increases confidence for future matches\n      if (llkbModule && options.journeyId) {\n        try {\n          llkbModule.recordPatternSuccess(\n            text, // Original text, not processed\n            llkbMatch.primitive,\n            options.journeyId,\n            { llkbRoot }\n          );\n        } catch {\n          // Don't fail mapping if recording fails - graceful degradation\n        }\n      }\n\n      // Apply hints to LLKB-matched primitive if available\n      if (hints.hasHints) {\n        primitive = applyHintsToPrimitive(primitive, hints);\n      }\n    }\n  }\n\n  // If still no match but we have locator hints, try to create primitive from hints\n  if (!primitive && hasLocatorHints(hints)) {\n    primitive = createPrimitiveFromHints(processedText, hints);\n    if (primitive) {\n      matchSource = 'hints';\n    }\n  }\n\n  if (primitive) {\n    return {\n      primitive,\n      sourceText: text,\n      isAssertion: isAssertion(primitive),\n      matchSource,\n      llkbPatternId,\n      llkbConfidence,\n    };\n  }\n\n  // No match - return blocked\n  return {\n    primitive: null,\n    sourceText: text,\n    isAssertion: false,\n    message: `Could not map step: \"${text}\"`,\n    matchSource: 'none',\n  };\n}\n\n/**\n * Apply hints to an existing primitive (override inferred values)\n */\nfunction applyHintsToPrimitive(primitive: IRPrimitive, hints: ExtractedHints): IRPrimitive {\n  // Clone the primitive to avoid mutation\n  const enhanced = { ...primitive };\n\n  // Apply locator hints if present\n  if (hasLocatorHints(hints)) {\n    const locatorSpec = buildLocatorFromHints(hints);\n    if (locatorSpec && 'locator' in enhanced) {\n      (enhanced as { locator: LocatorSpec }).locator = locatorSpec;\n    }\n  }\n\n  // Apply behavior hints\n  if (hasBehaviorHints(hints)) {\n    if (hints.behavior.timeout !== undefined && 'timeout' in enhanced) {\n      (enhanced as { timeout: number }).timeout = hints.behavior.timeout;\n    }\n    if (hints.behavior.signal && 'signal' in enhanced) {\n      (enhanced as { signal: string }).signal = hints.behavior.signal;\n    }\n    if (hints.behavior.module) {\n      const parsed = parseModuleHint(hints.behavior.module);\n      if (parsed) {\n        (enhanced as { module?: string; method?: string }).module = parsed.module;\n        (enhanced as { module?: string; method?: string }).method = parsed.method;\n      }\n    }\n  }\n\n  return enhanced;\n}\n\n/**\n * Build LocatorSpec from hints\n */\nfunction buildLocatorFromHints(hints: ExtractedHints): LocatorSpec | null {\n  const { locator } = hints;\n\n  if (locator.testid) {\n    return { strategy: 'testid', value: locator.testid };\n  }\n\n  if (locator.role) {\n    const options: Record<string, unknown> = {};\n    if (locator.label) options.name = locator.label;\n    if (locator.exact) options.exact = true;\n    if (locator.level) options.level = locator.level;\n    return {\n      strategy: 'role',\n      value: locator.role,\n      options: Object.keys(options).length > 0 ? options : undefined,\n    };\n  }\n\n  if (locator.label) {\n    return {\n      strategy: 'label',\n      value: locator.label,\n      options: locator.exact ? { exact: true } : undefined,\n    };\n  }\n\n  if (locator.text) {\n    return {\n      strategy: 'text',\n      value: locator.text,\n      options: locator.exact ? { exact: true } : undefined,\n    };\n  }\n\n  return null;\n}\n\n/**\n * Create a primitive from hints when no pattern matched\n */\nfunction createPrimitiveFromHints(text: string, hints: ExtractedHints): IRPrimitive | null {\n  const locator = buildLocatorFromHints(hints);\n  if (!locator) return null;\n\n  const lowerText = text.toLowerCase();\n\n  // Infer action type from text\n  if (lowerText.includes('click') || lowerText.includes('press')) {\n    return { type: 'click', locator };\n  }\n\n  if (lowerText.includes('enter') || lowerText.includes('type') || lowerText.includes('fill')) {\n    // Try to extract value from text\n    const valueMatch = text.match(/['\"]([^'\"]+)['\"]/);\n    return {\n      type: 'fill',\n      locator,\n      value: { type: 'literal', value: valueMatch ? valueMatch[1]! : '' },\n    };\n  }\n\n  if (lowerText.includes('see') || lowerText.includes('visible') || lowerText.includes('display')) {\n    return { type: 'expectVisible', locator };\n  }\n\n  if (lowerText.includes('check') || lowerText.includes('select')) {\n    return { type: 'check', locator };\n  }\n\n  // Default to click if we have a locator but can't determine action\n  return { type: 'click', locator };\n}\n\n/**\n * Map an acceptance criterion to an IR step\n */\nexport function mapAcceptanceCriterion(\n  ac: AcceptanceCriterion,\n  proceduralSteps: ProceduralStep[],\n  options: StepMapperOptions = {}\n): ACMappingResult {\n  const { includeBlocked = true } = options;\n\n  const actions: IRPrimitive[] = [];\n  const assertions: IRPrimitive[] = [];\n  const mappings: StepMappingResult[] = [];\n  const notes: string[] = [];\n\n  // Find procedural steps linked to this AC\n  const linkedProcedural = proceduralSteps.filter((ps) => ps.linkedAC === ac.id);\n\n  // Map all bullet points from the AC\n  for (const stepText of ac.steps) {\n    const result = mapStepText(stepText, options);\n    mappings.push(result);\n\n    if (result.primitive) {\n      if (result.isAssertion) {\n        assertions.push(result.primitive);\n      } else {\n        actions.push(result.primitive);\n      }\n    } else if (includeBlocked) {\n      actions.push({\n        type: 'blocked',\n        reason: result.message || 'Could not map step',\n        sourceText: stepText,\n      });\n    }\n  }\n\n  // Also map linked procedural steps\n  for (const ps of linkedProcedural) {\n    const result = mapStepText(ps.text, options);\n    // Don't duplicate in mappings, but add to actions if different from AC steps\n    if (result.primitive && !ac.steps.includes(ps.text)) {\n      if (result.isAssertion) {\n        assertions.push(result.primitive);\n      } else {\n        actions.push(result.primitive);\n      }\n    }\n  }\n\n  // Add note if no assertions\n  if (assertions.length === 0 && ac.title) {\n    notes.push(`TODO: Add assertion for: ${ac.title}`);\n  }\n\n  const step: IRStep = {\n    id: ac.id,\n    description: ac.title || `Step ${ac.id}`,\n    actions,\n    assertions,\n    sourceText: ac.rawContent,\n    notes: notes.length > 0 ? notes : undefined,\n  };\n\n  return {\n    step,\n    mappings,\n    mappedCount: mappings.filter((m) => m.primitive !== null).length,\n    blockedCount: mappings.filter((m) => m.primitive === null).length,\n  };\n}\n\n/**\n * Map a procedural step to an IR step\n */\nexport function mapProceduralStep(\n  ps: ProceduralStep,\n  options: StepMapperOptions = {}\n): ACMappingResult {\n  const { includeBlocked = true } = options;\n\n  const result = mapStepText(ps.text, options);\n  const actions: IRPrimitive[] = [];\n  const assertions: IRPrimitive[] = [];\n\n  if (result.primitive) {\n    if (result.isAssertion) {\n      assertions.push(result.primitive);\n    } else {\n      actions.push(result.primitive);\n    }\n  } else if (includeBlocked) {\n    actions.push({\n      type: 'blocked',\n      reason: result.message || 'Could not map procedural step',\n      sourceText: ps.text,\n    });\n  }\n\n  const step: IRStep = {\n    id: `PS-${ps.number}`,\n    description: ps.text,\n    actions,\n    assertions,\n  };\n\n  return {\n    step,\n    mappings: [result],\n    mappedCount: result.primitive ? 1 : 0,\n    blockedCount: result.primitive ? 0 : 1,\n  };\n}\n\n/**\n * Batch map multiple steps\n */\nexport function mapSteps(\n  steps: string[],\n  options: StepMapperOptions = {}\n): StepMappingResult[] {\n  return steps.map((step) => mapStepText(step, options));\n}\n\n/**\n * Get mapping statistics (enhanced with LLKB stats)\n */\nexport function getMappingStats(mappings: StepMappingResult[]): {\n  total: number;\n  mapped: number;\n  blocked: number;\n  actions: number;\n  assertions: number;\n  mappingRate: number;\n  /** Steps matched by core patterns */\n  patternMatches: number;\n  /** Steps matched by LLKB patterns */\n  llkbMatches: number;\n  /** Steps matched by hints */\n  hintMatches: number;\n} {\n  const mapped = mappings.filter((m) => m.primitive !== null);\n  const blocked = mappings.filter((m) => m.primitive === null);\n  const actions = mapped.filter((m) => !m.isAssertion);\n  const assertions = mapped.filter((m) => m.isAssertion);\n\n  const patternMatches = mappings.filter((m) => m.matchSource === 'pattern').length;\n  const llkbMatches = mappings.filter((m) => m.matchSource === 'llkb').length;\n  const hintMatches = mappings.filter((m) => m.matchSource === 'hints').length;\n\n  return {\n    total: mappings.length,\n    mapped: mapped.length,\n    blocked: blocked.length,\n    actions: actions.length,\n    assertions: assertions.length,\n    mappingRate: mappings.length > 0 ? mapped.length / mappings.length : 0,\n    patternMatches,\n    llkbMatches,\n    hintMatches,\n  };\n}\n\n/**\n * Initialize LLKB module for use with step mapping\n * Call this once at the start of generation to enable LLKB patterns\n */\nexport async function initializeLlkb(): Promise<boolean> {\n  const mod = await loadLlkbModule();\n  return mod !== null;\n}\n\n/**\n * Check if LLKB is available for use\n */\nexport function isLlkbAvailable(): boolean {\n  return llkbModule !== null;\n}\n\n/**\n * Suggest improvements for blocked steps\n */\nexport function suggestImprovements(blockedSteps: StepMappingResult[]): string[] {\n  const suggestions: string[] = [];\n\n  for (const step of blockedSteps) {\n    const text = step.sourceText.toLowerCase();\n\n    // Navigation suggestions\n    if (text.includes('go') || text.includes('open') || text.includes('navigate')) {\n      suggestions.push(\n        `\"${step.sourceText}\" - Try: \"User navigates to /path\" or \"User opens /path\"`\n      );\n    }\n    // Click suggestions\n    else if (text.includes('click') || text.includes('press') || text.includes('button')) {\n      suggestions.push(\n        `\"${step.sourceText}\" - Try: \"User clicks 'Button Name' button\" or \"Click the 'Label' button\"`\n      );\n    }\n    // Fill suggestions\n    else if (text.includes('enter') || text.includes('type') || text.includes('field')) {\n      suggestions.push(\n        `\"${step.sourceText}\" - Try: \"User enters 'value' in 'Field Label' field\"`\n      );\n    }\n    // Visibility suggestions\n    else if (text.includes('see') || text.includes('visible') || text.includes('display')) {\n      suggestions.push(\n        `\"${step.sourceText}\" - Try: \"User should see 'Text'\" or \"'Element' is visible\"`\n      );\n    }\n    // Generic suggestion\n    else {\n      suggestions.push(\n        `\"${step.sourceText}\" - Could not determine intent. Check the patterns documentation.`\n      );\n    }\n  }\n\n  return suggestions;\n}\n","/**\n * Machine Hint Syntax Patterns - Define regex patterns for parsing hints\n * @see T071 - Define machine hint syntax regex patterns\n */\n\n/**\n * Machine hint types\n */\nexport type HintType =\n  | 'role'       // ARIA role hint: (role=button)\n  | 'testid'     // Test ID hint: (testid=submit-btn)\n  | 'label'      // Label hint: (label=\"Email Address\")\n  | 'text'       // Text hint: (text=\"Submit\")\n  | 'exact'      // Exact matching: (exact=true)\n  | 'level'      // Heading level: (level=2)\n  | 'signal'     // Signal hint: (signal=loading-done)\n  | 'module'     // Module method hint: (module=auth.login)\n  | 'wait'       // Wait strategy: (wait=networkidle)\n  | 'timeout';   // Timeout hint: (timeout=5000)\n\n/**\n * Parsed machine hint\n */\nexport interface MachineHint {\n  /** Hint type */\n  type: HintType;\n  /** Hint value */\n  value: string;\n  /** Raw hint string */\n  raw: string;\n}\n\n/**\n * Pattern for detecting hint blocks: (key=value) or (key=\"value with spaces\")\n */\nexport const HINT_BLOCK_PATTERN = /\\(([a-z]+)=(?:\"([^\"]+)\"|'([^']+)'|([^,)\\s]+))\\)/gi;\n\n/**\n * Pattern for a complete hints section: (...hints...)\n */\nexport const HINTS_SECTION_PATTERN = /\\((?:[a-z]+=(?:\"[^\"]+\"|'[^']+'|[^,)\\s]+)(?:,\\s*)?)+\\)/gi;\n\n/**\n * Individual hint patterns for validation\n */\nexport const HINT_PATTERNS: Record<HintType, RegExp> = {\n  role: /role=(?:\"([^\"]+)\"|'([^']+)'|([a-z]+))/i,\n  testid: /testid=(?:\"([^\"]+)\"|'([^']+)'|([a-z0-9_-]+))/i,\n  label: /label=(?:\"([^\"]+)\"|'([^']+)')/i,\n  text: /text=(?:\"([^\"]+)\"|'([^']+)')/i,\n  exact: /exact=(true|false)/i,\n  level: /level=([1-6])/i,\n  signal: /signal=(?:\"([^\"]+)\"|'([^']+)'|([a-z0-9_-]+))/i,\n  module: /module=(?:\"([^\"]+)\"|'([^']+)'|([a-z0-9_.]+))/i,\n  wait: /wait=(networkidle|domcontentloaded|load|commit)/i,\n  timeout: /timeout=(\\d+)/i,\n};\n\n/**\n * Valid ARIA roles for validation\n */\nexport const VALID_ROLES = [\n  'alert',\n  'alertdialog',\n  'application',\n  'article',\n  'banner',\n  'button',\n  'cell',\n  'checkbox',\n  'columnheader',\n  'combobox',\n  'complementary',\n  'contentinfo',\n  'definition',\n  'dialog',\n  'directory',\n  'document',\n  'feed',\n  'figure',\n  'form',\n  'grid',\n  'gridcell',\n  'group',\n  'heading',\n  'img',\n  'link',\n  'list',\n  'listbox',\n  'listitem',\n  'log',\n  'main',\n  'marquee',\n  'math',\n  'menu',\n  'menubar',\n  'menuitem',\n  'menuitemcheckbox',\n  'menuitemradio',\n  'navigation',\n  'none',\n  'note',\n  'option',\n  'presentation',\n  'progressbar',\n  'radio',\n  'radiogroup',\n  'region',\n  'row',\n  'rowgroup',\n  'rowheader',\n  'scrollbar',\n  'search',\n  'searchbox',\n  'separator',\n  'slider',\n  'spinbutton',\n  'status',\n  'switch',\n  'tab',\n  'table',\n  'tablist',\n  'tabpanel',\n  'term',\n  'textbox',\n  'timer',\n  'toolbar',\n  'tooltip',\n  'tree',\n  'treegrid',\n  'treeitem',\n];\n\n/**\n * Check if a role is valid\n */\nexport function isValidRole(role: string): boolean {\n  return VALID_ROLES.includes(role.toLowerCase());\n}\n\n/**\n * Extract hint value from a match (handles quoted and unquoted values)\n */\nexport function extractHintValue(match: RegExpMatchArray): string | null {\n  // Try quoted values first, then unquoted\n  for (let i = 1; i < match.length; i++) {\n    if (match[i] !== undefined) {\n      return match[i] ?? null;\n    }\n  }\n  return null;\n}\n\n/**\n * Check if text contains machine hints\n */\nexport function containsHints(text: string): boolean {\n  // Reset lastIndex for global regex\n  HINTS_SECTION_PATTERN.lastIndex = 0;\n  return HINTS_SECTION_PATTERN.test(text);\n}\n\n/**\n * Remove hints section from step text\n */\nexport function removeHints(text: string): string {\n  return text.replace(HINTS_SECTION_PATTERN, '').trim();\n}\n","/**\n * Machine Hint Parser - Extract hints from Journey step text\n * @see T072 - Implement machine hint parser\n */\nimport {\n  type HintType,\n  type MachineHint,\n  HINT_BLOCK_PATTERN,\n  HINT_PATTERNS,\n  isValidRole,\n  containsHints,\n  removeHints,\n} from './hintPatterns.js';\n\n/**\n * Parsed hints result\n */\nexport interface ParsedHints {\n  /** All parsed hints */\n  hints: MachineHint[];\n  /** Step text with hints removed */\n  cleanText: string;\n  /** Original text */\n  originalText: string;\n  /** Validation warnings */\n  warnings: string[];\n}\n\n/**\n * Locator hints extracted for code generation\n */\nexport interface LocatorHints {\n  /** ARIA role */\n  role?: string;\n  /** Test ID */\n  testid?: string;\n  /** Label text */\n  label?: string;\n  /** Text content */\n  text?: string;\n  /** Exact matching */\n  exact?: boolean;\n  /** Heading level (for role=heading) */\n  level?: number;\n}\n\n/**\n * Behavioral hints extracted for code generation\n */\nexport interface BehaviorHints {\n  /** Signal to wait for */\n  signal?: string;\n  /** Module method to call */\n  module?: string;\n  /** Wait strategy */\n  wait?: 'networkidle' | 'domcontentloaded' | 'load' | 'commit';\n  /** Timeout in ms */\n  timeout?: number;\n}\n\n/**\n * Complete hint extraction result\n */\nexport interface ExtractedHints {\n  /** Locator-related hints */\n  locator: LocatorHints;\n  /** Behavior-related hints */\n  behavior: BehaviorHints;\n  /** Whether any hints were found */\n  hasHints: boolean;\n  /** Clean step text */\n  cleanText: string;\n  /** Warnings */\n  warnings: string[];\n}\n\n/**\n * Parse machine hints from step text\n */\nexport function parseHints(text: string): ParsedHints {\n  const hints: MachineHint[] = [];\n  const warnings: string[] = [];\n\n  if (!containsHints(text)) {\n    return {\n      hints: [],\n      cleanText: text,\n      originalText: text,\n      warnings: [],\n    };\n  }\n\n  // Extract all hint blocks\n  HINT_BLOCK_PATTERN.lastIndex = 0;\n  let match;\n\n  while ((match = HINT_BLOCK_PATTERN.exec(text)) !== null) {\n    const key = match[1]!.toLowerCase() as HintType;\n    const value = match[2] || match[3] || match[4];\n\n    if (!value) {\n      warnings.push(`Empty value for hint: ${key}`);\n      continue;\n    }\n\n    // Validate the hint type\n    if (!(key in HINT_PATTERNS)) {\n      warnings.push(`Unknown hint type: ${key}`);\n      continue;\n    }\n\n    // Validate role values\n    if (key === 'role' && !isValidRole(value)) {\n      warnings.push(`Invalid ARIA role: ${value}`);\n    }\n\n    hints.push({\n      type: key,\n      value,\n      raw: match[0],\n    });\n  }\n\n  return {\n    hints,\n    cleanText: removeHints(text),\n    originalText: text,\n    warnings,\n  };\n}\n\n/**\n * Extract structured hints for code generation\n */\nexport function extractHints(text: string): ExtractedHints {\n  const parsed = parseHints(text);\n\n  const locator: LocatorHints = {};\n  const behavior: BehaviorHints = {};\n\n  for (const hint of parsed.hints) {\n    switch (hint.type) {\n      case 'role':\n        locator.role = hint.value;\n        break;\n      case 'testid':\n        locator.testid = hint.value;\n        break;\n      case 'label':\n        locator.label = hint.value;\n        break;\n      case 'text':\n        locator.text = hint.value;\n        break;\n      case 'exact':\n        locator.exact = hint.value.toLowerCase() === 'true';\n        break;\n      case 'level':\n        locator.level = parseInt(hint.value, 10);\n        break;\n      case 'signal':\n        behavior.signal = hint.value;\n        break;\n      case 'module':\n        behavior.module = hint.value;\n        break;\n      case 'wait':\n        behavior.wait = hint.value as BehaviorHints['wait'];\n        break;\n      case 'timeout':\n        behavior.timeout = parseInt(hint.value, 10);\n        break;\n    }\n  }\n\n  return {\n    locator,\n    behavior,\n    hasHints: parsed.hints.length > 0,\n    cleanText: parsed.cleanText,\n    warnings: parsed.warnings,\n  };\n}\n\n/**\n * Check if hints specify a locator strategy\n */\nexport function hasLocatorHints(hints: ExtractedHints): boolean {\n  const { locator } = hints;\n  return !!(locator.role || locator.testid || locator.label || locator.text);\n}\n\n/**\n * Check if hints specify behavioral modifications\n */\nexport function hasBehaviorHints(hints: ExtractedHints): boolean {\n  const { behavior } = hints;\n  return !!(behavior.signal || behavior.module || behavior.wait || behavior.timeout);\n}\n\n/**\n * Generate locator code from hints\n */\nexport function generateLocatorFromHints(hints: LocatorHints): string | null {\n  // Priority: testid > role > label > text\n  if (hints.testid) {\n    return `page.getByTestId('${hints.testid}')`;\n  }\n\n  if (hints.role) {\n    const options: string[] = [];\n    if (hints.label) {\n      options.push(`name: '${hints.label}'`);\n    }\n    if (hints.exact) {\n      options.push('exact: true');\n    }\n    if (hints.level && hints.role === 'heading') {\n      options.push(`level: ${hints.level}`);\n    }\n\n    if (options.length > 0) {\n      return `page.getByRole('${hints.role}', { ${options.join(', ')} })`;\n    }\n    return `page.getByRole('${hints.role}')`;\n  }\n\n  if (hints.label) {\n    if (hints.exact) {\n      return `page.getByLabel('${hints.label}', { exact: true })`;\n    }\n    return `page.getByLabel('${hints.label}')`;\n  }\n\n  if (hints.text) {\n    if (hints.exact) {\n      return `page.getByText('${hints.text}', { exact: true })`;\n    }\n    return `page.getByText('${hints.text}')`;\n  }\n\n  return null;\n}\n\n/**\n * Parse module hint into module name and method\n */\nexport function parseModuleHint(moduleHint: string): { module: string; method: string } | null {\n  const parts = moduleHint.split('.');\n  if (parts.length !== 2) {\n    return null;\n  }\n  return {\n    module: parts[0]!,\n    method: parts[1]!,\n  };\n}\n\n/**\n * Validate hints for consistency\n */\nexport function validateHints(hints: ExtractedHints): string[] {\n  const errors: string[] = [];\n\n  // Check for conflicting locator hints\n  const locatorCount = [\n    hints.locator.testid,\n    hints.locator.role,\n    hints.locator.label && !hints.locator.role, // label with role is fine\n    hints.locator.text,\n  ].filter(Boolean).length;\n\n  if (locatorCount > 1) {\n    errors.push('Multiple conflicting locator hints specified');\n  }\n\n  // Check for level without heading role\n  if (hints.locator.level && hints.locator.role !== 'heading') {\n    errors.push('level hint only applies to role=heading');\n  }\n\n  // Check for module hint format\n  if (hints.behavior.module) {\n    const parsed = parseModuleHint(hints.behavior.module);\n    if (!parsed) {\n      errors.push('module hint must be in format: moduleName.methodName');\n    }\n  }\n\n  return errors;\n}\n\n/**\n * Merge hints with inferred locator (hints take priority)\n */\nexport function mergeWithInferred(\n  hints: LocatorHints,\n  inferred: { strategy: string; value: string }\n): { strategy: string; value: string; options?: Record<string, unknown> } {\n  // If hints specify a locator, use it\n  if (hints.testid) {\n    return { strategy: 'testid', value: hints.testid };\n  }\n\n  if (hints.role) {\n    const options: Record<string, unknown> = {};\n    if (hints.label) {\n      options.name = hints.label;\n    }\n    if (hints.exact) {\n      options.exact = true;\n    }\n    if (hints.level) {\n      options.level = hints.level;\n    }\n    return { strategy: 'role', value: hints.role, options };\n  }\n\n  if (hints.label) {\n    const options: Record<string, unknown> = {};\n    if (hints.exact) {\n      options.exact = true;\n    }\n    return { strategy: 'label', value: hints.label, options };\n  }\n\n  if (hints.text) {\n    const options: Record<string, unknown> = {};\n    if (hints.exact) {\n      options.exact = true;\n    }\n    return { strategy: 'text', value: hints.text, options };\n  }\n\n  // Add exact option to inferred if specified\n  if (hints.exact) {\n    return { ...inferred, options: { exact: true } };\n  }\n\n  // Fall back to inferred\n  return inferred;\n}\n","/**\n * Shared escaping utilities for code generation.\n * Consolidates escapeRegex and escapeString from multiple locations.\n */\n\n/**\n * Escape special regex characters in a string.\n * Includes forward slash for URL patterns.\n */\nexport function escapeRegex(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\\\/]/g, '\\\\$&');\n}\n\n/**\n * Escape a string for use in generated JavaScript/TypeScript code.\n * Handles quotes, backslashes, newlines, and carriage returns.\n */\nexport function escapeString(str: string): string {\n  return str\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/'/g, \"\\\\'\")\n    .replace(/\"/g, '\\\\\"')\n    .replace(/\\n/g, '\\\\n')\n    .replace(/\\r/g, '\\\\r');\n}\n\n/**\n * Escape a selector string for use in Playwright locators.\n * Handles quotes that would break the selector syntax.\n */\nexport function escapeSelector(str: string): string {\n  return str.replace(/'/g, \"\\\\'\");\n}\n","/**\n * Journey Normalizer - Convert parsed Journey to IR\n * @see research/2026-01-02_autogen-refined-plan.md Section 9\n */\nimport type { ParsedJourney, AcceptanceCriterion, ProceduralStep } from './parseJourney.js';\nimport type {\n  IRJourney,\n  IRStep,\n  IRPrimitive,\n  IRMappingResult,\n  ModuleDependencies,\n  CompletionSignal,\n  JourneyDataConfig,\n  LocatorSpec,\n} from '../ir/types.js';\nimport { mapStepText } from '../mapping/stepMapper.js';\nimport { escapeRegex } from '../utils/escaping.js';\n\n/**\n * Options for normalizing a Journey\n */\nexport interface NormalizeOptions {\n  /** Include blocked steps in output */\n  includeBlocked?: boolean;\n  /** Strict mode - fail on any blocked step */\n  strict?: boolean;\n  /** Default timeout for assertions (ms) */\n  defaultTimeout?: number;\n}\n\n/**\n * Normalize a parsed Journey into IR format\n */\nexport function normalizeJourney(\n  parsed: ParsedJourney,\n  options: NormalizeOptions = {}\n): IRMappingResult {\n  const { includeBlocked = true, strict = false } = options;\n\n  const blockedSteps: IRMappingResult['blockedSteps'] = [];\n  const warnings: string[] = [];\n\n  // Map acceptance criteria to IR steps\n  const steps: IRStep[] = [];\n\n  for (const ac of parsed.acceptanceCriteria) {\n    const step = mapAcceptanceCriterionToStep(ac, parsed.proceduralSteps, warnings);\n\n    // Check for blocked primitives\n    const blockedPrimitives = [\n      ...step.actions.filter((a) => a.type === 'blocked'),\n      ...step.assertions.filter((a) => a.type === 'blocked'),\n    ] as Array<{ type: 'blocked'; reason: string; sourceText: string }>;\n\n    if (blockedPrimitives.length > 0) {\n      for (const blocked of blockedPrimitives) {\n        blockedSteps.push({\n          stepId: step.id,\n          sourceText: blocked.sourceText,\n          reason: blocked.reason,\n        });\n      }\n\n      if (strict) {\n        continue; // Skip blocked steps in strict mode\n      }\n    }\n\n    if (includeBlocked || blockedPrimitives.length === 0) {\n      steps.push(step);\n    }\n  }\n\n  // If no AC-based steps, create steps from procedural steps\n  if (steps.length === 0 && parsed.proceduralSteps.length > 0) {\n    for (const ps of parsed.proceduralSteps) {\n      const step = mapProceduralStepToIRStep(ps, warnings);\n      steps.push(step);\n    }\n  }\n\n  // Build module dependencies\n  const moduleDependencies: ModuleDependencies = {\n    foundation: parsed.frontmatter.modules?.foundation ?? [],\n    feature: parsed.frontmatter.modules?.features ?? [],\n  };\n\n  // Map completion signals\n  const completion: CompletionSignal[] | undefined = parsed.frontmatter.completion?.map((c) => ({\n    type: c.type,\n    value: c.value,\n    options: c.options,\n  }));\n\n  // Map data config\n  const data: JourneyDataConfig | undefined = parsed.frontmatter.data\n    ? {\n        strategy: parsed.frontmatter.data.strategy,\n        cleanup: parsed.frontmatter.data.cleanup,\n      }\n    : undefined;\n\n  // Build the IR Journey\n  const journey: IRJourney = {\n    id: parsed.frontmatter.id,\n    title: parsed.frontmatter.title,\n    tier: parsed.frontmatter.tier,\n    scope: parsed.frontmatter.scope,\n    actor: parsed.frontmatter.actor,\n    tags: buildTags(parsed),\n    moduleDependencies,\n    data,\n    completion,\n    steps,\n    revision: parsed.frontmatter.revision,\n    prerequisites: parsed.frontmatter.prerequisites,\n    negativePaths: parsed.frontmatter.negativePaths,\n    sourcePath: parsed.sourcePath,\n    // P3 Feature fields - pass through from frontmatter\n    testData: parsed.frontmatter.testData,\n    visualRegression: parsed.frontmatter.visualRegression,\n    accessibility: parsed.frontmatter.accessibility,\n    performance: parsed.frontmatter.performance,\n  };\n\n  // Calculate stats\n  const stats = {\n    totalSteps: parsed.acceptanceCriteria.length || parsed.proceduralSteps.length,\n    mappedSteps: steps.length,\n    blockedSteps: blockedSteps.length,\n    totalActions: steps.reduce((sum, s) => sum + s.actions.length, 0),\n    totalAssertions: steps.reduce((sum, s) => sum + s.assertions.length, 0),\n  };\n\n  return {\n    journey,\n    blockedSteps,\n    warnings,\n    stats,\n  };\n}\n\n/**\n * Map an acceptance criterion to an IR step\n */\nfunction mapAcceptanceCriterionToStep(\n  ac: AcceptanceCriterion,\n  proceduralSteps: ProceduralStep[],\n  warnings: string[]\n): IRStep {\n  const actions: IRPrimitive[] = [];\n  const assertions: IRPrimitive[] = [];\n  const notes: string[] = [];\n\n  // Find related procedural steps\n  const relatedProcedural = proceduralSteps.filter((ps) => ps.linkedAC === ac.id);\n\n  // Process bullet points as potential actions/assertions\n  for (const stepText of ac.steps) {\n    const result = mapStepText(stepText, { normalizeText: false });\n\n    if (result.primitive) {\n      if (isAssertion(result.primitive)) {\n        assertions.push(result.primitive);\n      } else {\n        actions.push(result.primitive);\n      }\n    } else {\n      // Cannot parse - add as blocked\n      actions.push({\n        type: 'blocked',\n        reason: result.message || 'Could not parse step into primitive',\n        sourceText: stepText,\n      });\n      if (result.message) {\n        warnings.push(result.message);\n      }\n    }\n  }\n\n  // Add related procedural steps as actions\n  for (const ps of relatedProcedural) {\n    const result = mapStepText(ps.text, { normalizeText: false });\n    if (result.primitive) {\n      if (isAssertion(result.primitive)) {\n        assertions.push(result.primitive);\n      } else {\n        actions.push(result.primitive);\n      }\n    } else if (result.message) {\n      warnings.push(result.message);\n    }\n  }\n\n  // If no assertions from steps, add a visibility check for the AC title\n  if (assertions.length === 0 && ac.title) {\n    notes.push(`TODO: Add assertion for: ${ac.title}`);\n  }\n\n  return {\n    id: ac.id,\n    description: ac.title || `Step ${ac.id}`,\n    actions,\n    assertions,\n    sourceText: ac.rawContent,\n    notes: notes.length > 0 ? notes : undefined,\n  };\n}\n\n/**\n * Map a procedural step to an IR step\n */\nfunction mapProceduralStepToIRStep(ps: ProceduralStep, warnings: string[]): IRStep {\n  const actions: IRPrimitive[] = [];\n  const assertions: IRPrimitive[] = [];\n\n  const result = mapStepText(ps.text, { normalizeText: false });\n  if (result.primitive) {\n    if (isAssertion(result.primitive)) {\n      assertions.push(result.primitive);\n    } else {\n      actions.push(result.primitive);\n    }\n  } else {\n    actions.push({\n      type: 'blocked',\n      reason: result.message || 'Could not parse procedural step',\n      sourceText: ps.text,\n    });\n    if (result.message) {\n      warnings.push(result.message);\n    }\n  }\n\n  return {\n    id: `PS-${ps.number}`,\n    description: ps.text,\n    actions,\n    assertions,\n  };\n}\n\n/**\n * Check if a primitive is an assertion\n */\nfunction isAssertion(primitive: IRPrimitive): boolean {\n  return primitive.type.startsWith('expect');\n}\n\n/**\n * Build tags for the journey\n */\nfunction buildTags(parsed: ParsedJourney): string[] {\n  const tags = new Set<string>();\n\n  // Standard tags\n  tags.add('@artk');\n  tags.add('@journey');\n  tags.add(`@${parsed.frontmatter.id}`);\n  tags.add(`@tier-${parsed.frontmatter.tier}`);\n  tags.add(`@scope-${parsed.frontmatter.scope}`);\n  tags.add(`@actor-${parsed.frontmatter.actor}`);\n\n  // User-defined tags\n  if (parsed.frontmatter.tags) {\n    for (const tag of parsed.frontmatter.tags) {\n      tags.add(tag.startsWith('@') ? tag : `@${tag}`);\n    }\n  }\n\n  return Array.from(tags);\n}\n\n/**\n * Convert completion signals to IR primitives (final assertions)\n */\nexport function completionSignalsToAssertions(\n  signals: CompletionSignal[]\n): IRPrimitive[] {\n  return signals.map(signal => {\n    switch (signal.type) {\n      case 'url':\n        return {\n          type: 'expectURL',\n          pattern: signal.options?.exact\n            ? signal.value\n            : new RegExp(escapeRegex(signal.value)),\n        } as IRPrimitive;\n\n      case 'toast': {\n        // Parse toast type from value if it contains \"success\", \"error\", \"info\", or \"warning\"\n        const lowerValue = signal.value.toLowerCase();\n        let toastType: 'success' | 'error' | 'info' | 'warning' = 'success';\n        if (lowerValue.includes('error')) {\n          toastType = 'error';\n        } else if (lowerValue.includes('warning')) {\n          toastType = 'warning';\n        } else if (lowerValue.includes('info')) {\n          toastType = 'info';\n        }\n\n        return {\n          type: 'expectToast',\n          toastType,\n          message: signal.value,\n        } as IRPrimitive;\n      }\n\n      case 'element': {\n        const state = signal.options?.state || 'visible';\n        return {\n          type: state === 'hidden' || state === 'detached'\n            ? 'expectNotVisible'\n            : 'expectVisible',\n          locator: parseLocatorFromSelector(signal.value),\n          timeout: signal.options?.timeout,\n        } as IRPrimitive;\n      }\n\n      case 'text':\n        return {\n          type: 'expectVisible',\n          locator: { strategy: 'text', value: signal.value },\n          timeout: signal.options?.timeout,\n        } as IRPrimitive;\n\n      case 'title':\n        return {\n          type: 'expectTitle',\n          title: signal.options?.exact\n            ? signal.value\n            : new RegExp(escapeRegex(signal.value)),\n        } as IRPrimitive;\n\n      case 'api':\n        return {\n          type: 'waitForResponse',\n          urlPattern: signal.value,\n        } as IRPrimitive;\n\n      default:\n        throw new Error(`Unknown completion signal type: ${(signal as CompletionSignal).type}`);\n    }\n  });\n}\n\n/**\n * Parse a selector string to LocatorSpec\n */\nfunction parseLocatorFromSelector(selector: string): LocatorSpec {\n  // data-testid\n  if (selector.includes('data-testid')) {\n    const match = selector.match(/\\[data-testid=['\"]([^'\"]+)['\"]\\]/);\n    if (match) {\n      return { strategy: 'testid', value: match[1]! };\n    }\n  }\n\n  // Role selector\n  if (selector.startsWith('role=')) {\n    return { strategy: 'role', value: selector.slice(5) };\n  }\n\n  // Text selector\n  if (selector.startsWith('text=')) {\n    return { strategy: 'text', value: selector.slice(5) };\n  }\n\n  // Label selector\n  if (selector.startsWith('label=')) {\n    return { strategy: 'label', value: selector.slice(6) };\n  }\n\n  // Placeholder selector\n  if (selector.startsWith('placeholder=')) {\n    return { strategy: 'placeholder', value: selector.slice(12) };\n  }\n\n  // Default to CSS\n  return { strategy: 'css', value: selector };\n}\n\n/**\n * Validate that a Journey is ready for code generation\n */\nexport function validateJourneyForCodeGen(result: IRMappingResult): {\n  valid: boolean;\n  errors: string[];\n} {\n  const errors: string[] = [];\n\n  // Must have at least one step\n  if (result.journey.steps.length === 0) {\n    errors.push('Journey has no steps');\n  }\n\n  // Must have completion signals\n  if (!result.journey.completion || result.journey.completion.length === 0) {\n    errors.push('Journey has no completion signals');\n  }\n\n  // Should not have too many blocked steps\n  if (result.stats.blockedSteps > result.stats.mappedSteps) {\n    errors.push(`Too many blocked steps: ${result.stats.blockedSteps} blocked vs ${result.stats.mappedSteps} mapped`);\n  }\n\n  // Must have at least one assertion\n  if (result.stats.totalAssertions === 0) {\n    errors.push('Journey has no assertions');\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n","/**\n * Journey Frontmatter Updater - Enable bi-directional traceability\n * @see research/2026-01-03_autogen-remaining-features-plan.md Section 1\n */\nimport { readFileSync, writeFileSync } from 'node:fs';\nimport { parse as parseYaml, stringify as stringifyYaml } from 'yaml';\nimport { createHash } from 'node:crypto';\n\n/**\n * Journey test entry with generation metadata\n */\nexport interface JourneyTestEntry {\n  /** Path to generated test file (relative to project root) */\n  path: string;\n  /** Timestamp when test was generated */\n  generated: string;\n  /** Content hash for change detection (first 8 chars of SHA-256) */\n  hash: string;\n}\n\n/**\n * Options for updating journey frontmatter\n */\nexport interface JourneyUpdateOptions {\n  /** Path to the journey markdown file */\n  journeyPath: string;\n  /** Path to the generated test file */\n  testPath: string;\n  /** Content of the generated test (for hash calculation) */\n  testContent: string;\n  /** Module dependencies to add (foundation or feature module names) */\n  modules?: {\n    foundation?: string[];\n    features?: string[];\n  };\n}\n\n/**\n * Result of journey frontmatter update\n */\nexport interface JourneyUpdateResult {\n  /** Whether update succeeded */\n  success: boolean;\n  /** Previous tests array before update */\n  previousTests: JourneyTestEntry[];\n  /** Updated tests array after update */\n  updatedTests: JourneyTestEntry[];\n  /** Modules added (not previously in the list) */\n  modulesAdded: {\n    foundation: string[];\n    features: string[];\n  };\n}\n\n/**\n * Split journey content into frontmatter and body\n */\nfunction splitJourneyContent(content: string): {\n  frontmatter: string;\n  body: string;\n} {\n  const match = content.match(/^---\\r?\\n([\\s\\S]*?)\\r?\\n---\\r?\\n([\\s\\S]*)$/);\n\n  if (!match) {\n    throw new Error(\n      'Invalid Journey format: missing frontmatter delimiters (content should be wrapped in --- ... ---)'\n    );\n  }\n\n  return {\n    frontmatter: match[1]!,\n    body: match[2]!,\n  };\n}\n\n/**\n * Calculate SHA-256 hash of content (first 8 characters)\n */\nfunction calculateContentHash(content: string): string {\n  return createHash('sha256').update(content).digest('hex').substring(0, 8);\n}\n\n/**\n * Update Journey frontmatter with generated test info\n *\n * This enables bi-directional traceability by:\n * 1. Recording which tests were generated from this Journey\n * 2. Tracking when tests were generated\n * 3. Detecting test changes via content hash\n * 4. Linking module dependencies\n *\n * @param options - Update options\n * @returns Update result with previous and new state\n * @throws Error if journey file is invalid or cannot be written\n */\nexport function updateJourneyFrontmatter(\n  options: JourneyUpdateOptions\n): JourneyUpdateResult {\n  const {\n    journeyPath,\n    testPath,\n    testContent,\n    modules = { foundation: [], features: [] },\n  } = options;\n\n  // Read journey file\n  const content = readFileSync(journeyPath, 'utf-8');\n\n  // Split frontmatter and body\n  const { frontmatter, body } = splitJourneyContent(content);\n\n  // Parse YAML frontmatter\n  const parsed = parseYaml(frontmatter) as Record<string, unknown>;\n\n  // Store previous state (deep copy to avoid mutation)\n  const previousTests = Array.isArray(parsed.tests)\n    ? (parsed.tests as JourneyTestEntry[]).map((t) =>\n        typeof t === 'string' ? { path: t, generated: '', hash: '' } : { ...t }\n      )\n    : [];\n\n  // Calculate content hash\n  const hash = calculateContentHash(testContent);\n\n  // Create/update test entry\n  const testEntry: JourneyTestEntry = {\n    path: testPath,\n    generated: new Date().toISOString(),\n    hash,\n  };\n\n  // Ensure tests array exists\n  if (!Array.isArray(parsed.tests)) {\n    parsed.tests = [];\n  }\n\n  // Find existing test entry by path\n  const existingIndex = (parsed.tests as JourneyTestEntry[]).findIndex(\n    (t) =>\n      typeof t === 'string'\n        ? t === testPath\n        : (t as JourneyTestEntry).path === testPath\n  );\n\n  // Update or add test entry\n  if (existingIndex >= 0) {\n    (parsed.tests as JourneyTestEntry[])[existingIndex]! = testEntry;\n  } else {\n    (parsed.tests as JourneyTestEntry[]).push(testEntry);\n  }\n\n  // Update modules\n  const modulesAdded = {\n    foundation: [] as string[],\n    features: [] as string[],\n  };\n\n  // Ensure modules structure exists\n  if (!parsed.modules || typeof parsed.modules !== 'object') {\n    parsed.modules = { foundation: [], features: [] };\n  }\n\n  const parsedModules = parsed.modules as {\n    foundation?: string[];\n    features?: string[];\n  };\n\n  // Ensure foundation and features arrays exist\n  if (!Array.isArray(parsedModules.foundation)) {\n    parsedModules.foundation = [];\n  }\n  if (!Array.isArray(parsedModules.features)) {\n    parsedModules.features = [];\n  }\n\n  // Add foundation modules (deduplicate)\n  if (modules.foundation) {\n    const existingFoundation = new Set(parsedModules.foundation!);\n    for (const mod of modules.foundation) {\n      if (!existingFoundation.has(mod)) {\n        modulesAdded.foundation.push(mod);\n        parsedModules.foundation!.push(mod);\n      }\n    }\n    // Sort for consistency\n    parsedModules.foundation!.sort();\n  }\n\n  // Add feature modules (deduplicate)\n  if (modules.features) {\n    const existingFeatures = new Set(parsedModules.features);\n    for (const mod of modules.features) {\n      if (!existingFeatures.has(mod)) {\n        modulesAdded.features.push(mod);\n        parsedModules.features.push(mod);\n      }\n    }\n    // Sort for consistency\n    parsedModules.features.sort();\n  }\n\n  // Reconstruct file with updated frontmatter\n  const newFrontmatter = stringifyYaml(parsed, {\n    lineWidth: 0, // Prevent line wrapping\n    defaultKeyType: 'PLAIN',\n    defaultStringType: 'QUOTE_DOUBLE',\n  });\n\n  const newContent = `---\\n${newFrontmatter}---\\n${body}`;\n\n  // Write back to file\n  writeFileSync(journeyPath, newContent, 'utf-8');\n\n  return {\n    success: true,\n    previousTests,\n    updatedTests: parsed.tests as JourneyTestEntry[],\n    modulesAdded,\n  };\n}\n\n/**\n * Check if a Journey's test is up-to-date based on content hash\n *\n * @param journeyPath - Path to the journey file\n * @param testPath - Path to the test file to check\n * @param testContent - Current content of the test file\n * @returns True if the test hash matches the recorded hash\n */\nexport function isJourneyTestCurrent(\n  journeyPath: string,\n  testPath: string,\n  testContent: string\n): boolean {\n  const content = readFileSync(journeyPath, 'utf-8');\n  const { frontmatter } = splitJourneyContent(content);\n  const parsed = parseYaml(frontmatter) as Record<string, unknown>;\n\n  if (!Array.isArray(parsed.tests)) {\n    return false;\n  }\n\n  // Find test entry\n  const testEntry = (parsed.tests as JourneyTestEntry[]).find((t) =>\n    typeof t === 'string' ? t === testPath : t.path === testPath\n  );\n\n  if (!testEntry || typeof testEntry === 'string') {\n    return false;\n  }\n\n  // Calculate current hash\n  const currentHash = calculateContentHash(testContent);\n\n  return testEntry.hash === currentHash;\n}\n"]}
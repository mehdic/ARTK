"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPackageVersion = getPackageVersion;
exports.getGeneratedTimestamp = getGeneratedTimestamp;
exports.generateFileHeader = generateFileHeader;
exports.getBrandingComment = getBrandingComment;
/**
 * Version utilities for generated code branding
 *
 * Supports build-time version injection via:
 * - Environment variable: ARTK_VERSION
 * - Build tool define: __ARTK_VERSION__ (e.g., via esbuild/rollup define)
 *
 * Falls back to runtime package.json reading if not injected.
 */
const node_fs_1 = require("node:fs");
const node_path_1 = require("node:path");
const paths_js_1 = require("./paths.js");
/** Cached version to avoid repeated lookups */
let cachedVersion;
/**
 * Get the package version
 *
 * Priority:
 * 1. Build-time define (__ARTK_VERSION__)
 * 2. Environment variable (ARTK_VERSION)
 * 3. Runtime package.json reading (fallback)
 */
function getPackageVersion() {
    // Return cached version if available
    if (cachedVersion) {
        return cachedVersion;
    }
    // 1. Check build-time define (set by bundlers)
    try {
        if (typeof __ARTK_VERSION__ !== 'undefined' && __ARTK_VERSION__) {
            cachedVersion = __ARTK_VERSION__;
            return cachedVersion;
        }
    }
    catch {
        // __ARTK_VERSION__ not defined, continue to fallbacks
    }
    // 2. Check environment variable (useful for CI/CD)
    const envVersion = process.env['ARTK_VERSION'];
    if (envVersion) {
        cachedVersion = envVersion;
        return cachedVersion;
    }
    // 3. Fall back to runtime package.json reading
    try {
        const packageRoot = (0, paths_js_1.getPackageRoot)();
        const pkgPath = (0, node_path_1.join)(packageRoot, 'package.json');
        if ((0, node_fs_1.existsSync)(pkgPath)) {
            const pkg = JSON.parse((0, node_fs_1.readFileSync)(pkgPath, 'utf-8'));
            if (pkg.version) {
                cachedVersion = pkg.version;
                return cachedVersion;
            }
        }
    }
    catch {
        // Package.json lookup failed
    }
    cachedVersion = 'unknown';
    return cachedVersion;
}
/**
 * Get ISO timestamp for generated file headers
 */
function getGeneratedTimestamp() {
    return new Date().toISOString();
}
function generateFileHeader(options = {}) {
    const version = getPackageVersion();
    const timestamp = getGeneratedTimestamp();
    const lines = [
        '/**',
        options.title ? ` * ${options.title}` : ' * Generated file',
        options.journeyId ? ` * Journey: ${options.journeyId}` : null,
        ` *`,
        ` * @generated by @artk/core-autogen v${version}`,
        ` * @timestamp ${timestamp}`,
        ` * @warning Generated regions (ARTK:BEGIN/END GENERATED) will be overwritten.`,
        ` *          Code outside these blocks is preserved on regeneration.`,
    ];
    if (options.tags && options.tags.length > 0) {
        lines.push(` * @tags ${options.tags.join(', ')}`);
    }
    if (options.tier) {
        lines.push(` * @tier ${options.tier}`);
    }
    if (options.scope) {
        lines.push(` * @scope ${options.scope}`);
    }
    if (options.actor) {
        lines.push(` * @actor ${options.actor}`);
    }
    lines.push(' */');
    return lines.filter(l => l !== null).join('\n');
}
/**
 * Branding string for inline comments
 */
function getBrandingComment() {
    const version = getPackageVersion();
    return `@artk/core-autogen v${version}`;
}
//# sourceMappingURL=version.js.map
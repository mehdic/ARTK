"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadRegistry = loadRegistry;
exports.parseIndexFile = parseIndexFile;
exports.generateIndexContent = generateIndexContent;
exports.addToRegistry = addToRegistry;
exports.removeFromRegistry = removeFromRegistry;
exports.updateIndexFile = updateIndexFile;
exports.scanModulesDirectory = scanModulesDirectory;
exports.createRegistry = createRegistry;
exports.saveRegistry = saveRegistry;
exports.findEntry = findEntry;
exports.findEntriesByScope = findEntriesByScope;
exports.hasModule = hasModule;
exports.getModuleNames = getModuleNames;
exports.getRegistryStats = getRegistryStats;
/**
 * Module Registry - Track and update module index files
 * @see research/2026-01-02_autogen-refined-plan.md Section 12
 */
const node_fs_1 = require("node:fs");
const node_path_1 = require("node:path");
const ts_morph_1 = require("ts-morph");
/**
 * Load module registry from an index file
 */
function loadRegistry(indexPath) {
    if (!(0, node_fs_1.existsSync)(indexPath)) {
        return null;
    }
    const content = (0, node_fs_1.readFileSync)(indexPath, 'utf-8');
    const entries = parseIndexFile(content, indexPath);
    return {
        registryPath: indexPath,
        entries,
        lastUpdated: new Date(),
    };
}
/**
 * Parse an index.ts file to extract module entries
 */
function parseIndexFile(content, _indexPath) {
    const entries = [];
    const project = new ts_morph_1.Project({ useInMemoryFileSystem: true });
    const sourceFile = project.createSourceFile('index.ts', content);
    // Parse export declarations
    const exportDeclarations = sourceFile.getExportDeclarations();
    for (const exportDecl of exportDeclarations) {
        const moduleSpecifier = exportDecl.getModuleSpecifierValue();
        if (!moduleSpecifier)
            continue;
        const namedExports = exportDecl.getNamedExports();
        for (const namedExport of namedExports) {
            const exportName = namedExport.getName();
            const aliasNode = namedExport.getAliasNode();
            const alias = aliasNode ? aliasNode.getText() : exportName;
            // Determine export type from name convention
            let exportType = 'class';
            if (exportName.startsWith('create') || exportName.endsWith('Factory')) {
                exportType = 'function';
            }
            else if (exportName === exportName.toUpperCase()) {
                exportType = 'const';
            }
            entries.push({
                moduleName: alias,
                className: exportName,
                filePath: moduleSpecifier,
                scope: extractScope(moduleSpecifier),
                exportType,
            });
        }
    }
    // Parse re-exports (export * from './module')
    const starExports = content.match(/export\s+\*\s+from\s+['"]([^'"]+)['"]/g);
    if (starExports) {
        for (const match of starExports) {
            const pathMatch = match.match(/['"]([^'"]+)['"]/);
            if (pathMatch) {
                const modulePath = pathMatch[1];
                entries.push({
                    moduleName: extractModuleName(modulePath),
                    className: '*',
                    filePath: modulePath,
                    scope: extractScope(modulePath),
                    exportType: 'class',
                });
            }
        }
    }
    return entries;
}
/**
 * Extract module name from file path
 */
function extractModuleName(filePath) {
    const base = (0, node_path_1.basename)(filePath, '.js').replace('.page', '');
    return toPascalCase(base);
}
/**
 * Extract scope from file path
 */
function extractScope(filePath) {
    // e.g., './auth/login.page.js' -> 'auth'
    const dir = (0, node_path_1.dirname)(filePath);
    if (dir === '.' || dir === './') {
        return (0, node_path_1.basename)(filePath, '.js').replace('.page', '');
    }
    return (0, node_path_1.basename)(dir);
}
/**
 * Convert to PascalCase
 */
function toPascalCase(str) {
    return str
        .split(/[-_\s]+/)
        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
        .join('');
}
/**
 * Generate index file content from entries
 */
function generateIndexContent(entries, options = {}) {
    const lines = [
        '/**',
        ' * Module Registry - Auto-generated index',
        ' * @generated by @artk/core-autogen',
        ' */',
    ];
    // Group entries by file path
    const byFile = new Map();
    for (const entry of entries) {
        const existing = byFile.get(entry.filePath) || [];
        existing.push(entry);
        byFile.set(entry.filePath, existing);
    }
    // Sort if requested
    let filePaths = Array.from(byFile.keys());
    if (options.sortExports) {
        filePaths = filePaths.sort();
    }
    // Generate exports
    for (const filePath of filePaths) {
        const fileEntries = byFile.get(filePath);
        // Check if it's a star export
        if (fileEntries.length === 1 && fileEntries[0].className === '*') {
            lines.push(`export * from '${filePath}';`);
        }
        else {
            // Named exports
            const exports = fileEntries.map(e => {
                if (e.moduleName !== e.className) {
                    return `${e.className} as ${e.moduleName}`;
                }
                return e.className;
            });
            if (options.sortExports) {
                exports.sort();
            }
            lines.push(`export { ${exports.join(', ')} } from '${filePath}';`);
        }
    }
    return lines.join('\n') + '\n';
}
/**
 * Add a module to the registry
 */
function addToRegistry(registry, module, filePath) {
    const entry = {
        moduleName: module.moduleName,
        className: module.className,
        filePath,
        scope: module.scope,
        exportType: 'class',
    };
    // Check if already exists
    const existingIndex = registry.entries.findIndex(e => e.filePath === filePath || e.moduleName === module.moduleName);
    if (existingIndex >= 0) {
        registry.entries[existingIndex] = entry;
    }
    else {
        registry.entries.push(entry);
    }
    registry.lastUpdated = new Date();
    return entry;
}
/**
 * Remove a module from the registry
 */
function removeFromRegistry(registry, moduleNameOrPath) {
    const initialLength = registry.entries.length;
    registry.entries = registry.entries.filter(e => e.moduleName !== moduleNameOrPath && e.filePath !== moduleNameOrPath);
    const removed = registry.entries.length < initialLength;
    if (removed) {
        registry.lastUpdated = new Date();
    }
    return removed;
}
/**
 * Update index file with new modules
 */
function updateIndexFile(indexPath, newModules, options = {}) {
    let registry = loadRegistry(indexPath);
    const added = [];
    const removed = [];
    if (!registry) {
        if (!options.createIfMissing) {
            return {
                modified: false,
                added: [],
                removed: [],
                content: '',
            };
        }
        registry = {
            registryPath: indexPath,
            entries: [],
            lastUpdated: new Date(),
        };
    }
    // Track existing entries if preserving
    const existingNames = new Set(registry.entries.map(e => e.moduleName));
    // Add new modules
    for (const { module, filePath } of newModules) {
        const relativePath = filePath.startsWith('.')
            ? filePath
            : `./${(0, node_path_1.relative)((0, node_path_1.dirname)(indexPath), filePath).replace(/\\/g, '/')}`;
        // Remove .ts extension and add .js for ESM
        const importPath = relativePath.replace(/\.ts$/, '.js');
        addToRegistry(registry, module, importPath);
        if (!existingNames.has(module.moduleName)) {
            added.push(module.moduleName);
        }
    }
    // Generate updated content
    const content = generateIndexContent(registry.entries, options);
    return {
        modified: added.length > 0 || removed.length > 0,
        added,
        removed,
        content,
    };
}
/**
 * Scan directory for module files and build registry
 */
function scanModulesDirectory(_dirPath, _pattern = '*.page.ts') {
    // This is a simplified implementation
    // In production, would use glob to find files
    // For now, return empty array - actual scanning happens via glob in CLI
    return [];
}
/**
 * Create a new empty registry
 */
function createRegistry(indexPath) {
    return {
        registryPath: indexPath,
        entries: [],
        lastUpdated: new Date(),
    };
}
/**
 * Save registry to disk
 */
function saveRegistry(registry, options = {}) {
    const content = generateIndexContent(registry.entries, options);
    (0, node_fs_1.writeFileSync)(registry.registryPath, content, 'utf-8');
}
/**
 * Find entry by module name
 */
function findEntry(registry, moduleName) {
    return registry.entries.find(e => e.moduleName === moduleName);
}
/**
 * Find entry by scope
 */
function findEntriesByScope(registry, scope) {
    return registry.entries.filter(e => e.scope === scope);
}
/**
 * Check if module exists in registry
 */
function hasModule(registry, moduleName) {
    return registry.entries.some(e => e.moduleName === moduleName);
}
/**
 * Get all module names
 */
function getModuleNames(registry) {
    return registry.entries.map(e => e.moduleName);
}
/**
 * Get registry statistics
 */
function getRegistryStats(registry) {
    const byScope = {};
    const byType = {};
    for (const entry of registry.entries) {
        byScope[entry.scope] = (byScope[entry.scope] || 0) + 1;
        byType[entry.exportType] = (byType[entry.exportType] || 0) + 1;
    }
    return {
        totalModules: registry.entries.length,
        byScope,
        byType,
    };
}
//# sourceMappingURL=registry.js.map
/**
 * Version utilities for generated code branding
 *
 * Supports build-time version injection via:
 * - Environment variable: ARTK_VERSION
 * - Build tool define: __ARTK_VERSION__ (e.g., via esbuild/rollup define)
 *
 * Falls back to runtime package.json reading if not injected.
 */
import { readFileSync } from 'node:fs';
import { join, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

/**
 * Build-time injected version (can be replaced by bundlers like esbuild/rollup)
 * Usage: define({ '__ARTK_VERSION__': JSON.stringify('1.0.0') })
 */
declare const __ARTK_VERSION__: string | undefined;

/** Cached version to avoid repeated lookups */
let cachedVersion: string | undefined;

/**
 * Get the package version
 *
 * Priority:
 * 1. Build-time define (__ARTK_VERSION__)
 * 2. Environment variable (ARTK_VERSION)
 * 3. Runtime package.json reading (fallback)
 */
export function getPackageVersion(): string {
  // Return cached version if available
  if (cachedVersion) {
    return cachedVersion;
  }

  // 1. Check build-time define (set by bundlers)
  try {
    if (typeof __ARTK_VERSION__ !== 'undefined' && __ARTK_VERSION__) {
      cachedVersion = __ARTK_VERSION__;
      return cachedVersion;
    }
  } catch {
    // __ARTK_VERSION__ not defined, continue to fallbacks
  }

  // 2. Check environment variable (useful for CI/CD)
  const envVersion = process.env['ARTK_VERSION'];
  if (envVersion) {
    cachedVersion = envVersion;
    return cachedVersion;
  }

  // 3. Fall back to runtime package.json reading
  try {
    const paths = [
      join(__dirname, '..', '..', 'package.json'),  // from src/utils/
      join(__dirname, '..', 'package.json'),         // from dist/utils/
    ];

    for (const pkgPath of paths) {
      try {
        const pkg = JSON.parse(readFileSync(pkgPath, 'utf-8')) as { version?: string };
        if (pkg.version) {
          cachedVersion = pkg.version;
          return cachedVersion;
        }
      } catch {
        // Try next path
      }
    }
  } catch {
    // All paths failed
  }

  cachedVersion = 'unknown';
  return cachedVersion;
}

/**
 * Get ISO timestamp for generated file headers
 */
export function getGeneratedTimestamp(): string {
  return new Date().toISOString();
}

/**
 * Generate a standard header comment for generated files
 */
export interface GeneratedHeaderOptions {
  title?: string;
  journeyId?: string;
  tags?: string[];
  tier?: string;
  scope?: string;
  actor?: string;
}

export function generateFileHeader(options: GeneratedHeaderOptions = {}): string {
  const version = getPackageVersion();
  const timestamp = getGeneratedTimestamp();

  const lines = [
    '/**',
    options.title ? ` * ${options.title}` : ' * Generated file',
    options.journeyId ? ` * Journey: ${options.journeyId}` : null,
    ` *`,
    ` * @generated by @artk/core-autogen v${version}`,
    ` * @timestamp ${timestamp}`,
    ` * @warning Generated regions (ARTK:BEGIN/END GENERATED) will be overwritten.`,
    ` *          Code outside these blocks is preserved on regeneration.`,
  ];

  if (options.tags && options.tags.length > 0) {
    lines.push(` * @tags ${options.tags.join(', ')}`);
  }
  if (options.tier) {
    lines.push(` * @tier ${options.tier}`);
  }
  if (options.scope) {
    lines.push(` * @scope ${options.scope}`);
  }
  if (options.actor) {
    lines.push(` * @actor ${options.actor}`);
  }

  lines.push(' */');

  return lines.filter(l => l !== null).join('\n');
}

/**
 * Branding string for inline comments
 */
export function getBrandingComment(): string {
  const version = getPackageVersion();
  return `@artk/core-autogen v${version}`;
}

/**
 * <%= journey.title %>
 * Journey: <%= journey.id %>
 * Generated by @artk/core-autogen
 *
 * @tags <%= journey.tags.join(', ') %>
 * @tier <%= journey.tier %>
 * @scope <%= journey.scope %>
 * @actor <%= journey.actor %>
 */
import { test, expect } from '@playwright/test';
<% if (imports.length > 0) { %>
<% for (const imp of imports) { %>
import { <%= imp.members.join(', ') %> } from '<%= imp.from %>';
<% } %>
<% } %>

test.describe('<%- journey.title %>', {
  tag: [<%- journey.tags.map(t => `'${t}'`).join(', ') %>],
}, () => {
<% if (journey.setup && journey.setup.length > 0) { %>
  test.beforeEach(async ({ page }) => {
<% for (const primitive of journey.setup) { %>
    <%- renderPrimitive(primitive, '    ') %>
<% } %>
  });

<% } %>
  test('<%= journey.id %>: <%= journey.title %>', async ({ page }) => {
<% for (const step of journey.steps) { %>
    // <%= step.description %>
    await test.step('<%= step.id %>: <%- escapeString(step.description) %>', async () => {
<% for (const action of step.actions) { %>
<% if (action.type === 'blocked') { %>
      // TODO: <%= action.reason %>
      // Source: <%- escapeString(action.sourceText) %>
<% } else { %>
      <%- renderPrimitive(action, '      ') %>
<% } %>
<% } %>
<% for (const assertion of step.assertions) { %>
      <%- renderPrimitive(assertion, '      ') %>
<% } %>
    });

<% } %>
<% if (journey.completion && journey.completion.length > 0) { %>
    // Verify completion signals
    await test.step('Verify completion', async () => {
<% for (const signal of journey.completion) { %>
<% const timeoutOpt = signal.timeout ? `, { timeout: ${signal.timeout} }` : ''; %>
<% if (signal.type === 'url') { %>
      await expect(page).toHaveURL(/<%- escapeRegex(signal.value) %>/<%- timeoutOpt %>);
<% } else if (signal.type === 'toast') { %>
      await expect(page.getByRole('alert').getByText('<%- escapeString(signal.value) %>')).toBeVisible(<%- timeoutOpt %>);
<% } else if (signal.type === 'element') { %>
      await expect(page.locator('<%- escapeString(signal.value) %>')).toBeVisible(<%- timeoutOpt %>);
<% } else if (signal.type === 'text') { %>
      await expect(page.getByText('<%- escapeString(signal.value) %>')).toBeVisible(<%- timeoutOpt %>);
<% } %>
<% } %>
    });
<% } %>
  });
<% if (journey.cleanup && journey.cleanup.length > 0) { %>

  test.afterEach(async ({ page }) => {
<% for (const primitive of journey.cleanup) { %>
    <%- renderPrimitive(primitive, '    ') %>
<% } %>
  });
<% } %>
});

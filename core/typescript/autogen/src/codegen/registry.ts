/**
 * Module Registry - Track and update module index files
 * @see research/2026-01-02_autogen-refined-plan.md Section 12
 */
import { readFileSync, writeFileSync, existsSync } from 'node:fs';
import { basename, dirname, relative } from 'node:path';
import { Project } from 'ts-morph';
import type { ModuleDefinition } from './generateModule.js';

/**
 * Module registry entry
 */
export interface RegistryEntry {
  /** Module name (PascalCase) */
  moduleName: string;
  /** Class name */
  className: string;
  /** File path relative to registry */
  filePath: string;
  /** Module scope */
  scope: string;
  /** Export type */
  exportType: 'class' | 'function' | 'const';
}

/**
 * Module registry state
 */
export interface ModuleRegistry {
  /** Registry file path */
  registryPath: string;
  /** Registered modules */
  entries: RegistryEntry[];
  /** Last updated timestamp */
  lastUpdated: Date;
}

/**
 * Options for registry operations
 */
export interface RegistryOptions {
  /** Create registry file if it doesn't exist */
  createIfMissing?: boolean;
  /** Preserve manual exports in index file */
  preserveManualExports?: boolean;
  /** Sort exports alphabetically */
  sortExports?: boolean;
}

/**
 * Result of registry update
 */
export interface RegistryUpdateResult {
  /** Whether the registry was modified */
  modified: boolean;
  /** Entries added */
  added: string[];
  /** Entries removed */
  removed: string[];
  /** Updated registry content */
  content: string;
}

/**
 * Load module registry from an index file
 */
export function loadRegistry(indexPath: string): ModuleRegistry | null {
  if (!existsSync(indexPath)) {
    return null;
  }

  const content = readFileSync(indexPath, 'utf-8');
  const entries = parseIndexFile(content, indexPath);

  return {
    registryPath: indexPath,
    entries,
    lastUpdated: new Date(),
  };
}

/**
 * Parse an index.ts file to extract module entries
 */
export function parseIndexFile(content: string, _indexPath?: string): RegistryEntry[] {
  const entries: RegistryEntry[] = [];
  const project = new Project({ useInMemoryFileSystem: true });
  const sourceFile = project.createSourceFile('index.ts', content);

  // Parse export declarations
  const exportDeclarations = sourceFile.getExportDeclarations();

  for (const exportDecl of exportDeclarations) {
    const moduleSpecifier = exportDecl.getModuleSpecifierValue();
    if (!moduleSpecifier) continue;

    const namedExports = exportDecl.getNamedExports();

    for (const namedExport of namedExports) {
      const exportName = namedExport.getName();
      const aliasNode = namedExport.getAliasNode();
      const alias = aliasNode ? aliasNode.getText() : exportName;

      // Determine export type from name convention
      let exportType: 'class' | 'function' | 'const' = 'class';
      if (exportName.startsWith('create') || exportName.endsWith('Factory')) {
        exportType = 'function';
      } else if (exportName === exportName.toUpperCase()) {
        exportType = 'const';
      }

      entries.push({
        moduleName: alias,
        className: exportName,
        filePath: moduleSpecifier,
        scope: extractScope(moduleSpecifier),
        exportType,
      });
    }
  }

  // Parse re-exports (export * from './module')
  const starExports = content.match(/export\s+\*\s+from\s+['"]([^'"]+)['"]/g);
  if (starExports) {
    for (const match of starExports) {
      const pathMatch = match.match(/['"]([^'"]+)['"]/);
      if (pathMatch) {
        const modulePath = pathMatch[1]!;
        entries.push({
          moduleName: extractModuleName(modulePath),
          className: '*',
          filePath: modulePath,
          scope: extractScope(modulePath),
          exportType: 'class',
        });
      }
    }
  }

  return entries;
}

/**
 * Extract module name from file path
 */
function extractModuleName(filePath: string): string {
  const base = basename(filePath, '.js').replace('.page', '');
  return toPascalCase(base);
}

/**
 * Extract scope from file path
 */
function extractScope(filePath: string): string {
  // e.g., './auth/login.page.js' -> 'auth'
  const dir = dirname(filePath);
  if (dir === '.' || dir === './') {
    return basename(filePath, '.js').replace('.page', '');
  }
  return basename(dir);
}

/**
 * Convert to PascalCase
 */
function toPascalCase(str: string): string {
  return str
    .split(/[-_\s]+/)
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');
}

/**
 * Generate index file content from entries
 */
export function generateIndexContent(
  entries: RegistryEntry[],
  options: RegistryOptions = {}
): string {
  const lines: string[] = [
    '/**',
    ' * Module Registry - Auto-generated index',
    ' * @generated by @artk/core-autogen',
    ' */',
  ];

  // Group entries by file path
  const byFile = new Map<string, RegistryEntry[]>();
  for (const entry of entries) {
    const existing = byFile.get(entry.filePath) || [];
    existing.push(entry);
    byFile.set(entry.filePath, existing);
  }

  // Sort if requested
  let filePaths = Array.from(byFile.keys());
  if (options.sortExports) {
    filePaths = filePaths.sort();
  }

  // Generate exports
  for (const filePath of filePaths) {
    const fileEntries = byFile.get(filePath)!;

    // Check if it's a star export
    if (fileEntries.length === 1 && fileEntries[0]!.className === '*') {
      lines.push(`export * from '${filePath}';`);
    } else {
      // Named exports
      const exports = fileEntries.map(e => {
        if (e.moduleName !== e.className) {
          return `${e.className} as ${e.moduleName}`;
        }
        return e.className;
      });

      if (options.sortExports) {
        exports.sort();
      }

      lines.push(`export { ${exports.join(', ')} } from '${filePath}';`);
    }
  }

  return lines.join('\n') + '\n';
}

/**
 * Add a module to the registry
 */
export function addToRegistry(
  registry: ModuleRegistry,
  module: ModuleDefinition,
  filePath: string
): RegistryEntry {
  const entry: RegistryEntry = {
    moduleName: module.moduleName,
    className: module.className,
    filePath,
    scope: module.scope,
    exportType: 'class',
  };

  // Check if already exists
  const existingIndex = registry.entries.findIndex(
    e => e.filePath === filePath || e.moduleName === module.moduleName
  );

  if (existingIndex >= 0) {
    registry.entries[existingIndex] = entry;
  } else {
    registry.entries.push(entry);
  }

  registry.lastUpdated = new Date();
  return entry;
}

/**
 * Remove a module from the registry
 */
export function removeFromRegistry(
  registry: ModuleRegistry,
  moduleNameOrPath: string
): boolean {
  const initialLength = registry.entries.length;

  registry.entries = registry.entries.filter(
    e => e.moduleName !== moduleNameOrPath && e.filePath !== moduleNameOrPath
  );

  const removed = registry.entries.length < initialLength;
  if (removed) {
    registry.lastUpdated = new Date();
  }

  return removed;
}

/**
 * Update index file with new modules
 */
export function updateIndexFile(
  indexPath: string,
  newModules: Array<{ module: ModuleDefinition; filePath: string }>,
  options: RegistryOptions = {}
): RegistryUpdateResult {
  let registry = loadRegistry(indexPath);
  const added: string[] = [];
  const removed: string[] = [];

  if (!registry) {
    if (!options.createIfMissing) {
      return {
        modified: false,
        added: [],
        removed: [],
        content: '',
      };
    }

    registry = {
      registryPath: indexPath,
      entries: [],
      lastUpdated: new Date(),
    };
  }

  // Track existing entries if preserving
  const existingNames = new Set(registry.entries.map(e => e.moduleName));

  // Add new modules
  for (const { module, filePath } of newModules) {
    const relativePath = filePath.startsWith('.')
      ? filePath
      : `./${relative(dirname(indexPath), filePath).replace(/\\/g, '/')}`;

    // Remove .ts extension and add .js for ESM
    const importPath = relativePath.replace(/\.ts$/, '.js');

    addToRegistry(registry, module, importPath);

    if (!existingNames.has(module.moduleName)) {
      added.push(module.moduleName);
    }
  }

  // Generate updated content
  const content = generateIndexContent(registry.entries, options);

  return {
    modified: added.length > 0 || removed.length > 0,
    added,
    removed,
    content,
  };
}

/**
 * Scan directory for module files and build registry
 */
export function scanModulesDirectory(
  _dirPath: string,
  _pattern = '*.page.ts'
): RegistryEntry[] {
  // This is a simplified implementation
  // In production, would use glob to find files
  // For now, return empty array - actual scanning happens via glob in CLI
  return [];
}

/**
 * Create a new empty registry
 */
export function createRegistry(indexPath: string): ModuleRegistry {
  return {
    registryPath: indexPath,
    entries: [],
    lastUpdated: new Date(),
  };
}

/**
 * Save registry to disk
 */
export function saveRegistry(
  registry: ModuleRegistry,
  options: RegistryOptions = {}
): void {
  const content = generateIndexContent(registry.entries, options);
  writeFileSync(registry.registryPath, content, 'utf-8');
}

/**
 * Find entry by module name
 */
export function findEntry(
  registry: ModuleRegistry,
  moduleName: string
): RegistryEntry | undefined {
  return registry.entries.find(e => e.moduleName === moduleName);
}

/**
 * Find entry by scope
 */
export function findEntriesByScope(
  registry: ModuleRegistry,
  scope: string
): RegistryEntry[] {
  return registry.entries.filter(e => e.scope === scope);
}

/**
 * Check if module exists in registry
 */
export function hasModule(registry: ModuleRegistry, moduleName: string): boolean {
  return registry.entries.some(e => e.moduleName === moduleName);
}

/**
 * Get all module names
 */
export function getModuleNames(registry: ModuleRegistry): string[] {
  return registry.entries.map(e => e.moduleName);
}

/**
 * Get registry statistics
 */
export function getRegistryStats(registry: ModuleRegistry): {
  totalModules: number;
  byScope: Record<string, number>;
  byType: Record<string, number>;
} {
  const byScope: Record<string, number> = {};
  const byType: Record<string, number> = {};

  for (const entry of registry.entries) {
    byScope[entry.scope] = (byScope[entry.scope] || 0) + 1;
    byType[entry.exportType] = (byType[entry.exportType] || 0) + 1;
  }

  return {
    totalModules: registry.entries.length,
    byScope,
    byType,
  };
}

{"version":3,"sources":["../../src/selectors/priority.ts","../../src/selectors/catalogSchema.ts","../../src/selectors/catalog.ts","../../src/selectors/infer.ts"],"names":["z","path","resolve","existsSync","readFileSync"],"mappings":"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","file":"index.cjs","sourcesContent":["/**\n * Selector Priority - Playwright best practices for selector selection\n * @see research/2026-01-02_autogen-refined-plan.md Section 11\n *\n * Priority order (per Playwright docs):\n * 1. role - ARIA roles (most stable, semantic)\n * 2. label - Form labels (accessible)\n * 3. placeholder - Input placeholders\n * 4. text - Visible text content\n * 5. testid - data-testid attributes\n * 6. css - CSS selectors (last resort)\n */\nimport type { LocatorSpec, LocatorStrategy } from '../ir/types.js';\nimport type { AutogenConfig } from '../config/schema.js';\n\n/**\n * Default selector priority\n */\nexport const DEFAULT_SELECTOR_PRIORITY: LocatorStrategy[] = [\n  'role',\n  'label',\n  'placeholder',\n  'text',\n  'testid',\n  'css',\n];\n\n/**\n * Map from element type to preferred selector strategies\n */\nexport const ELEMENT_TYPE_STRATEGIES: Record<string, LocatorStrategy[]> = {\n  button: ['role', 'text', 'testid'],\n  link: ['role', 'text', 'testid'],\n  textbox: ['role', 'label', 'placeholder', 'testid'],\n  checkbox: ['role', 'label', 'testid'],\n  radio: ['role', 'label', 'testid'],\n  combobox: ['role', 'label', 'testid'],\n  heading: ['role', 'text', 'testid'],\n  listitem: ['role', 'text', 'testid'],\n  menuitem: ['role', 'text', 'testid'],\n  tab: ['role', 'text', 'testid'],\n  dialog: ['role', 'testid'],\n  alert: ['role', 'testid'],\n  generic: ['text', 'testid', 'css'],\n};\n\n/**\n * ARIA roles that can have accessible names\n */\nexport const NAMEABLE_ROLES = [\n  'button',\n  'link',\n  'textbox',\n  'checkbox',\n  'radio',\n  'combobox',\n  'heading',\n  'tab',\n  'menuitem',\n  'listitem',\n  'option',\n  'cell',\n  'row',\n  'columnheader',\n  'rowheader',\n];\n\n/**\n * Get selector priority from config or use defaults\n */\nexport function getSelectorPriority(config?: AutogenConfig): LocatorStrategy[] {\n  if (config?.selectorPolicy?.priority) {\n    // Map config selector strategies to LocatorStrategy\n    return config.selectorPolicy.priority.map((s) => {\n      // Handle strategy name mapping if needed\n      return s as LocatorStrategy;\n    });\n  }\n  return DEFAULT_SELECTOR_PRIORITY;\n}\n\n/**\n * Check if a selector strategy is forbidden by config\n */\nexport function isForbiddenSelector(\n  locator: LocatorSpec,\n  config?: AutogenConfig\n): boolean {\n  const forbiddenPatterns = config?.selectorPolicy?.forbiddenPatterns ?? [];\n\n  for (const pattern of forbiddenPatterns) {\n    const regex = new RegExp(pattern);\n    if (regex.test(locator.value)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Score a locator based on priority (lower is better)\n */\nexport function scoreLocator(\n  locator: LocatorSpec,\n  priority: LocatorStrategy[] = DEFAULT_SELECTOR_PRIORITY\n): number {\n  const index = priority.indexOf(locator.strategy);\n  return index >= 0 ? index : priority.length;\n}\n\n/**\n * Compare two locators and return the better one\n */\nexport function compareLocators(\n  a: LocatorSpec,\n  b: LocatorSpec,\n  priority: LocatorStrategy[] = DEFAULT_SELECTOR_PRIORITY\n): LocatorSpec {\n  const scoreA = scoreLocator(a, priority);\n  const scoreB = scoreLocator(b, priority);\n  return scoreA <= scoreB ? a : b;\n}\n\n/**\n * Select the best locator from alternatives\n */\nexport function selectBestLocator(\n  alternatives: LocatorSpec[],\n  config?: AutogenConfig\n): LocatorSpec | null {\n  if (alternatives.length === 0) {\n    return null;\n  }\n\n  const priority = getSelectorPriority(config);\n\n  // Filter out forbidden selectors\n  const allowed = alternatives.filter((loc) => !isForbiddenSelector(loc, config));\n\n  if (allowed.length === 0) {\n    // All forbidden, return first original\n    return alternatives[0] ?? null;\n  }\n\n  // Sort by priority\n  allowed.sort((a, b) => scoreLocator(a, priority) - scoreLocator(b, priority));\n\n  return allowed[0] ?? null;\n}\n\n/**\n * Check if a locator is a role locator\n */\nexport function isRoleLocator(locator: LocatorSpec): boolean {\n  return locator.strategy === 'role';\n}\n\n/**\n * Check if a locator uses semantic selectors (role, label, text)\n */\nexport function isSemanticLocator(locator: LocatorSpec): boolean {\n  return ['role', 'label', 'text', 'placeholder'].includes(locator.strategy);\n}\n\n/**\n * Check if a locator is a test ID locator\n */\nexport function isTestIdLocator(locator: LocatorSpec): boolean {\n  return locator.strategy === 'testid';\n}\n\n/**\n * Check if a locator is a CSS locator (last resort)\n */\nexport function isCssLocator(locator: LocatorSpec): boolean {\n  return locator.strategy === 'css';\n}\n\n/**\n * Get recommended strategies for an element type\n */\nexport function getRecommendedStrategies(elementType: string): LocatorStrategy[] {\n  return ELEMENT_TYPE_STRATEGIES[elementType] ?? ELEMENT_TYPE_STRATEGIES.generic!;\n}\n\n/**\n * Validate a locator against best practices\n */\nexport function validateLocator(\n  locator: LocatorSpec,\n  config?: AutogenConfig\n): { valid: boolean; warnings: string[] } {\n  const warnings: string[] = [];\n\n  // Check if forbidden\n  if (isForbiddenSelector(locator, config)) {\n    warnings.push(`Selector matches forbidden pattern: ${locator.value}`);\n  }\n\n  // Warn about CSS selectors\n  if (isCssLocator(locator)) {\n    warnings.push(\n      `CSS selector \"${locator.value}\" is fragile. Consider using role, label, or testid.`\n    );\n  }\n\n  // Warn about XPath-like patterns in CSS\n  if (locator.value.includes('//') || locator.value.includes('..')) {\n    warnings.push(`Selector \"${locator.value}\" appears to use XPath syntax in CSS.`);\n  }\n\n  // Warn about nth-child selectors\n  if (locator.value.includes('nth-child') || locator.value.includes('nth-of-type')) {\n    warnings.push(`Selector \"${locator.value}\" uses nth-child which is position-dependent.`);\n  }\n\n  // Warn about ID selectors that might be dynamic\n  if (locator.strategy === 'css' && /^#[a-z]+-\\d+$/i.test(locator.value)) {\n    warnings.push(`Selector \"${locator.value}\" appears to have a dynamic ID.`);\n  }\n\n  return {\n    valid: warnings.length === 0,\n    warnings,\n  };\n}\n\n/**\n * Generate Playwright locator code from LocatorSpec\n */\nexport function toPlaywrightLocator(locator: LocatorSpec): string {\n  switch (locator.strategy) {\n    case 'role': {\n      const opts: string[] = [];\n      if (locator.options?.name) {\n        opts.push(`name: '${escapeString(locator.options.name)}'`);\n      }\n      if (locator.options?.exact) {\n        opts.push('exact: true');\n      }\n      if (locator.options?.level) {\n        opts.push(`level: ${locator.options.level}`);\n      }\n      const optsStr = opts.length > 0 ? `, { ${opts.join(', ')} }` : '';\n      return `getByRole('${locator.value}'${optsStr})`;\n    }\n    case 'label': {\n      const exact = locator.options?.exact ? ', { exact: true }' : '';\n      return `getByLabel('${escapeString(locator.value)}'${exact})`;\n    }\n    case 'placeholder': {\n      const exact = locator.options?.exact ? ', { exact: true }' : '';\n      return `getByPlaceholder('${escapeString(locator.value)}'${exact})`;\n    }\n    case 'text': {\n      const exact = locator.options?.exact ? ', { exact: true }' : '';\n      return `getByText('${escapeString(locator.value)}'${exact})`;\n    }\n    case 'testid':\n      return `getByTestId('${escapeString(locator.value)}')`;\n    case 'css':\n      return `locator('${escapeString(locator.value)}')`;\n    default:\n      return `locator('${escapeString(locator.value)}')`;\n  }\n}\n\n/**\n * Escape string for use in generated code\n */\nfunction escapeString(str: string): string {\n  return str.replace(/'/g, \"\\\\'\").replace(/\\n/g, '\\\\n');\n}\n","/**\n * Selector Catalog Schema - Define structure for repo-local selector catalog\n * @see T088 - Define selector catalog JSON schema\n */\nimport { z } from 'zod';\n\n/**\n * Selector entry in the catalog\n */\nexport const SelectorEntrySchema = z.object({\n  /** Unique identifier for this selector */\n  id: z.string(),\n  /** Human-readable description */\n  description: z.string().optional(),\n  /** The selector strategy */\n  strategy: z.enum(['testid', 'role', 'label', 'text', 'css', 'xpath']),\n  /** The selector value */\n  value: z.string(),\n  /** Additional options for the locator */\n  options: z\n    .object({\n      name: z.string().optional(),\n      exact: z.boolean().optional(),\n      level: z.number().optional(),\n    })\n    .optional(),\n  /** Component or page this selector belongs to */\n  component: z.string().optional(),\n  /** File where this selector was discovered */\n  sourceFile: z.string().optional(),\n  /** Line number in source file */\n  sourceLine: z.number().optional(),\n  /** Tags for categorization */\n  tags: z.array(z.string()).optional(),\n  /** Whether this is a stable selector (not likely to change) */\n  stable: z.boolean().default(true),\n  /** Last verified timestamp */\n  lastVerified: z.string().optional(),\n});\n\n/**\n * Component entry in the catalog\n */\nexport const ComponentEntrySchema = z.object({\n  /** Component name */\n  name: z.string(),\n  /** Component file path */\n  path: z.string().optional(),\n  /** Selectors within this component */\n  selectors: z.array(z.string()), // References to selector IDs\n  /** Child components */\n  children: z.array(z.string()).optional(),\n});\n\n/**\n * Page entry in the catalog\n */\nexport const PageEntrySchema = z.object({\n  /** Page name */\n  name: z.string(),\n  /** Route pattern */\n  route: z.string().optional(),\n  /** Page file path */\n  path: z.string().optional(),\n  /** Components on this page */\n  components: z.array(z.string()).optional(),\n  /** Direct selectors on this page */\n  selectors: z.array(z.string()).optional(),\n});\n\n/**\n * CSS debt entry - tracks CSS selectors that should be migrated\n */\nexport const CSSDebtEntrySchema = z.object({\n  /** The CSS selector being used */\n  selector: z.string(),\n  /** Files using this selector */\n  usages: z.array(\n    z.object({\n      file: z.string(),\n      line: z.number(),\n    })\n  ),\n  /** Suggested replacement */\n  suggestedReplacement: z\n    .object({\n      strategy: z.string(),\n      value: z.string(),\n    })\n    .optional(),\n  /** Priority for migration (higher = more urgent) */\n  priority: z.enum(['low', 'medium', 'high']).default('medium'),\n  /** Reason this is considered debt */\n  reason: z.string().optional(),\n});\n\n/**\n * Complete selector catalog schema\n */\nexport const SelectorCatalogSchema = z.object({\n  /** Schema version */\n  version: z.string().default('1.0.0'),\n  /** Generation timestamp */\n  generatedAt: z.string(),\n  /** Source directory that was scanned */\n  sourceDir: z.string().optional(),\n  /** All selectors indexed by ID */\n  selectors: z.record(SelectorEntrySchema),\n  /** Components indexed by name */\n  components: z.record(ComponentEntrySchema).default({}),\n  /** Pages indexed by name */\n  pages: z.record(PageEntrySchema).default({}),\n  /** TestIDs found in the codebase */\n  testIds: z.array(z.string()).default([]),\n  /** CSS debt entries */\n  cssDebt: z.array(CSSDebtEntrySchema).default([]),\n  /** Statistics */\n  stats: z\n    .object({\n      totalSelectors: z.number(),\n      byStrategy: z.record(z.number()),\n      stableCount: z.number(),\n      unstableCount: z.number(),\n      cssDebtCount: z.number(),\n    })\n    .optional(),\n});\n\nexport type SelectorEntry = z.infer<typeof SelectorEntrySchema>;\nexport type ComponentEntry = z.infer<typeof ComponentEntrySchema>;\nexport type PageEntry = z.infer<typeof PageEntrySchema>;\nexport type CSSDebtEntry = z.infer<typeof CSSDebtEntrySchema>;\nexport type SelectorCatalog = z.infer<typeof SelectorCatalogSchema>;\n\n/**\n * Create an empty catalog\n */\nexport function createEmptyCatalog(): SelectorCatalog {\n  return {\n    version: '1.0.0',\n    generatedAt: new Date().toISOString(),\n    selectors: {},\n    components: {},\n    pages: {},\n    testIds: [],\n    cssDebt: [],\n  };\n}\n\n/**\n * Validate a catalog object\n */\nexport function validateCatalog(catalog: unknown): {\n  valid: boolean;\n  errors: string[];\n  catalog?: SelectorCatalog;\n} {\n  const result = SelectorCatalogSchema.safeParse(catalog);\n\n  if (result.success) {\n    return { valid: true, errors: [], catalog: result.data };\n  }\n\n  return {\n    valid: false,\n    errors: result.error.errors.map((e) => `${e.path.join('.')}: ${e.message}`),\n  };\n}\n","/**\n * Selector Catalog Loader - Load and query the selector catalog\n * @see T089 - Implement catalog loader\n */\nimport { readFileSync, existsSync, writeFileSync } from 'node:fs';\nimport { resolve, dirname } from 'node:path';\nimport { mkdirSync } from 'node:fs';\nimport {\n  type SelectorCatalog,\n  type SelectorEntry,\n  createEmptyCatalog,\n  validateCatalog,\n} from './catalogSchema.js';\n\n/**\n * Default catalog file path\n */\nconst DEFAULT_CATALOG_PATH = 'config/selector-catalog.json';\n\n/**\n * Catalog cache\n */\nlet catalogCache: SelectorCatalog | null = null;\nlet catalogPath: string | null = null;\n\n/**\n * Load selector catalog from file\n * @param path - Path to catalog JSON file\n */\nexport function loadCatalog(path?: string): SelectorCatalog {\n  const resolvedPath = resolve(path ?? DEFAULT_CATALOG_PATH);\n\n  if (!existsSync(resolvedPath)) {\n    console.warn(`Selector catalog not found at ${resolvedPath}, using empty catalog`);\n    return createEmptyCatalog();\n  }\n\n  try {\n    const content = readFileSync(resolvedPath, 'utf-8');\n    const parsed = JSON.parse(content);\n    const result = validateCatalog(parsed);\n\n    if (!result.valid) {\n      console.warn(`Invalid selector catalog at ${resolvedPath}: ${result.errors.join(', ')}`);\n      return createEmptyCatalog();\n    }\n\n    catalogCache = result.catalog!;\n    catalogPath = resolvedPath;\n    return catalogCache;\n  } catch (_err) {\n    console.warn(`Failed to load selector catalog from ${resolvedPath}`);\n    return createEmptyCatalog();\n  }\n}\n\n/**\n * Save catalog to file\n * @param catalog - Catalog to save\n * @param path - Path to save to\n */\nexport function saveCatalog(catalog: SelectorCatalog, path?: string): void {\n  const resolvedPath = resolve(path ?? catalogPath ?? DEFAULT_CATALOG_PATH);\n\n  // Ensure directory exists\n  const dir = dirname(resolvedPath);\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n\n  // Update generation timestamp\n  catalog.generatedAt = new Date().toISOString();\n\n  // Calculate stats\n  catalog.stats = calculateStats(catalog);\n\n  writeFileSync(resolvedPath, JSON.stringify(catalog, null, 2));\n  catalogCache = catalog;\n  catalogPath = resolvedPath;\n}\n\n/**\n * Calculate catalog statistics\n */\nfunction calculateStats(\n  catalog: SelectorCatalog\n): SelectorCatalog['stats'] {\n  const selectors = Object.values(catalog.selectors);\n  const byStrategy: Record<string, number> = {};\n\n  let stableCount = 0;\n  let unstableCount = 0;\n\n  for (const selector of selectors) {\n    byStrategy[selector.strategy] = (byStrategy[selector.strategy] ?? 0) + 1;\n    if (selector.stable) {\n      stableCount++;\n    } else {\n      unstableCount++;\n    }\n  }\n\n  return {\n    totalSelectors: selectors.length,\n    byStrategy,\n    stableCount,\n    unstableCount,\n    cssDebtCount: catalog.cssDebt?.length ?? 0,\n  };\n}\n\n/**\n * Get the current catalog (loads if not cached)\n */\nexport function getCatalog(): SelectorCatalog {\n  if (!catalogCache) {\n    catalogCache = loadCatalog();\n  }\n  return catalogCache;\n}\n\n/**\n * Reset catalog cache (for testing)\n */\nexport function resetCatalogCache(): void {\n  catalogCache = null;\n  catalogPath = null;\n}\n\n/**\n * Find a selector by ID\n */\nexport function findSelectorById(id: string): SelectorEntry | null {\n  const catalog = getCatalog();\n  return catalog.selectors[id] ?? null;\n}\n\n/**\n * Find selectors by testid\n */\nexport function findByTestId(testId: string): SelectorEntry | null {\n  const catalog = getCatalog();\n\n  for (const selector of Object.values(catalog.selectors)) {\n    if (selector.strategy === 'testid' && selector.value === testId) {\n      return selector;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Find selectors by component name\n */\nexport function findByComponent(componentName: string): SelectorEntry[] {\n  const catalog = getCatalog();\n  const component = catalog.components[componentName];\n\n  if (!component) {\n    return [];\n  }\n\n  return component.selectors\n    .map((id) => catalog.selectors[id])\n    .filter((s): s is SelectorEntry => s !== undefined);\n}\n\n/**\n * Find selectors by page name\n */\nexport function findByPage(pageName: string): SelectorEntry[] {\n  const catalog = getCatalog();\n  const page = catalog.pages[pageName];\n\n  if (!page) {\n    return [];\n  }\n\n  const selectorIds = new Set<string>();\n\n  // Add direct page selectors\n  for (const id of page.selectors ?? []) {\n    selectorIds.add(id);\n  }\n\n  // Add component selectors\n  for (const componentName of page.components ?? []) {\n    const component = catalog.components[componentName];\n    if (component) {\n      for (const id of component.selectors) {\n        selectorIds.add(id);\n      }\n    }\n  }\n\n  return Array.from(selectorIds)\n    .map((id) => catalog.selectors[id])\n    .filter((s): s is SelectorEntry => s !== undefined);\n}\n\n/**\n * Search selectors by text (searches description, value, tags)\n */\nexport function searchSelectors(query: string): SelectorEntry[] {\n  const catalog = getCatalog();\n  const lowerQuery = query.toLowerCase();\n\n  return Object.values(catalog.selectors).filter((selector) => {\n    if (selector.value.toLowerCase().includes(lowerQuery)) return true;\n    if (selector.description?.toLowerCase().includes(lowerQuery)) return true;\n    if (selector.component?.toLowerCase().includes(lowerQuery)) return true;\n    if (selector.tags?.some((t) => t.toLowerCase().includes(lowerQuery))) return true;\n    return false;\n  });\n}\n\n/**\n * Get all testids in the catalog\n */\nexport function getAllTestIds(): string[] {\n  const catalog = getCatalog();\n  return catalog.testIds;\n}\n\n/**\n * Check if a testid exists in the catalog\n */\nexport function hasTestId(testId: string): boolean {\n  const catalog = getCatalog();\n  return catalog.testIds.includes(testId);\n}\n\n/**\n * Add a selector to the catalog\n */\nexport function addSelector(selector: SelectorEntry): void {\n  const catalog = getCatalog();\n  catalog.selectors[selector.id] = selector;\n\n  // Track testids\n  if (selector.strategy === 'testid' && !catalog.testIds.includes(selector.value)) {\n    catalog.testIds.push(selector.value);\n  }\n}\n\n/**\n * Remove a selector from the catalog\n */\nexport function removeSelector(id: string): boolean {\n  const catalog = getCatalog();\n  if (catalog.selectors[id]) {\n    delete catalog.selectors[id];\n    return true;\n  }\n  return false;\n}\n\n/**\n * Get selectors that need migration (CSS debt)\n */\nexport function getCSSDebt(): SelectorCatalog['cssDebt'] {\n  return getCatalog().cssDebt ?? [];\n}\n\n/**\n * Get stable selectors for a given element description\n * Useful for test generation to find the best available selector\n */\nexport function suggestSelector(description: string): SelectorEntry | null {\n  const results = searchSelectors(description);\n\n  if (results.length === 0) {\n    return null;\n  }\n\n  // Prefer stable selectors, then by strategy priority\n  const strategyPriority: Record<string, number> = {\n    testid: 1,\n    role: 2,\n    label: 3,\n    text: 4,\n    css: 5,\n    xpath: 6,\n  };\n\n  return results.sort((a, b) => {\n    // Stable first\n    if (a.stable && !b.stable) return -1;\n    if (!a.stable && b.stable) return 1;\n\n    // Then by strategy priority\n    return (strategyPriority[a.strategy] ?? 99) - (strategyPriority[b.strategy] ?? 99);\n  })[0] ?? null;\n}\n","/**\n * Selector Inference - Infer selectors from step text\n * @see research/2026-01-02_autogen-refined-plan.md Section 11\n * @see T092 - Integrate catalog querying into selector inference\n */\nimport type { LocatorSpec, LocatorStrategy } from '../ir/types.js';\nimport {\n  NAMEABLE_ROLES,\n  selectBestLocator,\n} from './priority.js';\nimport { suggestSelector, hasTestId } from './catalog.js';\n\n/**\n * Common element type keywords\n */\nconst ELEMENT_KEYWORDS: Record<string, string> = {\n  button: 'button',\n  btn: 'button',\n  submit: 'button',\n  link: 'link',\n  anchor: 'link',\n  input: 'textbox',\n  textbox: 'textbox',\n  field: 'textbox',\n  textarea: 'textbox',\n  checkbox: 'checkbox',\n  check: 'checkbox',\n  radio: 'radio',\n  dropdown: 'combobox',\n  select: 'combobox',\n  combo: 'combobox',\n  heading: 'heading',\n  title: 'heading',\n  header: 'heading',\n  menu: 'menu',\n  menuitem: 'menuitem',\n  tab: 'tab',\n  dialog: 'dialog',\n  modal: 'dialog',\n  alert: 'alert',\n  list: 'list',\n  listitem: 'listitem',\n  table: 'table',\n  row: 'row',\n  cell: 'cell',\n};\n\n/**\n * Infer the element type from text\n */\nexport function inferElementType(text: string): string | null {\n  const lowerText = text.toLowerCase();\n\n  for (const [keyword, elementType] of Object.entries(ELEMENT_KEYWORDS)) {\n    if (lowerText.includes(keyword)) {\n      return elementType;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Infer the ARIA role from element type\n */\nexport function inferRole(elementType: string): string | null {\n  // Most element types map directly to roles\n  const roleMap: Record<string, string> = {\n    button: 'button',\n    link: 'link',\n    textbox: 'textbox',\n    checkbox: 'checkbox',\n    radio: 'radio',\n    combobox: 'combobox',\n    heading: 'heading',\n    menu: 'menu',\n    menuitem: 'menuitem',\n    tab: 'tab',\n    dialog: 'dialog',\n    alert: 'alert',\n    list: 'list',\n    listitem: 'listitem',\n    table: 'table',\n    row: 'row',\n    cell: 'cell',\n  };\n\n  return roleMap[elementType] ?? null;\n}\n\n/**\n * Extract a name/label from text\n */\nexport function extractName(text: string): string | null {\n  // Look for quoted strings\n  const quotedMatch = text.match(/['\"]([^'\"]+)['\"]/);\n  if (quotedMatch) {\n    return quotedMatch[1] ?? null;\n  }\n\n  // Look for \"the X button\" pattern\n  const theMatch = text.match(/(?:the\\s+)?['\"]?([^'\"]+?)['\"]?\\s+(?:button|link|field|input|checkbox|dropdown)/i);\n  if (theMatch) {\n    return theMatch[1]!.trim();\n  }\n\n  return null;\n}\n\n/**\n * Infer selector alternatives from step text\n */\nexport function inferSelectors(text: string): LocatorSpec[] {\n  const alternatives: LocatorSpec[] = [];\n  const elementType = inferElementType(text);\n  const name = extractName(text);\n  const role = elementType ? inferRole(elementType) : null;\n\n  // Try role-based selector if we have a role\n  if (role && NAMEABLE_ROLES.includes(role)) {\n    if (name) {\n      alternatives.push({\n        strategy: 'role',\n        value: role,\n        options: { name },\n      });\n    } else {\n      alternatives.push({\n        strategy: 'role',\n        value: role,\n      });\n    }\n  }\n\n  // Try label selector for form elements\n  if (name && ['textbox', 'checkbox', 'radio', 'combobox'].includes(elementType || '')) {\n    alternatives.push({\n      strategy: 'label',\n      value: name,\n    });\n  }\n\n  // Try text selector\n  if (name) {\n    alternatives.push({\n      strategy: 'text',\n      value: name,\n    });\n  }\n\n  return alternatives;\n}\n\n/**\n * Infer the best selector from step text\n */\nexport function inferBestSelector(text: string): LocatorSpec | null {\n  const alternatives = inferSelectors(text);\n  return selectBestLocator(alternatives);\n}\n\n/**\n * Infer selector for a button element\n */\nexport function inferButtonSelector(name: string): LocatorSpec {\n  return {\n    strategy: 'role',\n    value: 'button',\n    options: { name },\n  };\n}\n\n/**\n * Infer selector for a link element\n */\nexport function inferLinkSelector(name: string): LocatorSpec {\n  return {\n    strategy: 'role',\n    value: 'link',\n    options: { name },\n  };\n}\n\n/**\n * Infer selector for an input field\n */\nexport function inferInputSelector(labelOrPlaceholder: string): LocatorSpec {\n  return {\n    strategy: 'label',\n    value: labelOrPlaceholder,\n  };\n}\n\n/**\n * Infer selector for a checkbox\n */\nexport function inferCheckboxSelector(label: string): LocatorSpec {\n  return {\n    strategy: 'role',\n    value: 'checkbox',\n    options: { name: label },\n  };\n}\n\n/**\n * Infer selector for a heading\n */\nexport function inferHeadingSelector(text: string, level?: number): LocatorSpec {\n  const locator: LocatorSpec = {\n    strategy: 'role',\n    value: 'heading',\n    options: { name: text },\n  };\n  if (level) {\n    locator.options!.level = level;\n  }\n  return locator;\n}\n\n/**\n * Infer selector for a tab\n */\nexport function inferTabSelector(name: string): LocatorSpec {\n  return {\n    strategy: 'role',\n    value: 'tab',\n    options: { name },\n  };\n}\n\n/**\n * Infer selector for generic text content\n */\nexport function inferTextSelector(text: string): LocatorSpec {\n  return {\n    strategy: 'text',\n    value: text,\n  };\n}\n\n/**\n * Infer selector from a test ID\n */\nexport function inferTestIdSelector(testId: string): LocatorSpec {\n  return {\n    strategy: 'testid',\n    value: testId,\n  };\n}\n\n/**\n * Create a CSS selector (last resort)\n */\nexport function createCssSelector(selector: string): LocatorSpec {\n  return {\n    strategy: 'css',\n    value: selector,\n  };\n}\n\n/**\n * Analyze text and suggest the best selector approach\n */\nexport function suggestSelectorApproach(text: string): {\n  elementType: string | null;\n  role: string | null;\n  name: string | null;\n  recommendedStrategy: LocatorStrategy;\n  alternatives: LocatorSpec[];\n} {\n  const elementType = inferElementType(text);\n  const role = elementType ? inferRole(elementType) : null;\n  const name = extractName(text);\n  const alternatives = inferSelectors(text);\n\n  // Determine recommended strategy\n  let recommendedStrategy: LocatorStrategy = 'text';\n\n  if (role && NAMEABLE_ROLES.includes(role)) {\n    recommendedStrategy = 'role';\n  } else if (name && ['textbox', 'checkbox', 'radio', 'combobox'].includes(elementType || '')) {\n    recommendedStrategy = 'label';\n  } else if (name) {\n    recommendedStrategy = 'text';\n  }\n\n  return {\n    elementType,\n    role,\n    name,\n    recommendedStrategy,\n    alternatives,\n  };\n}\n\n/**\n * Infer selector with catalog lookup (T092)\n * First checks the catalog for a known selector, then falls back to inference\n */\nexport function inferSelectorWithCatalog(\n  text: string,\n  options?: { useCatalog?: boolean }\n): LocatorSpec | null {\n  const useCatalog = options?.useCatalog ?? true;\n\n  // Try catalog first if enabled\n  if (useCatalog) {\n    const catalogEntry = suggestSelector(text);\n    if (catalogEntry) {\n      return {\n        strategy: catalogEntry.strategy as LocatorStrategy,\n        value: catalogEntry.value,\n        options: catalogEntry.options,\n      };\n    }\n\n    // Also try extracting a name and checking if it's a known testid\n    const name = extractName(text);\n    if (name) {\n      // Try common testid patterns\n      const possibleTestIds = [\n        name.toLowerCase().replace(/\\s+/g, '-'),\n        name.toLowerCase().replace(/\\s+/g, '_'),\n        name,\n      ];\n\n      for (const testId of possibleTestIds) {\n        if (hasTestId(testId)) {\n          return {\n            strategy: 'testid',\n            value: testId,\n          };\n        }\n      }\n    }\n  }\n\n  // Fall back to inference\n  return inferBestSelector(text);\n}\n\n/**\n * Infer selectors with catalog augmentation (T092)\n * Returns catalog-based selectors first, then inferred alternatives\n */\nexport function inferSelectorsWithCatalog(\n  text: string,\n  options?: { useCatalog?: boolean }\n): LocatorSpec[] {\n  const useCatalog = options?.useCatalog ?? true;\n  const alternatives: LocatorSpec[] = [];\n\n  // Try catalog first if enabled\n  if (useCatalog) {\n    const catalogEntry = suggestSelector(text);\n    if (catalogEntry) {\n      alternatives.push({\n        strategy: catalogEntry.strategy as LocatorStrategy,\n        value: catalogEntry.value,\n        options: catalogEntry.options,\n      });\n    }\n  }\n\n  // Add inferred selectors\n  alternatives.push(...inferSelectors(text));\n\n  // Deduplicate by strategy+value\n  const seen = new Set<string>();\n  return alternatives.filter((loc) => {\n    const key = `${loc.strategy}:${loc.value}`;\n    if (seen.has(key)) return false;\n    seen.add(key);\n    return true;\n  });\n}\n"]}
{"version":3,"sources":["../../utils/logger.ts","../../utils/retry.ts"],"names":[],"mappings":"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","file":"index.cjs","sourcesContent":["/**\n * Structured logger utility\n *\n * Provides structured JSON logging with verbosity levels (debug, info, warn, error)\n * as required by NFR-001, NFR-002, and NFR-003.\n *\n * All logs include module, operation, and timestamp for filtering and aggregation.\n *\n * @example\n * ```typescript\n * import { createLogger } from './logger.js';\n *\n * const logger = createLogger('config', 'loadConfig');\n * logger.info('Loading configuration', { path: 'artk.config.yml' });\n * logger.error('Validation failed', { errors: [...] });\n * ```\n */\n\n/**\n * Log levels in order of severity\n */\nexport type LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\n/**\n * Log output format\n */\nexport type LogFormat = 'json' | 'pretty';\n\n/**\n * Structured log entry\n */\nexport interface LogEntry {\n  level: LogLevel;\n  module: string;\n  operation: string;\n  timestamp: string;\n  message: string;\n  context?: Record<string, unknown>;\n}\n\n/**\n * Logger configuration\n */\nexport interface LoggerConfig {\n  minLevel: LogLevel;\n  format: LogFormat;\n  output: (entry: LogEntry) => void;\n}\n\n/**\n * Log level numeric values for comparison\n */\nconst LOG_LEVELS: Record<LogLevel, number> = {\n  debug: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n};\n\n/**\n * Format log entry as pretty text\n *\n * @param entry - Log entry to format\n * @returns Formatted string\n */\nfunction formatPretty(entry: LogEntry): string {\n  // Extract time from ISO timestamp (HH:MM:SS)\n  const time = entry.timestamp.split('T')[1]?.split('.')[0] || '00:00:00';\n\n  // Format level (uppercase, padded to 5 chars for alignment)\n  const level = entry.level.toUpperCase().padEnd(5);\n\n  // Format context if present\n  const context = entry.context ? ` ${JSON.stringify(entry.context)}` : '';\n\n  return `[${time}] ${level} [${entry.module}] ${entry.message}${context}`;\n}\n\n/**\n * Global logger configuration\n */\nlet globalConfig: LoggerConfig = {\n  minLevel: 'info',\n  format: 'json',\n  output: (entry: LogEntry): void => {\n    // eslint-disable-next-line no-console\n    const target = entry.level === 'error' ? console.error : console.log;\n\n    if (globalConfig.format === 'pretty') {\n      target(formatPretty(entry));\n    } else {\n      target(JSON.stringify(entry));\n    }\n  },\n};\n\n/**\n * Configure global logger settings\n *\n * @param config - Logger configuration\n *\n * @example\n * ```typescript\n * // JSON format (default, for production)\n * configureLogger({\n *   minLevel: 'debug',\n *   format: 'json'\n * });\n *\n * // Pretty format (for local development)\n * configureLogger({\n *   minLevel: 'debug',\n *   format: 'pretty'\n * });\n *\n * // Custom output\n * configureLogger({\n *   output: (entry) => fs.appendFileSync('artk.log', JSON.stringify(entry) + '\\n')\n * });\n * ```\n */\nexport function configureLogger(config: Partial<LoggerConfig>): void {\n  globalConfig = { ...globalConfig, ...config };\n}\n\n/**\n * Get current logger configuration\n */\nexport function getLoggerConfig(): Readonly<LoggerConfig> {\n  return { ...globalConfig };\n}\n\n/**\n * Logger interface\n */\nexport interface Logger {\n  debug(message: string, context?: Record<string, unknown>): void;\n  info(message: string, context?: Record<string, unknown>): void;\n  warn(message: string, context?: Record<string, unknown>): void;\n  error(message: string, context?: Record<string, unknown>): void;\n}\n\n/**\n * Create a logger for a specific module and operation\n *\n * @param module - Module name (e.g., 'config', 'auth', 'fixtures')\n * @param operation - Operation name (e.g., 'loadConfig', 'saveStorageState')\n * @returns Logger instance\n *\n * @example\n * ```typescript\n * const logger = createLogger('auth', 'oidcLogin');\n * logger.info('Starting OIDC login flow', { role: 'admin' });\n * ```\n */\nexport function createLogger(module: string, operation: string): Logger {\n  const log = (level: LogLevel, message: string, context?: Record<string, unknown>): void => {\n    // Check if this log level should be output\n    if (LOG_LEVELS[level] < LOG_LEVELS[globalConfig.minLevel]) {\n      return;\n    }\n\n    const entry: LogEntry = {\n      level,\n      module,\n      operation,\n      timestamp: new Date().toISOString(),\n      message,\n      context,\n    };\n\n    globalConfig.output(entry);\n  };\n\n  return {\n    debug: (message: string, context?: Record<string, unknown>): void => log('debug', message, context),\n    info: (message: string, context?: Record<string, unknown>): void => log('info', message, context),\n    warn: (message: string, context?: Record<string, unknown>): void => log('warn', message, context),\n    error: (message: string, context?: Record<string, unknown>): void => log('error', message, context),\n  };\n}\n\n/**\n * Parse log level from string (case-insensitive)\n *\n * @param level - Log level string\n * @returns Parsed log level or undefined if invalid\n *\n * @example\n * ```typescript\n * const level = parseLogLevel(process.env.LOG_LEVEL);\n * if (level) {\n *   configureLogger({ minLevel: level });\n * }\n * ```\n */\nexport function parseLogLevel(level: string | undefined): LogLevel | undefined {\n  if (!level) {\n    return undefined;\n  }\n\n  const normalized = level.toLowerCase() as LogLevel;\n  if (normalized in LOG_LEVELS) {\n    return normalized;\n  }\n\n  return undefined;\n}\n","/**\n * Retry utility with exponential backoff\n *\n * Provides retry logic with exponential backoff as required by NFR-010, NFR-011, and NFR-012.\n *\n * - NFR-010: System MUST retry authentication failures up to 2 times with exponential backoff\n * - NFR-011: After retry exhaustion, fail with actionable error message\n * - NFR-012: Log each retry attempt at warn level\n *\n * @example\n * ```typescript\n * import { withRetry } from './retry.js';\n *\n * const result = await withRetry(\n *   async () => authenticateUser(page, credentials),\n *   {\n *     maxAttempts: 3,\n *     initialDelayMs: 1000,\n *     maxDelayMs: 10000,\n *     onRetry: (attempt, delay, error) => {\n *       logger.warn(`Retry attempt ${attempt} after ${delay}ms`, { error: error.message });\n *     }\n *   }\n * );\n * ```\n */\n\nimport { createLogger } from './logger.js';\n\nconst logger = createLogger('utils', 'retry');\n\n/**\n * Retry configuration options\n */\nexport interface RetryOptions {\n  /**\n   * Maximum number of attempts (including initial attempt)\n   * @default 3\n   */\n  maxAttempts?: number;\n\n  /**\n   * Initial delay in milliseconds before first retry\n   * @default 1000\n   */\n  initialDelayMs?: number;\n\n  /**\n   * Maximum delay in milliseconds (caps exponential growth)\n   * @default 30000\n   */\n  maxDelayMs?: number;\n\n  /**\n   * Backoff multiplier (delay *= multiplier after each retry)\n   * @default 2\n   */\n  backoffMultiplier?: number;\n\n  /**\n   * Whether to add jitter to delay (randomizes delay by ±10%)\n   * @default true\n   */\n  jitter?: boolean;\n\n  /**\n   * Predicate function to determine if error is retryable\n   * @default () => true (retry all errors)\n   */\n  shouldRetry?: (error: Error, attempt: number) => boolean;\n\n  /**\n   * Callback invoked before each retry\n   * @param attempt - Current attempt number (1-indexed)\n   * @param delayMs - Delay before this retry in milliseconds\n   * @param error - Error from previous attempt\n   */\n  onRetry?: (attempt: number, delayMs: number, error: Error) => void;\n}\n\n/**\n * Default retry options\n */\nconst DEFAULT_RETRY_OPTIONS: Required<RetryOptions> = {\n  maxAttempts: 3,\n  initialDelayMs: 1000,\n  maxDelayMs: 30000,\n  backoffMultiplier: 2,\n  jitter: true,\n  shouldRetry: (): boolean => true,\n  onRetry: (): void => {},\n};\n\n/**\n * Calculate delay for next retry with exponential backoff\n *\n * @param attempt - Current attempt number (0-indexed)\n * @param options - Retry options\n * @returns Delay in milliseconds\n */\nfunction calculateDelay(attempt: number, options: Required<RetryOptions>): number {\n  // Exponential backoff: initialDelay * (multiplier ^ attempt)\n  let delay = options.initialDelayMs * Math.pow(options.backoffMultiplier, attempt);\n\n  // Cap at maximum delay\n  delay = Math.min(delay, options.maxDelayMs);\n\n  // Add jitter (±10%)\n  if (options.jitter) {\n    const jitterFactor = 0.9 + Math.random() * 0.2; // Random between 0.9 and 1.1\n    delay = Math.floor(delay * jitterFactor);\n  }\n\n  return delay;\n}\n\n/**\n * Sleep for specified duration\n *\n * @param ms - Duration in milliseconds\n * @returns Promise that resolves after duration\n */\nfunction sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n/**\n * Execute an async function with retry and exponential backoff\n *\n * @param fn - Async function to execute\n * @param options - Retry configuration\n * @returns Promise resolving to function result\n * @throws Last error if all retries are exhausted\n *\n * @example\n * ```typescript\n * const result = await withRetry(\n *   async () => {\n *     const response = await fetch('https://api.example.com/data');\n *     if (!response.ok) throw new Error('Request failed');\n *     return response.json();\n *   },\n *   {\n *     maxAttempts: 3,\n *     initialDelayMs: 1000,\n *     shouldRetry: (error) => error.message.includes('timeout'),\n *   }\n * );\n * ```\n */\nexport async function withRetry<T>(\n  fn: () => Promise<T>,\n  options: RetryOptions = {}\n): Promise<T> {\n  const opts: Required<RetryOptions> = { ...DEFAULT_RETRY_OPTIONS, ...options };\n\n  let lastError: Error | undefined;\n\n  for (let attempt = 0; attempt < opts.maxAttempts; attempt++) {\n    try {\n      // Execute function\n      return await fn();\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      lastError = err;\n\n      // Check if we should retry\n      const isLastAttempt = attempt === opts.maxAttempts - 1;\n      const shouldRetry = !isLastAttempt && opts.shouldRetry(err, attempt + 1);\n\n      if (!shouldRetry) {\n        // Don't retry - throw error\n        throw err;\n      }\n\n      // Calculate delay and log retry\n      const delay = calculateDelay(attempt, opts);\n      const attemptNumber = attempt + 1;\n\n      logger.warn(`Retry attempt ${attemptNumber}/${opts.maxAttempts - 1} after ${delay}ms`, {\n        attempt: attemptNumber,\n        delayMs: delay,\n        error: err.message,\n      });\n\n      // Invoke callback\n      opts.onRetry(attemptNumber, delay, err);\n\n      // Wait before retry\n      await sleep(delay);\n    }\n  }\n\n  // All retries exhausted - throw last error\n  throw lastError || new Error('All retry attempts failed');\n}\n\n/**\n * Create a retry wrapper for a specific function with fixed options\n *\n * @param fn - Async function to wrap\n * @param options - Retry configuration\n * @returns Wrapped function that retries on failure\n *\n * @example\n * ```typescript\n * const authenticateWithRetry = createRetryWrapper(\n *   async (page, creds) => oidcProvider.login(page, creds),\n *   { maxAttempts: 3, initialDelayMs: 2000 }\n * );\n *\n * await authenticateWithRetry(page, credentials);\n * ```\n */\nexport function createRetryWrapper<TArgs extends unknown[], TResult>(\n  fn: (...args: TArgs) => Promise<TResult>,\n  options: RetryOptions = {}\n): (...args: TArgs) => Promise<TResult> {\n  return async (...args: TArgs): Promise<TResult> => {\n    return withRetry(() => fn(...args), options);\n  };\n}\n\n/**\n * Predefined shouldRetry predicates for common scenarios\n */\nexport const RetryPredicates = {\n  /**\n   * Retry all errors\n   */\n  always: (): boolean => true,\n\n  /**\n   * Never retry\n   */\n  never: (): boolean => false,\n\n  /**\n   * Retry only network errors\n   */\n  networkErrors: (error: Error): boolean => {\n    const message = error.message.toLowerCase();\n    return (\n      message.includes('network') ||\n      message.includes('timeout') ||\n      message.includes('econnrefused') ||\n      message.includes('enotfound')\n    );\n  },\n\n  /**\n   * Retry only specific error messages\n   */\n  messageIncludes: (substring: string): ((error: Error) => boolean) => {\n    return (error: Error): boolean => error.message.includes(substring);\n  },\n\n  /**\n   * Retry based on error name\n   */\n  errorName: (name: string): ((error: Error) => boolean) => {\n    return (error: Error): boolean => error.name === name;\n  },\n};\n"]}
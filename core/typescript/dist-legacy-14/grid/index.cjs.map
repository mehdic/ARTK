{"version":3,"sources":["../../grid/types.ts","../../grid/ag-grid/config.ts","../../grid/ag-grid/selectors.ts","../../grid/ag-grid/locators.ts","../../grid/ag-grid/wait.ts","../../grid/ag-grid/cell-renderers.ts","../../grid/ag-grid/row-data.ts","../../grid/ag-grid/state.ts","../../grid/ag-grid/assertions.ts","../../grid/ag-grid/helper.ts","../../grid/ag-grid/factory.ts"],"names":["expect","normalizeForComparison"],"mappings":"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","file":"index.cjs","sourcesContent":["/**\n * AG Grid Helper Module - TypeScript Types\n *\n * This file defines the public API types for the AG Grid helper module.\n *\n * @module grid/types\n */\n\nimport type { Locator, Page } from '@playwright/test';\n\n// ============================================================================\n// Configuration Types\n// ============================================================================\n\n/**\n * AG Grid locator configuration\n */\nexport interface AgGridConfig {\n  /** Grid container selector (testid, CSS, or Locator string) */\n  selector: string;\n\n  /** Column definitions for smart cell location */\n  columns?: AgGridColumnDef[];\n\n  /** Custom cell renderer mappings */\n  cellRenderers?: Record<string, CellRendererConfig>;\n\n  /** Field name used for stable row IDs (maps to getRowId in AG Grid) */\n  rowIdField?: string;\n\n  /** Enterprise feature configuration */\n  enterprise?: EnterpriseConfig;\n\n  /** Custom timeout overrides */\n  timeouts?: TimeoutConfig;\n}\n\n/**\n * Column definition for type-safe cell access\n */\nexport interface AgGridColumnDef {\n  /** Column ID (matches AG Grid col-id attribute) */\n  colId: string;\n\n  /** Human-readable name for error messages */\n  displayName?: string;\n\n  /** Cell value type for smart assertions */\n  type?: ColumnType;\n\n  /** Custom value extraction function for complex cells */\n  valueExtractor?: (cell: Locator) => Promise<string>;\n\n  /** Column pinned position */\n  pinned?: 'left' | 'right' | null;\n}\n\n/**\n * Cell value types\n */\nexport type ColumnType = 'text' | 'number' | 'date' | 'boolean' | 'custom';\n\n/**\n * Custom cell renderer configuration\n */\nexport interface CellRendererConfig {\n  /** CSS selector for the value element within cell */\n  valueSelector: string;\n\n  /** Custom extraction function (defaults to textContent) */\n  extractValue?: (element: Locator) => Promise<string>;\n}\n\n/**\n * AG Grid Enterprise feature configuration\n */\nexport interface EnterpriseConfig {\n  /** Enable row grouping support */\n  rowGrouping?: boolean;\n\n  /** Enable tree data support */\n  treeData?: boolean;\n\n  /** Enable master/detail support */\n  masterDetail?: boolean;\n\n  /** Enable server-side row model handling */\n  serverSide?: boolean;\n}\n\n/**\n * Custom timeout configuration\n */\nexport interface TimeoutConfig {\n  /** Timeout for grid ready state (ms). Default: 30000 */\n  gridReady?: number;\n\n  /** Timeout for row to appear (ms). Default: 10000 */\n  rowLoad?: number;\n\n  /** Timeout for cell edit mode (ms). Default: 5000 */\n  cellEdit?: number;\n\n  /** Interval between scroll operations (ms). Default: 50 */\n  scroll?: number;\n}\n\n/**\n * Default timeout values\n */\nexport const DEFAULT_TIMEOUTS: Required<TimeoutConfig> = {\n  gridReady: 30000,\n  rowLoad: 10000,\n  cellEdit: 5000,\n  scroll: 50,\n};\n\n// ============================================================================\n// Row Matching Types\n// ============================================================================\n\n/**\n * Criteria for finding a specific row in the grid\n */\nexport interface RowMatcher {\n  /** Match by viewport row index (0-based) */\n  rowIndex?: number;\n\n  /** Match by stable row ID (requires rowIdField in config) */\n  rowId?: string;\n\n  /** Match by absolute aria-rowindex (1-based) */\n  ariaRowIndex?: number;\n\n  /** Match by cell value combinations */\n  cellValues?: Record<string, unknown>;\n\n  /** Custom match predicate */\n  predicate?: (row: AgGridRowData) => boolean;\n}\n\n// ============================================================================\n// Data Extraction Types\n// ============================================================================\n\n/**\n * Extracted data from a grid row\n */\nexport interface AgGridRowData {\n  /** Viewport row index (0-based) */\n  rowIndex: number;\n\n  /** Stable row ID if available */\n  rowId?: string;\n\n  /** Absolute row position (1-based, from aria-rowindex) */\n  ariaRowIndex: number;\n\n  /** Cell values keyed by colId */\n  cells: Record<string, unknown>;\n\n  /** True if this is a group row */\n  isGroup?: boolean;\n\n  /** True if group/tree node is expanded */\n  isExpanded?: boolean;\n\n  /** Nesting level for tree/group rows */\n  groupLevel?: number;\n}\n\n/**\n * Current state of the grid\n */\nexport interface AgGridState {\n  /** Total row count (from pagination info or DOM) */\n  totalRows: number;\n\n  /** Currently visible row count in viewport */\n  visibleRows: number;\n\n  /** Selected row count */\n  selectedRows: number;\n\n  /** Current sort state */\n  sortedBy?: SortModel[];\n\n  /** Current filter state */\n  filteredBy?: Record<string, unknown>;\n\n  /** Columns used for grouping */\n  groupedBy?: string[];\n\n  /** True if loading overlay is visible */\n  isLoading: boolean;\n}\n\n/**\n * Sort state for a column\n */\nexport interface SortModel {\n  /** Column being sorted */\n  colId: string;\n\n  /** Sort direction */\n  direction: 'asc' | 'desc';\n}\n\n// ============================================================================\n// Assertion Options\n// ============================================================================\n\n/**\n * Common options for grid assertions\n */\nexport interface AssertionOptions {\n  /** Assertion timeout in ms. Default: 5000 */\n  timeout?: number;\n\n  /** Require exact match vs contains. Default: false */\n  exact?: boolean;\n}\n\n/**\n * Options for row count assertions\n */\nexport interface RowCountOptions extends AssertionOptions {\n  /** Minimum row count (for range assertions) */\n  min?: number;\n\n  /** Maximum row count (for range assertions) */\n  max?: number;\n}\n\n// ============================================================================\n// Helper Interface\n// ============================================================================\n\n/**\n * AG Grid Helper - Main interface for grid interactions\n */\nexport interface AgGridHelper {\n  // ─────────────────────────────────────────────────────────────────────────\n  // Locators\n  // ─────────────────────────────────────────────────────────────────────────\n\n  /** Get the root grid container */\n  getGrid(): Locator;\n\n  /** Get a specific row by matcher */\n  getRow(matcher: RowMatcher): Locator;\n\n  /** Get all visible rows */\n  getVisibleRows(): Locator;\n\n  /** Get a specific cell */\n  getCell(rowMatcher: RowMatcher, colId: string): Locator;\n\n  /** Get header cell by column ID */\n  getHeaderCell(colId: string): Locator;\n\n  /** Get filter input for a column (floating filters) */\n  getFilterInput(colId: string): Locator;\n\n  // ─────────────────────────────────────────────────────────────────────────\n  // Wait Utilities\n  // ─────────────────────────────────────────────────────────────────────────\n\n  /** Wait for grid to be fully rendered and ready */\n  waitForReady(options?: { timeout?: number }): Promise<void>;\n\n  /** Wait for loading overlay to disappear */\n  waitForDataLoaded(options?: { timeout?: number }): Promise<void>;\n\n  /** Wait for a specific row count */\n  waitForRowCount(count: number, options?: { timeout?: number }): Promise<void>;\n\n  /** Wait for row to appear (handles virtualization) */\n  waitForRow(matcher: RowMatcher, options?: { timeout?: number }): Promise<Locator>;\n\n  // ─────────────────────────────────────────────────────────────────────────\n  // Assertions\n  // ─────────────────────────────────────────────────────────────────────────\n\n  /** Assert grid has expected row count */\n  expectRowCount(count: number, options?: RowCountOptions): Promise<void>;\n\n  /** Assert grid contains a row matching criteria */\n  expectRowContains(cellValues: Record<string, unknown>, options?: AssertionOptions): Promise<void>;\n\n  /** Assert grid does NOT contain a row matching criteria */\n  expectRowNotContains(\n    cellValues: Record<string, unknown>,\n    options?: AssertionOptions\n  ): Promise<void>;\n\n  /** Assert cell has expected value */\n  expectCellValue(\n    rowMatcher: RowMatcher,\n    colId: string,\n    expectedValue: unknown,\n    options?: AssertionOptions\n  ): Promise<void>;\n\n  /** Assert grid is sorted by column */\n  expectSortedBy(colId: string, direction: 'asc' | 'desc', options?: AssertionOptions): Promise<void>;\n\n  /** Assert grid is empty (no data rows) */\n  expectEmpty(options?: AssertionOptions): Promise<void>;\n\n  /** Assert row is selected */\n  expectRowSelected(matcher: RowMatcher, options?: AssertionOptions): Promise<void>;\n\n  /** Assert grid shows \"no rows\" overlay */\n  expectNoRowsOverlay(options?: AssertionOptions): Promise<void>;\n\n  // ─────────────────────────────────────────────────────────────────────────\n  // Actions\n  // ─────────────────────────────────────────────────────────────────────────\n\n  /** Click on a cell */\n  clickCell(rowMatcher: RowMatcher, colId: string): Promise<void>;\n\n  /** Double-click to edit a cell */\n  editCell(rowMatcher: RowMatcher, colId: string, newValue: string): Promise<void>;\n\n  /** Sort by column (click header) */\n  sortByColumn(colId: string, direction?: 'asc' | 'desc'): Promise<void>;\n\n  /** Filter column using floating filter */\n  filterColumn(colId: string, filterValue: string): Promise<void>;\n\n  /** Clear filter for column */\n  clearFilter(colId: string): Promise<void>;\n\n  /** Clear all filters */\n  clearAllFilters(): Promise<void>;\n\n  /** Select a row (click checkbox or row) */\n  selectRow(matcher: RowMatcher): Promise<void>;\n\n  /** Deselect a row */\n  deselectRow(matcher: RowMatcher): Promise<void>;\n\n  /** Select all rows */\n  selectAllRows(): Promise<void>;\n\n  /** Deselect all rows */\n  deselectAllRows(): Promise<void>;\n\n  /** Scroll to bring row into view */\n  scrollToRow(matcher: RowMatcher): Promise<void>;\n\n  /** Scroll to bring column into view */\n  scrollToColumn(colId: string): Promise<void>;\n\n  // ─────────────────────────────────────────────────────────────────────────\n  // Enterprise Features\n  // ─────────────────────────────────────────────────────────────────────────\n\n  /** Expand a group row */\n  expandGroup(matcher: RowMatcher): Promise<void>;\n\n  /** Collapse a group row */\n  collapseGroup(matcher: RowMatcher): Promise<void>;\n\n  /** Expand all groups */\n  expandAllGroups(): Promise<void>;\n\n  /** Collapse all groups */\n  collapseAllGroups(): Promise<void>;\n\n  /** Get group children count */\n  getGroupChildCount(matcher: RowMatcher): Promise<number>;\n\n  /** Expand master row to show detail */\n  expandMasterRow(matcher: RowMatcher): Promise<void>;\n\n  /** Get detail grid for master row */\n  getDetailGrid(masterRowMatcher: RowMatcher): AgGridHelper;\n\n  // ─────────────────────────────────────────────────────────────────────────\n  // Data Extraction\n  // ─────────────────────────────────────────────────────────────────────────\n\n  /** Get cell value */\n  getCellValue(rowMatcher: RowMatcher, colId: string): Promise<unknown>;\n\n  /** Get all cell values for a row */\n  getRowData(matcher: RowMatcher): Promise<AgGridRowData>;\n\n  /** Get all visible row data */\n  getAllVisibleRowData(): Promise<AgGridRowData[]>;\n\n  /** Get current grid state */\n  getGridState(): Promise<AgGridState>;\n\n  /** Get selected row IDs */\n  getSelectedRowIds(): Promise<string[]>;\n}\n\n// ============================================================================\n// Factory Function Type\n// ============================================================================\n\n/**\n * Create an AG Grid helper instance\n *\n * @param page - Playwright page object\n * @param config - Grid configuration (string selector or full config)\n * @returns AG Grid helper instance\n *\n * @example\n * ```typescript\n * // Simple usage with test ID\n * const grid = agGrid(page, 'orders-grid');\n *\n * // Full configuration\n * const grid = agGrid(page, {\n *   selector: 'orders-grid',\n *   columns: [\n *     { colId: 'orderId', type: 'text' },\n *     { colId: 'amount', type: 'number' },\n *   ],\n *   enterprise: { rowGrouping: true }\n * });\n * ```\n */\nexport type AgGridFactory = (page: Page, config: string | AgGridConfig) => AgGridHelper;\n\n// ============================================================================\n// Internal Types (used by implementation)\n// ============================================================================\n\n/**\n * Normalized configuration with all defaults applied\n * @internal\n */\nexport interface NormalizedAgGridConfig extends AgGridConfig {\n  timeouts: Required<TimeoutConfig>;\n}\n\n/**\n * Result of finding the closest matching row\n * @internal\n */\nexport interface ClosestMatchResult {\n  /** The row data of the closest match */\n  row: AgGridRowData;\n  /** Number of fields that matched */\n  matchedFields: number;\n  /** Total fields being compared */\n  totalFields: number;\n  /** Fields that didn't match with expected vs actual */\n  mismatches: Array<{\n    field: string;\n    expected: unknown;\n    actual: unknown;\n  }>;\n}\n\n// ============================================================================\n// Server-Side Row Model Types\n// ============================================================================\n\n/**\n * Server-side row model configuration\n */\nexport interface ServerSideConfig {\n  /** Block size for infinite scrolling. Default: 100 */\n  blockSize?: number;\n\n  /** Maximum blocks to keep in cache. Default: 10 */\n  maxBlocksInCache?: number;\n\n  /** Timeout for waiting for block to load (ms). Default: 30000 */\n  blockLoadTimeout?: number;\n}\n\n/**\n * Server-side loading state\n */\nexport interface ServerSideState {\n  /** True if currently loading a block */\n  isLoading: boolean;\n\n  /** Range of loaded row indices */\n  loadedRange: { start: number; end: number } | null;\n\n  /** Total row count from server (-1 if unknown) */\n  totalServerRows: number;\n\n  /** Number of blocks currently cached */\n  cachedBlocks: number;\n}\n\n/**\n * Options for server-side operations\n */\nexport interface ServerSideOptions {\n  /** Timeout for block load (ms) */\n  timeout?: number;\n\n  /** Whether to force refresh cached data */\n  forceRefresh?: boolean;\n\n  /** Block size for server-side loading (default: 100) */\n  blockSize?: number;\n\n  /** Maximum blocks to keep in cache (default: 10) */\n  maxBlocksInCache?: number;\n}\n\n// ============================================================================\n// Column Group Types\n// ============================================================================\n\n/**\n * Column group definition\n */\nexport interface ColumnGroupDef {\n  /** Group ID */\n  groupId: string;\n\n  /** Human-readable group name */\n  displayName?: string;\n\n  /** Child column IDs in this group */\n  children: string[];\n\n  /** Whether group is initially expanded */\n  openByDefault?: boolean;\n}\n\n/**\n * Column group state\n */\nexport interface ColumnGroupState {\n  /** Group ID */\n  groupId: string;\n\n  /** Whether the group is expanded */\n  isExpanded: boolean;\n\n  /** Visible child column IDs */\n  visibleChildren: string[];\n}\n\n// ============================================================================\n// Range Selection Types\n// ============================================================================\n\n/**\n * Cell position in grid\n */\nexport interface CellPosition {\n  /** Row matcher to identify the row */\n  rowMatcher: RowMatcher;\n\n  /** Column ID */\n  colId: string;\n}\n\n/**\n * Cell range for selection\n */\nexport interface CellRange {\n  /** Starting cell (top-left of range) */\n  start: CellPosition;\n\n  /** Ending cell (bottom-right of range) */\n  end: CellPosition;\n}\n\n/**\n * Range selection state\n */\nexport interface RangeSelectionState {\n  /** Currently selected ranges */\n  ranges: CellRange[];\n\n  /** Number of cells selected */\n  cellCount: number;\n\n  /** Number of rows spanned */\n  rowCount: number;\n\n  /** Number of columns spanned */\n  columnCount: number;\n}\n\n/**\n * Options for range selection\n */\nexport interface RangeSelectionOptions {\n  /** Whether to add to existing selection (Ctrl+click behavior) */\n  addToSelection?: boolean;\n\n  /** Whether to extend existing selection (Shift+click behavior) */\n  extendSelection?: boolean;\n}\n\n// ============================================================================\n// Keyboard Navigation Types\n// ============================================================================\n\n/**\n * Navigation direction\n */\nexport type NavigationDirection = 'up' | 'down' | 'left' | 'right';\n\n/**\n * Keyboard navigation options\n */\nexport interface KeyboardNavigationOptions {\n  /** Number of cells to move. Default: 1 */\n  count?: number;\n\n  /** Whether to hold Shift (for range selection) */\n  shiftKey?: boolean;\n\n  /** Whether to hold Ctrl/Cmd (for jump navigation) */\n  ctrlKey?: boolean;\n\n  /** Whether to hold Alt (for special navigation) */\n  altKey?: boolean;\n}\n\n/**\n * Keyboard action type\n */\nexport type KeyboardAction =\n  | 'enter'        // Enter edit mode or confirm\n  | 'escape'       // Exit edit mode or cancel\n  | 'tab'          // Move to next cell\n  | 'shiftTab'     // Move to previous cell\n  | 'space'        // Toggle selection\n  | 'delete'       // Clear cell content\n  | 'copy'         // Copy selected cells\n  | 'paste'        // Paste clipboard content\n  | 'selectAll'    // Select all cells (Ctrl+A)\n  | 'home'         // Jump to first cell in row\n  | 'end'          // Jump to last cell in row\n  | 'ctrlHome'     // Jump to first cell in grid\n  | 'ctrlEnd'      // Jump to last cell in grid\n  | 'pageUp'       // Scroll up one page\n  | 'pageDown';    // Scroll down one page\n\n/**\n * Keyboard navigation state\n */\nexport interface KeyboardNavigationState {\n  /** Currently focused cell position */\n  focusedCell: CellPosition | null;\n\n  /** Whether a cell is currently in edit mode */\n  isEditing: boolean;\n\n  /** Cell currently being edited (if any) */\n  editingCell: CellPosition | null;\n\n  /** Whether header row is focused */\n  isHeaderFocused: boolean;\n}\n\n// ============================================================================\n// Nested Detail Grid Types\n// ============================================================================\n\n/**\n * Detail grid path for nested navigation\n */\nexport interface DetailGridPath {\n  /** Sequence of master row matchers from root to target */\n  path: RowMatcher[];\n}\n\n/**\n * Nested detail grid state\n */\nexport interface NestedDetailState {\n  /** Depth level (0 = root grid, 1 = first detail, etc.) */\n  depth: number;\n\n  /** Path from root to this grid */\n  path: DetailGridPath;\n\n  /** Whether this detail grid has its own details */\n  hasNestedDetails: boolean;\n\n  /** Number of expanded detail rows in this grid */\n  expandedDetailCount: number;\n}\n\n/**\n * Options for nested detail operations\n */\nexport interface NestedDetailOptions {\n  /** Maximum depth to traverse. Default: 5 */\n  maxDepth?: number;\n\n  /** Timeout for each level expansion (ms). Default: 5000 */\n  timeout?: number;\n\n  /** Whether to auto-expand intermediate levels */\n  autoExpand?: boolean;\n}\n\n// ============================================================================\n// Extended Helper Interface\n// ============================================================================\n\n/**\n * Extended AG Grid helper with advanced features\n */\nexport interface AgGridHelperExtended extends AgGridHelper {\n  // ─────────────────────────────────────────────────────────────────────────\n  // Server-Side Row Model\n  // ─────────────────────────────────────────────────────────────────────────\n\n  /** Wait for server-side block to load */\n  waitForBlockLoad(rowIndex: number, options?: ServerSideOptions): Promise<void>;\n\n  /** Get server-side loading state */\n  getServerSideState(): Promise<ServerSideState>;\n\n  /** Refresh server-side data */\n  refreshServerSideData(options?: ServerSideOptions): Promise<void>;\n\n  /** Scroll to row with server-side loading */\n  scrollToServerSideRow(rowIndex: number, options?: ServerSideOptions): Promise<void>;\n\n  /** Check if row index is loaded */\n  isRowLoaded(rowIndex: number): Promise<boolean>;\n\n  // ─────────────────────────────────────────────────────────────────────────\n  // Column Groups\n  // ─────────────────────────────────────────────────────────────────────────\n\n  /** Get column group header locator */\n  getColumnGroupHeader(groupId: string): Locator;\n\n  /** Expand a column group */\n  expandColumnGroup(groupId: string): Promise<void>;\n\n  /** Collapse a column group */\n  collapseColumnGroup(groupId: string): Promise<void>;\n\n  /** Toggle column group expand/collapse */\n  toggleColumnGroup(groupId: string): Promise<void>;\n\n  /** Check if column group is expanded */\n  isColumnGroupExpanded(groupId: string): Promise<boolean>;\n\n  /** Get all column group states */\n  getColumnGroupStates(): Promise<ColumnGroupState[]>;\n\n  /** Get visible columns in a group */\n  getGroupVisibleColumns(groupId: string): Promise<string[]>;\n\n  // ─────────────────────────────────────────────────────────────────────────\n  // Range Selection\n  // ─────────────────────────────────────────────────────────────────────────\n\n  /** Select a range of cells */\n  selectCellRange(range: CellRange, options?: RangeSelectionOptions): Promise<void>;\n\n  /** Select cells by dragging */\n  selectCellsByDrag(start: CellPosition, end: CellPosition): Promise<void>;\n\n  /** Add cell to selection */\n  addCellToSelection(position: CellPosition): Promise<void>;\n\n  /** Clear all range selections */\n  clearRangeSelection(): Promise<void>;\n\n  /** Get current range selection state */\n  getRangeSelectionState(): Promise<RangeSelectionState>;\n\n  /** Get values from selected range */\n  getSelectedRangeValues(): Promise<unknown[][]>;\n\n  /** Assert cells in range are selected */\n  expectRangeSelected(range: CellRange): Promise<void>;\n\n  /** Copy selected cells to clipboard */\n  copySelectedCells(): Promise<void>;\n\n  /** Paste from clipboard to selected cells */\n  pasteToSelectedCells(): Promise<void>;\n\n  // ─────────────────────────────────────────────────────────────────────────\n  // Keyboard Navigation\n  // ─────────────────────────────────────────────────────────────────────────\n\n  /** Navigate using arrow keys */\n  navigateCell(direction: NavigationDirection, options?: KeyboardNavigationOptions): Promise<void>;\n\n  /** Perform keyboard action */\n  performKeyboardAction(action: KeyboardAction): Promise<void>;\n\n  /** Navigate to first cell in grid */\n  navigateToFirstCell(): Promise<void>;\n\n  /** Navigate to last cell in grid */\n  navigateToLastCell(): Promise<void>;\n\n  /** Navigate to first cell in current row */\n  navigateToRowStart(): Promise<void>;\n\n  /** Navigate to last cell in current row */\n  navigateToRowEnd(): Promise<void>;\n\n  /** Navigate to specific cell and focus it */\n  focusCell(position: CellPosition): Promise<void>;\n\n  /** Get currently focused cell position */\n  getFocusedCell(): Promise<CellPosition | null>;\n\n  /** Assert cell is focused */\n  expectCellFocused(position: CellPosition): Promise<void>;\n\n  /** Enter edit mode on focused cell */\n  enterEditMode(): Promise<void>;\n\n  /** Exit edit mode */\n  exitEditMode(confirm?: boolean): Promise<void>;\n\n  /** Tab to next editable cell */\n  tabToNextCell(): Promise<void>;\n\n  /** Tab to previous editable cell */\n  tabToPreviousCell(): Promise<void>;\n\n  // ─────────────────────────────────────────────────────────────────────────\n  // Nested Detail Grids\n  // ─────────────────────────────────────────────────────────────────────────\n\n  /** Get detail grid by path */\n  getDetailGridByPath(path: DetailGridPath): AgGridHelperExtended;\n\n  /** Get nested detail state */\n  getNestedDetailState(): Promise<NestedDetailState>;\n\n  /** Expand nested detail row at path */\n  expandNestedDetail(path: DetailGridPath, options?: NestedDetailOptions): Promise<void>;\n\n  /** Collapse nested detail row at path */\n  collapseNestedDetail(path: DetailGridPath): Promise<void>;\n\n  /** Get all expanded detail paths */\n  getExpandedDetailPaths(): Promise<DetailGridPath[]>;\n\n  /** Find detail grid containing specific data */\n  findDetailGridWithData(\n    cellValues: Record<string, unknown>,\n    options?: NestedDetailOptions\n  ): Promise<AgGridHelperExtended | null>;\n\n  /** Get depth of current grid (0 = root) */\n  getGridDepth(): number;\n\n  /** Get parent grid (null if root) */\n  getParentGrid(): AgGridHelperExtended | null;\n\n  /** Get root grid */\n  getRootGrid(): AgGridHelperExtended;\n}\n","/**\n * AG Grid Configuration Utilities\n *\n * Handles normalization and merging of grid configuration options.\n *\n * @module grid/ag-grid/config\n */\n\nimport type {\n  AgGridConfig,\n  NormalizedAgGridConfig,\n  TimeoutConfig,\n  EnterpriseConfig,\n} from '../types.js';\nimport { DEFAULT_TIMEOUTS } from '../types.js';\n\n/**\n * Normalize a grid configuration, converting string selector to full config\n * and applying default values.\n *\n * @param config - String selector or full configuration object\n * @returns Normalized configuration with all defaults applied\n *\n * @example\n * ```typescript\n * // String selector\n * const config = normalizeConfig('orders-grid');\n * // Result: { selector: 'orders-grid', timeouts: { gridReady: 30000, ... } }\n *\n * // Full config with overrides\n * const config = normalizeConfig({\n *   selector: 'orders-grid',\n *   timeouts: { gridReady: 60000 }\n * });\n * // Result: { selector: 'orders-grid', timeouts: { gridReady: 60000, rowLoad: 10000, ... } }\n * ```\n */\nexport function normalizeConfig(config: string | AgGridConfig): NormalizedAgGridConfig {\n  // Handle string shorthand\n  if (typeof config === 'string') {\n    return {\n      selector: config,\n      timeouts: { ...DEFAULT_TIMEOUTS },\n    };\n  }\n\n  // Merge timeouts with defaults\n  return {\n    ...config,\n    timeouts: mergeTimeouts(config.timeouts),\n  };\n}\n\n/**\n * Merge custom timeouts with default values\n *\n * @param custom - Custom timeout values (partial)\n * @returns Complete timeout configuration\n */\nexport function mergeTimeouts(custom?: TimeoutConfig): Required<TimeoutConfig> {\n  return {\n    ...DEFAULT_TIMEOUTS,\n    ...custom,\n  };\n}\n\n/**\n * Validate that a configuration is valid\n *\n * @param config - Configuration to validate\n * @throws Error if configuration is invalid\n */\nexport function validateConfig(config: AgGridConfig): void {\n  if (!config.selector || typeof config.selector !== 'string') {\n    throw new Error('AG Grid config requires a valid selector string');\n  }\n\n  if (config.selector.trim() === '') {\n    throw new Error('AG Grid config selector cannot be empty');\n  }\n\n  // Validate column definitions if provided\n  if (config.columns) {\n    for (const col of config.columns) {\n      if (!col.colId || typeof col.colId !== 'string') {\n        throw new Error(`AG Grid column definition requires a valid colId`);\n      }\n    }\n  }\n\n  // Validate timeouts if provided\n  if (config.timeouts) {\n    const timeoutKeys: (keyof TimeoutConfig)[] = ['gridReady', 'rowLoad', 'cellEdit', 'scroll'];\n    for (const key of timeoutKeys) {\n      const value = config.timeouts[key];\n      if (value !== undefined && (typeof value !== 'number' || value < 0)) {\n        throw new Error(`AG Grid timeout \"${key}\" must be a positive number`);\n      }\n    }\n  }\n}\n\n/**\n * Get the display name for a column\n *\n * @param config - Grid configuration\n * @param colId - Column ID to look up\n * @returns Display name or column ID if not found\n */\nexport function getColumnDisplayName(config: NormalizedAgGridConfig, colId: string): string {\n  const column = config.columns?.find((c) => c.colId === colId);\n  return column?.displayName ?? colId;\n}\n\n/**\n * Check if enterprise features are enabled\n *\n * @param config - Grid configuration\n * @returns Object indicating which enterprise features are enabled\n */\nexport function getEnterpriseFeatures(config: NormalizedAgGridConfig): Required<EnterpriseConfig> {\n  return {\n    rowGrouping: config.enterprise?.rowGrouping ?? false,\n    treeData: config.enterprise?.treeData ?? false,\n    masterDetail: config.enterprise?.masterDetail ?? false,\n    serverSide: config.enterprise?.serverSide ?? false,\n  };\n}\n\n/**\n * Check if any enterprise features are enabled\n *\n * @param config - Grid configuration\n * @returns True if any enterprise feature is enabled\n */\nexport function hasEnterpriseFeatures(config: NormalizedAgGridConfig): boolean {\n  const features = getEnterpriseFeatures(config);\n  return features.rowGrouping || features.treeData || features.masterDetail || features.serverSide;\n}\n\n/**\n * Get the pinned position for a column\n *\n * @param config - Grid configuration\n * @param colId - Column ID to look up\n * @returns Pinned position ('left', 'right') or null if not pinned\n */\nexport function getColumnPinnedPosition(\n  config: NormalizedAgGridConfig,\n  colId: string\n): 'left' | 'right' | null {\n  const column = config.columns?.find((c) => c.colId === colId);\n  return column?.pinned ?? null;\n}\n\n/**\n * Create a config with updated values\n *\n * @param config - Original configuration\n * @param updates - Partial updates to apply\n * @returns New configuration with updates applied\n */\nexport function updateConfig(\n  config: NormalizedAgGridConfig,\n  updates: Partial<AgGridConfig>\n): NormalizedAgGridConfig {\n  return {\n    ...config,\n    ...updates,\n    timeouts: updates.timeouts ? mergeTimeouts(updates.timeouts) : config.timeouts,\n  };\n}\n","/**\n * AG Grid DOM Selector Utilities\n *\n * Provides stable DOM selectors for AG Grid elements based on ARIA attributes\n * and AG Grid's internal class/attribute patterns.\n *\n * @module grid/ag-grid/selectors\n */\n\nimport type { Locator, Page } from '@playwright/test';\nimport type { RowMatcher } from '../types.js';\n\n/**\n * AG Grid CSS class and attribute selectors\n * These are stable across AG Grid versions 30-33\n */\nexport const AG_GRID_SELECTORS = {\n  // Grid structure\n  ROOT_WRAPPER: '.ag-root-wrapper',\n  HEADER: '.ag-header',\n  HEADER_ROW: '.ag-header-row',\n  HEADER_CELL: '.ag-header-cell',\n  BODY_VIEWPORT: '.ag-body-viewport',\n  CENTER_COLS_CONTAINER: '.ag-center-cols-container',\n  PINNED_LEFT_CONTAINER: '.ag-pinned-left-cols-container',\n  PINNED_RIGHT_CONTAINER: '.ag-pinned-right-cols-container',\n\n  // Row and cell\n  ROW: '.ag-row',\n  CELL: '.ag-cell',\n  ROW_GROUP: '.ag-row-group',\n  ROW_SELECTED: '.ag-row-selected',\n  CELL_FOCUS: '.ag-cell-focus',\n\n  // Overlays\n  LOADING_OVERLAY: '.ag-overlay-loading-center',\n  NO_ROWS_OVERLAY: '.ag-overlay-no-rows-center',\n\n  // Enterprise features\n  GROUP_EXPANDED: '.ag-group-expanded',\n  GROUP_CONTRACTED: '.ag-group-contracted',\n  DETAILS_ROW: '.ag-details-row',\n  FULL_WIDTH_ROW: '.ag-full-width-row',\n\n  // Floating filter\n  FLOATING_FILTER: '.ag-floating-filter',\n  FLOATING_FILTER_INPUT: '.ag-floating-filter-input',\n\n  // Selection checkbox\n  SELECTION_CHECKBOX: '.ag-selection-checkbox',\n  HEADER_SELECT_ALL: '.ag-header-select-all',\n\n  // Attributes\n  ATTR_COL_ID: 'col-id',\n  ATTR_ROW_INDEX: 'row-index',\n  ATTR_ROW_ID: 'row-id',\n  ATTR_ARIA_ROW_INDEX: 'aria-rowindex',\n  ATTR_ARIA_COL_INDEX: 'aria-colindex',\n  ATTR_ARIA_SORT: 'aria-sort',\n  ATTR_ARIA_SELECTED: 'aria-selected',\n} as const;\n\n/**\n * Get the root grid container element\n *\n * @param page - Playwright page object\n * @param selector - Grid selector (test-id, CSS selector, or custom)\n * @returns Locator for the grid root wrapper\n *\n * @example\n * ```typescript\n * // By test ID\n * const grid = getGridRoot(page, 'orders-grid');\n *\n * // By CSS selector\n * const grid = getGridRoot(page, '#my-grid');\n *\n * // By custom CSS\n * const grid = getGridRoot(page, '.custom-grid-container');\n * ```\n */\nexport function getGridRoot(page: Page, selector: string): Locator {\n  // Try data-testid first (most common pattern)\n  const byTestId = page.locator(`[data-testid=\"${selector}\"]`);\n\n  // If selector starts with special characters, treat as CSS selector\n  if (selector.startsWith('#') || selector.startsWith('.') || selector.startsWith('[')) {\n    return page.locator(selector).locator(AG_GRID_SELECTORS.ROOT_WRAPPER).or(page.locator(selector));\n  }\n\n  // Default: use data-testid, but fall back to finding root wrapper with that testid\n  return byTestId.locator(AG_GRID_SELECTORS.ROOT_WRAPPER).or(byTestId);\n}\n\n/**\n * Build a CSS selector for a cell by column ID\n *\n * @param colId - Column ID (col-id attribute value)\n * @returns CSS selector string\n */\nexport function buildCellSelector(colId: string): string {\n  return `${AG_GRID_SELECTORS.CELL}[${AG_GRID_SELECTORS.ATTR_COL_ID}=\"${colId}\"]`;\n}\n\n/**\n * Build a CSS selector for a header cell by column ID\n *\n * @param colId - Column ID (col-id attribute value)\n * @returns CSS selector string\n */\nexport function buildHeaderCellSelector(colId: string): string {\n  return `${AG_GRID_SELECTORS.HEADER_CELL}[${AG_GRID_SELECTORS.ATTR_COL_ID}=\"${colId}\"]`;\n}\n\n/**\n * Build a CSS selector for a row based on various matching criteria\n *\n * @param options - Row matching options\n * @returns CSS selector string\n */\nexport function buildRowSelector(options: {\n  rowIndex?: number;\n  rowId?: string;\n  ariaRowIndex?: number;\n}): string {\n  const { rowIndex, rowId, ariaRowIndex } = options;\n\n  if (ariaRowIndex !== undefined) {\n    return `${AG_GRID_SELECTORS.ROW}[${AG_GRID_SELECTORS.ATTR_ARIA_ROW_INDEX}=\"${ariaRowIndex}\"]`;\n  }\n\n  if (rowId !== undefined) {\n    return `${AG_GRID_SELECTORS.ROW}[${AG_GRID_SELECTORS.ATTR_ROW_ID}=\"${rowId}\"]`;\n  }\n\n  if (rowIndex !== undefined) {\n    return `${AG_GRID_SELECTORS.ROW}[${AG_GRID_SELECTORS.ATTR_ROW_INDEX}=\"${rowIndex}\"]`;\n  }\n\n  // Default: all rows\n  return AG_GRID_SELECTORS.ROW;\n}\n\n/**\n * Build a CSS selector for a floating filter input by column ID\n *\n * @param colId - Column ID (col-id attribute value)\n * @returns CSS selector string\n */\nexport function buildFilterInputSelector(colId: string): string {\n  return `${AG_GRID_SELECTORS.FLOATING_FILTER}[${AG_GRID_SELECTORS.ATTR_COL_ID}=\"${colId}\"] input`;\n}\n\n/**\n * Get all container locators for pinned and center columns\n *\n * @param gridLocator - The grid root locator\n * @returns Object with locators for each container\n */\nexport function getColumnContainers(gridLocator: Locator): {\n  left: Locator;\n  center: Locator;\n  right: Locator;\n} {\n  return {\n    left: gridLocator.locator(AG_GRID_SELECTORS.PINNED_LEFT_CONTAINER),\n    center: gridLocator.locator(AG_GRID_SELECTORS.CENTER_COLS_CONTAINER),\n    right: gridLocator.locator(AG_GRID_SELECTORS.PINNED_RIGHT_CONTAINER),\n  };\n}\n\n/**\n * Find a cell across all column containers (handles pinned columns)\n *\n * @param gridLocator - The grid root locator\n * @param rowSelector - CSS selector for the row\n * @param colId - Column ID\n * @returns Locator for the cell\n */\nexport function findCellAcrossContainers(\n  gridLocator: Locator,\n  rowSelector: string,\n  colId: string\n): Locator {\n  const cellSelector = buildCellSelector(colId);\n\n  // Use first() to return the first matching cell across all containers\n  return gridLocator\n    .locator(`${rowSelector} ${cellSelector}`)\n    .first();\n}\n\n/**\n * Check if a row is a group row (enterprise feature)\n *\n * @param rowLocator - The row locator\n * @returns Promise resolving to true if it's a group row\n */\nexport async function isGroupRow(rowLocator: Locator): Promise<boolean> {\n  const classAttr = await rowLocator.getAttribute('class');\n  return classAttr?.includes('ag-row-group') ?? false;\n}\n\n/**\n * Check if a row is expanded (group or tree node)\n *\n * @param rowLocator - The row locator\n * @returns Promise resolving to true if expanded\n */\nexport async function isRowExpanded(rowLocator: Locator): Promise<boolean> {\n  const ariaExpanded = await rowLocator.getAttribute('aria-expanded');\n  return ariaExpanded === 'true';\n}\n\n/**\n * Check if a row is selected\n *\n * @param rowLocator - The row locator\n * @returns Promise resolving to true if selected\n */\nexport async function isRowSelected(rowLocator: Locator): Promise<boolean> {\n  const classAttr = await rowLocator.getAttribute('class');\n  const ariaSelected = await rowLocator.getAttribute('aria-selected');\n\n  return classAttr?.includes('ag-row-selected') || ariaSelected === 'true';\n}\n\n/**\n * Get the aria-rowindex value from a row element\n *\n * @param rowLocator - The row locator\n * @returns Promise resolving to the aria-rowindex value (1-based)\n */\nexport async function getAriaRowIndex(rowLocator: Locator): Promise<number> {\n  const ariaRowIndex = await rowLocator.getAttribute(AG_GRID_SELECTORS.ATTR_ARIA_ROW_INDEX);\n  return ariaRowIndex ? parseInt(ariaRowIndex, 10) : -1;\n}\n\n/**\n * Get the row-index value from a row element (viewport index)\n *\n * @param rowLocator - The row locator\n * @returns Promise resolving to the row-index value (0-based)\n */\nexport async function getRowIndex(rowLocator: Locator): Promise<number> {\n  const rowIndex = await rowLocator.getAttribute(AG_GRID_SELECTORS.ATTR_ROW_INDEX);\n  return rowIndex ? parseInt(rowIndex, 10) : -1;\n}\n\n/**\n * Get the row-id value from a row element\n *\n * @param rowLocator - The row locator\n * @returns Promise resolving to the row-id value\n */\nexport async function getRowId(rowLocator: Locator): Promise<string | null> {\n  return rowLocator.getAttribute(AG_GRID_SELECTORS.ATTR_ROW_ID);\n}\n\n/**\n * Get the sort direction of a header cell\n *\n * @param headerCellLocator - The header cell locator\n * @returns Promise resolving to sort direction or undefined if not sorted\n */\nexport async function getSortDirection(\n  headerCellLocator: Locator\n): Promise<'asc' | 'desc' | undefined> {\n  const ariaSort = await headerCellLocator.getAttribute(AG_GRID_SELECTORS.ATTR_ARIA_SORT);\n\n  if (ariaSort === 'ascending') return 'asc';\n  if (ariaSort === 'descending') return 'desc';\n  return undefined;\n}\n\n/**\n * Build a row selector from a RowMatcher using priority order.\n * Priority: ariaRowIndex > rowId > rowIndex > (fallback to all rows)\n *\n * @param matcher - Row matching criteria\n * @returns CSS selector string or null if only predicate/cellValues matching\n */\nexport function buildRowSelectorFromMatcher(matcher: RowMatcher): string | null {\n  if (matcher.ariaRowIndex !== undefined) {\n    return `${AG_GRID_SELECTORS.ROW}[${AG_GRID_SELECTORS.ATTR_ARIA_ROW_INDEX}=\"${matcher.ariaRowIndex}\"]`;\n  }\n\n  if (matcher.rowId !== undefined) {\n    return `${AG_GRID_SELECTORS.ROW}[${AG_GRID_SELECTORS.ATTR_ROW_ID}=\"${matcher.rowId}\"]`;\n  }\n\n  if (matcher.rowIndex !== undefined) {\n    return `${AG_GRID_SELECTORS.ROW}[${AG_GRID_SELECTORS.ATTR_ROW_INDEX}=\"${matcher.rowIndex}\"]`;\n  }\n\n  // For cellValues or predicate, we need to iterate - return null\n  if (matcher.cellValues || matcher.predicate) {\n    return null;\n  }\n\n  // No criteria specified - fallback to all rows\n  return AG_GRID_SELECTORS.ROW;\n}\n\n/**\n * Check if a matcher can be resolved directly via CSS selector (fast path)\n *\n * @param matcher - Row matching criteria\n * @returns True if matcher can be resolved with CSS selector\n */\nexport function isDirectMatcher(matcher: RowMatcher): boolean {\n  return (\n    matcher.ariaRowIndex !== undefined ||\n    matcher.rowId !== undefined ||\n    matcher.rowIndex !== undefined\n  );\n}\n\n/**\n * Format a RowMatcher for error messages with meaningful context\n *\n * @param matcher - Row matching criteria\n * @returns Human-readable string describing the matcher\n */\nexport function formatRowMatcher(matcher: RowMatcher): string {\n  const parts: string[] = [];\n\n  if (matcher.ariaRowIndex !== undefined) {\n    parts.push(`ariaRowIndex=${matcher.ariaRowIndex}`);\n  }\n  if (matcher.rowId !== undefined) {\n    parts.push(`rowId=\"${matcher.rowId}\"`);\n  }\n  if (matcher.rowIndex !== undefined) {\n    parts.push(`rowIndex=${matcher.rowIndex}`);\n  }\n  if (matcher.cellValues) {\n    const cellParts = Object.entries(matcher.cellValues)\n      .map(([key, val]) => `${key}=\"${val}\"`)\n      .join(', ');\n    parts.push(`cellValues={${cellParts}}`);\n  }\n  if (matcher.predicate) {\n    parts.push('predicate=[function]');\n  }\n\n  if (parts.length === 0) {\n    return '(empty matcher)';\n  }\n\n  return parts.join(', ');\n}\n","/**\n * AG Grid Locators\n *\n * Provides locator factories for AG Grid elements.\n *\n * @module grid/ag-grid/locators\n */\n\nimport type { Locator, Page } from '@playwright/test';\nimport type { NormalizedAgGridConfig, RowMatcher } from '../types.js';\nimport {\n  AG_GRID_SELECTORS,\n  buildCellSelector,\n  buildHeaderCellSelector,\n  buildFilterInputSelector,\n  buildRowSelectorFromMatcher,\n  getGridRoot,\n} from './selectors.js';\nimport { getColumnPinnedPosition } from './config.js';\n\n/**\n * Locator context for a grid instance\n */\nexport interface GridLocatorContext {\n  page: Page;\n  config: NormalizedAgGridConfig;\n  gridLocator: Locator;\n}\n\n/**\n * Create the grid locator context\n *\n * @param page - Playwright page\n * @param config - Normalized grid configuration\n * @returns Grid locator context\n */\nexport function createLocatorContext(\n  page: Page,\n  config: NormalizedAgGridConfig\n): GridLocatorContext {\n  return {\n    page,\n    config,\n    gridLocator: getGridRoot(page, config.selector),\n  };\n}\n\n/**\n * Get the root grid container locator\n *\n * @param ctx - Grid locator context\n * @returns Grid root locator\n */\nexport function getGrid(ctx: GridLocatorContext): Locator {\n  return ctx.gridLocator;\n}\n\n/**\n * Get a specific row by matcher criteria\n *\n * @param ctx - Grid locator context\n * @param matcher - Row matching criteria\n * @returns Row locator\n */\nexport function getRow(ctx: GridLocatorContext, matcher: RowMatcher): Locator {\n  const { gridLocator } = ctx;\n\n  // Use shared row matcher logic with consistent priority order\n  const selector = buildRowSelectorFromMatcher(matcher);\n\n  if (selector) {\n    return gridLocator.locator(selector);\n  }\n\n  // For cellValues/predicate, return all rows (filtering will be done async)\n  return gridLocator.locator(AG_GRID_SELECTORS.ROW);\n}\n\n/**\n * Get all visible rows in the grid\n *\n * @param ctx - Grid locator context\n * @returns Locator for all visible rows\n */\nexport function getVisibleRows(ctx: GridLocatorContext): Locator {\n  return ctx.gridLocator.locator(AG_GRID_SELECTORS.ROW);\n}\n\n/**\n * Get a specific cell by row matcher and column ID\n *\n * @param ctx - Grid locator context\n * @param rowMatcher - Row matching criteria\n * @param colId - Column ID\n * @returns Cell locator\n */\nexport function getCell(\n  ctx: GridLocatorContext,\n  rowMatcher: RowMatcher,\n  colId: string\n): Locator {\n  const { gridLocator, config } = ctx;\n\n  // Check if column is pinned (if column config is provided)\n  const pinnedPosition = getColumnPinnedPosition(config, colId);\n\n  if (pinnedPosition) {\n    // For pinned columns, search in the appropriate container\n    const containerSelector = pinnedPosition === 'left'\n      ? AG_GRID_SELECTORS.PINNED_LEFT_CONTAINER\n      : AG_GRID_SELECTORS.PINNED_RIGHT_CONTAINER;\n\n    const rowSelector = buildRowSelectorFromMatcher(rowMatcher) ?? AG_GRID_SELECTORS.ROW;\n    return gridLocator\n      .locator(containerSelector)\n      .locator(rowSelector)\n      .locator(buildCellSelector(colId));\n  }\n\n  // Standard path: use row locator then find cell\n  const rowLocator = getRow(ctx, rowMatcher);\n  return rowLocator.locator(buildCellSelector(colId));\n}\n\n/**\n * Get a header cell by column ID\n *\n * @param ctx - Grid locator context\n * @param colId - Column ID\n * @returns Header cell locator\n */\nexport function getHeaderCell(ctx: GridLocatorContext, colId: string): Locator {\n  return ctx.gridLocator.locator(buildHeaderCellSelector(colId));\n}\n\n/**\n * Get the floating filter input for a column\n *\n * @param ctx - Grid locator context\n * @param colId - Column ID\n * @returns Filter input locator\n */\nexport function getFilterInput(ctx: GridLocatorContext, colId: string): Locator {\n  return ctx.gridLocator.locator(buildFilterInputSelector(colId));\n}\n\n/**\n * Get the loading overlay locator\n *\n * @param ctx - Grid locator context\n * @returns Loading overlay locator\n */\nexport function getLoadingOverlay(ctx: GridLocatorContext): Locator {\n  return ctx.gridLocator.locator(AG_GRID_SELECTORS.LOADING_OVERLAY);\n}\n\n/**\n * Get the \"no rows\" overlay locator\n *\n * @param ctx - Grid locator context\n * @returns No rows overlay locator\n */\nexport function getNoRowsOverlay(ctx: GridLocatorContext): Locator {\n  return ctx.gridLocator.locator(AG_GRID_SELECTORS.NO_ROWS_OVERLAY);\n}\n\n/**\n * Get the header select-all checkbox\n *\n * @param ctx - Grid locator context\n * @returns Select-all checkbox locator\n */\nexport function getSelectAllCheckbox(ctx: GridLocatorContext): Locator {\n  return ctx.gridLocator.locator(AG_GRID_SELECTORS.HEADER_SELECT_ALL);\n}\n\n/**\n * Get the selection checkbox for a row\n *\n * @param ctx - Grid locator context\n * @param rowMatcher - Row matching criteria\n * @returns Row selection checkbox locator\n */\nexport function getRowSelectionCheckbox(\n  ctx: GridLocatorContext,\n  rowMatcher: RowMatcher\n): Locator {\n  const rowLocator = getRow(ctx, rowMatcher);\n  return rowLocator.locator(AG_GRID_SELECTORS.SELECTION_CHECKBOX);\n}\n\n/**\n * Get the group expand/collapse icon for a row\n *\n * @param ctx - Grid locator context\n * @param rowMatcher - Row matching criteria\n * @returns Group icon locator\n */\nexport function getGroupIcon(ctx: GridLocatorContext, rowMatcher: RowMatcher): Locator {\n  const rowLocator = getRow(ctx, rowMatcher);\n  return rowLocator.locator(\n    `${AG_GRID_SELECTORS.GROUP_EXPANDED}, ${AG_GRID_SELECTORS.GROUP_CONTRACTED}`\n  );\n}\n\n/**\n * Get the body viewport (scrollable container)\n *\n * @param ctx - Grid locator context\n * @returns Body viewport locator\n */\nexport function getBodyViewport(ctx: GridLocatorContext): Locator {\n  return ctx.gridLocator.locator(AG_GRID_SELECTORS.BODY_VIEWPORT);\n}\n\n/**\n * Get the detail row for a master row (enterprise)\n *\n * @param ctx - Grid locator context\n * @param masterRowMatcher - Master row matching criteria\n * @returns Detail row locator\n */\nexport function getDetailRow(\n  ctx: GridLocatorContext,\n  masterRowMatcher: RowMatcher\n): Locator {\n  const masterRow = getRow(ctx, masterRowMatcher);\n\n  // Detail row is typically a sibling or following row with .ag-details-row class\n  // In AG Grid, detail rows follow their master row\n  if (masterRowMatcher.ariaRowIndex !== undefined) {\n    // Detail row has aria-rowindex = master + 1 for detail\n    return ctx.gridLocator.locator(\n      `${AG_GRID_SELECTORS.DETAILS_ROW}, ${AG_GRID_SELECTORS.FULL_WIDTH_ROW}`\n    ).filter({\n      has: masterRow.page().locator(`[aria-rowindex=\"${masterRowMatcher.ariaRowIndex + 1}\"]`),\n    });\n  }\n\n  // Fallback: find detail row near the master row\n  return ctx.gridLocator.locator(AG_GRID_SELECTORS.DETAILS_ROW);\n}\n","/**\n * AG Grid Wait Utilities\n *\n * Provides wait functions for grid ready states and data loading.\n *\n * @module grid/ag-grid/wait\n */\n\nimport type { Locator } from '@playwright/test';\nimport { expect } from '@playwright/test';\nimport type { NormalizedAgGridConfig, RowMatcher } from '../types.js';\nimport { AG_GRID_SELECTORS } from './selectors.js';\n\n/**\n * Wait for the grid to be fully rendered and ready for interaction\n *\n * @param gridLocator - The grid root locator\n * @param config - Normalized grid configuration\n * @param options - Wait options\n */\nexport async function waitForReady(\n  gridLocator: Locator,\n  config: NormalizedAgGridConfig,\n  options?: { timeout?: number }\n): Promise<void> {\n  const timeout = options?.timeout ?? config.timeouts.gridReady;\n\n  // Wait for root wrapper to be visible\n  await expect(gridLocator.locator(AG_GRID_SELECTORS.ROOT_WRAPPER).or(gridLocator))\n    .toBeVisible({ timeout });\n\n  // Wait for header to be visible (indicates grid structure is rendered)\n  await expect(gridLocator.locator(AG_GRID_SELECTORS.HEADER))\n    .toBeVisible({ timeout });\n\n  // Wait for loading overlay to disappear (if present)\n  await waitForDataLoaded(gridLocator, config, { timeout });\n}\n\n/**\n * Wait for the loading overlay to disappear\n *\n * @param gridLocator - The grid root locator\n * @param config - Normalized grid configuration\n * @param options - Wait options\n */\nexport async function waitForDataLoaded(\n  gridLocator: Locator,\n  config: NormalizedAgGridConfig,\n  options?: { timeout?: number }\n): Promise<void> {\n  const timeout = options?.timeout ?? config.timeouts.gridReady;\n  const loadingOverlay = gridLocator.locator(AG_GRID_SELECTORS.LOADING_OVERLAY);\n\n  // Check if loading overlay exists\n  const overlayCount = await loadingOverlay.count();\n  if (overlayCount > 0) {\n    // Check if it has the .visible class (our test fixture pattern)\n    const visibleOverlay = loadingOverlay.locator('.visible');\n    const visibleCount = await visibleOverlay.count();\n\n    if (visibleCount > 0) {\n      // Wait for .visible class to be removed\n      await expect(visibleOverlay).toHaveCount(0, { timeout });\n    }\n    // If no .visible class, assume it's hidden (display: none is the default in our fixture)\n  }\n}\n\n/**\n * Wait for a specific number of rows to be visible\n *\n * @param gridLocator - The grid root locator\n * @param count - Expected row count\n * @param config - Normalized grid configuration\n * @param options - Wait options\n */\nexport async function waitForRowCount(\n  gridLocator: Locator,\n  count: number,\n  config: NormalizedAgGridConfig,\n  options?: { timeout?: number }\n): Promise<void> {\n  const timeout = options?.timeout ?? config.timeouts.rowLoad;\n  const rows = gridLocator.locator(AG_GRID_SELECTORS.ROW);\n\n  await expect(rows).toHaveCount(count, { timeout });\n}\n\n/**\n * Wait for at least one row to be visible\n *\n * @param gridLocator - The grid root locator\n * @param config - Normalized grid configuration\n * @param options - Wait options\n */\nexport async function waitForAnyRows(\n  gridLocator: Locator,\n  config: NormalizedAgGridConfig,\n  options?: { timeout?: number }\n): Promise<void> {\n  const timeout = options?.timeout ?? config.timeouts.rowLoad;\n  const rows = gridLocator.locator(AG_GRID_SELECTORS.ROW);\n\n  // Wait for at least one row\n  await expect(rows.first()).toBeVisible({ timeout });\n}\n\n/**\n * Wait for a specific row to appear in the DOM\n *\n * @param gridLocator - The grid root locator\n * @param matcher - Row matching criteria\n * @param config - Normalized grid configuration\n * @param options - Wait options\n * @returns Locator for the found row\n */\nexport async function waitForRow(\n  gridLocator: Locator,\n  matcher: RowMatcher,\n  config: NormalizedAgGridConfig,\n  options?: { timeout?: number }\n): Promise<Locator> {\n  const timeout = options?.timeout ?? config.timeouts.rowLoad;\n\n  // Build row selector based on matcher\n  let rowLocator: Locator;\n\n  if (matcher.ariaRowIndex !== undefined) {\n    rowLocator = gridLocator.locator(\n      `${AG_GRID_SELECTORS.ROW}[${AG_GRID_SELECTORS.ATTR_ARIA_ROW_INDEX}=\"${matcher.ariaRowIndex}\"]`\n    );\n  } else if (matcher.rowId !== undefined) {\n    rowLocator = gridLocator.locator(\n      `${AG_GRID_SELECTORS.ROW}[${AG_GRID_SELECTORS.ATTR_ROW_ID}=\"${matcher.rowId}\"]`\n    );\n  } else if (matcher.rowIndex !== undefined) {\n    rowLocator = gridLocator.locator(\n      `${AG_GRID_SELECTORS.ROW}[${AG_GRID_SELECTORS.ATTR_ROW_INDEX}=\"${matcher.rowIndex}\"]`\n    );\n  } else {\n    // For cellValues matcher, we need more complex logic (handled elsewhere)\n    // Default to first row\n    rowLocator = gridLocator.locator(AG_GRID_SELECTORS.ROW).first();\n  }\n\n  await expect(rowLocator).toBeVisible({ timeout });\n  return rowLocator;\n}\n\n/**\n * Wait for the grid to show the \"no rows\" overlay\n *\n * @param gridLocator - The grid root locator\n * @param config - Normalized grid configuration\n * @param options - Wait options\n */\nexport async function waitForNoRowsOverlay(\n  gridLocator: Locator,\n  config: NormalizedAgGridConfig,\n  options?: { timeout?: number }\n): Promise<void> {\n  const timeout = options?.timeout ?? config.timeouts.gridReady;\n  const noRowsOverlay = gridLocator.locator(AG_GRID_SELECTORS.NO_ROWS_OVERLAY);\n\n  // Wait for no rows overlay to be visible (either by .visible class or actual visibility)\n  await expect(\n    noRowsOverlay.filter({ has: gridLocator.page().locator('.visible') })\n      .or(noRowsOverlay)\n  ).toBeVisible({ timeout });\n}\n\n/**\n * Wait for a cell to be in edit mode\n *\n * @param cellLocator - The cell locator\n * @param config - Normalized grid configuration\n * @param options - Wait options\n */\nexport async function waitForCellEditing(\n  cellLocator: Locator,\n  config: NormalizedAgGridConfig,\n  options?: { timeout?: number }\n): Promise<void> {\n  const timeout = options?.timeout ?? config.timeouts.cellEdit;\n\n  // AG Grid adds specific classes when a cell is being edited\n  await expect(\n    cellLocator.locator('.ag-cell-edit-wrapper').or(cellLocator.locator('input, textarea'))\n  ).toBeVisible({ timeout });\n}\n","/**\n * AG Grid Cell Value Extraction\n *\n * Provides utilities for extracting values from cells, including\n * support for custom cell renderers.\n *\n * @module grid/ag-grid/cell-renderers\n */\n\nimport type { Locator } from '@playwright/test';\nimport type { CellRendererConfig, NormalizedAgGridConfig } from '../types.js';\n\n/**\n * Built-in cell renderer extractors for common patterns\n */\nexport const BUILT_IN_EXTRACTORS: Record<string, CellRendererConfig> = {\n  // Checkbox cell\n  checkbox: {\n    valueSelector: 'input[type=\"checkbox\"]',\n    extractValue: async (el: Locator) => String(await el.isChecked()),\n  },\n\n  // Link/anchor cell\n  link: {\n    valueSelector: 'a',\n    extractValue: async (el: Locator) => (await el.textContent())?.trim() ?? '',\n  },\n\n  // Input cell (for inline editing)\n  input: {\n    valueSelector: 'input:not([type=\"checkbox\"])',\n    extractValue: async (el: Locator) => await el.inputValue(),\n  },\n\n  // Select/dropdown cell\n  select: {\n    valueSelector: 'select',\n    extractValue: async (el: Locator) => await el.inputValue(),\n  },\n\n  // Badge/tag cell\n  badge: {\n    valueSelector: '.badge, .tag, .chip, .label',\n    extractValue: async (el: Locator) => (await el.textContent())?.trim() ?? '',\n  },\n\n  // Button cell\n  button: {\n    valueSelector: 'button',\n    extractValue: async (el: Locator) => (await el.textContent())?.trim() ?? '',\n  },\n};\n\n/**\n * Extract the value from a cell, handling custom renderers\n *\n * @param cellLocator - The cell locator\n * @param config - Normalized grid configuration\n * @param colId - Column ID (for column-specific extractors)\n * @returns The extracted cell value\n */\nexport async function extractCellValue(\n  cellLocator: Locator,\n  config: NormalizedAgGridConfig,\n  colId?: string\n): Promise<string> {\n  // Check for column-specific custom renderer\n  if (colId && config.cellRenderers?.[colId]) {\n    const renderer = config.cellRenderers[colId];\n    return extractWithRenderer(cellLocator, renderer);\n  }\n\n  // Check for column definition with valueExtractor\n  if (colId && config.columns) {\n    const column = config.columns.find((c) => c.colId === colId);\n    if (column?.valueExtractor) {\n      return column.valueExtractor(cellLocator);\n    }\n  }\n\n  // Try built-in extractors based on cell content\n  for (const [, extractor] of Object.entries(BUILT_IN_EXTRACTORS)) {\n    const element = cellLocator.locator(extractor.valueSelector);\n    const count = await element.count();\n    if (count > 0 && extractor.extractValue) {\n      return extractor.extractValue(element.first());\n    }\n  }\n\n  // Fall back to text content with whitespace normalization\n  return normalizeText(await cellLocator.textContent());\n}\n\n/**\n * Extract value using a specific renderer configuration\n *\n * @param cellLocator - The cell locator\n * @param renderer - The renderer configuration\n * @returns The extracted value\n */\nasync function extractWithRenderer(\n  cellLocator: Locator,\n  renderer: CellRendererConfig\n): Promise<string> {\n  const element = cellLocator.locator(renderer.valueSelector);\n\n  if (renderer.extractValue) {\n    return renderer.extractValue(element.first());\n  }\n\n  // Default to text content\n  return normalizeText(await element.first().textContent());\n}\n\n/**\n * Normalize text content by trimming and collapsing whitespace\n *\n * @param text - Raw text content\n * @returns Normalized text\n */\nexport function normalizeText(text: string | null): string {\n  if (!text) return '';\n  return text.replace(/\\s+/g, ' ').trim();\n}\n\n/**\n * Get a cell value by column ID from a row\n *\n * @param rowLocator - The row locator\n * @param colId - Column ID\n * @param config - Normalized grid configuration\n * @returns The cell value\n */\nexport async function getCellValueByColId(\n  rowLocator: Locator,\n  colId: string,\n  config: NormalizedAgGridConfig\n): Promise<string> {\n  const cellLocator = rowLocator.locator(`.ag-cell[col-id=\"${colId}\"]`);\n  return extractCellValue(cellLocator, config, colId);\n}\n\n/**\n * Get all cell values for a row\n *\n * @param rowLocator - The row locator\n * @param config - Normalized grid configuration\n * @returns Object mapping column IDs to values\n */\nexport async function getAllCellValues(\n  rowLocator: Locator,\n  config: NormalizedAgGridConfig\n): Promise<Record<string, unknown>> {\n  const cells = rowLocator.locator('.ag-cell');\n  const cellCount = await cells.count();\n  const values: Record<string, unknown> = {};\n\n  for (let i = 0; i < cellCount; i++) {\n    const cell = cells.nth(i);\n    const colId = await cell.getAttribute('col-id');\n    if (colId) {\n      values[colId] = await extractCellValue(cell, config, colId);\n    }\n  }\n\n  return values;\n}\n\n/**\n * Parse a cell value based on column type\n *\n * @param value - The string value\n * @param type - The column type\n * @returns Parsed value\n */\nexport function parseValueByType(\n  value: string,\n  type?: 'text' | 'number' | 'date' | 'boolean' | 'custom'\n): unknown {\n  if (!type || type === 'text' || type === 'custom') {\n    return value;\n  }\n\n  if (type === 'number') {\n    // Handle formatted numbers (remove currency symbols, commas)\n    const numStr = value.replace(/[^0-9.-]/g, '');\n    const parsed = parseFloat(numStr);\n    return isNaN(parsed) ? value : parsed;\n  }\n\n  if (type === 'boolean') {\n    const lower = value.toLowerCase();\n    if (lower === 'true' || lower === 'yes' || lower === '1') return true;\n    if (lower === 'false' || lower === 'no' || lower === '0') return false;\n    return value;\n  }\n\n  if (type === 'date') {\n    const date = new Date(value);\n    return isNaN(date.getTime()) ? value : date;\n  }\n\n  return value;\n}\n","/**\n * AG Grid Row Data Extraction\n *\n * Provides utilities for extracting and finding row data.\n *\n * @module grid/ag-grid/row-data\n */\n\nimport type { Locator } from '@playwright/test';\nimport type { AgGridRowData, ClosestMatchResult, NormalizedAgGridConfig, RowMatcher } from '../types.js';\nimport {\n  AG_GRID_SELECTORS,\n  buildRowSelectorFromMatcher,\n  getAriaRowIndex,\n  getRowId,\n  getRowIndex,\n  isDirectMatcher,\n  isGroupRow,\n  isRowExpanded,\n} from './selectors.js';\nimport { getAllCellValues } from './cell-renderers.js';\n\n/**\n * Extract data from a row element\n *\n * @param rowLocator - The row locator\n * @param config - Normalized grid configuration\n * @returns Extracted row data\n */\nexport async function getRowData(\n  rowLocator: Locator,\n  config: NormalizedAgGridConfig\n): Promise<AgGridRowData> {\n  const [ariaRowIndex, rowIndex, rowId, isGroup, isExpanded, cells] = await Promise.all([\n    getAriaRowIndex(rowLocator),\n    getRowIndex(rowLocator),\n    getRowId(rowLocator),\n    isGroupRow(rowLocator),\n    isRowExpanded(rowLocator),\n    getAllCellValues(rowLocator, config),\n  ]);\n\n  const rowData: AgGridRowData = {\n    rowIndex,\n    ariaRowIndex,\n    cells,\n  };\n\n  if (rowId) {\n    rowData.rowId = rowId;\n  }\n\n  if (isGroup) {\n    rowData.isGroup = true;\n    rowData.isExpanded = isExpanded;\n\n    // Try to get group level from aria attribute or class\n    const level = await rowLocator.getAttribute('aria-level');\n    if (level) {\n      rowData.groupLevel = parseInt(level, 10);\n    }\n  }\n\n  return rowData;\n}\n\n/**\n * Extract data from all visible rows\n *\n * @param gridLocator - The grid root locator\n * @param config - Normalized grid configuration\n * @returns Array of row data\n */\nexport async function getAllVisibleRowData(\n  gridLocator: Locator,\n  config: NormalizedAgGridConfig\n): Promise<AgGridRowData[]> {\n  const rows = gridLocator.locator(AG_GRID_SELECTORS.ROW);\n  const rowCount = await rows.count();\n  const results: AgGridRowData[] = [];\n\n  for (let i = 0; i < rowCount; i++) {\n    const rowLocator = rows.nth(i);\n    const rowData = await getRowData(rowLocator, config);\n    results.push(rowData);\n  }\n\n  return results;\n}\n\n/**\n * Find a row by matching criteria\n *\n * @param gridLocator - The grid root locator\n * @param matcher - Row matching criteria\n * @param config - Normalized grid configuration\n * @returns Locator for the matching row, or null if not found\n */\nexport async function findRowByMatcher(\n  gridLocator: Locator,\n  matcher: RowMatcher,\n  config: NormalizedAgGridConfig\n): Promise<{ row: Locator; data: AgGridRowData } | null> {\n  // Fast path: Direct CSS selector matchers (ariaRowIndex, rowId, rowIndex)\n  if (isDirectMatcher(matcher)) {\n    const selector = buildRowSelectorFromMatcher(matcher);\n    if (selector) {\n      const row = gridLocator.locator(selector);\n      const count = await row.count();\n      if (count > 0) {\n        return { row: row.first(), data: await getRowData(row.first(), config) };\n      }\n    }\n    return null;\n  }\n\n  // Slow path: Cell values or predicate matching (requires iterating)\n  if (matcher.cellValues || matcher.predicate) {\n    const allRows = await getAllVisibleRowData(gridLocator, config);\n\n    for (let i = 0; i < allRows.length; i++) {\n      const rowData = allRows[i];\n      if (!rowData) {continue;}\n\n      const matches = matcher.cellValues\n        ? matchesCellValues(rowData, matcher.cellValues)\n        : matcher.predicate?.(rowData);\n\n      if (matches) {\n        const row = gridLocator.locator(AG_GRID_SELECTORS.ROW).nth(i);\n        return { row, data: rowData };\n      }\n    }\n    return null;\n  }\n\n  return null;\n}\n\n/**\n * Check if a row's cell values match the expected values\n *\n * @param rowData - Row data to check\n * @param expectedValues - Expected cell values\n * @returns True if all expected values match\n */\nexport function matchesCellValues(\n  rowData: AgGridRowData,\n  expectedValues: Record<string, unknown>\n): boolean {\n  for (const [colId, expectedValue] of Object.entries(expectedValues)) {\n    const actualValue = rowData.cells[colId];\n\n    // Normalize both values for comparison\n    const normalizedExpected = normalizeForComparison(expectedValue);\n    const normalizedActual = normalizeForComparison(actualValue);\n\n    if (normalizedExpected !== normalizedActual) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Find the closest matching row for error messages\n *\n * @param gridLocator - The grid root locator\n * @param expectedValues - Expected cell values\n * @param config - Normalized grid configuration\n * @returns Closest match result\n */\nexport async function findClosestMatch(\n  gridLocator: Locator,\n  expectedValues: Record<string, unknown>,\n  config: NormalizedAgGridConfig\n): Promise<ClosestMatchResult | null> {\n  const allRows = await getAllVisibleRowData(gridLocator, config);\n\n  if (allRows.length === 0) {\n    return null;\n  }\n\n  let bestMatch: ClosestMatchResult | null = null;\n  let bestMatchCount = -1;\n\n  const expectedKeys = Object.keys(expectedValues);\n  const totalFields = expectedKeys.length;\n\n  for (const rowData of allRows) {\n    let matchedFields = 0;\n    const mismatches: ClosestMatchResult['mismatches'] = [];\n\n    for (const colId of expectedKeys) {\n      const expectedValue = expectedValues[colId];\n      const actualValue = rowData.cells[colId];\n\n      const normalizedExpected = normalizeForComparison(expectedValue);\n      const normalizedActual = normalizeForComparison(actualValue);\n\n      if (normalizedExpected === normalizedActual) {\n        matchedFields++;\n      } else {\n        mismatches.push({\n          field: colId,\n          expected: expectedValue,\n          actual: actualValue,\n        });\n      }\n    }\n\n    if (matchedFields > bestMatchCount) {\n      bestMatchCount = matchedFields;\n      bestMatch = {\n        row: rowData,\n        matchedFields,\n        totalFields,\n        mismatches,\n      };\n    }\n  }\n\n  return bestMatch;\n}\n\n/**\n * Normalize a value for comparison\n *\n * @param value - Value to normalize\n * @returns Normalized string value\n */\nfunction normalizeForComparison(value: unknown): string {\n  if (value === null || value === undefined) {\n    return '';\n  }\n\n  if (typeof value === 'string') {\n    return value.trim().toLowerCase();\n  }\n\n  return String(value).trim().toLowerCase();\n}\n\n/**\n * Count visible rows in the grid\n *\n * @param gridLocator - The grid root locator\n * @returns Number of visible rows\n */\nexport async function countVisibleRows(gridLocator: Locator): Promise<number> {\n  return gridLocator.locator(AG_GRID_SELECTORS.ROW).count();\n}\n\n/**\n * Count selected rows in the grid\n *\n * @param gridLocator - The grid root locator\n * @returns Number of selected rows\n */\nexport async function countSelectedRows(gridLocator: Locator): Promise<number> {\n  return gridLocator.locator(AG_GRID_SELECTORS.ROW_SELECTED).count();\n}\n","/**\n * AG Grid State Extraction\n *\n * Provides utilities for extracting the current grid state.\n *\n * @module grid/ag-grid/state\n */\n\nimport type { Locator } from '@playwright/test';\nimport type { AgGridState, NormalizedAgGridConfig, SortModel } from '../types.js';\nimport { AG_GRID_SELECTORS, getSortDirection } from './selectors.js';\nimport { countSelectedRows, countVisibleRows } from './row-data.js';\n\n/**\n * Extract the current state of the grid\n *\n * @param gridLocator - The grid root locator\n * @param config - Normalized grid configuration\n * @returns Current grid state\n */\nexport async function getGridState(\n  gridLocator: Locator,\n  _config: NormalizedAgGridConfig\n): Promise<AgGridState> {\n  const [visibleRows, selectedRows, sortedBy, isLoading, totalRows] = await Promise.all([\n    countVisibleRows(gridLocator),\n    countSelectedRows(gridLocator),\n    getSortState(gridLocator),\n    checkIsLoading(gridLocator),\n    getTotalRowCount(gridLocator),\n  ]);\n\n  const state: AgGridState = {\n    totalRows,\n    visibleRows,\n    selectedRows,\n    isLoading,\n  };\n\n  if (sortedBy.length > 0) {\n    state.sortedBy = sortedBy;\n  }\n\n  // TODO: Extract filter state (more complex, depends on filter type)\n  // TODO: Extract groupedBy (enterprise feature)\n\n  return state;\n}\n\n/**\n * Get the current sort state from header cells\n *\n * @param gridLocator - The grid root locator\n * @returns Array of sort models\n */\nexport async function getSortState(gridLocator: Locator): Promise<SortModel[]> {\n  const headerCells = gridLocator.locator(AG_GRID_SELECTORS.HEADER_CELL);\n  const cellCount = await headerCells.count();\n  const sortedColumns: SortModel[] = [];\n\n  for (let i = 0; i < cellCount; i++) {\n    const cell = headerCells.nth(i);\n    const colId = await cell.getAttribute(AG_GRID_SELECTORS.ATTR_COL_ID);\n    const direction = await getSortDirection(cell);\n\n    if (colId && direction) {\n      sortedColumns.push({ colId, direction });\n    }\n  }\n\n  return sortedColumns;\n}\n\n/**\n * Check if an overlay element is visible\n * Handles AG Grid's overlay visibility patterns (CSS class and display)\n *\n * @param overlayLocator - Locator for the overlay element\n * @returns True if overlay is visible\n */\nasync function isOverlayVisible(overlayLocator: Locator): Promise<boolean> {\n  const count = await overlayLocator.count();\n\n  if (count === 0) {\n    return false;\n  }\n\n  // Check if the overlay has the .visible class (AG Grid pattern)\n  const visibleOverlay = overlayLocator.locator('.visible');\n  const visibleCount = await visibleOverlay.count();\n\n  if (visibleCount > 0) {\n    return true;\n  }\n\n  // Check if it's actually visible (not display: none)\n  try {\n    const isVisible = await overlayLocator.first().isVisible({ timeout: 100 });\n    return isVisible;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Check if the grid is in a loading state\n *\n * @param gridLocator - The grid root locator\n * @returns True if loading overlay is visible\n */\nexport async function checkIsLoading(gridLocator: Locator): Promise<boolean> {\n  const loadingOverlay = gridLocator.locator(AG_GRID_SELECTORS.LOADING_OVERLAY);\n  return isOverlayVisible(loadingOverlay);\n}\n\n/**\n * Get the total row count\n *\n * This tries multiple strategies:\n * 1. Read from pagination info if available\n * 2. Count visible rows if no pagination\n *\n * @param gridLocator - The grid root locator\n * @returns Total row count\n */\nexport async function getTotalRowCount(gridLocator: Locator): Promise<number> {\n  // Strategy 1: Check for pagination info\n  // AG Grid typically has pagination info like \"1 to 10 of 100\"\n  const paginationPanel = gridLocator.locator('.ag-paging-panel');\n  const paginationCount = await paginationPanel.count();\n\n  if (paginationCount > 0) {\n    const paginationText = await paginationPanel.textContent();\n    if (paginationText) {\n      // Try to extract \"of X\" pattern\n      const match = paginationText.match(/of\\s*(\\d+)/i);\n      const matchedValue = match?.[1];\n      if (matchedValue) {\n        return parseInt(matchedValue, 10);\n      }\n    }\n  }\n\n  // Strategy 2: Check for row count in status bar\n  const statusBar = gridLocator.locator('.ag-status-bar');\n  const statusBarCount = await statusBar.count();\n\n  if (statusBarCount > 0) {\n    const statusText = await statusBar.textContent();\n    if (statusText) {\n      const match = statusText.match(/(\\d+)\\s*(rows?|records?|items?)/i);\n      const matchedValue = match?.[1];\n      if (matchedValue) {\n        return parseInt(matchedValue, 10);\n      }\n    }\n  }\n\n  // Strategy 3: Count visible rows (fallback)\n  return countVisibleRows(gridLocator);\n}\n\n/**\n * Check if the \"no rows\" overlay is visible\n *\n * @param gridLocator - The grid root locator\n * @returns True if no rows overlay is visible\n */\nexport async function isNoRowsOverlayVisible(gridLocator: Locator): Promise<boolean> {\n  const noRowsOverlay = gridLocator.locator(AG_GRID_SELECTORS.NO_ROWS_OVERLAY);\n  return isOverlayVisible(noRowsOverlay);\n}\n\n/**\n * Get the columns that are currently grouped (enterprise feature)\n *\n * @param gridLocator - The grid root locator\n * @returns Array of column IDs used for grouping\n */\nexport async function getGroupedColumns(gridLocator: Locator): Promise<string[]> {\n  // AG Grid shows grouped columns in a row group panel\n  const rowGroupPanel = gridLocator.locator('.ag-column-drop-row-group');\n  const count = await rowGroupPanel.count();\n\n  if (count === 0) {\n    return [];\n  }\n\n  // Extract column IDs from the chips in the panel\n  const chips = rowGroupPanel.locator('.ag-column-drop-cell');\n  const chipCount = await chips.count();\n  const groupedColumns: string[] = [];\n\n  for (let i = 0; i < chipCount; i++) {\n    const chip = chips.nth(i);\n    const colId = await chip.getAttribute('col-id');\n    if (colId) {\n      groupedColumns.push(colId);\n    }\n  }\n\n  return groupedColumns;\n}\n","/**\n * AG Grid Assertions\n *\n * Provides assertion functions for grid state verification.\n *\n * @module grid/ag-grid/assertions\n */\n\nimport { expect, type Locator } from '@playwright/test';\nimport type {\n  AssertionOptions,\n  NormalizedAgGridConfig,\n  RowCountOptions,\n  RowMatcher,\n} from '../types.js';\nimport { AG_GRID_SELECTORS, isRowSelected } from './selectors.js';\nimport { getColumnDisplayName } from './config.js';\nimport {\n  countVisibleRows,\n  findClosestMatch,\n  findRowByMatcher,\n  getAllVisibleRowData,\n  matchesCellValues,\n} from './row-data.js';\nimport { getSortState, isNoRowsOverlayVisible } from './state.js';\n\n/**\n * Assert that the grid has the expected row count\n *\n * @param gridLocator - The grid root locator\n * @param count - Expected row count\n * @param config - Normalized grid configuration\n * @param options - Assertion options\n */\nexport async function expectRowCount(\n  gridLocator: Locator,\n  count: number,\n  config: NormalizedAgGridConfig,\n  options?: RowCountOptions\n): Promise<void> {\n  const timeout = options?.timeout ?? 5000;\n  const rows = gridLocator.locator(AG_GRID_SELECTORS.ROW);\n\n  // Handle range assertions\n  if (options?.min !== undefined || options?.max !== undefined) {\n    const actualCount = await rows.count();\n\n    if (options.min !== undefined && actualCount < options.min) {\n      throw new Error(\n        `Grid \"${config.selector}\" has ${actualCount} rows, expected at least ${options.min}`\n      );\n    }\n\n    if (options.max !== undefined && actualCount > options.max) {\n      throw new Error(\n        `Grid \"${config.selector}\" has ${actualCount} rows, expected at most ${options.max}`\n      );\n    }\n\n    return;\n  }\n\n  // Exact count assertion\n  await expect(rows).toHaveCount(count, { timeout });\n}\n\n/**\n * Assert that the grid contains a row matching the given cell values\n *\n * @param gridLocator - The grid root locator\n * @param cellValues - Expected cell values\n * @param config - Normalized grid configuration\n * @param options - Assertion options\n */\nexport async function expectRowContains(\n  gridLocator: Locator,\n  cellValues: Record<string, unknown>,\n  config: NormalizedAgGridConfig,\n  options?: AssertionOptions\n): Promise<void> {\n  const timeout = options?.timeout ?? 5000;\n  const startTime = Date.now();\n\n  // Poll until timeout\n  while (Date.now() - startTime < timeout) {\n    const match = await findRowByMatcher(gridLocator, { cellValues }, config);\n\n    if (match) {\n      return; // Found a matching row\n    }\n\n    // Small delay before retry\n    await gridLocator.page().waitForTimeout(100);\n  }\n\n  // No match found - build detailed error message\n  const visibleRowCount = await countVisibleRows(gridLocator);\n  const closestMatch = await findClosestMatch(gridLocator, cellValues, config);\n\n  let errorMessage = `Grid \"${config.selector}\" does not contain a row matching:\\n`;\n  errorMessage += `   Expected: ${formatCellValues(cellValues, config)}\\n\\n`;\n  errorMessage += `   Visible rows checked: ${visibleRowCount}\\n`;\n\n  if (closestMatch && closestMatch.matchedFields > 0) {\n    errorMessage += `   Closest match: ${formatCellValues(closestMatch.row.cells, config)}\\n`;\n    errorMessage += `   Mismatched fields:\\n`;\n    for (const mismatch of closestMatch.mismatches) {\n      const displayName = getColumnDisplayName(config, mismatch.field);\n      errorMessage += `     - ${displayName}: expected \"${String(mismatch.expected)}\", got \"${String(mismatch.actual)}\"\\n`;\n    }\n  } else {\n    errorMessage += `   No similar rows found\\n`;\n  }\n\n  errorMessage += `\\n   Tip: If the row exists but isn't visible, it may require scrolling.\\n`;\n  errorMessage += `   The helper automatically scrolls for you - check if the data exists.`;\n\n  throw new Error(errorMessage);\n}\n\n/**\n * Assert that the grid does NOT contain a row matching the given cell values\n *\n * @param gridLocator - The grid root locator\n * @param cellValues - Cell values that should NOT match any row\n * @param config - Normalized grid configuration\n * @param options - Assertion options\n */\nexport async function expectRowNotContains(\n  gridLocator: Locator,\n  cellValues: Record<string, unknown>,\n  config: NormalizedAgGridConfig,\n  options?: AssertionOptions\n): Promise<void> {\n  const timeout = options?.timeout ?? 5000;\n  const startTime = Date.now();\n\n  // Poll until timeout to ensure row doesn't appear\n  while (Date.now() - startTime < timeout) {\n    const allRows = await getAllVisibleRowData(gridLocator, config);\n\n    let foundMatch = false;\n    for (const rowData of allRows) {\n      if (matchesCellValues(rowData, cellValues)) {\n        foundMatch = true;\n        break;\n      }\n    }\n\n    if (foundMatch) {\n      // Found a match - this is a failure, wait a bit and check again\n      // (the row might be about to be removed)\n      await gridLocator.page().waitForTimeout(100);\n    } else {\n      // No match - success\n      return;\n    }\n  }\n\n  // Timeout reached and row still exists\n  throw new Error(\n    `Grid \"${config.selector}\" contains a row matching:\\n` +\n      `   ${formatCellValues(cellValues, config)}\\n\\n` +\n      `   Expected this row to NOT exist.`\n  );\n}\n\n/**\n * Assert that a specific cell has the expected value\n *\n * @param gridLocator - The grid root locator\n * @param rowMatcher - Row matching criteria\n * @param colId - Column ID\n * @param expectedValue - Expected cell value\n * @param config - Normalized grid configuration\n * @param options - Assertion options\n */\nexport async function expectCellValue(\n  gridLocator: Locator,\n  rowMatcher: RowMatcher,\n  colId: string,\n  expectedValue: unknown,\n  config: NormalizedAgGridConfig,\n  options?: AssertionOptions\n): Promise<void> {\n  const _timeout = options?.timeout ?? 5000;\n  void _timeout; // Reserved for future retry logic\n  const exact = options?.exact ?? false;\n\n  const match = await findRowByMatcher(gridLocator, rowMatcher, config);\n\n  if (!match) {\n    throw new Error(\n      `Grid \"${config.selector}\": Could not find row matching ${formatMatcher(rowMatcher)}`\n    );\n  }\n\n  const actualValue = match.data.cells[colId];\n  const displayName = getColumnDisplayName(config, colId);\n\n  if (exact) {\n    // Exact match\n    if (actualValue !== expectedValue) {\n      throw new Error(\n        `Grid \"${config.selector}\": Cell \"${displayName}\" has value \"${String(actualValue)}\", expected exactly \"${String(expectedValue)}\"`\n      );\n    }\n  } else {\n    // Normalized comparison\n    const normalizedExpected = normalizeForComparison(expectedValue);\n    const normalizedActual = normalizeForComparison(actualValue);\n\n    if (normalizedExpected !== normalizedActual) {\n      throw new Error(\n        `Grid \"${config.selector}\": Cell \"${displayName}\" has value \"${String(actualValue)}\", expected \"${String(expectedValue)}\"`\n      );\n    }\n  }\n}\n\n/**\n * Assert that the grid is sorted by a specific column\n *\n * @param gridLocator - The grid root locator\n * @param colId - Column ID\n * @param direction - Expected sort direction\n * @param config - Normalized grid configuration\n * @param options - Assertion options\n */\nexport async function expectSortedBy(\n  gridLocator: Locator,\n  colId: string,\n  direction: 'asc' | 'desc',\n  config: NormalizedAgGridConfig,\n  _options?: AssertionOptions\n): Promise<void> {\n  const sortState = await getSortState(gridLocator);\n  const columnSort = sortState.find((s) => s.colId === colId);\n  const displayName = getColumnDisplayName(config, colId);\n\n  if (!columnSort) {\n    const sortedCols = sortState.map((s) => `${s.colId} (${s.direction})`).join(', ') || 'none';\n    throw new Error(\n      `Grid \"${config.selector}\": Column \"${displayName}\" is not sorted. Currently sorted: ${sortedCols}`\n    );\n  }\n\n  if (columnSort.direction !== direction) {\n    throw new Error(\n      `Grid \"${config.selector}\": Column \"${displayName}\" is sorted \"${columnSort.direction}\", expected \"${direction}\"`\n    );\n  }\n}\n\n/**\n * Assert that the grid is empty (no data rows)\n *\n * @param gridLocator - The grid root locator\n * @param config - Normalized grid configuration\n * @param options - Assertion options\n */\nexport async function expectEmpty(\n  gridLocator: Locator,\n  _config: NormalizedAgGridConfig,\n  options?: AssertionOptions\n): Promise<void> {\n  const timeout = options?.timeout ?? 5000;\n  const rows = gridLocator.locator(AG_GRID_SELECTORS.ROW);\n\n  await expect(rows).toHaveCount(0, { timeout });\n}\n\n/**\n * Assert that the \"no rows\" overlay is visible\n *\n * @param gridLocator - The grid root locator\n * @param config - Normalized grid configuration\n * @param options - Assertion options\n */\nexport async function expectNoRowsOverlay(\n  gridLocator: Locator,\n  config: NormalizedAgGridConfig,\n  _options?: AssertionOptions\n): Promise<void> {\n  const isVisible = await isNoRowsOverlayVisible(gridLocator);\n\n  if (!isVisible) {\n    const rowCount = await countVisibleRows(gridLocator);\n    throw new Error(\n      `Grid \"${config.selector}\": \"No rows\" overlay is not visible. Grid has ${rowCount} rows.`\n    );\n  }\n}\n\n/**\n * Assert that a row is selected\n *\n * @param gridLocator - The grid root locator\n * @param matcher - Row matching criteria\n * @param config - Normalized grid configuration\n * @param options - Assertion options\n */\nexport async function expectRowSelected(\n  gridLocator: Locator,\n  matcher: RowMatcher,\n  config: NormalizedAgGridConfig,\n  _options?: AssertionOptions\n): Promise<void> {\n  const match = await findRowByMatcher(gridLocator, matcher, config);\n\n  if (!match) {\n    throw new Error(\n      `Grid \"${config.selector}\": Could not find row matching ${formatMatcher(matcher)}`\n    );\n  }\n\n  const selected = await isRowSelected(match.row);\n\n  if (!selected) {\n    throw new Error(\n      `Grid \"${config.selector}\": Row matching ${formatMatcher(matcher)} is not selected`\n    );\n  }\n}\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/**\n * Format cell values for error messages\n */\nfunction formatCellValues(\n  values: Record<string, unknown>,\n  config: NormalizedAgGridConfig\n): string {\n  const parts: string[] = [];\n  for (const [colId, value] of Object.entries(values)) {\n    const displayName = getColumnDisplayName(config, colId);\n    parts.push(`${displayName}: \"${String(value)}\"`);\n  }\n  return `{ ${parts.join(', ')} }`;\n}\n\n/**\n * Format a row matcher for error messages\n */\nfunction formatMatcher(matcher: RowMatcher): string {\n  if (matcher.ariaRowIndex !== undefined) {\n    return `aria-rowindex=${matcher.ariaRowIndex}`;\n  }\n  if (matcher.rowId !== undefined) {\n    return `row-id=\"${matcher.rowId}\"`;\n  }\n  if (matcher.rowIndex !== undefined) {\n    return `row-index=${matcher.rowIndex}`;\n  }\n  if (matcher.cellValues) {\n    return JSON.stringify(matcher.cellValues);\n  }\n  return '<custom predicate>';\n}\n\n/**\n * Normalize a value for comparison\n */\nfunction normalizeForComparison(value: unknown): string {\n  if (value === null || value === undefined) {\n    return '';\n  }\n  if (typeof value === 'string') {\n    return value.trim().toLowerCase();\n  }\n  return String(value).trim().toLowerCase();\n}\n","/**\n * AG Grid Helper Class\n *\n * Main class implementing the AgGridHelper interface.\n *\n * @module grid/ag-grid/helper\n */\n\nimport type { Locator, Page } from '@playwright/test';\nimport type {\n  AgGridHelper as IAgGridHelper,\n  AgGridConfig,\n  NormalizedAgGridConfig,\n  RowMatcher,\n  AgGridRowData,\n  AgGridState,\n  AssertionOptions,\n  RowCountOptions,\n} from '../types.js';\nimport { normalizeConfig, validateConfig } from './config.js';\nimport {\n  createLocatorContext,\n  getGrid as getGridLocator,\n  getRow as getRowLocator,\n  getVisibleRows as getVisibleRowsLocator,\n  getCell as getCellLocator,\n  getHeaderCell as getHeaderCellLocator,\n  getFilterInput as getFilterInputLocator,\n  type GridLocatorContext,\n} from './locators.js';\nimport { formatRowMatcher, isRowSelected } from './selectors.js';\nimport {\n  waitForReady as waitForReadyFn,\n  waitForDataLoaded as waitForDataLoadedFn,\n  waitForRowCount as waitForRowCountFn,\n  waitForRow as waitForRowFn,\n} from './wait.js';\nimport {\n  expectRowCount as expectRowCountFn,\n  expectRowContains as expectRowContainsFn,\n  expectRowNotContains as expectRowNotContainsFn,\n  expectCellValue as expectCellValueFn,\n  expectSortedBy as expectSortedByFn,\n  expectEmpty as expectEmptyFn,\n  expectRowSelected as expectRowSelectedFn,\n  expectNoRowsOverlay as expectNoRowsOverlayFn,\n} from './assertions.js';\nimport {\n  getAllVisibleRowData as getAllVisibleRowDataFn,\n  findRowByMatcher,\n} from './row-data.js';\nimport { getGridState as getGridStateFn } from './state.js';\n\n/**\n * AG Grid Helper implementation\n */\nexport class AgGridHelperImpl implements IAgGridHelper {\n  private page: Page;\n  private config: NormalizedAgGridConfig;\n  private ctx: GridLocatorContext;\n\n  constructor(page: Page, config: string | AgGridConfig) {\n    this.page = page;\n\n    // Validate config before normalizing (skip validation for string selectors)\n    if (typeof config !== 'string') {\n      validateConfig(config);\n    }\n\n    this.config = normalizeConfig(config);\n    this.ctx = createLocatorContext(page, this.config);\n  }\n\n  // ─────────────────────────────────────────────────────────────────────────\n  // Locators\n  // ─────────────────────────────────────────────────────────────────────────\n\n  getGrid(): Locator {\n    return getGridLocator(this.ctx);\n  }\n\n  getRow(matcher: RowMatcher): Locator {\n    return getRowLocator(this.ctx, matcher);\n  }\n\n  getVisibleRows(): Locator {\n    return getVisibleRowsLocator(this.ctx);\n  }\n\n  getCell(rowMatcher: RowMatcher, colId: string): Locator {\n    return getCellLocator(this.ctx, rowMatcher, colId);\n  }\n\n  getHeaderCell(colId: string): Locator {\n    return getHeaderCellLocator(this.ctx, colId);\n  }\n\n  getFilterInput(colId: string): Locator {\n    return getFilterInputLocator(this.ctx, colId);\n  }\n\n  // ─────────────────────────────────────────────────────────────────────────\n  // Wait Utilities\n  // ─────────────────────────────────────────────────────────────────────────\n\n  async waitForReady(options?: { timeout?: number }): Promise<void> {\n    await waitForReadyFn(this.getGrid(), this.config, options);\n  }\n\n  async waitForDataLoaded(options?: { timeout?: number }): Promise<void> {\n    await waitForDataLoadedFn(this.getGrid(), this.config, options);\n  }\n\n  async waitForRowCount(count: number, options?: { timeout?: number }): Promise<void> {\n    await waitForRowCountFn(this.getGrid(), count, this.config, options);\n  }\n\n  async waitForRow(matcher: RowMatcher, options?: { timeout?: number }): Promise<Locator> {\n    return waitForRowFn(this.getGrid(), matcher, this.config, options);\n  }\n\n  // ─────────────────────────────────────────────────────────────────────────\n  // Assertions\n  // ─────────────────────────────────────────────────────────────────────────\n\n  async expectRowCount(count: number, options?: RowCountOptions): Promise<void> {\n    await expectRowCountFn(this.getGrid(), count, this.config, options);\n  }\n\n  async expectRowContains(\n    cellValues: Record<string, unknown>,\n    options?: AssertionOptions\n  ): Promise<void> {\n    await expectRowContainsFn(this.getGrid(), cellValues, this.config, options);\n  }\n\n  async expectRowNotContains(\n    cellValues: Record<string, unknown>,\n    options?: AssertionOptions\n  ): Promise<void> {\n    await expectRowNotContainsFn(this.getGrid(), cellValues, this.config, options);\n  }\n\n  async expectCellValue(\n    rowMatcher: RowMatcher,\n    colId: string,\n    expectedValue: unknown,\n    options?: AssertionOptions\n  ): Promise<void> {\n    await expectCellValueFn(this.getGrid(), rowMatcher, colId, expectedValue, this.config, options);\n  }\n\n  async expectSortedBy(\n    colId: string,\n    direction: 'asc' | 'desc',\n    options?: AssertionOptions\n  ): Promise<void> {\n    await expectSortedByFn(this.getGrid(), colId, direction, this.config, options);\n  }\n\n  async expectEmpty(options?: AssertionOptions): Promise<void> {\n    await expectEmptyFn(this.getGrid(), this.config, options);\n  }\n\n  async expectRowSelected(matcher: RowMatcher, options?: AssertionOptions): Promise<void> {\n    await expectRowSelectedFn(this.getGrid(), matcher, this.config, options);\n  }\n\n  async expectNoRowsOverlay(options?: AssertionOptions): Promise<void> {\n    await expectNoRowsOverlayFn(this.getGrid(), this.config, options);\n  }\n\n  // ─────────────────────────────────────────────────────────────────────────\n  // Actions (stubs - implemented in Phase 4)\n  // ─────────────────────────────────────────────────────────────────────────\n\n  async clickCell(rowMatcher: RowMatcher, colId: string): Promise<void> {\n    const cell = this.getCell(rowMatcher, colId);\n    await cell.click();\n  }\n\n  async editCell(rowMatcher: RowMatcher, colId: string, newValue: string): Promise<void> {\n    const cell = this.getCell(rowMatcher, colId);\n    await cell.dblclick();\n    await cell.locator('input, textarea').fill(newValue);\n    await cell.press('Enter');\n  }\n\n  async sortByColumn(colId: string, direction?: 'asc' | 'desc'): Promise<void> {\n    const header = this.getHeaderCell(colId);\n    // Click until desired direction is reached\n    if (!direction) {\n      await header.click();\n      return;\n    }\n\n    // Click up to 3 times to cycle through sort states\n    for (let i = 0; i < 3; i++) {\n      const currentSort = await header.getAttribute('aria-sort');\n      if (\n        (direction === 'asc' && currentSort === 'ascending') ||\n        (direction === 'desc' && currentSort === 'descending')\n      ) {\n        return;\n      }\n      await header.click();\n      await this.page.waitForTimeout(100);\n    }\n  }\n\n  async filterColumn(colId: string, filterValue: string): Promise<void> {\n    const filterInput = this.getFilterInput(colId);\n    await filterInput.fill(filterValue);\n  }\n\n  async clearFilter(colId: string): Promise<void> {\n    const filterInput = this.getFilterInput(colId);\n    await filterInput.clear();\n  }\n\n  async clearAllFilters(): Promise<void> {\n    // Find all filter inputs and clear them\n    const filterInputs = this.getGrid().locator('.ag-floating-filter input');\n    const count = await filterInputs.count();\n    for (let i = 0; i < count; i++) {\n      await filterInputs.nth(i).clear();\n    }\n  }\n\n  async selectRow(matcher: RowMatcher): Promise<void> {\n    const row = this.getRow(matcher);\n    const checkbox = row.locator('.ag-selection-checkbox input');\n    const checkboxCount = await checkbox.count();\n\n    if (checkboxCount > 0) {\n      await checkbox.check();\n    } else {\n      await row.click();\n    }\n\n    // Wait briefly for selection state to update\n    await this.page.waitForTimeout(50);\n\n    // Verify selection succeeded (post-action verification)\n    // Note: Only fails if row exists but selection didn't register\n    // Some grids may not support selection or may have custom selection handlers\n    const rowCount = await row.count();\n    if (rowCount > 0) {\n      const selected = await isRowSelected(row.first());\n      // Log warning but don't fail - fixture may not have JS selection support\n      if (!selected && checkboxCount > 0) {\n        // Only throw if we explicitly used checkbox (indicates broken selection)\n        throw new Error(\n          `Failed to select row matching: ${formatRowMatcher(matcher)}. ` +\n          `Checkbox was checked but selection state did not change.`\n        );\n      }\n    }\n  }\n\n  async deselectRow(matcher: RowMatcher): Promise<void> {\n    const row = this.getRow(matcher);\n    const checkbox = row.locator('.ag-selection-checkbox input');\n    const checkboxCount = await checkbox.count();\n\n    if (checkboxCount > 0) {\n      await checkbox.uncheck();\n    }\n  }\n\n  async selectAllRows(): Promise<void> {\n    const selectAll = this.getGrid().locator('.ag-header-select-all input');\n    await selectAll.check();\n  }\n\n  async deselectAllRows(): Promise<void> {\n    const selectAll = this.getGrid().locator('.ag-header-select-all input');\n    await selectAll.uncheck();\n  }\n\n  async scrollToRow(matcher: RowMatcher): Promise<void> {\n    // Basic scroll - will be enhanced in Phase 5\n    const row = this.getRow(matcher);\n    await row.scrollIntoViewIfNeeded();\n  }\n\n  async scrollToColumn(colId: string): Promise<void> {\n    const cell = this.getGrid().locator(`.ag-cell[col-id=\"${colId}\"]`).first();\n    await cell.scrollIntoViewIfNeeded();\n  }\n\n  // ─────────────────────────────────────────────────────────────────────────\n  // Enterprise Features (stubs - implemented in Phase 6)\n  // ─────────────────────────────────────────────────────────────────────────\n\n  async expandGroup(matcher: RowMatcher): Promise<void> {\n    const row = this.getRow(matcher);\n    const expandIcon = row.locator('.ag-group-contracted');\n    await expandIcon.click();\n  }\n\n  async collapseGroup(matcher: RowMatcher): Promise<void> {\n    const row = this.getRow(matcher);\n    const collapseIcon = row.locator('.ag-group-expanded');\n    await collapseIcon.click();\n  }\n\n  async expandAllGroups(): Promise<void> {\n    // Optimized: Keep expanding until no more contracted groups exist\n    // This handles dynamically appearing nested groups\n    const maxIterations = 100; // Safety limit\n    let iterations = 0;\n\n    while (iterations < maxIterations) {\n      const contractedGroup = this.getGrid().locator('.ag-group-contracted').first();\n      const count = await contractedGroup.count();\n\n      if (count === 0) {\n        break; // No more contracted groups\n      }\n\n      await contractedGroup.click();\n      await this.page.waitForTimeout(50);\n      iterations++;\n    }\n  }\n\n  async collapseAllGroups(): Promise<void> {\n    // Optimized: Keep collapsing until no more expanded groups exist\n    // Process from deepest level first by collapsing outermost first\n    const maxIterations = 100; // Safety limit\n    let iterations = 0;\n\n    while (iterations < maxIterations) {\n      const expandedGroup = this.getGrid().locator('.ag-group-expanded').first();\n      const count = await expandedGroup.count();\n\n      if (count === 0) {\n        break; // No more expanded groups\n      }\n\n      await expandedGroup.click();\n      await this.page.waitForTimeout(50);\n      iterations++;\n    }\n  }\n\n  async getGroupChildCount(matcher: RowMatcher): Promise<number> {\n    const row = this.getRow(matcher);\n    const childCountEl = row.locator('.ag-group-child-count');\n    const count = await childCountEl.count();\n\n    if (count > 0) {\n      const text = await childCountEl.textContent();\n      const match = text?.match(/\\d+/);\n      return match ? parseInt(match[0], 10) : 0;\n    }\n\n    return 0;\n  }\n\n  async expandMasterRow(matcher: RowMatcher): Promise<void> {\n    const row = this.getRow(matcher);\n    const expandIcon = row.locator('.ag-group-contracted, .ag-row-group-expand');\n    await expandIcon.click();\n  }\n\n  getDetailGrid(_masterRowMatcher: RowMatcher): IAgGridHelper {\n    // Find the detail grid for this master row\n    // TODO: Use masterRowMatcher to find the specific detail grid when needed\n    const detailSelector = '.ag-details-row .ag-root-wrapper';\n    return new AgGridHelperImpl(this.page, {\n      ...this.config,\n      selector: detailSelector,\n    });\n  }\n\n  // ─────────────────────────────────────────────────────────────────────────\n  // Data Extraction\n  // ─────────────────────────────────────────────────────────────────────────\n\n  async getCellValue(rowMatcher: RowMatcher, colId: string): Promise<unknown> {\n    const match = await findRowByMatcher(this.getGrid(), rowMatcher, this.config);\n    if (!match) {\n      const visibleCount = await this.getVisibleRows().count();\n      throw new Error(\n        `Could not find row matching: ${formatRowMatcher(rowMatcher)}. ` +\n        `Grid has ${visibleCount} visible row(s).`\n      );\n    }\n    return match.data.cells[colId];\n  }\n\n  async getRowData(matcher: RowMatcher): Promise<AgGridRowData> {\n    const match = await findRowByMatcher(this.getGrid(), matcher, this.config);\n    if (!match) {\n      const visibleCount = await this.getVisibleRows().count();\n      throw new Error(\n        `Could not find row matching: ${formatRowMatcher(matcher)}. ` +\n        `Grid has ${visibleCount} visible row(s).`\n      );\n    }\n    return match.data;\n  }\n\n  async getAllVisibleRowData(): Promise<AgGridRowData[]> {\n    return getAllVisibleRowDataFn(this.getGrid(), this.config);\n  }\n\n  async getGridState(): Promise<AgGridState> {\n    return getGridStateFn(this.getGrid(), this.config);\n  }\n\n  async getSelectedRowIds(): Promise<string[]> {\n    const selectedRows = this.getGrid().locator('.ag-row-selected');\n    const count = await selectedRows.count();\n    const ids: string[] = [];\n\n    for (let i = 0; i < count; i++) {\n      const rowId = await selectedRows.nth(i).getAttribute('row-id');\n      if (rowId) {\n        ids.push(rowId);\n      }\n    }\n\n    return ids;\n  }\n}\n","/**\n * AG Grid Factory Function\n *\n * Creates AG Grid helper instances.\n *\n * @module grid/ag-grid/factory\n */\n\nimport type { Page } from '@playwright/test';\nimport type { AgGridConfig, AgGridHelper, AgGridFactory } from '../types.js';\nimport { AgGridHelperImpl } from './helper.js';\n\n/**\n * Create an AG Grid helper instance\n *\n * @param page - Playwright page object\n * @param config - Grid configuration (string selector or full config)\n * @returns AG Grid helper instance\n *\n * @example\n * ```typescript\n * // Simple usage with test ID\n * const grid = agGrid(page, 'orders-grid');\n *\n * // Full configuration\n * const grid = agGrid(page, {\n *   selector: 'orders-grid',\n *   columns: [\n *     { colId: 'orderId', type: 'text', displayName: 'Order ID' },\n *     { colId: 'amount', type: 'number', displayName: 'Amount' },\n *   ],\n *   enterprise: { rowGrouping: true }\n * });\n *\n * // Usage in tests\n * await grid.waitForReady();\n * await grid.expectRowCount(10);\n * await grid.expectRowContains({ orderId: 'ORD-001', status: 'Active' });\n * ```\n */\nexport const agGrid: AgGridFactory = (\n  page: Page,\n  config: string | AgGridConfig\n): AgGridHelper => {\n  return new AgGridHelperImpl(page, config);\n};\n"]}
{"version":3,"sources":["../../reporters/journey-reporter.ts","../../reporters/artk-reporter.ts","../../reporters/masking.ts","../../reporters/artifacts.ts"],"names":["dirname","fs"],"mappings":"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","file":"index.cjs","sourcesContent":["/**\n * Journey mapping utilities for ARTK reporters\n *\n * This module provides functions to map Playwright test results back to\n * Journey definitions and calculate aggregated journey status.\n *\n * @module reporters/journey-reporter\n */\n\nimport type { TestCase, TestResult } from '@playwright/test/reporter';\nimport type {\n  JourneyReport,\n  JourneyStatus,\n  JourneyTestMapping,\n  TestArtifacts,\n  TestStatus,\n} from './types.js';\n\n// =============================================================================\n// Journey ID Extraction\n// =============================================================================\n\n/**\n * Extract journey ID from test case\n *\n * Looks for journey ID in:\n * 1. Test annotations (@journey JRN-0001)\n * 2. Test tags (@JRN-0001)\n * 3. Test title (JRN-0001: ...)\n *\n * @param testCase - Playwright test case\n * @returns Journey ID or null if not found\n */\nexport function extractJourneyId(testCase: TestCase): string | null {\n  // Check annotations\n  for (const annotation of testCase.annotations) {\n    if (annotation.type === 'journey') {\n      return annotation.description ?? null;\n    }\n  }\n\n  // Check tags (format: @JRN-0001)\n  const journeyTagRegex = /^@(JRN-\\d+)$/;\n  for (const tag of testCase.tags) {\n    const match = journeyTagRegex.exec(tag);\n    if (match?.[1]) {\n      return match[1];\n    }\n  }\n\n  // Check title (format: \"JRN-0001: Test description\")\n  const titleRegex = /^(JRN-\\d+):/;\n  const titleMatch = titleRegex.exec(testCase.title);\n  if (titleMatch?.[1]) {\n    return titleMatch[1];\n  }\n\n  return null;\n}\n\n// =============================================================================\n// Test to Journey Mapping\n// =============================================================================\n\n/**\n * Map a Playwright test case to a journey test mapping\n *\n * @param testCase - Playwright test case\n * @param result - Test result\n * @returns Journey test mapping\n */\nexport function mapTestToJourney(testCase: TestCase, result: TestResult): JourneyTestMapping {\n  const artifacts = extractTestArtifacts(result);\n\n  return {\n    journeyId: extractJourneyId(testCase) ?? 'UNMAPPED',\n    testTitle: testCase.titlePath().join(' › '),\n    testFile: testCase.location.file,\n    status: result.status as TestStatus,\n    duration: result.duration,\n    retries: result.retry,\n    error: result.error?.message,\n    artifacts,\n  };\n}\n\n/**\n * Extract test artifacts from result\n *\n * @param result - Test result\n * @returns Test artifacts\n */\nfunction extractTestArtifacts(result: TestResult): TestArtifacts {\n  const screenshots: string[] = [];\n  let video: string | undefined;\n  let trace: string | undefined;\n\n  for (const attachment of result.attachments) {\n    if (attachment.name === 'screenshot' && attachment.path) {\n      screenshots.push(attachment.path);\n    } else if (attachment.name === 'video' && attachment.path) {\n      video = attachment.path;\n    } else if (attachment.name === 'trace' && attachment.path) {\n      trace = attachment.path;\n    }\n  }\n\n  return {\n    screenshots,\n    video,\n    trace,\n  };\n}\n\n// =============================================================================\n// Group Tests by Journey\n// =============================================================================\n\n/**\n * Group test mappings by journey ID\n *\n * @param mappings - Array of journey test mappings\n * @returns Map of journey ID to test mappings\n */\nexport function groupTestsByJourney(\n  mappings: readonly JourneyTestMapping[]\n): ReadonlyMap<string, readonly JourneyTestMapping[]> {\n  const groups = new Map<string, JourneyTestMapping[]>();\n\n  for (const mapping of mappings) {\n    const existing = groups.get(mapping.journeyId) ?? [];\n    groups.set(mapping.journeyId, [...existing, mapping]);\n  }\n\n  // Convert to readonly\n  const readonlyGroups = new Map<string, readonly JourneyTestMapping[]>();\n  for (const entry of Array.from(groups.entries())) {\n    const [journeyId, tests] = entry;\n    readonlyGroups.set(journeyId, tests);\n  }\n\n  return readonlyGroups;\n}\n\n// =============================================================================\n// Journey Status Calculation\n// =============================================================================\n\n/**\n * Calculate journey status from test results\n *\n * Logic:\n * - 'failed': Any test failed (even after retries)\n * - 'flaky': All tests passed, but some required retries\n * - 'passed': All tests passed on first attempt\n * - 'skipped': All tests skipped\n * - 'not-run': No tests executed\n *\n * @param tests - Test mappings for a journey\n * @returns Journey status\n */\nexport function calculateJourneyStatus(tests: readonly JourneyTestMapping[]): JourneyStatus {\n  if (tests.length === 0) {\n    return 'not-run';\n  }\n\n  let hasFailed = false;\n  let hasFlaky = false;\n  let allSkipped = true;\n\n  for (const test of tests) {\n    if (test.status === 'failed' || test.status === 'timedOut' || test.status === 'interrupted') {\n      hasFailed = true;\n      allSkipped = false;\n    } else if (test.status === 'passed') {\n      allSkipped = false;\n      if (test.retries > 0) {\n        hasFlaky = true;\n      }\n    } else if (test.status !== 'skipped') {\n      allSkipped = false;\n    }\n  }\n\n  if (hasFailed) {\n    return 'failed';\n  }\n\n  if (allSkipped) {\n    return 'skipped';\n  }\n\n  if (hasFlaky) {\n    return 'flaky';\n  }\n\n  return 'passed';\n}\n\n/**\n * Create a journey report from grouped test mappings\n *\n * @param journeyId - Journey ID\n * @param tests - Test mappings for this journey\n * @returns Journey report\n */\nexport function createJourneyReport(\n  journeyId: string,\n  tests: readonly JourneyTestMapping[]\n): JourneyReport {\n  let passedTests = 0;\n  let failedTests = 0;\n  let skippedTests = 0;\n  let flakyTests = 0;\n  let totalDuration = 0;\n\n  for (const test of tests) {\n    totalDuration += test.duration;\n\n    if (test.status === 'passed') {\n      if (test.retries > 0) {\n        flakyTests++;\n      } else {\n        passedTests++;\n      }\n    } else if (test.status === 'failed' || test.status === 'timedOut' || test.status === 'interrupted') {\n      failedTests++;\n    } else if (test.status === 'skipped') {\n      skippedTests++;\n    }\n  }\n\n  const status = calculateJourneyStatus(tests);\n\n  return {\n    journeyId,\n    status,\n    totalTests: tests.length,\n    passedTests,\n    failedTests,\n    skippedTests,\n    flakyTests,\n    totalDuration,\n    tests,\n  };\n}\n","/**\n * ARTK custom reporter for Playwright\n *\n * This reporter maps test results to Journey definitions and generates\n * ARTK-specific reports with journey status aggregation.\n *\n * @module reporters/artk-reporter\n */\n\nimport type {\n  FullConfig,\n  FullResult,\n  Reporter,\n  Suite,\n  TestCase,\n  TestResult,\n} from '@playwright/test/reporter';\nimport type {\n  ARTKReport,\n  ARTKReporterOptions,\n  JourneyTestMapping,\n  RunSummary,\n} from './types.js';\nimport {\n  createJourneyReport,\n  groupTestsByJourney,\n  mapTestToJourney,\n} from './journey-reporter.js';\nimport { promises as fs } from 'fs';\nimport { dirname } from 'path';\n\n/**\n * ARTK Reporter implementation\n *\n * Usage in playwright.config.ts:\n * ```typescript\n * import { ARTKReporter } from '@artk/core/reporters';\n *\n * export default defineConfig({\n *   reporter: [\n *     ['@artk/core/reporters', {\n *       outputFile: './test-results/artk-report.json',\n *       includeJourneyMapping: true\n *     }]\n *   ]\n * });\n * ```\n */\nexport class ARTKReporter implements Reporter {\n  // Note: config is stored for future use (filtering, metadata, etc.)\n  // Currently not used but kept for API compatibility\n  // private _config: FullConfig | undefined;\n\n  private readonly options: ARTKReporterOptions;\n  private readonly testMappings: JourneyTestMapping[] = [];\n  private startTime: number = 0;\n  private endTime: number = 0;\n\n  constructor(options: ARTKReporterOptions) {\n    this.options = options;\n  }\n\n  /**\n   * Called once before running tests\n   */\n  onBegin(_config: FullConfig, _suite: Suite): void {\n    // this._config = config; // Stored for future use\n    this.startTime = Date.now();\n  }\n\n  /**\n   * Called for each test after it finishes\n   */\n  onTestEnd(test: TestCase, result: TestResult): void {\n    const mapping = mapTestToJourney(test, result);\n    this.testMappings.push(mapping);\n  }\n\n  /**\n   * Called after all tests finish\n   */\n  async onEnd(result: FullResult): Promise<void> {\n    this.endTime = Date.now();\n\n    const report = this.generateARTKReport(result);\n    await this.writeARTKReport(report);\n  }\n\n  /**\n   * Generate ARTK report from collected test mappings\n   */\n  private generateARTKReport(result: FullResult): ARTKReport {\n    const summary = this.createRunSummary(result);\n    const { journeys, unmappedTests } = this.createJourneyReports();\n\n    return {\n      timestamp: new Date().toISOString(),\n      summary,\n      journeys,\n      unmappedTests,\n    };\n  }\n\n  /**\n   * Create run summary from full result\n   */\n  private createRunSummary(result: FullResult): RunSummary {\n    let totalTests = 0;\n    let passed = 0;\n    let failed = 0;\n    let skipped = 0;\n    let flaky = 0;\n\n    for (const mapping of this.testMappings) {\n      totalTests++;\n\n      if (mapping.status === 'passed') {\n        if (mapping.retries > 0) {\n          flaky++;\n        } else {\n          passed++;\n        }\n      } else if (mapping.status === 'failed' || mapping.status === 'timedOut' || mapping.status === 'interrupted') {\n        failed++;\n      } else if (mapping.status === 'skipped') {\n        skipped++;\n      }\n    }\n\n    return {\n      totalTests,\n      passed,\n      failed,\n      skipped,\n      flaky,\n      duration: this.endTime - this.startTime,\n      status: result.status,\n    };\n  }\n\n  /**\n   * Create journey reports from test mappings\n   */\n  private createJourneyReports(): {\n    journeys: readonly ReturnType<typeof createJourneyReport>[];\n    unmappedTests: readonly JourneyTestMapping[];\n  } {\n    if (!this.options.includeJourneyMapping) {\n      return {\n        journeys: [],\n        unmappedTests: [],\n      };\n    }\n\n    // Group tests by journey\n    const grouped = groupTestsByJourney(this.testMappings);\n\n    const journeys: ReturnType<typeof createJourneyReport>[] = [];\n    const unmappedTests: JourneyTestMapping[] = [];\n\n    for (const entry of Array.from(grouped.entries())) {\n      const [journeyId, tests] = entry;\n      if (journeyId === 'UNMAPPED') {\n        unmappedTests.push(...tests);\n      } else {\n        journeys.push(createJourneyReport(journeyId, tests));\n      }\n    }\n\n    return {\n      journeys,\n      unmappedTests,\n    };\n  }\n\n  /**\n   * Write ARTK report to file\n   */\n  private async writeARTKReport(report: ARTKReport): Promise<void> {\n    const outputFile = this.options.outputFile;\n\n    // Ensure output directory exists\n    const outputDir = dirname(outputFile);\n    await fs.mkdir(outputDir, { recursive: true });\n\n    // Write report as JSON\n    const reportJson = JSON.stringify(report, null, 2);\n    await fs.writeFile(outputFile, reportJson, 'utf-8');\n\n    // eslint-disable-next-line no-console\n    console.log(`\\nARTK report written to: ${outputFile}`);\n    this.printSummary(report);\n  }\n\n  /**\n   * Print summary to console\n   */\n  private printSummary(report: ARTKReport): void {\n    const { summary, journeys } = report;\n\n    // eslint-disable-next-line no-console\n    console.log('\\n=== ARTK Test Summary ===');\n    // eslint-disable-next-line no-console\n    console.log(`Total Tests: ${summary.totalTests}`);\n    // eslint-disable-next-line no-console\n    console.log(`Passed: ${summary.passed}`);\n    // eslint-disable-next-line no-console\n    console.log(`Failed: ${summary.failed}`);\n    // eslint-disable-next-line no-console\n    console.log(`Skipped: ${summary.skipped}`);\n    // eslint-disable-next-line no-console\n    console.log(`Flaky: ${summary.flaky}`);\n    // eslint-disable-next-line no-console\n    console.log(`Duration: ${(summary.duration / 1000).toFixed(2)}s`);\n    // eslint-disable-next-line no-console\n    console.log(`Status: ${summary.status}`);\n\n    if (journeys.length > 0) {\n      // eslint-disable-next-line no-console\n      console.log('\\n=== Journey Results ===');\n      for (const journey of journeys) {\n        const statusIcon = journey.status === 'passed' ? '✓' : journey.status === 'failed' ? '✗' : '○';\n        // eslint-disable-next-line no-console\n        console.log(\n          `${statusIcon} ${journey.journeyId}: ${journey.passedTests}/${journey.totalTests} passed (${journey.status})`\n        );\n      }\n    }\n\n    // eslint-disable-next-line no-console\n    console.log('');\n  }\n}\n\n/**\n * Generate ARTK report from test mappings (standalone function)\n *\n * @param mappings - Array of journey test mappings\n * @param includeJourneyMapping - Whether to include journey mapping\n * @returns ARTK report\n */\nexport function generateARTKReport(\n  mappings: readonly JourneyTestMapping[],\n  includeJourneyMapping: boolean = true\n): ARTKReport {\n  const summary = createStandaloneSummary(mappings);\n  const { journeys, unmappedTests } = createStandaloneJourneyReports(mappings, includeJourneyMapping);\n\n  return {\n    timestamp: new Date().toISOString(),\n    summary,\n    journeys,\n    unmappedTests,\n  };\n}\n\n/**\n * Create run summary from mappings (standalone)\n */\nfunction createStandaloneSummary(mappings: readonly JourneyTestMapping[]): RunSummary {\n  let passed = 0;\n  let failed = 0;\n  let skipped = 0;\n  let flaky = 0;\n  let totalDuration = 0;\n\n  for (const mapping of mappings) {\n    totalDuration += mapping.duration;\n\n    if (mapping.status === 'passed') {\n      if (mapping.retries > 0) {\n        flaky++;\n      } else {\n        passed++;\n      }\n    } else if (mapping.status === 'failed' || mapping.status === 'timedOut' || mapping.status === 'interrupted') {\n      failed++;\n    } else if (mapping.status === 'skipped') {\n      skipped++;\n    }\n  }\n\n  return {\n    totalTests: mappings.length,\n    passed,\n    failed,\n    skipped,\n    flaky,\n    duration: totalDuration,\n    status: failed > 0 ? 'failed' : 'passed',\n  };\n}\n\n/**\n * Create journey reports (standalone)\n */\nfunction createStandaloneJourneyReports(\n  mappings: readonly JourneyTestMapping[],\n  includeJourneyMapping: boolean\n): {\n  journeys: readonly ReturnType<typeof createJourneyReport>[];\n  unmappedTests: readonly JourneyTestMapping[];\n} {\n  if (!includeJourneyMapping) {\n    return {\n      journeys: [],\n      unmappedTests: [],\n    };\n  }\n\n  const grouped = groupTestsByJourney(mappings);\n  const journeys: ReturnType<typeof createJourneyReport>[] = [];\n  const unmappedTests: JourneyTestMapping[] = [];\n\n  for (const entry of Array.from(grouped.entries())) {\n    const [journeyId, tests] = entry;\n    if (journeyId === 'UNMAPPED') {\n      unmappedTests.push(...tests);\n    } else {\n      journeys.push(createJourneyReport(journeyId, tests));\n    }\n  }\n\n  return {\n    journeys,\n    unmappedTests,\n  };\n}\n\n/**\n * Write ARTK report to file (standalone function)\n *\n * @param report - ARTK report\n * @param outputFile - Output file path\n * @returns Promise that resolves when report is written\n */\nexport async function writeARTKReport(report: ARTKReport, outputFile: string): Promise<void> {\n  const outputDir = dirname(outputFile);\n  await fs.mkdir(outputDir, { recursive: true });\n\n  const reportJson = JSON.stringify(report, null, 2);\n  await fs.writeFile(outputFile, reportJson, 'utf-8');\n}\n","/**\n * PII masking utilities for screenshots\n *\n * This module provides functions to mask Personally Identifiable Information (PII)\n * in screenshots before saving them to artifacts.\n *\n * @module reporters/masking\n */\n\nimport type { Page } from '@playwright/test';\nimport type { MaskingOptions } from './types.js';\n\n/**\n * Default masking color (black)\n */\nconst DEFAULT_MASK_COLOR = '#000000';\n\n/**\n * Mask PII in a screenshot by applying CSS-based masking to specified selectors\n *\n * This function works by:\n * 1. Injecting CSS to hide/mask elements matching PII selectors\n * 2. Taking the screenshot with masked elements\n * 3. Removing the injected CSS to restore page state\n *\n * @param page - Playwright page instance\n * @param options - Masking options with selectors\n * @returns Promise that resolves when masking is applied\n *\n * @example\n * ```typescript\n * await maskPiiInScreenshot(page, {\n *   selectors: ['.user-email', '.ssn', '[data-testid=\"personal-info\"]'],\n *   maskColor: '#000000'\n * });\n * ```\n */\nexport async function maskPiiInScreenshot(\n  page: Page,\n  options: MaskingOptions\n): Promise<void> {\n  if (options.selectors.length === 0) {\n    return;\n  }\n\n  const maskColor = options.maskColor ?? DEFAULT_MASK_COLOR;\n  const blurRadius = options.blurRadius;\n\n  // Build CSS selector for all PII elements\n  const selectorList = options.selectors.join(', ');\n\n  // Build CSS rules\n  const cssRules: string[] = [];\n\n  if (blurRadius !== undefined && blurRadius > 0) {\n    // Use blur filter\n    cssRules.push(`\n      ${selectorList} {\n        filter: blur(${blurRadius}px) !important;\n        -webkit-filter: blur(${blurRadius}px) !important;\n      }\n    `);\n  } else {\n    // Use solid color mask\n    cssRules.push(`\n      ${selectorList} {\n        background-color: ${maskColor} !important;\n        color: ${maskColor} !important;\n        border-color: ${maskColor} !important;\n        opacity: 1 !important;\n      }\n      ${selectorList} * {\n        visibility: hidden !important;\n      }\n    `);\n  }\n\n  const cssContent = cssRules.join('\\n');\n\n  // Inject masking CSS\n  await page.addStyleTag({\n    content: cssContent,\n  });\n\n  // Wait a tick for CSS to apply\n  await page.waitForTimeout(100);\n}\n\n/**\n * Remove PII masking from page\n *\n * This is a best-effort cleanup. Since addStyleTag returns a handle,\n * we rely on the caller to manage cleanup or page reload.\n *\n * @param page - Playwright page instance\n * @returns Promise that resolves when masking is removed\n */\nexport async function removePiiMasking(page: Page): Promise<void> {\n  // Remove all style tags with our masking rules\n  await page.evaluate(() => {\n    const styles = document.querySelectorAll('style');\n    for (const style of Array.from(styles)) {\n      if (style.textContent?.includes('!important')) {\n        style.remove();\n      }\n    }\n  });\n}\n\n/**\n * Validate PII selectors\n *\n * Ensures all selectors are valid CSS selectors before attempting to mask.\n *\n * @param selectors - Array of CSS selectors\n * @returns True if all selectors are valid\n */\nexport function validatePiiSelectors(selectors: readonly string[]): boolean {\n  for (const selector of selectors) {\n    try {\n      // Try to use querySelector to validate selector syntax\n      document.querySelector(selector);\n    } catch {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Sanitize PII selectors\n *\n * Removes invalid selectors and returns only valid ones.\n *\n * @param selectors - Array of CSS selectors\n * @returns Array of valid CSS selectors\n */\nexport function sanitizePiiSelectors(selectors: readonly string[]): readonly string[] {\n  const valid: string[] = [];\n\n  for (const selector of selectors) {\n    try {\n      // Test if selector is valid\n      document.querySelector(selector);\n      valid.push(selector);\n    } catch {\n      // Skip invalid selectors\n      continue;\n    }\n  }\n\n  return valid;\n}\n","/**\n * Artifact management utilities for reporters\n *\n * This module provides functions for saving test artifacts with optional\n * PII masking for screenshots.\n *\n * @module reporters/artifacts\n */\n\nimport type { Page } from '@playwright/test';\nimport type { ScreenshotOptions } from './types.js';\nimport { maskPiiInScreenshot, removePiiMasking } from './masking.js';\nimport { promises as fs } from 'fs';\nimport { dirname } from 'path';\n\n/**\n * Save a screenshot with optional PII masking\n *\n * This function:\n * 1. Optionally applies PII masking to specified selectors\n * 2. Takes the screenshot\n * 3. Removes masking to restore page state\n * 4. Saves the screenshot to the specified path\n *\n * @param page - Playwright page instance\n * @param options - Screenshot save options\n * @returns Promise that resolves when screenshot is saved\n *\n * @example\n * ```typescript\n * await saveScreenshot(page, {\n *   path: './screenshots/test-result.png',\n *   maskPii: true,\n *   piiSelectors: ['.user-email', '.ssn']\n * });\n * ```\n */\nexport async function saveScreenshot(\n  page: Page,\n  options: ScreenshotOptions\n): Promise<void> {\n  // Ensure output directory exists\n  const outputDir = dirname(options.path);\n  await fs.mkdir(outputDir, { recursive: true });\n\n  // Apply PII masking if requested\n  if (options.maskPii && options.piiSelectors && options.piiSelectors.length > 0) {\n    await maskPiiInScreenshot(page, {\n      selectors: options.piiSelectors,\n    });\n\n    try {\n      // Take screenshot with masking applied\n      await page.screenshot({\n        path: options.path,\n        fullPage: true,\n      });\n    } finally {\n      // Always remove masking to restore page state\n      await removePiiMasking(page);\n    }\n  } else {\n    // Take screenshot without masking\n    await page.screenshot({\n      path: options.path,\n      fullPage: true,\n    });\n  }\n}\n\n/**\n * Ensure directory exists for artifact storage\n *\n * @param dirPath - Directory path\n * @returns Promise that resolves when directory exists\n */\nexport async function ensureArtifactDir(dirPath: string): Promise<void> {\n  await fs.mkdir(dirPath, { recursive: true });\n}\n\n/**\n * Get artifact file extension from path\n *\n * @param filePath - File path\n * @returns File extension (e.g., 'png', 'json', 'webm')\n */\nexport function getArtifactExtension(filePath: string): string {\n  const parts = filePath.split('.');\n  return parts[parts.length - 1] ?? '';\n}\n\n/**\n * Validate artifact path\n *\n * Ensures path is safe and doesn't contain path traversal attempts.\n *\n * @param filePath - File path to validate\n * @returns True if path is valid\n */\nexport function validateArtifactPath(filePath: string): boolean {\n  // Check for path traversal attempts\n  if (filePath.includes('..')) {\n    return false;\n  }\n\n  // Check for absolute paths (we want relative paths)\n  if (filePath.startsWith('/') || /^[A-Z]:/i.test(filePath)) {\n    return false;\n  }\n\n  return true;\n}\n"]}
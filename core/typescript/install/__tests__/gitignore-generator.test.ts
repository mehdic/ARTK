/**
 * Unit tests for .gitignore generator
 *
 * @group unit
 * @group install
 */

import { describe, expect, it } from 'vitest';
import {
  generateGitignore,
  generateMinimalGitignore,
  mergeGitignore,
  GITIGNORE_PATTERNS,
  type GitignoreOptions,
} from '../gitignore-generator.js';

// =============================================================================
// generateGitignore Tests
// =============================================================================

describe('generateGitignore', () => {
  describe('header', () => {
    it('should include ARTK header', () => {
      const gitignore = generateGitignore();

      expect(gitignore).toContain('# ARTK E2E .gitignore');
      expect(gitignore).toContain('# Generated by ARTK install');
    });

    it('should include date in header', () => {
      const gitignore = generateGitignore();
      const today = new Date().toISOString().split('T')[0];

      expect(gitignore).toContain(today);
    });
  });

  describe('default sections', () => {
    it('should always include dependencies section', () => {
      const gitignore = generateGitignore();

      expect(gitignore).toContain('# Dependencies');
      expect(gitignore).toContain('node_modules/');
    });

    it('should always include build section', () => {
      const gitignore = generateGitignore();

      expect(gitignore).toContain('# Build Output');
      expect(gitignore).toContain('dist/');
      expect(gitignore).toContain('build/');
    });

    it('should always include environment section', () => {
      const gitignore = generateGitignore();

      expect(gitignore).toContain('# Environment');
      expect(gitignore).toContain('.env');
      expect(gitignore).toContain('.env.local');
    });

    it('should always include logs section', () => {
      const gitignore = generateGitignore();

      expect(gitignore).toContain('# Logs');
      expect(gitignore).toContain('*.log');
      expect(gitignore).toContain('npm-debug.log*');
    });

    it('should preserve vendor directory', () => {
      const gitignore = generateGitignore();

      expect(gitignore).toContain('!vendor/');
      expect(gitignore).toContain('!vendor/**');
    });

    it('should preserve example env files', () => {
      const gitignore = generateGitignore();

      expect(gitignore).toContain('!.env.example');
      expect(gitignore).toContain('!.env.template');
    });
  });

  describe('auth states section', () => {
    it('should include auth states by default', () => {
      const gitignore = generateGitignore();

      expect(gitignore).toContain('# Auth Storage States (sensitive)');
      expect(gitignore).toContain('.auth-states/');
      expect(gitignore).toContain('*.storageState.json');
    });

    it('should preserve .gitkeep in auth-states', () => {
      const gitignore = generateGitignore({ includeAuthStates: true });

      expect(gitignore).toContain('!.auth-states/.gitkeep');
    });

    it('should exclude auth states when disabled', () => {
      const gitignore = generateGitignore({ includeAuthStates: false });

      expect(gitignore).not.toContain('# Auth Storage States');
      expect(gitignore).not.toContain('.auth-states/');
    });
  });

  describe('test artifacts section', () => {
    it('should include test artifacts by default', () => {
      const gitignore = generateGitignore();

      expect(gitignore).toContain('# Test Artifacts');
      expect(gitignore).toContain('test-results/');
      expect(gitignore).toContain('playwright-report/');
      expect(gitignore).toContain('blob-report/');
      expect(gitignore).toContain('.playwright/');
      expect(gitignore).toContain('*.trace.zip');
    });

    it('should include screenshots and videos', () => {
      const gitignore = generateGitignore({ includeTestArtifacts: true });

      expect(gitignore).toContain('screenshots/');
      expect(gitignore).toContain('videos/');
    });

    it('should exclude test artifacts when disabled', () => {
      const gitignore = generateGitignore({ includeTestArtifacts: false });

      expect(gitignore).not.toContain('# Test Artifacts');
      expect(gitignore).not.toContain('test-results/');
      expect(gitignore).not.toContain('playwright-report/');
    });
  });

  describe('coverage section', () => {
    it('should include coverage by default', () => {
      const gitignore = generateGitignore();

      expect(gitignore).toContain('# Coverage');
      expect(gitignore).toContain('coverage/');
      expect(gitignore).toContain('.nyc_output/');
      expect(gitignore).toContain('*.lcov');
    });

    it('should exclude coverage when disabled', () => {
      const gitignore = generateGitignore({ includeCoverage: false });

      expect(gitignore).not.toContain('# Coverage');
      expect(gitignore).not.toContain('coverage/');
    });
  });

  describe('IDE files section', () => {
    it('should include IDE files by default', () => {
      const gitignore = generateGitignore();

      expect(gitignore).toContain('# IDE and Editor');
      expect(gitignore).toContain('.idea/');
      expect(gitignore).toContain('.vscode/');
      expect(gitignore).toContain('*.swp');
      expect(gitignore).toContain('*.swo');
    });

    it('should include additional IDE patterns', () => {
      const gitignore = generateGitignore({ includeIdeFiles: true });

      expect(gitignore).toContain('.project');
      expect(gitignore).toContain('.classpath');
      expect(gitignore).toContain('.settings/');
    });

    it('should exclude IDE files when disabled', () => {
      const gitignore = generateGitignore({ includeIdeFiles: false });

      expect(gitignore).not.toContain('# IDE and Editor');
      expect(gitignore).not.toContain('.idea/');
      expect(gitignore).not.toContain('.vscode/');
    });
  });

  describe('OS files section', () => {
    it('should include OS files by default', () => {
      const gitignore = generateGitignore();

      expect(gitignore).toContain('# OS Files');
      expect(gitignore).toContain('.DS_Store');
      expect(gitignore).toContain('Thumbs.db');
      expect(gitignore).toContain('Desktop.ini');
    });

    it('should exclude OS files when disabled', () => {
      const gitignore = generateGitignore({ includeOsFiles: false });

      expect(gitignore).not.toContain('# OS Files');
      expect(gitignore).not.toContain('.DS_Store');
    });
  });

  describe('additional patterns', () => {
    it('should include additional patterns', () => {
      const gitignore = generateGitignore({
        additionalPatterns: ['custom-folder/', '*.custom', 'tmp/**'],
      });

      expect(gitignore).toContain('# Additional Patterns');
      expect(gitignore).toContain('custom-folder/');
      expect(gitignore).toContain('*.custom');
      expect(gitignore).toContain('tmp/**');
    });

    it('should not add section for empty additional patterns', () => {
      const gitignore = generateGitignore({ additionalPatterns: [] });

      expect(gitignore).not.toContain('# Additional Patterns');
    });
  });

  describe('exceptions', () => {
    it('should include exceptions at the end', () => {
      const gitignore = generateGitignore({
        exceptions: ['important.log', 'keep-this-folder/'],
      });

      expect(gitignore).toContain('# Exceptions (never ignore)');
      expect(gitignore).toContain('!important.log');
      expect(gitignore).toContain('!keep-this-folder/');
    });

    it('should not add section for empty exceptions', () => {
      const gitignore = generateGitignore({ exceptions: [] });

      const lines = gitignore.split('\n');
      // Find lines that are only about exceptions (not built-in exceptions like !vendor/)
      const exceptionSection = lines.filter((l) => l === '# Exceptions (never ignore)');

      expect(exceptionSection.length).toBe(0);
    });
  });

  describe('all options disabled', () => {
    it('should only include required sections', () => {
      const gitignore = generateGitignore({
        includeAuthStates: false,
        includeTestArtifacts: false,
        includeCoverage: false,
        includeIdeFiles: false,
        includeOsFiles: false,
      });

      // Should still have required sections
      expect(gitignore).toContain('# Dependencies');
      expect(gitignore).toContain('# Build Output');
      expect(gitignore).toContain('# Environment');
      expect(gitignore).toContain('# Logs');

      // Should not have optional sections
      expect(gitignore).not.toContain('# Auth Storage States');
      expect(gitignore).not.toContain('# Test Artifacts');
      expect(gitignore).not.toContain('# Coverage');
      expect(gitignore).not.toContain('# IDE and Editor');
      expect(gitignore).not.toContain('# OS Files');
    });
  });
});

// =============================================================================
// generateMinimalGitignore Tests
// =============================================================================

describe('generateMinimalGitignore', () => {
  it('should be minimal', () => {
    const gitignore = generateMinimalGitignore();

    // Count lines (excluding empty lines)
    const lines = gitignore.split('\n').filter((l) => l.trim());

    expect(lines.length).toBeLessThan(10);
  });

  it('should include header comment', () => {
    const gitignore = generateMinimalGitignore();

    expect(gitignore).toContain('# ARTK E2E Minimal .gitignore');
  });

  it('should include node_modules', () => {
    const gitignore = generateMinimalGitignore();

    expect(gitignore).toContain('node_modules/');
  });

  it('should include auth-states', () => {
    const gitignore = generateMinimalGitignore();

    expect(gitignore).toContain('.auth-states/');
  });

  it('should include test-results', () => {
    const gitignore = generateMinimalGitignore();

    expect(gitignore).toContain('test-results/');
  });

  it('should include playwright-report', () => {
    const gitignore = generateMinimalGitignore();

    expect(gitignore).toContain('playwright-report/');
  });

  it('should include .env', () => {
    const gitignore = generateMinimalGitignore();

    expect(gitignore).toContain('.env');
  });

  it('should include *.log', () => {
    const gitignore = generateMinimalGitignore();

    expect(gitignore).toContain('*.log');
  });
});

// =============================================================================
// mergeGitignore Tests
// =============================================================================

describe('mergeGitignore', () => {
  it('should append ARTK patterns to existing content', () => {
    const existing = `# Existing .gitignore
node_modules/
.env
`;
    const merged = mergeGitignore(existing);

    expect(merged).toContain('# Existing .gitignore');
    expect(merged).toContain('node_modules/');
    expect(merged).toContain('# ARTK E2E Additions');
  });

  it('should not duplicate existing patterns', () => {
    const existing = `node_modules/
.env
test-results/
`;
    const merged = mergeGitignore(existing);

    // Count occurrences of node_modules/
    const count = (merged.match(/node_modules\//g) || []).length;

    expect(count).toBe(1);
  });

  it('should add separator if existing does not end with newline', () => {
    const existing = 'node_modules/';
    const merged = mergeGitignore(existing);

    expect(merged).toContain('node_modules/\n');
  });

  it('should not add separator if existing ends with newline', () => {
    const existing = 'node_modules/\n';
    const merged = mergeGitignore(existing);

    // Should not have double newline before ARTK additions
    expect(merged).not.toContain('node_modules/\n\n\n');
  });

  it('should return original if no new patterns to add', () => {
    // Create existing content with all ARTK patterns already present
    const existing = generateGitignore();
    const merged = mergeGitignore(existing);

    expect(merged).toBe(existing);
  });

  it('should skip comments when checking for duplicates', () => {
    const existing = `# My gitignore
node_modules/

# Test stuff
test-results/
`;
    const merged = mergeGitignore(existing);

    // Should not duplicate these patterns
    const nodeModulesCount = (merged.match(/node_modules\//g) || []).length;
    const testResultsCount = (merged.match(/test-results\//g) || []).length;

    expect(nodeModulesCount).toBe(1);
    expect(testResultsCount).toBe(1);
  });

  it('should add new patterns that are not in existing', () => {
    const existing = `node_modules/
`;
    const merged = mergeGitignore(existing, { includeAuthStates: true });

    expect(merged).toContain('.auth-states/');
    expect(merged).toContain('# ARTK E2E Additions');
  });

  it('should handle empty existing content', () => {
    const merged = mergeGitignore('');

    expect(merged).toContain('# ARTK E2E Additions');
    expect(merged).toContain('node_modules/');
  });

  it('should pass options to generateGitignore', () => {
    const existing = 'node_modules/\n';
    const merged = mergeGitignore(existing, {
      includeAuthStates: true,
      includeTestArtifacts: true,
    });

    expect(merged).toContain('.auth-states/');
    expect(merged).toContain('test-results/');
  });

  it('should handle whitespace-only lines in existing', () => {
    const existing = `node_modules/


.env
`;
    const merged = mergeGitignore(existing);

    // Should work without errors
    expect(merged).toContain('node_modules/');
    expect(merged).toContain('.env');
  });
});

// =============================================================================
// GITIGNORE_PATTERNS Tests
// =============================================================================

describe('GITIGNORE_PATTERNS', () => {
  it('should have authStates patterns', () => {
    expect(GITIGNORE_PATTERNS.authStates).toContain('.auth-states/');
    expect(GITIGNORE_PATTERNS.authStates).toContain('*.storageState.json');
  });

  it('should have testArtifacts patterns', () => {
    expect(GITIGNORE_PATTERNS.testArtifacts).toContain('test-results/');
    expect(GITIGNORE_PATTERNS.testArtifacts).toContain('playwright-report/');
    expect(GITIGNORE_PATTERNS.testArtifacts).toContain('*.trace.zip');
  });

  it('should have coverage patterns', () => {
    expect(GITIGNORE_PATTERNS.coverage).toContain('coverage/');
    expect(GITIGNORE_PATTERNS.coverage).toContain('.nyc_output/');
  });

  it('should have dependencies patterns', () => {
    expect(GITIGNORE_PATTERNS.dependencies).toContain('node_modules/');
  });

  it('should have environment patterns', () => {
    expect(GITIGNORE_PATTERNS.environment).toContain('.env');
    expect(GITIGNORE_PATTERNS.environment).toContain('.env.local');
  });

  it('should be readonly', () => {
    // TypeScript enforces this at compile time via `as const`
    // We just verify the object exists and has expected shape
    expect(Object.keys(GITIGNORE_PATTERNS)).toEqual([
      'authStates',
      'testArtifacts',
      'coverage',
      'dependencies',
      'environment',
    ]);
  });
});

// =============================================================================
// Edge Cases and Integration Tests
// =============================================================================

describe('edge cases', () => {
  it('should handle all options enabled', () => {
    const gitignore = generateGitignore({
      includeAuthStates: true,
      includeTestArtifacts: true,
      includeCoverage: true,
      includeIdeFiles: true,
      includeOsFiles: true,
      additionalPatterns: ['custom/'],
      exceptions: ['keep.txt'],
    });

    // All sections should be present
    expect(gitignore).toContain('# Auth Storage States');
    expect(gitignore).toContain('# Test Artifacts');
    expect(gitignore).toContain('# Coverage');
    expect(gitignore).toContain('# IDE and Editor');
    expect(gitignore).toContain('# OS Files');
    expect(gitignore).toContain('# Additional Patterns');
    expect(gitignore).toContain('# Exceptions');
  });

  it('should handle undefined options', () => {
    const gitignore = generateGitignore(undefined);

    expect(gitignore).toContain('# ARTK E2E .gitignore');
    expect(gitignore).toContain('node_modules/');
  });

  it('should handle empty options object', () => {
    const gitignore = generateGitignore({});

    expect(gitignore).toContain('# ARTK E2E .gitignore');
    expect(gitignore).toContain('node_modules/');
  });

  it('should produce consistent output', () => {
    const gitignore1 = generateGitignore({ includeAuthStates: true });
    const gitignore2 = generateGitignore({ includeAuthStates: true });

    // Remove date line for comparison (it includes today's date)
    const normalize = (s: string) =>
      s.split('\n').filter((l) => !l.includes(new Date().toISOString().split('T')[0])).join('\n');

    expect(normalize(gitignore1)).toBe(normalize(gitignore2));
  });
});

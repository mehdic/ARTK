# Auth Abstraction Pattern: Building Generic Auth Without Knowing the App

**Date:** 2024-12-29
**Topic:** How to build reusable auth infrastructure that adapts to any project

---

## The Core Question

> "If we build auth core, won't it have to adapt to each project? How can we build core auth whilst knowing nothing about the client app?"

---

## The Key Insight

**We don't build the login code — we build the login infrastructure.**

Every app has different:
- Login page URL
- Form field selectors
- Submit button
- Success indicators
- Auth mechanisms (form, SSO, token)

But every app ALSO needs the same:
- Storage state management (save/load session)
- Setup project pattern (login once, reuse)
- Multi-role handling (admin vs user)
- Credential management (from env vars)
- Session caching (don't re-login every test)

**Core = Infrastructure (universal)**
**Config = Specifics (per-project)**

---

## The Pattern: Config-Driven Providers

### What Core Provides (Generic)

```typescript
// core/auth/providers/form.ts

export interface FormAuthConfig {
  loginUrl: string;
  fields: {
    username: string;  // selector
    password: string;  // selector
  };
  submit: string;      // selector
  success: {
    url?: string | RegExp;
    selector?: string;
  };
}

export class FormAuthProvider implements AuthProvider {
  constructor(private config: FormAuthConfig) {}

  async login(page: Page, credentials: Credentials): Promise<void> {
    await page.goto(this.config.loginUrl);
    await page.fill(this.config.fields.username, credentials.username);
    await page.fill(this.config.fields.password, credentials.password);
    await page.click(this.config.submit);

    // Wait for success indicator
    if (this.config.success.url) {
      await page.waitForURL(this.config.success.url);
    } else if (this.config.success.selector) {
      await page.waitForSelector(this.config.success.selector);
    }
  }
}
```

**Notice:** The code knows HOW to do form login, but doesn't know WHERE or WHAT. That comes from config.

### What Config Provides (Project-Specific)

```yaml
# artk.config.yml in target project

auth:
  provider: form

  roles:
    admin:
      credentialsEnv: [ADMIN_USER, ADMIN_PASS]
    standardUser:
      credentialsEnv: [USER_EMAIL, USER_PASS]

  form:
    loginUrl: /auth/login
    fields:
      username: '[data-testid="email-input"]'
      password: '[data-testid="password-input"]'
    submit: '[data-testid="login-button"]'
    success:
      url: /dashboard
```

**Notice:** The config knows WHERE and WHAT, but doesn't contain logic.

### How They Connect

```typescript
// Generated by /foundation-build in target project

import { FormAuthProvider, loadAuthConfig } from '@artk/auth';
import { artkConfig } from './artk.config';

// Core provider + project config = working auth
export const authProvider = new FormAuthProvider(artkConfig.auth.form);
```

---

## Multiple Provider Types

### 1. Form Login (Most Common ~70% of apps)

```yaml
auth:
  provider: form
  form:
    loginUrl: /login
    fields:
      username: '#email'
      password: '#password'
    submit: 'button[type="submit"]'
    success:
      url: /home
```

Core handles: Navigation, filling fields, clicking, waiting for success.
Config provides: URLs and selectors.

### 2. Token Injection (API-based ~20% of apps)

```yaml
auth:
  provider: token
  token:
    endpoint: /api/auth/login
    method: POST
    body:
      username: '{{username}}'
      password: '{{password}}'
    extractToken: response.data.accessToken
    storage:
      type: localStorage  # or cookie
      key: auth_token
    successUrl: /dashboard  # navigate here after injection
```

Core handles: API call, token extraction, storage injection, navigation.
Config provides: Endpoint, body shape, where to store token.

### 3. SSO/OAuth (Complex ~10% of apps)

```yaml
auth:
  provider: sso
  sso:
    # SSO is complex - often needs custom handling
    pattern: oauth2  # or saml, oidc
    idpDomain: login.company.com
    callbackPath: /auth/callback
    # Often requires custom provider extension
```

Core handles: Basic redirect patterns, callback waiting.
Config provides: Domains, paths.
**Often needs:** Custom provider extension (see below).

### 4. Custom (Escape Hatch)

When standard patterns don't fit:

```yaml
auth:
  provider: custom
  custom:
    providerPath: ./auth/my-custom-auth.provider.ts
```

---

## The Escape Hatch: Custom Provider

For apps with weird auth that doesn't fit patterns:

```typescript
// core/auth/providers/custom.ts

export abstract class CustomAuthProvider implements AuthProvider {
  // User MUST implement this
  abstract login(page: Page, credentials: Credentials): Promise<void>;

  // User gets these for FREE from core
  protected async saveStorageState(page: Page, path: string): Promise<void> {
    await page.context().storageState({ path });
  }

  protected async isStateValid(path: string, maxAgeMs: number): Promise<boolean> {
    // Check if saved state exists and isn't expired
  }

  protected getCredentials(role: string): Credentials {
    // Read from env vars based on config
  }
}
```

Then `/foundation-build` prompt generates:

```typescript
// Target project: src/auth/app-auth.provider.ts

import { CustomAuthProvider, Credentials } from '@artk/auth';
import { Page } from '@playwright/test';

export class AppAuthProvider extends CustomAuthProvider {
  async login(page: Page, credentials: Credentials): Promise<void> {
    // AI generates this based on app discovery
    await page.goto('/sso-entry');
    await page.click('[data-testid="enterprise-login"]');

    // Handle redirect to IdP
    await page.waitForURL(/login\.okta\.com/);
    await page.fill('#username', credentials.username);
    await page.fill('#password', credentials.password);
    await page.click('#submit-btn');

    // Wait for callback
    await page.waitForURL(/\/auth\/callback/);
    await page.waitForURL('/dashboard');
  }
}
```

**Key point:** Even custom auth uses core utilities (storage state, credentials, etc.)

---

## What Core Actually Contains

```
core/auth/
├── types.ts                    # Interfaces
│   ├── AuthProvider
│   ├── AuthConfig
│   ├── Credentials
│   └── Role
│
├── storage-state.ts            # Universal utilities
│   ├── saveState()
│   ├── loadState()
│   ├── isStateValid()
│   └── clearState()
│
├── credentials.ts              # Credential management
│   ├── getCredentialsForRole()
│   └── validateCredentialsEnv()
│
├── setup-project.ts            # Playwright setup project helper
│   └── createAuthSetup()
│
├── providers/
│   ├── base.ts                 # Abstract base
│   ├── form.ts                 # FormAuthProvider
│   ├── token.ts                # TokenAuthProvider
│   └── custom.ts               # CustomAuthProvider (abstract)
│
├── multi-role.ts               # Multi-role handling
│   ├── RoleManager
│   └── getStatePathForRole()
│
└── index.ts                    # Exports
```

---

## The Three-Layer Model

```
┌────────────────────────────────────────────────────────────┐
│ Layer 3: Project-Specific (Generated by Prompts/AI)        │
│ - Custom provider implementations                          │
│ - Unusual auth flows                                       │
│ - App-specific workarounds                                 │
├────────────────────────────────────────────────────────────┤
│ Layer 2: Configuration (artk.config.yml)                   │
│ - URLs, selectors, endpoints                               │
│ - Role definitions                                         │
│ - Provider selection                                       │
├────────────────────────────────────────────────────────────┤
│ Layer 1: Core Infrastructure (Pre-built)                   │
│ - Provider implementations (form, token)                   │
│ - Storage state management                                 │
│ - Setup project pattern                                    │
│ - Credential handling                                      │
│ - Multi-role support                                       │
└────────────────────────────────────────────────────────────┘
```

**80% of projects:** Layer 1 + Layer 2 only (config-driven)
**20% of projects:** Need Layer 3 (AI generates custom code)

---

## How This Answers the Question

### "Won't it have to adapt to each project?"

**Yes, but adaptation happens in CONFIG, not CODE.**

The core auth code is the same for every project. What changes:
- `artk.config.yml` specifies selectors, URLs, provider type
- If that's not enough, AI generates a thin custom provider

### "How can we build it knowing nothing about the client app?"

**We know the PATTERNS, not the specifics.**

We know:
- Form login = go to URL, fill fields, click submit, wait for success
- Token auth = call API, extract token, inject to storage
- All apps need = save state, load state, handle multiple roles

We don't know:
- What URL? → Config
- What selectors? → Config
- What API endpoint? → Config
- Weird SSO flow? → AI generates custom provider

---

## Validation: How Other Tools Do This

### Playwright
- Provides `storageState` mechanism
- Provides project dependencies
- Documents patterns
- **User implements specifics**

### Cypress
- Provides `cy.session()` for caching
- Documents patterns
- **User implements `cy.login()`**

### ARTK Advantage
- Provides config-driven providers (less code to write)
- Provides multi-role handling built-in
- AI generates custom code when config isn't enough
- **User just configures, or AI generates**

---

## Practical Example

### Project A: Simple Form Login

```yaml
# artk.config.yml
auth:
  provider: form
  form:
    loginUrl: /login
    fields:
      username: '#email'
      password: '#password'
    submit: '#login-btn'
    success:
      url: /dashboard
```

**Result:** Zero custom code. Core FormAuthProvider + config = working auth.

### Project B: API Token Auth

```yaml
# artk.config.yml
auth:
  provider: token
  token:
    endpoint: /api/v1/auth/token
    method: POST
    body:
      email: '{{username}}'
      password: '{{password}}'
    extractToken: data.jwt
    storage:
      type: localStorage
      key: accessToken
```

**Result:** Zero custom code. Core TokenAuthProvider + config = working auth.

### Project C: Weird Okta SSO

```yaml
# artk.config.yml
auth:
  provider: custom
  custom:
    providerPath: ./src/auth/okta.provider.ts
```

```typescript
// Generated by /foundation-build (AI-created)
import { CustomAuthProvider } from '@artk/auth';

export class OktaAuthProvider extends CustomAuthProvider {
  async login(page, credentials) {
    // AI analyzes app and generates this
    await page.goto('/login');
    await page.click('[data-testid="okta-sso"]');
    await page.waitForURL(/.*okta\.com.*/);
    await page.fill('#okta-signin-username', credentials.username);
    await page.fill('#okta-signin-password', credentials.password);
    await page.click('#okta-signin-submit');
    await page.waitForURL('/dashboard');
  }
}
```

**Result:** AI generates ~15 lines of custom code. Still uses core utilities.

---

## Summary

| Aspect | Where It Lives | Who Creates It |
|--------|---------------|----------------|
| Auth patterns (form, token) | Core | Pre-built |
| Storage state management | Core | Pre-built |
| Multi-role handling | Core | Pre-built |
| URLs and selectors | Config | User or /init |
| Standard provider config | Config | User or /discover |
| Custom auth flows | Project code | AI via /foundation-build |

**The core is viable because we separate PATTERN from SPECIFICS.**

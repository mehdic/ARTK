# LLKB-AutoGen Integration: Full Technical Specification

**Date:** 2026-01-23
**Topic:** Complete technical specification for integrating LLKB with AutoGen in ARTK
**Prerequisite:** `research/2026-01-23_llkb-autogen-integration-debate.md`

---

## Executive Summary

This specification defines how the LLKB Adapter Pattern (from the debate document) will be implemented within ARTK's existing architecture. It covers schema changes, new modules, prompt modifications, and the learning loop that enables continuous improvement.

---

## Multi-AI Specification Debate

**Debate Style:** Thorough Technical Specification
**Participants:** Claude (Architect), Gemini (API Designer), Codex (Implementer)

---

### Round 1: Schema Design

#### Claude (Architect)

Let me define the schema for the LLKB-to-AutoGen export. The adapter needs to generate files that AutoGen can consume.

**Export Schema: `autogen-llkb.config.yml`**

```yaml
# Generated by LLKB Adapter - DO NOT EDIT MANUALLY
# Regenerate with: npx artk-llkb export --for-autogen
version: 1
exportedAt: "2026-01-23T10:00:00Z"
llkbVersion: "1.0.0"
minConfidence: 0.7

# Additional patterns from LLKB lessons
additionalPatterns:
  - name: "llkb-ag-grid-edit-cell"
    regex: "^(?:user\\s+)?edits?\\s+cell\\s+(?:at\\s+)?row\\s+(\\d+)\\s+column\\s+[\"']([^\"']+)[\"']\\s+(?:with|to)\\s+[\"']([^\"']+)[\"']"
    primitiveType: "callModule"
    module: "ag-grid"
    method: "editCell"
    argMapping: ["$1", "$2", "$3"]
    source:
      lessonId: "L042"
      confidence: 0.92
      occurrences: 15

# Selector overrides from LLKB lessons
selectorOverrides:
  - pattern: "Save button"
    override:
      strategy: "testid"
      value: "btn-save"
    source:
      lessonId: "L015"
      confidence: 0.88

# Timing hints from lessons
timingHints:
  - trigger: "after ag-grid edit"
    waitMs: 500
    source:
      lessonId: "L023"
      confidence: 0.85

# Module mappings from components
modules:
  - name: "waitForAgGridLoad"
    trigger: "wait for (?:the )?(?:ag-?)?grid to load"
    componentId: "COMP012"
    importPath: "./components/ag-grid/waitForLoad"
    confidence: 0.91
```

**Glossary Export Schema: `llkb-glossary.ts`**

```typescript
/**
 * LLKB-Generated Glossary Extension
 * Generated: 2026-01-23T10:00:00Z
 * Source: .artk/llkb/
 * Min Confidence: 0.7
 *
 * DO NOT EDIT - Regenerate with: npx artk-llkb export --for-autogen
 */
import type { IRPrimitive } from '@artk/core-autogen';

export const llkbGlossary = new Map<string, IRPrimitive>([
  // From component COMP012 (confidence: 0.91)
  ["wait for grid to load", { type: "callModule", module: "ag-grid", method: "waitForLoad" }],
  ["wait for ag-grid to load", { type: "callModule", module: "ag-grid", method: "waitForLoad" }],

  // From lesson L042 (confidence: 0.92)
  ["edit grid cell", { type: "callModule", module: "ag-grid", method: "editCell" }],

  // From component COMP018 (confidence: 0.87)
  ["handle sticky header", { type: "callModule", module: "ui", method: "handleStickyHeader" }],
]);

export const llkbGlossaryMeta = {
  exportedAt: "2026-01-23T10:00:00Z",
  minConfidence: 0.7,
  entryCount: 4,
  sourceComponents: ["COMP012", "COMP018"],
  sourceLessons: ["L042"],
};
```

#### Gemini (API Designer)

Claude's schemas look good. Let me define the API contract for the adapter module.

**Adapter API Contract:**

```typescript
// core/typescript/llkb/adapter.ts

export interface LLKBAdapterConfig {
  /** Path to LLKB root directory (default: .artk/llkb) */
  llkbRoot?: string;

  /** Output directory for generated files */
  outputDir: string;

  /** Minimum confidence threshold (default: 0.7) */
  minConfidence?: number;

  /** Categories to include (default: all) */
  includeCategories?: LLKBCategory[];

  /** Scopes to include (default: all) */
  includeScopes?: LLKBScope[];

  /** Whether to generate glossary file (default: true) */
  generateGlossary?: boolean;

  /** Whether to generate config file (default: true) */
  generateConfig?: boolean;

  /** Output format for config (default: yaml) */
  configFormat?: 'yaml' | 'json';
}

export interface LLKBAdapterResult {
  /** Path to generated config file */
  configPath: string | null;

  /** Path to generated glossary file */
  glossaryPath: string | null;

  /** Statistics about what was exported */
  stats: {
    patternsExported: number;
    selectorsExported: number;
    timingHintsExported: number;
    modulesExported: number;
    glossaryEntriesExported: number;
    lessonsSkipped: number;
    componentsSkipped: number;
  };

  /** Warnings encountered during export */
  warnings: string[];

  /** Export timestamp */
  exportedAt: string;
}

/**
 * Main export function - generates AutoGen-compatible files from LLKB
 */
export async function exportForAutogen(
  config: LLKBAdapterConfig
): Promise<LLKBAdapterResult>;

/**
 * CLI wrapper for export
 */
export async function runAdapterCLI(args: string[]): Promise<void>;
```

**CLI Interface:**

```bash
# Full export
npx artk-llkb export --for-autogen --output artk-e2e/

# With options
npx artk-llkb export --for-autogen \
  --output artk-e2e/ \
  --min-confidence 0.8 \
  --categories selector,timing,auth \
  --scopes universal,framework:angular

# Dry run (preview only)
npx artk-llkb export --for-autogen --output artk-e2e/ --dry-run

# Generate only glossary
npx artk-llkb export --for-autogen --output artk-e2e/ --glossary-only

# Generate only config
npx artk-llkb export --for-autogen --output artk-e2e/ --config-only
```

#### Codex (Implementer)

I'll define the implementation approach for the adapter.

**Implementation Approach:**

```typescript
// core/typescript/llkb/adapter.ts

import { loadLessons, loadComponents, loadLLKBConfig } from './loaders.js';
import { calculateConfidence } from './confidence.js';
import { saveJSONAtomic } from './file-utils.js';
import { writeFileSync } from 'node:fs';
import { join } from 'node:path';
import { stringify as yamlStringify } from 'yaml';
import type { Lesson, Component, LLKBCategory, LLKBScope } from './types.js';

// Internal transformation functions
function lessonToPattern(lesson: Lesson): AdditionalPattern | null {
  // Convert lesson trigger to regex pattern
  // Only if category is selector/timing/navigation/ui-interaction
  if (!['selector', 'timing', 'navigation', 'ui-interaction'].includes(lesson.category)) {
    return null;
  }

  // Parse lesson pattern for regex construction
  // This is heuristic-based: lessons with clear triggers become patterns
  const regex = triggerToRegex(lesson.trigger);
  if (!regex) return null;

  return {
    name: `llkb-${lesson.id.toLowerCase()}`,
    regex: regex,
    primitiveType: categoryToPrimitiveType(lesson.category),
    source: {
      lessonId: lesson.id,
      confidence: lesson.metrics.confidence,
      occurrences: lesson.metrics.occurrences,
    },
  };
}

function componentToModule(component: Component): ModuleMapping {
  // Convert component to module mapping
  const trigger = componentNameToTrigger(component.name);

  return {
    name: component.name,
    trigger: trigger,
    componentId: component.id,
    importPath: component.filePath,
    confidence: component.metrics.successRate,
  };
}

function componentToGlossaryEntries(component: Component): Array<[string, IRPrimitive]> {
  // Generate multiple glossary entries for natural language variations
  const entries: Array<[string, IRPrimitive]> = [];
  const variations = generateNameVariations(component.name);

  for (const variation of variations) {
    entries.push([
      variation,
      {
        type: 'callModule',
        module: inferModuleFromCategory(component.category),
        method: component.name,
      },
    ]);
  }

  return entries;
}
```

---

### Round 2: AutoGen Integration Points

#### Claude (Architect)

Now let's specify the changes needed in AutoGen to consume the adapter output.

**AutoGen Schema Extension:**

```typescript
// core/typescript/autogen/src/config/schema.ts (ADDITIONS)

/**
 * LLKB integration configuration (optional)
 */
export const LLKBIntegrationSchema = z.object({
  /** Enable LLKB integration */
  enabled: z.boolean().default(false),

  /** Path to LLKB-generated config file */
  configPath: z.string().optional(),

  /** Path to LLKB-generated glossary file */
  glossaryPath: z.string().optional(),

  /** Integration level */
  level: z.enum(['minimal', 'enhance', 'aggressive']).default('enhance'),
}).default({});

// Add to AutogenConfigSchema
export const AutogenConfigSchema = z.object({
  version: z.literal(1).default(1),
  paths: PathsSchema.default({}),
  selectorPolicy: SelectorPolicySchema.default({}),
  validation: ValidationSchema.default({}),
  heal: HealSchema.default({}),
  regenerationStrategy: RegenerationStrategySchema,
  llkb: LLKBIntegrationSchema,  // NEW
});
```

**Config Loader Extension:**

```typescript
// core/typescript/autogen/src/config/loader.ts (ADDITIONS)

/**
 * Load and merge multiple config files
 */
export function loadConfigs(configPaths: string[]): AutogenConfig {
  const configs = configPaths
    .filter(p => existsSync(resolve(process.cwd(), p)))
    .map(p => loadSingleConfig(p));

  if (configs.length === 0) {
    return getDefaultConfig();
  }

  return mergeConfigs(configs);
}

/**
 * Merge multiple configs with later configs taking precedence
 */
function mergeConfigs(configs: AutogenConfig[]): AutogenConfig {
  return configs.reduce((merged, config) => ({
    ...merged,
    ...config,
    paths: { ...merged.paths, ...config.paths },
    selectorPolicy: {
      ...merged.selectorPolicy,
      ...config.selectorPolicy,
      // Merge arrays additively for patterns
      forbiddenPatterns: [
        ...(merged.selectorPolicy?.forbiddenPatterns || []),
        ...(config.selectorPolicy?.forbiddenPatterns || []),
      ],
    },
    validation: {
      ...merged.validation,
      ...config.validation,
      eslintRules: { ...merged.validation?.eslintRules, ...config.validation?.eslintRules },
    },
    llkb: { ...merged.llkb, ...config.llkb },
  }), getDefaultConfig());
}

/**
 * Load LLKB extension config if present
 */
export function loadLLKBConfig(basePath: string): Partial<AutogenConfig> | null {
  const llkbConfigPath = join(basePath, 'autogen-llkb.config.yml');
  if (!existsSync(llkbConfigPath)) {
    return null;
  }
  return loadSingleConfig(llkbConfigPath);
}
```

#### Gemini (API Designer)

Let me specify the glossary extension API.

**Glossary Extension API:**

```typescript
// core/typescript/autogen/src/mapping/glossary.ts (ADDITIONS)

import type { IRPrimitive } from '../ir/types.js';

/**
 * Core glossary - built into AutoGen (read-only)
 */
const coreGlossary = new Map<string, IRPrimitive>([
  // Existing entries...
]);

/**
 * Extended glossary - loaded from LLKB (optional)
 */
let extendedGlossary: Map<string, IRPrimitive> | null = null;
let extendedGlossaryMeta: { exportedAt: string; entryCount: number } | null = null;

/**
 * Load extended glossary from LLKB export
 */
export async function loadExtendedGlossary(glossaryPath: string): Promise<{
  loaded: boolean;
  entryCount: number;
  exportedAt: string | null;
}> {
  try {
    // Dynamic import of the generated glossary file
    const module = await import(glossaryPath);

    if (module.llkbGlossary instanceof Map) {
      extendedGlossary = module.llkbGlossary;
      extendedGlossaryMeta = module.llkbGlossaryMeta || null;

      return {
        loaded: true,
        entryCount: extendedGlossary.size,
        exportedAt: extendedGlossaryMeta?.exportedAt || null,
      };
    }

    return { loaded: false, entryCount: 0, exportedAt: null };
  } catch {
    return { loaded: false, entryCount: 0, exportedAt: null };
  }
}

/**
 * Clear extended glossary (for testing)
 */
export function clearExtendedGlossary(): void {
  extendedGlossary = null;
  extendedGlossaryMeta = null;
}

/**
 * Lookup a term in both core and extended glossaries
 * Core glossary takes precedence (LLKB only extends, never overrides)
 */
export function lookupGlossary(term: string): IRPrimitive | undefined {
  const normalizedTerm = term.toLowerCase().trim();

  // Core glossary has priority
  const coreMatch = coreGlossary.get(normalizedTerm);
  if (coreMatch) {
    return coreMatch;
  }

  // Fall back to extended glossary
  return extendedGlossary?.get(normalizedTerm);
}

/**
 * Get glossary statistics
 */
export function getGlossaryStats(): {
  coreEntries: number;
  extendedEntries: number;
  extendedExportedAt: string | null;
} {
  return {
    coreEntries: coreGlossary.size,
    extendedEntries: extendedGlossary?.size || 0,
    extendedExportedAt: extendedGlossaryMeta?.exportedAt || null,
  };
}
```

#### Codex (Implementer)

Let me specify the CLI changes.

**CLI Changes:**

```typescript
// core/typescript/autogen/src/cli/commands/generate.ts (ADDITIONS)

import { loadExtendedGlossary, getGlossaryStats } from '../../mapping/glossary.js';
import { loadConfigs } from '../../config/loader.js';

// Add new CLI options
const generateOptions = {
  // Existing options...
  output: { type: 'string', short: 'o' },
  modules: { type: 'boolean', short: 'm' },
  config: { type: 'string', short: 'c' },
  'dry-run': { type: 'boolean' },
  quiet: { type: 'boolean', short: 'q' },

  // NEW: LLKB integration options
  'llkb-config': { type: 'string', description: 'Path to LLKB-generated config' },
  'llkb-glossary': { type: 'string', description: 'Path to LLKB-generated glossary' },
  'no-llkb': { type: 'boolean', description: 'Disable LLKB integration' },
};

async function runGenerate(args: ParsedArgs): Promise<void> {
  // Load configs (base + LLKB if provided)
  const configPaths = [];
  if (args.config) configPaths.push(args.config);
  if (args['llkb-config']) configPaths.push(args['llkb-config']);

  const config = configPaths.length > 0
    ? loadConfigs(configPaths)
    : loadConfig();

  // Load LLKB glossary if provided
  if (args['llkb-glossary'] && !args['no-llkb']) {
    const glossaryResult = await loadExtendedGlossary(args['llkb-glossary']);
    if (glossaryResult.loaded && !args.quiet) {
      console.log(`Loaded LLKB glossary: ${glossaryResult.entryCount} entries (exported: ${glossaryResult.exportedAt})`);
    }
  }

  // Continue with generation...
}
```

---

### Round 3: Prompt Integration Flow

#### Claude (Architect)

Now let's define how the prompts orchestrate the LLKB → AutoGen flow.

**Updated journey-implement Flow:**

```
┌─────────────────────────────────────────────────────────────────────┐
│                    /artk.journey-implement                           │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  GATE 1: Verify LLKB Exists                                         │
│  ├─ Check .artk/llkb/ directory                                     │
│  ├─ Check config.yml has enabled: true                              │
│  └─ If missing → STOP, run /artk.discover-foundation                │
│                                                                      │
│  GATE 2: Load LLKB Context (unchanged)                              │
│  ├─ Read config.yml, components.json, lessons.json                  │
│  └─ Display "LLKB Context Loaded" section                           │
│                                                                      │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │  GATE 2.5: Export LLKB for AutoGen (NEW)                    │    │
│  │  ├─ Run: npx artk-llkb export --for-autogen                 │    │
│  │  │        --output <harnessRoot>/                           │    │
│  │  │        --min-confidence 0.7                              │    │
│  │  ├─ Generates:                                              │    │
│  │  │   • <harnessRoot>/autogen-llkb.config.yml               │    │
│  │  │   • <harnessRoot>/llkb-glossary.ts                      │    │
│  │  └─ Display export statistics                               │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                      │
│  GATE 3: Use AutoGen CLI (updated command)                          │
│  ├─ Run: npx artk-autogen generate                                  │
│  │        --config <harnessRoot>/autogen.config.yml                 │
│  │        --llkb-config <harnessRoot>/autogen-llkb.config.yml      │
│  │        --llkb-glossary <harnessRoot>/llkb-glossary.ts           │
│  │        -o <testsDir> -m                                          │
│  │        <journeyPath>                                             │
│  └─ Continue with existing flow...                                  │
│                                                                      │
│  POST-IMPLEMENTATION: Learning Loop (NEW)                           │
│  ├─ After verify passes: Check for new patterns to learn            │
│  ├─ If test used new selectors → Record to LLKB                     │
│  ├─ If component was reused → Boost confidence                      │
│  └─ If pattern matched → Record success                             │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

**Prompt Modification (Step 2.5 Addition):**

```markdown
## Step 2.5: Export LLKB for AutoGen (MANDATORY)

Before running AutoGen, export LLKB knowledge to AutoGen-compatible format:

```bash
npx artk-llkb export --for-autogen \
  --output <harnessRoot>/ \
  --min-confidence 0.7
```

**Expected output:**
```
LLKB Export for AutoGen
========================
Exported patterns: 12
Exported selector overrides: 5
Exported timing hints: 3
Exported modules: 8
Generated glossary entries: 24

Output files:
  - <harnessRoot>/autogen-llkb.config.yml
  - <harnessRoot>/llkb-glossary.ts

Export completed at: 2026-01-23T10:00:00Z
```

**If export fails:**
- Check LLKB exists: `.artk/llkb/`
- Check LLKB enabled: `config.yml` has `enabled: true`
- If no high-confidence entries: Continue without LLKB export (warning only)
```

#### Gemini (API Designer)

Let me define the learning loop API that feeds back to LLKB.

**Learning Loop API:**

```typescript
// core/typescript/llkb/learning.ts (NEW FILE)

import { appendToHistory } from './history.js';
import { updateJSONWithLock } from './file-utils.js';
import type { Lesson, Component, LessonAppliedEvent, ComponentUsedEvent } from './types.js';

export interface LearningInput {
  journeyId: string;
  testFile: string;
  prompt: 'journey-implement' | 'journey-verify';
}

export interface PatternLearnedInput extends LearningInput {
  stepText: string;
  selectorUsed: {
    strategy: string;
    value: string;
  };
  success: boolean;
}

export interface ComponentUsedInput extends LearningInput {
  componentId: string;
  success: boolean;
}

export interface LessonAppliedInput extends LearningInput {
  lessonId: string;
  success: boolean;
  context?: string;
}

/**
 * Record that a selector pattern was learned/validated
 */
export async function recordPatternLearned(input: PatternLearnedInput): Promise<void> {
  // Check if this pattern matches an existing lesson
  // If yes, update metrics
  // If no and successful, create new lesson candidate

  const lessonsPath = join(input.llkbRoot || '.artk/llkb', 'lessons.json');

  await updateJSONWithLock(lessonsPath, (data: LessonsFile) => {
    const existingLesson = data.lessons.find(l =>
      l.pattern.includes(input.selectorUsed.value) ||
      l.trigger.includes(input.stepText)
    );

    if (existingLesson) {
      // Update existing lesson metrics
      existingLesson.metrics.occurrences++;
      if (input.success) {
        existingLesson.metrics.lastSuccess = new Date().toISOString();
        existingLesson.metrics.successRate = calculateNewSuccessRate(existingLesson.metrics);
      }
      existingLesson.metrics.confidence = calculateConfidence(existingLesson.metrics);
      existingLesson.journeyIds = [...new Set([...existingLesson.journeyIds, input.journeyId])];
    }
    // Note: Creating new lessons is handled by journey-verify, not here

    data.lastUpdated = new Date().toISOString();
    return data;
  });

  // Log to history
  await appendToHistory({
    event: 'lesson_applied',
    timestamp: new Date().toISOString(),
    journeyId: input.journeyId,
    prompt: input.prompt,
    lessonId: existingLesson?.id,
    success: input.success,
    context: input.stepText,
  });
}

/**
 * Record that a component was used
 */
export async function recordComponentUsed(input: ComponentUsedInput): Promise<void> {
  const componentsPath = join(input.llkbRoot || '.artk/llkb', 'components.json');

  await updateJSONWithLock(componentsPath, (data: ComponentsFile) => {
    const component = data.components.find(c => c.id === input.componentId);
    if (component) {
      component.metrics.totalUses++;
      component.metrics.lastUsed = new Date().toISOString();
      if (input.success) {
        component.metrics.successRate = calculateNewComponentSuccessRate(component.metrics);
      }
    }
    data.lastUpdated = new Date().toISOString();
    return data;
  });

  // Log to history
  await appendToHistory({
    event: 'component_used',
    timestamp: new Date().toISOString(),
    journeyId: input.journeyId,
    prompt: input.prompt,
    componentId: input.componentId,
    success: input.success,
  });
}

/**
 * Record that a lesson was applied
 */
export async function recordLessonApplied(input: LessonAppliedInput): Promise<void> {
  // Similar to recordPatternLearned but for explicit lesson application
  // ...
}
```

#### Codex (Implementer)

Let me add the CLI command for the learning loop.

**Learning CLI:**

```typescript
// core/typescript/llkb/cli.ts (ADDITIONS)

/**
 * Record learning event from CLI
 */
export async function recordLearning(args: {
  type: 'pattern' | 'component' | 'lesson';
  journeyId: string;
  prompt: string;
  id?: string;
  success: boolean;
  context?: string;
}): Promise<void> {
  switch (args.type) {
    case 'pattern':
      await recordPatternLearned({
        journeyId: args.journeyId,
        prompt: args.prompt as any,
        stepText: args.context || '',
        selectorUsed: JSON.parse(args.context || '{}'),
        success: args.success,
      });
      break;
    case 'component':
      await recordComponentUsed({
        journeyId: args.journeyId,
        prompt: args.prompt as any,
        componentId: args.id!,
        success: args.success,
      });
      break;
    case 'lesson':
      await recordLessonApplied({
        journeyId: args.journeyId,
        prompt: args.prompt as any,
        lessonId: args.id!,
        success: args.success,
        context: args.context,
      });
      break;
  }
}

// CLI command
// npx artk-llkb learn --type component --id COMP012 --journey JRN-0001 --success
// npx artk-llkb learn --type lesson --id L042 --journey JRN-0001 --success --context "grid edit"
```

---

### Round 4: Journey-Maintain Integration

#### Claude (Architect)

**Critical Note:** When `/artk.journey-maintain` is implemented, it must handle updating older tests to use the latest LLKB knowledge.

**Journey-Maintain LLKB Responsibilities:**

```
┌─────────────────────────────────────────────────────────────────────┐
│                    /artk.journey-maintain                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  LLKB Version Check:                                                │
│  ├─ Read test file header for LLKB version                          │
│  │   // ARTK:LLKB_VERSION: 2026-01-15T00:00:00Z                    │
│  ├─ Compare with current LLKB export timestamp                      │
│  └─ If different → flag for potential update                        │
│                                                                      │
│  Update Flow (with user confirmation):                              │
│  ├─ Show diff preview: "LLKB has N new patterns since last gen"    │
│  ├─ Ask: "Update test to use latest LLKB knowledge?"                │
│  │   - Yes: Regenerate with latest LLKB export                      │
│  │   - No: Keep current version                                     │
│  │   - Always: Update all flagged tests without asking              │
│  └─ If yes: Run AutoGen with --llkb-config --llkb-glossary         │
│                                                                      │
│  Structural Change Detection:                                       │
│  ├─ Before regeneration: Capture current test structure             │
│  ├─ After regeneration: Compare structures                          │
│  ├─ If behavioral change detected → STOP, require review            │
│  └─ If structural-only change → Apply with notice                   │
│                                                                      │
│  LLKB Health Maintenance:                                           │
│  ├─ Prune low-confidence lessons                                    │
│  ├─ Archive unused components                                       │
│  └─ Regenerate analytics                                            │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

**Test File Header Format:**

```typescript
/**
 * @journey JRN-0001
 * @generated 2026-01-23T10:00:00Z
 * @artk-version 1.0.0
 * @llkb-version 2026-01-23T10:00:00Z
 * @llkb-entries 24
 *
 * DO NOT EDIT GENERATED SECTIONS
 */
import { test, expect } from '@playwright/test';
// ...
```

#### Gemini (API Designer)

Let me define the version comparison API.

**Version Comparison API:**

```typescript
// core/typescript/llkb/versioning.ts (NEW FILE)

export interface VersionComparison {
  testLlkbVersion: string | null;
  currentLlkbVersion: string;
  isOutdated: boolean;
  daysSinceUpdate: number;
  newPatternsAvailable: number;
  newComponentsAvailable: number;
  recommendation: 'update' | 'skip' | 'review';
}

/**
 * Compare test's LLKB version with current LLKB state
 */
export async function compareVersions(
  testFilePath: string,
  llkbRoot?: string
): Promise<VersionComparison> {
  // Read test file header
  const testContent = readFileSync(testFilePath, 'utf-8');
  const llkbVersionMatch = testContent.match(/@llkb-version\s+(\S+)/);
  const testLlkbVersion = llkbVersionMatch?.[1] || null;

  // Get current LLKB version
  const analyticsPath = join(llkbRoot || '.artk/llkb', 'analytics.json');
  const analytics = JSON.parse(readFileSync(analyticsPath, 'utf-8'));
  const currentLlkbVersion = analytics.lastUpdated;

  // Calculate differences
  const isOutdated = !testLlkbVersion ||
    new Date(testLlkbVersion) < new Date(currentLlkbVersion);

  const daysSinceUpdate = testLlkbVersion
    ? Math.floor((Date.now() - new Date(testLlkbVersion).getTime()) / (1000 * 60 * 60 * 24))
    : Infinity;

  // Count new entries since test version
  const newPatternsAvailable = countNewEntriesSince(testLlkbVersion, 'lessons');
  const newComponentsAvailable = countNewEntriesSince(testLlkbVersion, 'components');

  // Determine recommendation
  let recommendation: 'update' | 'skip' | 'review' = 'skip';
  if (isOutdated && (newPatternsAvailable > 5 || newComponentsAvailable > 2)) {
    recommendation = 'update';
  } else if (isOutdated && daysSinceUpdate > 30) {
    recommendation = 'review';
  }

  return {
    testLlkbVersion,
    currentLlkbVersion,
    isOutdated,
    daysSinceUpdate,
    newPatternsAvailable,
    newComponentsAvailable,
    recommendation,
  };
}
```

#### Codex (Implementer)

Let me define the batch update command.

**Batch Update CLI:**

```bash
# Check which tests need LLKB updates
npx artk-llkb check-updates --tests-dir artk-e2e/tests/

# Output:
# Tests needing LLKB update:
#   - login.spec.ts (LLKB: 2026-01-15, current: 2026-01-23, +8 patterns)
#   - checkout.spec.ts (LLKB: 2026-01-10, current: 2026-01-23, +12 patterns)
#   - dashboard.spec.ts (up to date)
#
# Recommendation: 2 tests should be updated

# Update specific test
npx artk-llkb update-test --test artk-e2e/tests/login.spec.ts --dry-run

# Update all outdated tests (with confirmation)
npx artk-llkb update-tests --tests-dir artk-e2e/tests/ --confirm
```

---

### Round 5: Error Handling & Edge Cases

#### Claude (Architect)

**Error Handling Matrix:**

| Scenario | Detection | Response | Recovery |
|----------|-----------|----------|----------|
| LLKB missing | Check directory | STOP, prompt user | Run discover-foundation |
| LLKB disabled | Check config.yml | STOP, prompt user | Edit config |
| Export fails | CLI exit code | Warn, continue without | Manual export |
| No high-confidence entries | Stats check | Warn, empty export | Continue normally |
| Glossary import fails | Try-catch | Warn, use core only | Check file syntax |
| Pattern conflict | Merge detection | Core wins | Log for review |
| Parallel write conflict | Lock timeout | Retry with backoff | Queue updates |
| Test regression after update | Verify gate | Rollback | Manual review |

**Rollback Mechanism:**

```typescript
// Before regeneration, save backup
const backupPath = `${testFilePath}.llkb-backup-${Date.now()}`;
copyFileSync(testFilePath, backupPath);

// After regeneration, run quick verify
const verifyResult = await quickVerify(testFilePath);

if (verifyResult.status === 'failed') {
  // Rollback
  copyFileSync(backupPath, testFilePath);
  console.warn(`LLKB update caused test failure, rolled back to backup`);
  // Flag for manual review
}

// Cleanup backup on success
unlinkSync(backupPath);
```

#### Gemini (API Designer)

**Conflict Resolution Rules:**

1. **Core vs LLKB patterns:** Core always wins (LLKB extends, never overrides)
2. **Multiple LLKB patterns:** Higher confidence wins
3. **Equal confidence:** More recent lesson wins
4. **Selector conflicts:** Test-specific override > LLKB > default
5. **Module conflicts:** Explicit import > LLKB > built-in

**Conflict Detection API:**

```typescript
export interface ConflictReport {
  type: 'pattern' | 'selector' | 'module';
  core: string;
  llkb: string;
  resolution: 'core-wins' | 'llkb-wins' | 'merge' | 'manual';
  reason: string;
}

export function detectConflicts(
  coreConfig: AutogenConfig,
  llkbConfig: Partial<AutogenConfig>
): ConflictReport[];
```

#### Codex (Implementer)

**Health Check Integration:**

```bash
# Run LLKB health check
npx artk-llkb health

# Output:
# LLKB Health Check
# =================
# Status: HEALTHY
#
# Lessons:
#   - Active: 45
#   - Archived: 12
#   - Low confidence (< 0.4): 3 [REVIEW NEEDED]
#   - Declining: 1 [REVIEW NEEDED]
#
# Components:
#   - Active: 23
#   - Archived: 5
#   - Unused (30+ days): 2 [CONSIDER ARCHIVING]
#
# AutoGen Integration:
#   - Export file exists: YES
#   - Export age: 2 days
#   - Patterns exported: 12
#   - Glossary entries: 24
#
# Recommendations:
#   1. Review 3 low-confidence lessons
#   2. Consider archiving 2 unused components
#   3. Re-export for AutoGen (export > 1 day old)
```

---

## Final Specification Summary

### New Files

| File | Purpose | Lines (est) |
|------|---------|-------------|
| `core/typescript/llkb/adapter.ts` | LLKB → AutoGen export | 150 |
| `core/typescript/llkb/learning.ts` | Learning loop API | 100 |
| `core/typescript/llkb/versioning.ts` | Version comparison | 80 |
| `core/typescript/autogen/src/config/llkb-schema.ts` | LLKB config schema | 40 |

### Modified Files

| File | Changes | Lines (est) |
|------|---------|-------------|
| `core/typescript/llkb/index.ts` | Export new modules | 10 |
| `core/typescript/llkb/cli.ts` | Add export, learn, health commands | 80 |
| `core/typescript/autogen/src/config/schema.ts` | Add LLKB schema | 20 |
| `core/typescript/autogen/src/config/loader.ts` | Multi-config merge | 40 |
| `core/typescript/autogen/src/mapping/glossary.ts` | Extended glossary | 50 |
| `core/typescript/autogen/src/cli/commands/generate.ts` | LLKB flags | 30 |
| `prompts/artk.journey-implement.md` | Add Step 2.5 | 50 |
| `prompts/artk.journey-verify.md` | Add learning hooks | 30 |
| `CLAUDE.md` | Journey-maintain note | 10 |

### Total Estimated Changes

- **New code:** ~370 lines
- **Modified code:** ~320 lines
- **Total:** ~690 lines

### Implementation Phases

1. **Phase 1:** Adapter module + CLI export command
2. **Phase 2:** AutoGen config/glossary extensions
3. **Phase 3:** Prompt integration (journey-implement)
4. **Phase 4:** Learning loop (journey-verify)
5. **Phase 5:** Version tracking + journey-maintain support

---

## Confidence Level

**0.94** - High confidence based on:
- Minimal changes to existing AutoGen code
- Well-defined interfaces between components
- Clear error handling and rollback mechanisms
- Backwards compatible by design

## Key Caveats

1. Journey-maintain prompt does not exist yet - must be implemented
2. Learning loop requires careful testing to avoid feedback loops
3. Parallel execution needs thorough testing with concurrent LLKB writes
4. Pattern-to-regex conversion is heuristic-based and may need tuning

---

## Related Documents

- `research/2026-01-23_llkb-autogen-integration-debate.md` - Architecture debate
- `research/2026-01-19_llkb-implementation-review-v4.md` - LLKB review
- `core/typescript/llkb/types.ts` - LLKB type definitions
- `core/typescript/autogen/src/ir/types.ts` - AutoGen IR types

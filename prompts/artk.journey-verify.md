---
mode: agent
description: "Runtime verification gate - runs Playwright tests, detects flakiness, auto-heals common failures, updates Journey status"
---

# ARTK /journey-verify — Run + Stabilize a Journey’s Tests (Phase 8.5)

You are running **ARTK Phase 8.5**.

Humans love regressions. ARTK exists to stop you from shipping them by accident.

This command verifies that a Journey’s Playwright tests:
- **actually run**
- **actually pass**
- and are **stable enough** to be worth trusting.

If the tests fail, you will attempt to **fix test code (not product code)** in a **bounded healing loop**, using traces and deterministic diagnostics.

---

## What this command does

1) Finds the Journey and its linked tests (or discovers them via the `@JRN-####` tag).
2) Runs only those tests using Playwright CLI filtering (`--grep`) and sane defaults.
3) Collects artifacts (HTML report, traces, screenshots, optional videos).
4) If failures occur, classifies them and attempts targeted fixes (selectors, waits, data, navigation).
5) Re-runs until either:
   - tests pass + stability gate passes, or
   - the attempt budget is exhausted, or
   - the failure is blocked by environment/app/permissions constraints.

6) Writes a managed verification summary back to the Journey (optional).

---

## Research-backed capabilities we rely on (don’t fight them)
- **Targeted runs**: `--grep`, `--workers`, `--max-failures`, `--repeat-each`, `--last-failed`.  
- **Flake detection**: `--fail-on-flaky-tests` + retries, plus optional repeat runs.  
- **Tracing**: `--trace` modes including `retain-on-failure`, and newer `retain-on-first-failure` where supported.  
- **Reports**: HTML for humans, JSON optional for machines.

(All of the above are native Playwright Test features.)

---

## Preconditions (verify before running)

### Core Framework Requirements (CRITICAL)

Before running any tests, verify ARTK Core v1 is properly integrated:

1. **ARTK Core framework installed:**
   - ✅ `<ARTK_ROOT>/.core/` directory exists
   - ✅ `<ARTK_ROOT>/.core/dist/` contains compiled modules:
     - `dist/config/`, `dist/fixtures/`, `dist/harness/`
     - `dist/locators/`, `dist/assertions/`, `dist/data/`
     - `dist/auth/`, `dist/reporters/`
   - ✅ `<ARTK_ROOT>/.core/package.json` exists with correct version
   - ❌ If missing: Run `/init-playbook` to install core framework

2. **artk.config.yml valid:**
   - ✅ Valid ARTK Core v1 schema (validated by `@artk/core/config`)
   - ✅ `version: "1.0"` field present
   - ✅ Required sections: `app`, `environments`, `auth`, `selectors`, `tiers`
   - ❌ If invalid: Fix config or run `/init-playbook` to regenerate

3. **Playwright config uses core harness:**
   - ✅ `playwright.config.ts` imports from `@artk/core/harness`
   - ✅ Uses `createPlaywrightConfig()` factory
   - ✅ Config loads via `loadConfig()` from `@artk/core/config`
   - ❌ If manual config: Run `/discover-foundation` to regenerate

4. **Tests use core fixtures:**
   - ✅ Test files import from `@artk/core/fixtures`
   - ✅ NO custom fixture files in `<harnessRoot>/fixtures/`
   - ✅ NO direct imports from `@playwright/test`
   - ❌ If invalid: Run `/journey-validate` to detect violations

5. **Auth setup configured:**
   - ✅ Auth setup projects auto-generated by core harness
   - ✅ Storage state directory exists at `<ARTK_ROOT>/.auth-states/`
   - ✅ `.gitignore` excludes `.auth-states/`
   - ❌ If missing: Check `artk.config.yml` auth section

6. **Journey and tests exist:**
   - ✅ Journey file exists (`id=` or `file=` provided)
   - ✅ At least one test tagged with `@JRN-####` exists
   - ❌ If no tests: Run `/journey-implement id=...`

7. **Environment reachable:**
   - ✅ `baseURL` from config is accessible from test runner
   - ✅ VPN/network connectivity verified
   - ❌ If unreachable: STOP - do not pretend

**Precondition failure actions:**

| Failed Check | Command to Run | Description |
|--------------|----------------|-------------|
| Core missing | `/init` | Install ARTK Core framework |
| Config invalid | Fix `artk.config.yml` | Update to Core v1 schema |
| Config uses manual Playwright | `/discover-foundation` | Regenerate using core harness |
| Tests use custom fixtures | `/journey-implement id=... --fix-imports` | Re-implement with core imports |
| No auth setup | Check config + run `/discover-foundation` | Configure auth in config |
| No tests | `/journey-implement id=...` | Implement the Journey |
| Environment unreachable | Fix network/VPN | Cannot verify without access |

**If ANY precondition fails, STOP and provide the exact command(s) to run. Do NOT attempt to run tests.**

---

## Inputs and defaults (simple, not fragile)
- `mode`:
  - `quick`: one run, fail fast, minimal healing.
  - `standard` (default): run + bounded healing + 1 stability check.
  - `max`: deeper stability checks, more aggressive evidence collection.
- Journey selector: `id=JRN-####` preferred. `file=` allowed.
- `harnessRoot`: default `e2e`.
- `env/baseURL`: `auto` means “use harness env loader defaults”. Never hardcode URLs.
- `trace` default `auto`:
  - Prefer `retain-on-first-failure` when Playwright supports it.
  - Else use `retain-on-failure` (works broadly).
- `repeat` default:
  - quick: 0
  - standard: 2 (light stability gate)
  - max: 3
- `heal` default `auto` with `healAttempts=2` (standard), `1` (quick), `3` (max).

---

## Outputs (must produce)
- A **single command line** that reproduces the run locally.
- A verification summary:
  - pass/fail
  - number of attempts
  - failure categories (if any)
  - artifact locations (report/traces)
- If `updateJourney=true`:
  - Update Journey with a managed block:
    - lastVerifiedAt, verifiedBy, env, baseURL (redacted if needed)
    - command used
    - attempts
    - result (pass/fail/blocked)
    - notes (what was fixed, what is blocked)

---

# Required assistant response structure
1) **Detected Context**
2) **Run Command**
3) **Results**
4) **Fixes Applied (if any)**
5) **Stability Gate Result**
6) **Artifacts + How to Debug**
7) **Blockers / Next Actions**

If `dryRun=true`, output sections 1–2 only.

---

# Execution algorithm (do in order)

## Step 0 — Locate Journey and tests
1) Resolve `ARTK_ROOT` (from `artkRoot=` or repo root heuristics).
2) Load Journey file:
   - If `id=`: locate in `journeys/**/JRN-####*.md` and parse frontmatter.
   - If `file=`: open and parse.
3) Determine the canonical tag: `@JRN-####`.
4) Determine test set:
   - Prefer Journey frontmatter `tests[]` if non-empty.
   - Else search under `<harnessRoot>/tests/` for files containing `@JRN-####`.

If no tests found: stop and instruct `/journey-implement id=...`.

## Step 1 — Detect Playwright + package manager
- Detect package manager (pnpm/yarn/npm) from lockfiles.
- Detect Playwright version from package.json/lock.
- Detect configured projects (from `playwright.config.*`).

If Playwright isn’t installed or browsers missing:
- Provide exact install commands (do not guess).

## Step 2 — Build the run command (reproducible)
Always build a command that:
- filters to the Journey tag (`--grep @JRN-####`)
- runs with **1 worker** for determinism while stabilizing
- stops early (`--max-failures=1`) during heal loop
- enables trace collection on failure (auto)

Base template:
- `npx playwright test --grep @JRN-#### --workers=1 --max-failures=1`

Trace mode selection:
- If Playwright supports `retain-on-first-failure`, use:
  - `--trace=retain-on-first-failure`
- Else:
  - `--trace=retain-on-failure`

Retries:
- For stabilization runs, default to `--retries=0` to avoid masking issues.
- For flake classification, run a later gate with `--retries=1 --fail-on-flaky-tests`.

Repeat:
- Stability gate may run with `--repeat-each=2` (or 3 in max).

If `project` is provided or auto-detected:
- include `--project=<name>`.

If env vars are needed and the harness provides a loader:
- run via `npm run e2e` wrapper if the repo defines it, otherwise use direct `npx`.

## Step 3 — Run (or request user run)
If you can execute commands in this environment, run them.
If you cannot:
- print the exact command(s)
- ask the user to paste:
  - the failing test output
  - the location of the Playwright report folder

Do not continue “fixing” without evidence.

## Step 4 — Healing loop (bounded, test code only)
If `heal=off`: skip to Step 6.

Else, loop up to `healAttempts`:
1) Run the stabilization command (Step 2) and capture:
   - stdout/stderr
   - which step failed (if available)
   - the failing locator/action (from stacktrace)
   - trace/report paths
2) Classify failure (pick one primary category):
   - **ENV**: DNS/VPN/baseURL unreachable, TLS, proxy, region restriction.
   - **AUTH**: login redirect loops, expired storageState, MFA/SSO blocking.
   - **SELECTOR**: strict mode violations, missing roles/labels/testids, dynamic text locators.
   - **DATA**: collisions, stale shared accounts, missing seed, cleanup not happening.
   - **ASYNC**: eventual consistency, background jobs, delayed toasts, websockets.
   - **NAV**: wrong route, SPA navigation race, new tabs/iframes.
   - **APP BUG**: deterministic product bug surfaced by the test.
3) Fix strategy by category (minimal change that increases determinism):
   - ENV: stop and mark blocked. Do not hack around unreachable environments.
   - AUTH: refresh storageState strategy, ensure setup project runs, avoid UI login if impossible.
   - SELECTOR:
     - prefer role/label/testid locators
     - remove brittle `nth()` and dynamic text targeting
     - encapsulate locator changes in the right module
   - DATA:
     - introduce/strengthen `runId` namespacing
     - ensure cleanup or create unique records per run
     - avoid assuming pre-existing data unless Journey explicitly says so
   - ASYNC:
     - replace implicit timing with explicit completion signals
     - use web-first assertions, `expect.poll`, or `expect.toPass` with bounded timeouts
     - never “fix” by adding `waitForTimeout`
   - NAV:
     - assert on stable route markers (heading, breadcrumb, URL)
     - handle new tabs with `context.waitForEvent('page')`
     - handle iframes with frame locators
   - APP BUG:
     - stop healing the test into lying
     - capture evidence and propose an issue link (do not set Journey verified)
4) Re-run the stabilization command.
5) If pass, break. If fail and category is blocked or app bug, stop early.

Hard rule: **never introduce sleeps** as a "stability fix" unless explicitly allowed by the playbook and only with a TODO and justification.

## Step 4A — Deterministic Healing Rules (Step-by-Step)

When tests fail, apply these fixes in priority order. Each fix should be atomic and traceable.

### Selector Failures (element not found, strict mode violation)

**Healing Priority Order:**
1. Check if element has accessible role → use `getByRole()`
2. Check if element has label/aria-label → use `getByLabel()`
3. Check if element has text content → use `getByText()`
4. Check if element has data-testid → use `getByTestId()`
5. Check TESTABILITY.md for app-specific conventions
6. If no good selector exists → add blocker note, do NOT use CSS hack

**Fix Examples:**
| Original (broken) | Fixed | Reason |
|------------------|-------|--------|
| `.locator('.btn-primary')` | `getByRole('button', { name: 'Submit' })` | Role + name is stable |
| `.locator('#submit')` | `getByRole('button', { name: 'Submit' })` | ID may change, role won't |
| `.locator('button').first()` | `getByRole('button', { name: 'Save' })` | Avoid positional selectors |
| `.locator('[data-qa="save"]')` | `getByTestId('save')` | Use core helper |

### Timing Failures (timeout, element not visible yet)

**Never add `waitForTimeout()` - use these instead:**

| Failure Type | Correct Fix |
|-------------|-------------|
| Navigation not complete | Add URL assertion: `await expect(page).toHaveURL(/\/expected/);` |
| Loading spinner visible | Use core helper: `await waitForLoadingComplete(page);` |
| Toast not appearing | Use core helper: `await expectToast(page, { type: 'success' });` |
| API not responded | Add response wait: `await page.waitForResponse(r => r.url().includes('/api'));` |
| Element appearing late | Increase assertion timeout: `await expect(el).toBeVisible({ timeout: 10000 });` |
| Modal animation | Wait for stable state: `await expect(dialog).toBeVisible();` |

### Data Failures (collision, stale data, missing record)

**Healing Strategy:**
1. Ensure `runId` namespacing is used for all created data
2. Check cleanup is registered with `testData.register()`
3. Verify test isolation (no shared state between tests)
4. If using shared test accounts, check for parallel run conflicts

**Fix Examples:**
```typescript
// Before (collision risk)
const userName = 'testuser';

// After (isolated)
const userName = namespace('user', runId);  // → 'user-abc123'
```

### Navigation Failures (wrong page, redirect loop)

**Healing Strategy:**
1. Add explicit URL assertion before interactions
2. Handle redirects with `waitForURL()`
3. For new tabs: use `context.waitForEvent('page')`
4. For iframes: use frame locators

**Fix Examples:**
```typescript
// Before (assumes navigation complete)
await page.goto('/dashboard');
await page.getByRole('button', { name: 'Action' }).click();

// After (explicit wait)
await page.goto('/dashboard');
await expect(page).toHaveURL(/\/dashboard/);
await expect(page.getByRole('heading', { name: 'Dashboard' })).toBeVisible();
await page.getByRole('button', { name: 'Action' }).click();
```

## Step 4B — Healing Attempt Logging

Track each healing attempt for audit and learning:

```json
{
  "journeyId": "JRN-0001",
  "attempt": 1,
  "timestamp": "2026-01-02T10:30:00Z",
  "failureCategory": "SELECTOR",
  "failingStep": "test.step('AC-1: User sees dashboard')",
  "failingLocator": ".locator('.dashboard-header')",
  "errorMessage": "Strict mode violation: locator resolved to 2 elements",
  "evidence": {
    "traceFile": "test-results/trace.zip",
    "screenshot": "test-results/failure.png",
    "domSnapshot": "Multiple h1 elements found"
  },
  "fix": {
    "type": "SELECTOR_UPGRADE",
    "original": ".locator('.dashboard-header')",
    "replacement": "getByRole('heading', { name: 'Dashboard', level: 1 })",
    "rationale": "Role + name uniquely identifies the header"
  },
  "result": "PASS"
}
```

**Healing Attempt Budget:**
- quick mode: 1 attempt
- standard mode: 2 attempts
- max mode: 3 attempts

If all attempts exhausted and still failing → mark as BLOCKED with evidence.

## Step 5 — Stability gate (don't trust a single green run)
If the tests pass once:
- Run a light stability gate:
  - `--repeat-each=2 --workers=1 --retries=0`
- Then run a flake classification gate:
  - `--retries=1 --fail-on-flaky-tests`
If either gate fails:
- treat as flaky and continue healing (if attempts remain), else stop and mark as flaky/quarantine candidate.

## Step 6 — Update Journey (optional)
If `updateJourney=true`:
- Add/update:
  `<!-- ARTK:VERIFY:BEGIN --> ... <!-- ARTK:VERIFY:END -->`
Include:
- verifiedAt (ISO)
- result: pass | fail | blocked | flaky
- attemptsUsed
- primaryFailureCategory (if not pass)
- commands used (stabilization + gates)
- artifact pointers (relative paths only)
- notes (what changed)

Do NOT silently change Journey `status` unless:
- it is already `implemented` and verification passes (fine), OR
- you have explicit rule in playbook that “implemented requires verified”.

## Step 7 — Print final summary
Always end with:
- the single best repro command
- where to open the report:
  - `npx playwright show-report`
- where to open a trace:
  - `npx playwright show-trace <trace.zip>`

---

# Edge cases you must handle
- **SSO/MFA** blocks UI login: verification must rely on storageState provisioning. Mark blocked if not available.
- **Region-restricted environments**: stop, don’t “assume” connectivity.
- **Shared accounts**: avoid parallel runs until data isolation is proven.
- **Flaky backends**: stabilize with explicit completion checks, not retries forever.
- **Retry side effects**: prefer tracing that captures the *first failure* when supported.
- **Non-deterministic UI** (feature flags/permissions): require actor/role clarification or mark blocked.


{"version":3,"sources":["../../src/ir/types.ts","../../src/ir/builder.ts","../../src/ir/serialize.ts","../../src/config/schema.ts","../../src/config/loader.ts","../../src/journey/schema.ts","../../src/mapping/patterns.ts","../../src/utils/result.ts","../../src/journey/parseJourney.ts","../../src/mapping/glossary.ts","../../src/journey/hintPatterns.ts","../../src/journey/parseHints.ts","../../src/utils/paths.ts","../../src/mapping/patternDistance.ts","../../src/llkb/patternExtension.ts","../../src/mapping/stepMapper.ts","../../src/utils/escaping.ts","../../src/journey/normalize.ts","../../src/selectors/priority.ts","../../src/selectors/catalogSchema.ts","../../src/selectors/catalog.ts","../../src/selectors/infer.ts","../../src/selectors/scanner.ts","../../src/selectors/debt.ts","../../src/codegen/blocks.ts","../../src/journey/updater.ts","../../src/utils/version.ts","../../src/variants/index.ts","../../src/codegen/generateTest.ts","../../src/codegen/generateModule.ts","../../src/codegen/astEdit.ts","../../src/codegen/registry.ts","../../src/utils/parsing.ts","../../src/validate/journey.ts","../../src/validate/patterns.ts","../../src/validate/lint.ts","../../src/validate/tags.ts","../../src/validate/coverage.ts","../../src/validate/code.ts","../../src/validate/index.ts","../../src/verify/runner.ts","../../src/verify/parser.ts","../../src/verify/classifier.ts","../../src/verify/stability.ts","../../src/verify/evidence.ts","../../src/verify/summary.ts","../../src/verify/index.ts","../../src/heal/rules.ts","../../src/heal/logger.ts","../../src/heal/fixes/selector.ts","../../src/heal/fixes/navigation.ts","../../src/heal/fixes/timing.ts","../../src/heal/loop.ts","../../src/heal/fixes/data.ts","../../src/heal/index.ts","../../src/instance/install.ts","../../src/instance/upgrade.ts","../../src/shared/types.ts","../../src/shared/llm-response-parser.ts","../../src/shared/config-validator.ts","../../src/shared/cost-tracker.ts","../../src/shared/telemetry.ts","../../src/shared/index.ts","../../src/scot/types.ts","../../src/scot/parser.ts","../../src/scot/validator.ts","../../src/scot/prompts.ts","../../src/scot/planner.ts","../../src/scot/index.ts","../../src/refinement/types.ts","../../src/refinement/error-parser.ts","../../src/refinement/convergence-detector.ts","../../src/refinement/refinement-loop.ts","../../src/refinement/llkb-learning.ts","../../src/refinement/llkb-storage.ts","../../src/refinement/playwright-runner.ts","../../src/refinement/index.ts","../../src/uncertainty/types.ts","../../src/uncertainty/syntax-validator.ts","../../src/uncertainty/pattern-matcher.ts","../../src/uncertainty/selector-analyzer.ts","../../src/uncertainty/confidence-scorer.ts","../../src/uncertainty/multi-sampler.ts","../../src/uncertainty/index.ts","../../src/index.ts","../../src/pipeline/state.ts","../../src/cli/analyze.ts","../../src/mapping/normalize.ts","../../src/mapping/fuzzyMatcher.ts","../../src/mapping/unifiedMatcher.ts","../../src/mapping/plannedActionAdapter.ts","../../src/cli/plan.ts","../../src/mapping/telemetry.ts","../../src/mapping/blockedStepAnalysis.ts","../../src/cli/generate.ts","../../src/shared/blocked-step-telemetry.ts","../../src/cli/run.ts","../../src/cli/refine.ts","../../src/cli/status.ts","../../src/cli/clean.ts","../../src/cli/validate.ts","../../src/cli/verify.ts","../../src/cli/install.ts","../../src/cli/upgrade.ts","../../src/llkb/patternPromotion.ts","../../src/cli/patterns.ts","../../src/cli/llkb-patterns.ts","../../src/cli/index.ts"],"names":["path","err","parseYaml","init_schema","z","resolve","existsSync","readFileSync","join","dirname","buildLocatorFromHints","isAssertion","stringifyYaml","writeFileSync","escapeString","loadDefaultTemplate","ejs","getPatternStats","init_patterns","mkdirSync","unlinkSync","DEFAULT_OPTIONS","tmpdir","spawnSync","matchPattern","CURRENT_CONFIG_VERSION","init_types","init_parser","spawn","checkStability","runHealingLoop","DEFAULT_HEALING_CONFIG","renameSync","basename","fg","escapeRegex","init_normalize","DEFAULT_CONFIG","parseArgs","USAGE","init_telemetry","relative","getAutogenArtifact","parseErrors","code","statSync","hasFailures","summary","readdirSync","rmSync","init_validate","init_verify","init_install","init_upgrade","runList","runExport","confirmAction","createInterface","runClear","data","fileURLToPath","runAnalyze","runPlan","runGenerate","runRun","runRefine","runStatus","runClean","runValidate","runVerify","runInstall","runUpgrade","runPatterns","runLlkbPatterns"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Intermediate Representation (IR) Types\n * @see research/2026-01-02_autogen-refined-plan.md Section 9\n *\n * All code generation goes through IR. Prompts never generate Playwright code directly.\n */\n\n/**\n * Locator strategy following Playwright priority\n * role > label > text > testid > css\n */\nexport type LocatorStrategy = 'role' | 'label' | 'placeholder' | 'text' | 'testid' | 'css';\n\n/**\n * Specification for how to locate an element\n */\nexport interface LocatorSpec {\n  /** Locator strategy to use */\n  strategy: LocatorStrategy;\n  /** Primary value for the strategy (e.g., role name, label text) */\n  value: string;\n  /** Additional options for the locator */\n  options?: {\n    /** Accessible name for role locators */\n    name?: string;\n    /** Exact match flag */\n    exact?: boolean;\n    /** Heading level for heading role */\n    level?: number;\n    /** Whether to use strict mode (fail if multiple matches) */\n    strict?: boolean;\n  };\n}\n\n/**\n * Value specification for inputs and assertions\n */\nexport interface ValueSpec {\n  /** Type of value */\n  type: 'literal' | 'actor' | 'runId' | 'generated' | 'testData';\n  /** Value content or path */\n  value: string;\n  /** Optional transform to apply */\n  transform?: 'uppercase' | 'lowercase' | 'trim';\n}\n\n/**\n * IR Primitive - atomic actions that map to Playwright calls\n */\nexport type IRPrimitive =\n  // Navigation\n  | { type: 'goto'; url: string; waitForLoad?: boolean }\n  | { type: 'waitForURL'; pattern: string | RegExp }\n  | { type: 'waitForResponse'; urlPattern: string }\n  | { type: 'waitForLoadingComplete'; timeout?: number }\n  | { type: 'reload' }\n  | { type: 'goBack' }\n  | { type: 'goForward' }\n\n  // Wait primitives\n  | { type: 'waitForVisible'; locator: LocatorSpec; timeout?: number }\n  | { type: 'waitForHidden'; locator: LocatorSpec; timeout?: number }\n  | { type: 'waitForTimeout'; ms: number }\n  | { type: 'waitForNetworkIdle'; timeout?: number }\n\n  // Interactions\n  | { type: 'click'; locator: LocatorSpec }\n  | { type: 'dblclick'; locator: LocatorSpec }\n  | { type: 'rightClick'; locator: LocatorSpec }\n  | { type: 'fill'; locator: LocatorSpec; value: ValueSpec }\n  | { type: 'select'; locator: LocatorSpec; option: string }\n  | { type: 'check'; locator: LocatorSpec }\n  | { type: 'uncheck'; locator: LocatorSpec }\n  | { type: 'upload'; locator: LocatorSpec; files: string[] }\n  | { type: 'press'; key: string; locator?: LocatorSpec }\n  | { type: 'hover'; locator: LocatorSpec }\n  | { type: 'focus'; locator: LocatorSpec }\n  | { type: 'clear'; locator: LocatorSpec }\n\n  // Assertions (web-first, auto-retrying)\n  | { type: 'expectVisible'; locator: LocatorSpec; timeout?: number }\n  | { type: 'expectNotVisible'; locator: LocatorSpec; timeout?: number }\n  | { type: 'expectHidden'; locator: LocatorSpec; timeout?: number }\n  | { type: 'expectText'; locator: LocatorSpec; text: string | RegExp; timeout?: number }\n  | { type: 'expectValue'; locator: LocatorSpec; value: string; timeout?: number }\n  | { type: 'expectChecked'; locator: LocatorSpec; checked?: boolean }\n  | { type: 'expectEnabled'; locator: LocatorSpec }\n  | { type: 'expectDisabled'; locator: LocatorSpec }\n  | { type: 'expectURL'; pattern: string | RegExp }\n  | { type: 'expectTitle'; title: string | RegExp }\n  | { type: 'expectCount'; locator: LocatorSpec; count: number }\n  | { type: 'expectContainsText'; locator: LocatorSpec; text: string }\n\n  // Signals (toasts, modals, alerts)\n  | { type: 'expectToast'; toastType: 'success' | 'error' | 'info' | 'warning'; message?: string }\n  | { type: 'dismissModal'; }\n  | { type: 'acceptAlert'; }\n  | { type: 'dismissAlert'; }\n\n  // Module calls (abstraction layer)\n  | { type: 'callModule'; module: string; method: string; args?: unknown[] }\n\n  // Blocked/TODO (for steps that cannot be mapped)\n  | { type: 'blocked'; reason: string; sourceText: string };\n\n/**\n * A single step in the IR Journey\n * Maps to a test.step() in generated code\n */\nexport interface IRStep {\n  /** Step identifier (e.g., 'AC-1', 'AC-2') */\n  id: string;\n  /** Human-readable description */\n  description: string;\n  /** Actions to perform (clicks, fills, navigations) */\n  actions: IRPrimitive[];\n  /** Assertions to verify (expects) */\n  assertions: IRPrimitive[];\n  /** Original source text from Journey */\n  sourceText?: string;\n  /** Notes for debugging or TODOs */\n  notes?: string[];\n}\n\n/**\n * Journey tier classification\n */\nexport type JourneyTier = 'smoke' | 'release' | 'regression';\n\n/**\n * Data strategy for test data management\n */\nexport type DataStrategy = 'seed' | 'create' | 'reuse';\n\n/**\n * Cleanup strategy for test data\n */\nexport type CleanupStrategy = 'required' | 'best-effort' | 'none';\n\n/**\n * Module dependencies for a Journey\n */\nexport interface ModuleDependencies {\n  /** Foundation modules (auth, nav, etc.) */\n  foundation: string[];\n  /** Feature modules specific to this journey */\n  feature: string[];\n}\n\n/**\n * Completion signal types\n */\nexport type CompletionSignalType = 'url' | 'toast' | 'element' | 'text' | 'title' | 'api';\n\n/**\n * Completion signal for journey success\n */\nexport interface CompletionSignal {\n  type: CompletionSignalType;\n  value: string;\n  options?: {\n    timeout?: number;\n    exact?: boolean;\n    state?: 'visible' | 'hidden' | 'attached' | 'detached';\n    method?: string; // For API signals\n    status?: number; // For API signals\n  };\n}\n\n/**\n * Data configuration for a journey\n */\nexport interface JourneyDataConfig {\n  strategy: DataStrategy;\n  cleanup: CleanupStrategy;\n  /** Seed data requirements */\n  seeds?: string[];\n  /** Test data factory references */\n  factories?: string[];\n}\n\n/**\n * Negative path definition for error scenario testing\n */\nexport interface NegativePath {\n  /** Name of the negative path scenario */\n  name: string;\n  /** Input values to trigger the error */\n  input: Record<string, unknown>;\n  /** Expected error message */\n  expectedError: string;\n  /** Optional element selector where error should appear */\n  expectedElement?: string;\n}\n\n/**\n * Visual regression configuration\n */\nexport interface VisualRegressionConfig {\n  enabled: boolean;\n  snapshots?: string[];\n  threshold?: number;\n}\n\n/**\n * Accessibility timing mode\n */\nexport type AccessibilityTiming = 'afterEach' | 'inTest';\n\n/**\n * Accessibility configuration\n */\nexport interface AccessibilityConfig {\n  enabled: boolean;\n  rules?: string[];\n  exclude?: string[];\n  /** When to run checks: 'afterEach' (default) or 'inTest' */\n  timing?: AccessibilityTiming;\n}\n\n/**\n * Performance budgets configuration\n */\nexport interface PerformanceConfig {\n  enabled: boolean;\n  budgets?: {\n    lcp?: number;\n    fid?: number;\n    cls?: number;\n    ttfb?: number;\n  };\n  /** Timeout for collecting performance metrics in ms (default: 3000) */\n  collectTimeout?: number;\n}\n\n/**\n * Test data set for parameterized testing\n */\nexport interface TestDataSet {\n  /** Name of the test data set */\n  name: string;\n  /** Optional description */\n  description?: string;\n  /** Test data key-value pairs */\n  data: Record<string, unknown>;\n}\n\n/**\n * Complete IR representation of a Journey\n * This is the canonical format before code generation\n */\nexport interface IRJourney {\n  /** Journey ID (e.g., 'JRN-0001') */\n  id: string;\n  /** Human-readable title */\n  title: string;\n  /** Tier classification */\n  tier: JourneyTier;\n  /** Scope/area (e.g., 'billing', 'auth') */\n  scope: string;\n  /** Actor performing the journey */\n  actor: string;\n  /** Tags for filtering and organization */\n  tags: string[];\n  /** Module dependencies */\n  moduleDependencies: ModuleDependencies;\n  /** Data configuration */\n  data?: JourneyDataConfig;\n  /** Completion signals */\n  completion?: CompletionSignal[];\n  /** Setup steps (before main journey) */\n  setup?: IRPrimitive[];\n  /** Main journey steps */\n  steps: IRStep[];\n  /** Cleanup steps (after main journey) */\n  cleanup?: IRPrimitive[];\n  /** Journey revision number */\n  revision?: number;\n  /** Source file path */\n  sourcePath?: string;\n  /** Prerequisites - Journey IDs that must run first */\n  prerequisites?: string[];\n  /** Negative paths - Error scenarios to test */\n  negativePaths?: NegativePath[];\n  /** Test data sets for parameterized testing */\n  testData?: TestDataSet[];\n  /** Visual regression configuration */\n  visualRegression?: VisualRegressionConfig;\n  /** Accessibility configuration */\n  accessibility?: AccessibilityConfig;\n  /** Performance configuration */\n  performance?: PerformanceConfig;\n}\n\n/**\n * Result of mapping a journey to IR\n */\nexport interface IRMappingResult {\n  /** The mapped IR Journey */\n  journey: IRJourney;\n  /** Steps that could not be fully mapped */\n  blockedSteps: Array<{\n    stepId: string;\n    sourceText: string;\n    reason: string;\n  }>;\n  /** Warnings during mapping */\n  warnings: string[];\n  /** Mapping statistics */\n  stats: {\n    totalSteps: number;\n    mappedSteps: number;\n    blockedSteps: number;\n    totalActions: number;\n    totalAssertions: number;\n  };\n}\n","/**\n * IR Builder - Fluent API for constructing IR structures\n * @see research/2026-01-02_autogen-refined-plan.md Section 9\n */\nimport type {\n  IRJourney,\n  IRStep,\n  IRPrimitive,\n  LocatorSpec,\n  ValueSpec,\n  JourneyTier,\n  ModuleDependencies,\n  CompletionSignal,\n  JourneyDataConfig,\n  LocatorStrategy,\n} from './types.js';\n\n/**\n * Builder for constructing LocatorSpec\n */\nexport class LocatorBuilder {\n  private spec: Partial<LocatorSpec> = {};\n\n  static role(role: string, name?: string): LocatorBuilder {\n    const builder = new LocatorBuilder();\n    builder.spec.strategy = 'role';\n    builder.spec.value = role;\n    if (name) {\n      builder.spec.options = { ...builder.spec.options, name };\n    }\n    return builder;\n  }\n\n  static label(label: string): LocatorBuilder {\n    const builder = new LocatorBuilder();\n    builder.spec.strategy = 'label';\n    builder.spec.value = label;\n    return builder;\n  }\n\n  static placeholder(placeholder: string): LocatorBuilder {\n    const builder = new LocatorBuilder();\n    builder.spec.strategy = 'placeholder';\n    builder.spec.value = placeholder;\n    return builder;\n  }\n\n  static text(text: string): LocatorBuilder {\n    const builder = new LocatorBuilder();\n    builder.spec.strategy = 'text';\n    builder.spec.value = text;\n    return builder;\n  }\n\n  static testId(testId: string): LocatorBuilder {\n    const builder = new LocatorBuilder();\n    builder.spec.strategy = 'testid';\n    builder.spec.value = testId;\n    return builder;\n  }\n\n  static css(selector: string): LocatorBuilder {\n    const builder = new LocatorBuilder();\n    builder.spec.strategy = 'css';\n    builder.spec.value = selector;\n    return builder;\n  }\n\n  static fromSpec(strategy: LocatorStrategy, value: string): LocatorBuilder {\n    const builder = new LocatorBuilder();\n    builder.spec.strategy = strategy;\n    builder.spec.value = value;\n    return builder;\n  }\n\n  exact(exact = true): LocatorBuilder {\n    this.spec.options = { ...this.spec.options, exact };\n    return this;\n  }\n\n  level(level: number): LocatorBuilder {\n    this.spec.options = { ...this.spec.options, level };\n    return this;\n  }\n\n  strict(strict = true): LocatorBuilder {\n    this.spec.options = { ...this.spec.options, strict };\n    return this;\n  }\n\n  name(name: string): LocatorBuilder {\n    this.spec.options = { ...this.spec.options, name };\n    return this;\n  }\n\n  build(): LocatorSpec {\n    if (!this.spec.strategy || !this.spec.value) {\n      throw new Error('LocatorSpec requires strategy and value');\n    }\n    return this.spec as LocatorSpec;\n  }\n}\n\n/**\n * Builder for constructing ValueSpec\n */\nexport class ValueBuilder {\n  static literal(value: string): ValueSpec {\n    return { type: 'literal', value };\n  }\n\n  static actor(path: string): ValueSpec {\n    return { type: 'actor', value: path };\n  }\n\n  static runId(): ValueSpec {\n    return { type: 'runId', value: 'runId' };\n  }\n\n  static generated(template: string): ValueSpec {\n    return { type: 'generated', value: template };\n  }\n\n  static testData(path: string): ValueSpec {\n    return { type: 'testData', value: path };\n  }\n}\n\n/**\n * Builder for constructing IRStep\n */\nexport class StepBuilder {\n  private step: Partial<IRStep> = {\n    actions: [],\n    assertions: [],\n    notes: [],\n  };\n\n  constructor(id: string, description: string) {\n    this.step.id = id;\n    this.step.description = description;\n  }\n\n  sourceText(text: string): StepBuilder {\n    this.step.sourceText = text;\n    return this;\n  }\n\n  note(note: string): StepBuilder {\n    this.step.notes!.push(note);\n    return this;\n  }\n\n  // Navigation actions\n  goto(url: string, waitForLoad = true): StepBuilder {\n    this.step.actions!.push({ type: 'goto', url, waitForLoad });\n    return this;\n  }\n\n  waitForURL(pattern: string | RegExp): StepBuilder {\n    this.step.actions!.push({ type: 'waitForURL', pattern });\n    return this;\n  }\n\n  // Interaction actions\n  click(locator: LocatorSpec | LocatorBuilder): StepBuilder {\n    const spec = locator instanceof LocatorBuilder ? locator.build() : locator;\n    this.step.actions!.push({ type: 'click', locator: spec });\n    return this;\n  }\n\n  fill(locator: LocatorSpec | LocatorBuilder, value: ValueSpec | string): StepBuilder {\n    const spec = locator instanceof LocatorBuilder ? locator.build() : locator;\n    const valueSpec = typeof value === 'string' ? ValueBuilder.literal(value) : value;\n    this.step.actions!.push({ type: 'fill', locator: spec, value: valueSpec });\n    return this;\n  }\n\n  select(locator: LocatorSpec | LocatorBuilder, option: string): StepBuilder {\n    const spec = locator instanceof LocatorBuilder ? locator.build() : locator;\n    this.step.actions!.push({ type: 'select', locator: spec, option });\n    return this;\n  }\n\n  check(locator: LocatorSpec | LocatorBuilder): StepBuilder {\n    const spec = locator instanceof LocatorBuilder ? locator.build() : locator;\n    this.step.actions!.push({ type: 'check', locator: spec });\n    return this;\n  }\n\n  press(key: string, locator?: LocatorSpec | LocatorBuilder): StepBuilder {\n    const spec = locator\n      ? locator instanceof LocatorBuilder\n        ? locator.build()\n        : locator\n      : undefined;\n    this.step.actions!.push({ type: 'press', key, locator: spec });\n    return this;\n  }\n\n  // Assertions\n  expectVisible(\n    locator: LocatorSpec | LocatorBuilder,\n    timeout?: number\n  ): StepBuilder {\n    const spec = locator instanceof LocatorBuilder ? locator.build() : locator;\n    this.step.assertions!.push({ type: 'expectVisible', locator: spec, timeout });\n    return this;\n  }\n\n  expectNotVisible(\n    locator: LocatorSpec | LocatorBuilder,\n    timeout?: number\n  ): StepBuilder {\n    const spec = locator instanceof LocatorBuilder ? locator.build() : locator;\n    this.step.assertions!.push({ type: 'expectNotVisible', locator: spec, timeout });\n    return this;\n  }\n\n  expectText(\n    locator: LocatorSpec | LocatorBuilder,\n    text: string | RegExp,\n    timeout?: number\n  ): StepBuilder {\n    const spec = locator instanceof LocatorBuilder ? locator.build() : locator;\n    this.step.assertions!.push({ type: 'expectText', locator: spec, text, timeout });\n    return this;\n  }\n\n  expectURL(pattern: string | RegExp): StepBuilder {\n    this.step.assertions!.push({ type: 'expectURL', pattern });\n    return this;\n  }\n\n  expectTitle(title: string | RegExp): StepBuilder {\n    this.step.assertions!.push({ type: 'expectTitle', title });\n    return this;\n  }\n\n  expectToast(\n    toastType: 'success' | 'error' | 'info' | 'warning',\n    message?: string\n  ): StepBuilder {\n    this.step.assertions!.push({ type: 'expectToast', toastType, message });\n    return this;\n  }\n\n  // Module calls\n  callModule(module: string, method: string, args?: unknown[]): StepBuilder {\n    this.step.actions!.push({ type: 'callModule', module, method, args });\n    return this;\n  }\n\n  // Blocked step\n  blocked(reason: string, sourceText: string): StepBuilder {\n    this.step.actions!.push({ type: 'blocked', reason, sourceText });\n    return this;\n  }\n\n  // Raw primitive\n  action(primitive: IRPrimitive): StepBuilder {\n    this.step.actions!.push(primitive);\n    return this;\n  }\n\n  assertion(primitive: IRPrimitive): StepBuilder {\n    this.step.assertions!.push(primitive);\n    return this;\n  }\n\n  build(): IRStep {\n    if (!this.step.id || !this.step.description) {\n      throw new Error('IRStep requires id and description');\n    }\n    return this.step as IRStep;\n  }\n}\n\n/**\n * Builder for constructing IRJourney\n */\nexport class JourneyBuilder {\n  private journey: Partial<IRJourney> = {\n    tags: [],\n    steps: [],\n    moduleDependencies: { foundation: [], feature: [] },\n  };\n\n  constructor(id: string, title: string) {\n    this.journey.id = id;\n    this.journey.title = title;\n  }\n\n  tier(tier: JourneyTier): JourneyBuilder {\n    this.journey.tier = tier;\n    return this;\n  }\n\n  scope(scope: string): JourneyBuilder {\n    this.journey.scope = scope;\n    return this;\n  }\n\n  actor(actor: string): JourneyBuilder {\n    this.journey.actor = actor;\n    return this;\n  }\n\n  tag(tag: string): JourneyBuilder {\n    this.journey.tags!.push(tag);\n    return this;\n  }\n\n  tags(tags: string[]): JourneyBuilder {\n    this.journey.tags!.push(...tags);\n    return this;\n  }\n\n  foundationModule(module: string): JourneyBuilder {\n    this.journey.moduleDependencies!.foundation.push(module);\n    return this;\n  }\n\n  featureModule(module: string): JourneyBuilder {\n    this.journey.moduleDependencies!.feature.push(module);\n    return this;\n  }\n\n  modules(deps: ModuleDependencies): JourneyBuilder {\n    this.journey.moduleDependencies = deps;\n    return this;\n  }\n\n  data(config: JourneyDataConfig): JourneyBuilder {\n    this.journey.data = config;\n    return this;\n  }\n\n  completion(signals: CompletionSignal[]): JourneyBuilder {\n    this.journey.completion = signals;\n    return this;\n  }\n\n  setup(primitives: IRPrimitive[]): JourneyBuilder {\n    this.journey.setup = primitives;\n    return this;\n  }\n\n  step(step: IRStep | StepBuilder): JourneyBuilder {\n    const builtStep = step instanceof StepBuilder ? step.build() : step;\n    this.journey.steps!.push(builtStep);\n    return this;\n  }\n\n  cleanup(primitives: IRPrimitive[]): JourneyBuilder {\n    this.journey.cleanup = primitives;\n    return this;\n  }\n\n  revision(rev: number): JourneyBuilder {\n    this.journey.revision = rev;\n    return this;\n  }\n\n  sourcePath(path: string): JourneyBuilder {\n    this.journey.sourcePath = path;\n    return this;\n  }\n\n  build(): IRJourney {\n    if (\n      !this.journey.id ||\n      !this.journey.title ||\n      !this.journey.tier ||\n      !this.journey.scope ||\n      !this.journey.actor\n    ) {\n      throw new Error('IRJourney requires id, title, tier, scope, and actor');\n    }\n\n    // Add standard tags\n    const standardTags = [\n      '@artk',\n      '@journey',\n      `@${this.journey.id}`,\n      `@tier-${this.journey.tier}`,\n      `@scope-${this.journey.scope}`,\n    ];\n\n    const allTags = [...new Set([...standardTags, ...this.journey.tags!])];\n    this.journey.tags = allTags;\n\n    return this.journey as IRJourney;\n  }\n}\n\n/**\n * Convenience factory functions\n */\nexport const IR = {\n  journey: (id: string, title: string) => new JourneyBuilder(id, title),\n  step: (id: string, description: string) => new StepBuilder(id, description),\n  locator: {\n    role: LocatorBuilder.role,\n    label: LocatorBuilder.label,\n    placeholder: LocatorBuilder.placeholder,\n    text: LocatorBuilder.text,\n    testId: LocatorBuilder.testId,\n    css: LocatorBuilder.css,\n  },\n  value: ValueBuilder,\n};\n","/**\n * IR Serializer - Convert IR to JSON for debugging and analysis\n * @see research/2026-01-02_autogen-refined-plan.md Section 9\n */\nimport type { IRJourney, IRStep, IRPrimitive, LocatorSpec } from './types.js';\n\n/**\n * Options for IR serialization\n */\nexport interface SerializeOptions {\n  /** Include null/undefined values */\n  includeEmpty?: boolean;\n  /** Pretty print with indentation */\n  pretty?: boolean;\n  /** Indent size for pretty printing */\n  indent?: number;\n}\n\n/**\n * Serialize an IR Journey to JSON string\n */\nexport function serializeJourney(\n  journey: IRJourney,\n  options: SerializeOptions = {}\n): string {\n  const { pretty = true, indent = 2 } = options;\n\n  const cleaned = cleanObject(journey, options.includeEmpty ?? false);\n\n  return pretty\n    ? JSON.stringify(cleaned, null, indent)\n    : JSON.stringify(cleaned);\n}\n\n/**\n * Serialize an IR Step to JSON string\n */\nexport function serializeStep(\n  step: IRStep,\n  options: SerializeOptions = {}\n): string {\n  const { pretty = true, indent = 2 } = options;\n\n  const cleaned = cleanObject(step, options.includeEmpty ?? false);\n\n  return pretty\n    ? JSON.stringify(cleaned, null, indent)\n    : JSON.stringify(cleaned);\n}\n\n/**\n * Serialize an IR Primitive to JSON string\n */\nexport function serializePrimitive(\n  primitive: IRPrimitive,\n  options: SerializeOptions = {}\n): string {\n  const { pretty = true, indent = 2 } = options;\n\n  const cleaned = cleanObject(primitive, options.includeEmpty ?? false);\n\n  return pretty\n    ? JSON.stringify(cleaned, null, indent)\n    : JSON.stringify(cleaned);\n}\n\n/**\n * Convert a LocatorSpec to a human-readable description\n */\nexport function describeLocator(locator: LocatorSpec): string {\n  const { strategy, value, options } = locator;\n\n  switch (strategy) {\n    case 'role': {\n      let desc = `getByRole('${value}'`;\n      if (options?.name) {\n        desc += `, { name: '${options.name}'`;\n        if (options.exact) desc += ', exact: true';\n        if (options.level) desc += `, level: ${options.level}`;\n        desc += ' }';\n      }\n      desc += ')';\n      return desc;\n    }\n    case 'label':\n      return `getByLabel('${value}'${options?.exact ? ', { exact: true }' : ''})`;\n    case 'placeholder':\n      return `getByPlaceholder('${value}'${options?.exact ? ', { exact: true }' : ''})`;\n    case 'text':\n      return `getByText('${value}'${options?.exact ? ', { exact: true }' : ''})`;\n    case 'testid':\n      return `getByTestId('${value}')`;\n    case 'css':\n      return `locator('${value}')`;\n    default:\n      return `unknown('${value}')`;\n  }\n}\n\n/**\n * Convert an IR Primitive to a human-readable description\n */\nexport function describePrimitive(primitive: IRPrimitive): string {\n  switch (primitive.type) {\n    case 'goto':\n      return `Navigate to ${primitive.url}`;\n    case 'click':\n      return `Click ${describeLocator(primitive.locator)}`;\n    case 'fill':\n      return `Fill ${describeLocator(primitive.locator)} with \"${primitive.value.value}\"`;\n    case 'select':\n      return `Select \"${primitive.option}\" in ${describeLocator(primitive.locator)}`;\n    case 'check':\n      return `Check ${describeLocator(primitive.locator)}`;\n    case 'uncheck':\n      return `Uncheck ${describeLocator(primitive.locator)}`;\n    case 'press':\n      return `Press \"${primitive.key}\"`;\n    case 'hover':\n      return `Hover ${describeLocator(primitive.locator)}`;\n    case 'expectVisible':\n      return `Expect ${describeLocator(primitive.locator)} to be visible`;\n    case 'expectNotVisible':\n      return `Expect ${describeLocator(primitive.locator)} to be hidden`;\n    case 'expectText':\n      return `Expect ${describeLocator(primitive.locator)} to have text \"${primitive.text}\"`;\n    case 'expectURL':\n      return `Expect URL to match ${primitive.pattern}`;\n    case 'expectTitle':\n      return `Expect title to be \"${primitive.title}\"`;\n    case 'expectToast':\n      return `Expect ${primitive.toastType} toast${primitive.message ? `: \"${primitive.message}\"` : ''}`;\n    case 'callModule':\n      return `Call ${primitive.module}.${primitive.method}()`;\n    case 'blocked':\n      return `BLOCKED: ${primitive.reason}`;\n    case 'waitForURL':\n      return `Wait for URL to match ${primitive.pattern}`;\n    case 'waitForResponse':\n      return `Wait for response matching ${primitive.urlPattern}`;\n    case 'waitForLoadingComplete':\n      return `Wait for loading to complete`;\n    default:\n      return `Unknown primitive: ${(primitive as { type: string }).type}`;\n  }\n}\n\n/**\n * Generate a summary of an IR Journey\n */\nexport function summarizeJourney(journey: IRJourney): string {\n  const lines: string[] = [\n    `Journey: ${journey.id} - ${journey.title}`,\n    `  Tier: ${journey.tier}`,\n    `  Scope: ${journey.scope}`,\n    `  Actor: ${journey.actor}`,\n    `  Tags: ${journey.tags.join(', ')}`,\n    '',\n    `  Steps (${journey.steps.length}):`,\n  ];\n\n  for (const step of journey.steps) {\n    lines.push(`    ${step.id}: ${step.description}`);\n    lines.push(`      Actions: ${step.actions.length}`);\n    lines.push(`      Assertions: ${step.assertions.length}`);\n  }\n\n  if (journey.moduleDependencies.foundation.length > 0) {\n    lines.push('');\n    lines.push(`  Foundation Modules: ${journey.moduleDependencies.foundation.join(', ')}`);\n  }\n\n  if (journey.moduleDependencies.feature.length > 0) {\n    lines.push(`  Feature Modules: ${journey.moduleDependencies.feature.join(', ')}`);\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Remove null/undefined values from an object recursively\n */\nfunction cleanObject(obj: unknown, includeEmpty: boolean): unknown {\n  if (obj === null || obj === undefined) {\n    return includeEmpty ? obj : undefined;\n  }\n\n  if (Array.isArray(obj)) {\n    const cleaned = obj\n      .map((item) => cleanObject(item, includeEmpty))\n      .filter((item) => includeEmpty || item !== undefined);\n    return cleaned.length > 0 || includeEmpty ? cleaned : undefined;\n  }\n\n  if (typeof obj === 'object') {\n    const cleaned: Record<string, unknown> = {};\n    for (const [key, value] of Object.entries(obj)) {\n      const cleanedValue = cleanObject(value, includeEmpty);\n      if (includeEmpty || cleanedValue !== undefined) {\n        cleaned[key] = cleanedValue;\n      }\n    }\n    return Object.keys(cleaned).length > 0 || includeEmpty ? cleaned : undefined;\n  }\n\n  return obj;\n}\n","/**\n * Zod schema for autogen.config.yml\n * @see research/2026-01-02_autogen-refined-plan.md Section 7\n */\nimport { z } from 'zod';\n\n/**\n * Selector strategy types following Playwright priority\n */\nexport const SelectorStrategySchema = z.enum([\n  'role',\n  'label',\n  'placeholder',\n  'text',\n  'testid',\n  'css',\n]);\n\n/**\n * Path configuration for generated artifacts\n */\nexport const PathsSchema = z.object({\n  journeys: z.string().default('journeys'),\n  modules: z.string().default('e2e/modules'),\n  tests: z.string().default('e2e/tests'),\n  templates: z.string().default('artk/templates'),\n  catalog: z.string().default('artk/selectors'),\n});\n\n/**\n * ESLint rule severity\n */\nexport const EslintSeveritySchema = z.enum(['error', 'warn', 'off']);\n\n/**\n * ESLint rules configuration\n */\nexport const EslintRulesSchema = z.record(z.string(), EslintSeveritySchema).default({\n  'no-wait-for-timeout': 'error',\n  'no-force-option': 'error',\n  'prefer-web-first-assertions': 'error',\n});\n\n/**\n * Selector policy configuration\n */\nexport const SelectorPolicySchema = z.object({\n  priority: z.array(SelectorStrategySchema).default([\n    'role',\n    'label',\n    'placeholder',\n    'text',\n    'testid',\n    'css',\n  ]),\n  forbiddenPatterns: z.array(z.string()).default([]),\n});\n\n/**\n * Validation configuration\n */\nexport const ValidationSchema = z.object({\n  eslintRules: EslintRulesSchema.default({\n    'no-wait-for-timeout': 'error',\n    'no-force-option': 'error',\n    'prefer-web-first-assertions': 'error',\n  }),\n  customRules: z.array(z.string()).default([]),\n});\n\n/**\n * Healing configuration\n */\nexport const HealSchema = z.object({\n  enabled: z.boolean().default(true),\n  maxSuggestions: z.number().min(1).max(10).default(5),\n  skipPatterns: z.array(z.string()).default([]),\n});\n\n/**\n * Code regeneration strategy\n */\nexport const RegenerationStrategySchema = z.enum(['ast', 'blocks']).default('ast');\n\n/**\n * LLKB integration level\n * - minimal: Only load patterns, no glossary extension\n * - enhance: Load patterns and extend glossary (default)\n * - aggressive: Full LLKB integration with selector overrides\n */\nexport const LLKBIntegrationLevelSchema = z.enum(['minimal', 'enhance', 'aggressive']).default('enhance');\n\n/**\n * LLKB integration configuration (optional)\n * @see research/2026-01-23_llkb-autogen-integration-specification.md\n */\nexport const LLKBIntegrationSchema = z.object({\n  /** Enable LLKB integration (default: true - LLKB enhances test generation) */\n  enabled: z.boolean().default(true),\n\n  /** Path to LLKB-generated config file */\n  configPath: z.string().optional(),\n\n  /** Path to LLKB-generated glossary file */\n  glossaryPath: z.string().optional(),\n\n  /** Integration level */\n  level: LLKBIntegrationLevelSchema,\n}).default({});\n\n/**\n * Complete AutoGen configuration schema\n */\nexport const AutogenConfigSchema = z.object({\n  version: z.literal(1).default(1),\n  paths: PathsSchema.default({}),\n  selectorPolicy: SelectorPolicySchema.default({}),\n  validation: ValidationSchema.default({}),\n  heal: HealSchema.default({}),\n  regenerationStrategy: RegenerationStrategySchema,\n  llkb: LLKBIntegrationSchema,\n});\n\n/**\n * TypeScript types derived from schemas\n */\nexport type SelectorStrategy = z.infer<typeof SelectorStrategySchema>;\nexport type Paths = z.infer<typeof PathsSchema>;\nexport type EslintSeverity = z.infer<typeof EslintSeveritySchema>;\nexport type SelectorPolicy = z.infer<typeof SelectorPolicySchema>;\nexport type Validation = z.infer<typeof ValidationSchema>;\nexport type Heal = z.infer<typeof HealSchema>;\nexport type RegenerationStrategy = z.infer<typeof RegenerationStrategySchema>;\nexport type LLKBIntegrationLevel = z.infer<typeof LLKBIntegrationLevelSchema>;\nexport type LLKBIntegration = z.infer<typeof LLKBIntegrationSchema>;\nexport type AutogenConfig = z.infer<typeof AutogenConfigSchema>;\n","/**\n * Config loader for artk/autogen.config.yml\n * @see research/2026-01-02_autogen-refined-plan.md Section 7\n * @see research/2026-01-23_llkb-autogen-integration-specification.md (LLKB integration)\n */\nimport { readFileSync, existsSync } from 'node:fs';\nimport { join, resolve } from 'node:path';\nimport { parse as parseYaml } from 'yaml';\nimport { AutogenConfigSchema, type AutogenConfig } from './schema.js';\n\n/**\n * Default config file locations to search\n */\nconst CONFIG_PATHS = [\n  'artk/autogen.config.yml',\n  'artk/autogen.config.yaml',\n  '.artk/autogen.config.yml',\n  '.artk/autogen.config.yaml',\n];\n\n/**\n * Error thrown when config loading fails\n */\nexport class ConfigLoadError extends Error {\n  constructor(\n    message: string,\n    public readonly cause?: unknown // Preserved for error chaining, used by callers\n  ) {\n    super(message);\n    this.name = 'ConfigLoadError';\n    // Store cause in standard Error.cause property if supported\n    if (cause !== undefined) {\n      (this as { cause?: unknown }).cause = cause;\n    }\n  }\n}\n\n/**\n * Find the config file in the project\n */\nexport function findConfigFile(rootDir: string): string | null {\n  for (const configPath of CONFIG_PATHS) {\n    const fullPath = join(rootDir, configPath);\n    if (existsSync(fullPath)) {\n      return fullPath;\n    }\n  }\n  return null;\n}\n\n/**\n * Load and parse the autogen config file\n * @param configPath - Path to config file, or project root to auto-detect\n * @returns Parsed and validated config\n * @throws ConfigLoadError if config cannot be loaded or is invalid\n */\nexport function loadConfig(configPath?: string): AutogenConfig {\n  const rootDir = process.cwd();\n  let resolvedPath: string;\n\n  if (configPath) {\n    resolvedPath = resolve(rootDir, configPath);\n  } else {\n    const found = findConfigFile(rootDir);\n    if (!found) {\n      // Return default config if no file found\n      console.warn(\n        'No autogen config file found, using defaults. Create artk/autogen.config.yml to customize.'\n      );\n      return AutogenConfigSchema.parse({});\n    }\n    resolvedPath = found;\n  }\n\n  if (!existsSync(resolvedPath)) {\n    throw new ConfigLoadError(`Config file not found: ${resolvedPath}`);\n  }\n\n  let rawContent: string;\n  try {\n    rawContent = readFileSync(resolvedPath, 'utf-8');\n  } catch (err) {\n    throw new ConfigLoadError(`Failed to read config file: ${resolvedPath}`, err);\n  }\n\n  let parsed: unknown;\n  try {\n    parsed = parseYaml(rawContent);\n  } catch (err) {\n    throw new ConfigLoadError(`Invalid YAML in config file: ${resolvedPath}`, err);\n  }\n\n  // Validate with Zod schema\n  const result = AutogenConfigSchema.safeParse(parsed);\n  if (!result.success) {\n    const issues = result.error.issues\n      .map((i) => `  - ${i.path.join('.')}: ${i.message}`)\n      .join('\\n');\n    throw new ConfigLoadError(\n      `Invalid config in ${resolvedPath}:\\n${issues}`,\n      result.error\n    );\n  }\n\n  return result.data;\n}\n\n/**\n * Get the default config without loading from file\n */\nexport function getDefaultConfig(): AutogenConfig {\n  return AutogenConfigSchema.parse({});\n}\n\n/**\n * Resolve a path from config relative to project root\n */\nexport function resolveConfigPath(\n  config: AutogenConfig,\n  pathKey: keyof AutogenConfig['paths'],\n  rootDir?: string\n): string {\n  const base = rootDir || process.cwd();\n  return resolve(base, config.paths[pathKey]);\n}\n\n/**\n * Load a single config file without validation error handling\n * Used internally by loadConfigs for multi-config merging\n */\nfunction loadSingleConfig(configPath: string): AutogenConfig {\n  const resolvedPath = resolve(process.cwd(), configPath);\n\n  if (!existsSync(resolvedPath)) {\n    throw new ConfigLoadError(`Config file not found: ${resolvedPath}`);\n  }\n\n  let rawContent: string;\n  try {\n    rawContent = readFileSync(resolvedPath, 'utf-8');\n  } catch (err) {\n    throw new ConfigLoadError(`Failed to read config file: ${resolvedPath}`, err);\n  }\n\n  let parsed: unknown;\n  try {\n    parsed = parseYaml(rawContent);\n  } catch (err) {\n    throw new ConfigLoadError(`Invalid YAML in config file: ${resolvedPath}`, err);\n  }\n\n  const result = AutogenConfigSchema.safeParse(parsed);\n  if (!result.success) {\n    const issues = result.error.issues\n      .map((i) => `  - ${i.path.join('.')}: ${i.message}`)\n      .join('\\n');\n    throw new ConfigLoadError(\n      `Invalid config in ${resolvedPath}:\\n${issues}`,\n      result.error\n    );\n  }\n\n  return result.data;\n}\n\n/**\n * Deep merge helper for nested objects\n * Only merges properties that are explicitly defined (not undefined)\n */\nfunction deepMerge<T extends Record<string, unknown>>(base: T, override: Partial<T>): T {\n  const result = { ...base };\n\n  for (const key of Object.keys(override) as Array<keyof T>) {\n    const overrideValue = override[key];\n    if (overrideValue !== undefined) {\n      result[key] = overrideValue as T[keyof T];\n    }\n  }\n\n  return result;\n}\n\n/**\n * Merge multiple configs with later configs taking precedence\n * Arrays are merged additively for forbiddenPatterns, but overwritten for others\n * @see research/2026-01-23_llkb-autogen-integration-specification.md Round 2\n */\nexport function mergeConfigs(configs: AutogenConfig[]): AutogenConfig {\n  if (configs.length === 0) {\n    return getDefaultConfig();\n  }\n\n  // Start with first config, then merge subsequent configs into it\n  return configs.reduce((merged, config, index) => {\n    if (index === 0) {\n      return config;\n    }\n\n    return {\n      ...merged,\n      version: config.version ?? merged.version,\n      regenerationStrategy: config.regenerationStrategy ?? merged.regenerationStrategy,\n      paths: deepMerge(merged.paths, config.paths),\n      selectorPolicy: {\n        ...merged.selectorPolicy,\n        ...config.selectorPolicy,\n        // Merge arrays additively for forbiddenPatterns\n        forbiddenPatterns: [\n          ...new Set([\n            ...(merged.selectorPolicy?.forbiddenPatterns ?? []),\n            ...(config.selectorPolicy?.forbiddenPatterns ?? []),\n          ]),\n        ],\n        // Priority is overwritten if provided, not merged\n        priority: config.selectorPolicy?.priority?.length\n          ? config.selectorPolicy.priority\n          : merged.selectorPolicy?.priority,\n      },\n      validation: {\n        ...merged.validation,\n        ...config.validation,\n        eslintRules: {\n          ...merged.validation?.eslintRules,\n          ...config.validation?.eslintRules,\n        },\n        customRules: [\n          ...new Set([\n            ...(merged.validation?.customRules ?? []),\n            ...(config.validation?.customRules ?? []),\n          ]),\n        ],\n      },\n      heal: deepMerge(merged.heal, config.heal),\n      llkb: deepMerge(merged.llkb, config.llkb),\n    };\n  });\n}\n\n/**\n * Load and merge multiple config files\n * Later configs take precedence over earlier ones\n * @param configPaths - Array of config file paths to load and merge\n * @returns Merged config\n */\nexport function loadConfigs(configPaths: string[]): AutogenConfig {\n  const existingPaths = configPaths.filter((p) => {\n    const resolved = resolve(process.cwd(), p);\n    return existsSync(resolved);\n  });\n\n  if (existingPaths.length === 0) {\n    return getDefaultConfig();\n  }\n\n  const configs = existingPaths.map((p) => loadSingleConfig(p));\n  return mergeConfigs(configs);\n}\n\n/**\n * Load LLKB extension config if present\n * @param basePath - Base path to search for LLKB config\n * @returns Partial config or null if not found\n */\nexport function loadLLKBConfig(basePath: string): AutogenConfig | null {\n  const llkbConfigPaths = [\n    join(basePath, 'autogen-llkb.config.yml'),\n    join(basePath, 'autogen-llkb.config.yaml'),\n  ];\n\n  for (const llkbConfigPath of llkbConfigPaths) {\n    if (existsSync(llkbConfigPath)) {\n      try {\n        return loadSingleConfig(llkbConfigPath);\n      } catch {\n        // If LLKB config is invalid, return null rather than failing\n        console.warn(`Warning: Invalid LLKB config at ${llkbConfigPath}, skipping`);\n        return null;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Load config with automatic migration for backward compatibility (T009)\n *\n * This function ensures backward compatibility when the llkb field was added\n * to the AutogenConfig schema. Old configs without the llkb field will be\n * migrated to include it with default values.\n *\n * @param configPath - Path to config file, or project root to auto-detect\n * @returns Parsed config with llkb field guaranteed to exist\n *\n * @example\n * ```typescript\n * // Load config with automatic migration\n * const config = loadConfigWithMigration();\n * // config.llkb is guaranteed to exist (even for old configs)\n * ```\n */\nexport function loadConfigWithMigration(configPath?: string): AutogenConfig {\n  const config = loadConfig(configPath);\n\n  // Migration: Ensure llkb field has all required defaults\n  // The schema already has .default({}) but we add explicit migration\n  // for clarity and to handle edge cases where partial configs are loaded\n  // IMPORTANT: We MERGE with defaults, not replace, to preserve user's explicit settings\n  if (config.llkb === undefined || config.llkb === null) {\n    // No llkb config at all - use full defaults\n    config.llkb = {\n      enabled: true,  // LLKB should always be on by default\n      level: 'enhance',  // Match schema default\n    };\n  } else {\n    // Partial llkb config - merge with defaults, preserving user's explicit values\n    config.llkb = {\n      enabled: config.llkb.enabled ?? true,  // Default to true if not specified\n      level: config.llkb.level ?? 'enhance',  // Default to enhance if not specified\n      // Preserve any other user-specified fields\n      ...(config.llkb.configPath !== undefined && { configPath: config.llkb.configPath }),\n      ...(config.llkb.glossaryPath !== undefined && { glossaryPath: config.llkb.glossaryPath }),\n    };\n  }\n\n  return config;\n}\n\n/**\n * Check if a config needs migration\n *\n * @param config - Config to check\n * @returns True if migration is needed\n */\nexport function needsConfigMigration(config: unknown): boolean {\n  if (typeof config !== 'object' || config === null) {\n    return false;\n  }\n\n  const obj = config as Record<string, unknown>;\n\n  // Check if llkb field is missing or undefined\n  return obj.llkb === undefined;\n}\n\n/**\n * Get schema version from config\n *\n * This helps track which version of the schema a config file was created with.\n * Future schema changes can use this for more sophisticated migrations.\n *\n * @param config - Config object\n * @returns Schema version number\n */\nexport function getSchemaVersion(config: AutogenConfig): number {\n  return config.version;\n}\n","/**\n * Journey Frontmatter Zod Schema\n * @see research/2026-01-02_autogen-refined-plan.md Section 8\n */\nimport { z } from 'zod';\n\n/**\n * Journey status enum\n */\nexport const JourneyStatusSchema = z.enum([\n  'proposed',\n  'defined',\n  'clarified',\n  'implemented',\n  'quarantined',\n  'deprecated',\n]);\n\n/**\n * Journey tier enum\n */\nexport const JourneyTierSchema = z.enum(['smoke', 'release', 'regression']);\n\n/**\n * Data strategy enum\n */\nexport const DataStrategySchema = z.enum(['seed', 'create', 'reuse']);\n\n/**\n * Cleanup strategy enum\n */\nexport const CleanupStrategySchema = z.enum(['required', 'best-effort', 'none']);\n\n/**\n * Completion signal type enum\n */\nexport const CompletionTypeSchema = z.enum(['url', 'toast', 'element', 'text', 'title', 'api']);\n\n/**\n * Element state enum for completion signals\n */\nexport const ElementStateSchema = z.enum(['visible', 'hidden', 'attached', 'detached']);\n\n/**\n * Completion signal schema\n */\nexport const CompletionSignalSchema = z.object({\n  type: CompletionTypeSchema,\n  value: z.string().min(1, 'Completion signal value is required'),\n  options: z.object({\n    timeout: z.number().positive().optional(),\n    exact: z.boolean().optional(),\n    state: ElementStateSchema.optional(),\n    method: z.string().optional(),\n    status: z.number().int().positive().optional(),\n  }).optional(),\n});\n\n/**\n * Data configuration schema\n */\nexport const DataConfigSchema = z.object({\n  strategy: DataStrategySchema.default('create'),\n  cleanup: CleanupStrategySchema.default('best-effort'),\n});\n\n/**\n * Module dependencies schema\n */\nexport const ModulesSchema = z.object({\n  foundation: z.array(z.string()).default([]),\n  features: z.array(z.string()).default([]),\n});\n\n/**\n * Test reference schema\n */\nexport const TestRefSchema = z.object({\n  file: z.string(),\n  line: z.number().optional(),\n});\n\n/**\n * Link schema\n */\nexport const LinksSchema = z.object({\n  issues: z.array(z.string()).optional(),\n  prs: z.array(z.string()).optional(),\n  docs: z.array(z.string()).optional(),\n});\n\n/**\n * Negative path schema for error scenario testing\n */\nexport const NegativePathSchema = z.object({\n  name: z.string().min(1, 'Negative path name is required'),\n  input: z.record(z.any()),\n  expectedError: z.string().min(1, 'Expected error message is required'),\n  expectedElement: z.string().optional(),\n});\n\n/**\n * Visual regression configuration schema\n */\nexport const VisualRegressionSchema = z.object({\n  enabled: z.boolean(),\n  snapshots: z.array(z.string()).optional(),\n  threshold: z.number().min(0).max(1).optional(),\n});\n\n/**\n * Accessibility timing mode enum\n */\nexport const AccessibilityTimingSchema = z.enum(['afterEach', 'inTest']);\n\n/**\n * Accessibility configuration schema\n */\nexport const AccessibilitySchema = z.object({\n  enabled: z.boolean(),\n  rules: z.array(z.string()).optional(),\n  exclude: z.array(z.string()).optional(),\n  /**\n   * When to run accessibility checks:\n   * - 'afterEach': Run after each test (default, catches issues but doesn't fail individual tests)\n   * - 'inTest': Run within test steps (fails immediately, better for CI)\n   */\n  timing: AccessibilityTimingSchema.default('afterEach'),\n});\n\n/**\n * Performance budgets schema\n */\nexport const PerformanceSchema = z.object({\n  enabled: z.boolean(),\n  budgets: z\n    .object({\n      lcp: z.number().positive().optional(),\n      fid: z.number().positive().optional(),\n      cls: z.number().min(0).optional(),\n      ttfb: z.number().positive().optional(),\n    })\n    .optional(),\n  /** Timeout for collecting performance metrics in ms (default: 3000) */\n  collectTimeout: z.number().positive().optional(),\n});\n\n/**\n * Test data set schema for parameterized/data-driven tests\n */\nexport const TestDataSetSchema = z.object({\n  name: z.string().min(1, 'Test data set name is required'),\n  description: z.string().optional(),\n  data: z.record(z.string(), z.any()),\n});\n\n/**\n * Complete Journey frontmatter schema\n */\nexport const JourneyFrontmatterSchema = z.object({\n  id: z\n    .string()\n    .regex(/^JRN-\\d{4}$/, 'Journey ID must be in format JRN-XXXX'),\n  title: z.string().min(1, 'Title is required'),\n  status: JourneyStatusSchema,\n  tier: JourneyTierSchema,\n  scope: z.string().min(1, 'Scope is required'),\n  actor: z.string().min(1, 'Actor is required'),\n  revision: z.number().int().positive().default(1),\n  owner: z.string().optional(),\n  statusReason: z.string().optional(),\n  modules: ModulesSchema.default({ foundation: [], features: [] }),\n  tests: z.array(z.union([z.string(), TestRefSchema])).default([]),\n  data: DataConfigSchema.optional(),\n  completion: z.array(CompletionSignalSchema).optional(),\n  links: LinksSchema.optional(),\n  tags: z.array(z.string()).optional(),\n  flags: z\n    .object({\n      required: z.array(z.string()).optional(),\n      forbidden: z.array(z.string()).optional(),\n    })\n    .optional(),\n  prerequisites: z\n    .array(z.string())\n    .optional()\n    .describe('Array of Journey IDs that must run first'),\n  negativePaths: z\n    .array(NegativePathSchema)\n    .optional()\n    .describe('Error scenarios to test'),\n  testData: z\n    .array(TestDataSetSchema)\n    .optional()\n    .describe('Parameterized test data sets for data-driven testing'),\n  visualRegression: VisualRegressionSchema.optional(),\n  accessibility: AccessibilitySchema.optional(),\n  performance: PerformanceSchema.optional(),\n});\n\n/**\n * Schema specifically for clarified journeys (required for AutoGen)\n */\nexport const ClarifiedJourneyFrontmatterSchema = JourneyFrontmatterSchema.extend({\n  status: z.literal('clarified'),\n}).refine(\n  (data) => {\n    // Clarified journeys should have completion signals\n    return data.completion && data.completion.length > 0;\n  },\n  {\n    message: 'Clarified journeys must have at least one completion signal',\n    path: ['completion'],\n  }\n);\n\n/**\n * Schema for implemented journeys (must have tests)\n */\nexport const ImplementedJourneyFrontmatterSchema = JourneyFrontmatterSchema.extend({\n  status: z.literal('implemented'),\n}).refine(\n  (data) => {\n    return data.tests && data.tests.length > 0;\n  },\n  {\n    message: 'Implemented journeys must have at least one test reference',\n    path: ['tests'],\n  }\n);\n\n/**\n * Schema for quarantined journeys (must have owner and reason)\n */\nexport const QuarantinedJourneyFrontmatterSchema = JourneyFrontmatterSchema.extend({\n  status: z.literal('quarantined'),\n  owner: z.string().min(1, 'Quarantined journeys require an owner'),\n  statusReason: z.string().min(1, 'Quarantined journeys require a status reason'),\n}).refine(\n  (data) => {\n    return data.links?.issues && data.links.issues.length > 0;\n  },\n  {\n    message: 'Quarantined journeys must have at least one linked issue',\n    path: ['links', 'issues'],\n  }\n);\n\n/**\n * TypeScript types\n */\nexport type JourneyStatus = z.infer<typeof JourneyStatusSchema>;\nexport type JourneyTier = z.infer<typeof JourneyTierSchema>;\nexport type DataStrategy = z.infer<typeof DataStrategySchema>;\nexport type CleanupStrategy = z.infer<typeof CleanupStrategySchema>;\nexport type CompletionType = z.infer<typeof CompletionTypeSchema>;\nexport type CompletionSignal = z.infer<typeof CompletionSignalSchema>;\nexport type DataConfig = z.infer<typeof DataConfigSchema>;\nexport type Modules = z.infer<typeof ModulesSchema>;\nexport type TestRef = z.infer<typeof TestRefSchema>;\nexport type Links = z.infer<typeof LinksSchema>;\nexport type NegativePath = z.infer<typeof NegativePathSchema>;\nexport type TestDataSet = z.infer<typeof TestDataSetSchema>;\nexport type VisualRegression = z.infer<typeof VisualRegressionSchema>;\nexport type Accessibility = z.infer<typeof AccessibilitySchema>;\nexport type Performance = z.infer<typeof PerformanceSchema>;\nexport type JourneyFrontmatter = z.infer<typeof JourneyFrontmatterSchema>;\n\n/**\n * Validate that a journey is ready for AutoGen (must be clarified)\n */\nexport function validateForAutoGen(\n  frontmatter: JourneyFrontmatter\n): { valid: boolean; errors: string[] } {\n  const errors: string[] = [];\n\n  if (frontmatter.status !== 'clarified') {\n    errors.push(\n      `Journey status must be \"clarified\" for AutoGen, got \"${frontmatter.status}\"`\n    );\n  }\n\n  if (!frontmatter.completion || frontmatter.completion.length === 0) {\n    errors.push('Journey must have completion signals defined');\n  }\n\n  if (!frontmatter.actor) {\n    errors.push('Journey must have an actor defined');\n  }\n\n  if (!frontmatter.scope) {\n    errors.push('Journey must have a scope defined');\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n","/**\n * Step Mapping Patterns - Regex patterns for parsing step text into IR primitives\n * @see research/2026-01-02_autogen-refined-plan.md Section 10\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md Phase 3\n */\nimport type { IRPrimitive, LocatorSpec, ValueSpec, LocatorStrategy } from '../ir/types.js';\n\n/**\n * Pattern version - increment when patterns change\n * Format: MAJOR.MINOR.PATCH\n * - MAJOR: Breaking changes to pattern behavior\n * - MINOR: New patterns added\n * - PATCH: Bug fixes to existing patterns\n */\nexport const PATTERN_VERSION = '1.1.0';\n\n/**\n * Pattern metadata for tracking\n */\nexport interface PatternMetadata {\n  name: string;\n  version: string;\n  addedDate: string;\n  source: 'core' | 'llkb' | 'telemetry';\n  category: string;\n}\n\n/**\n * Pattern result with match groups\n */\nexport interface PatternMatch {\n  type: IRPrimitive['type'];\n  groups: Record<string, string>;\n}\n\n/**\n * Pattern definition\n */\nexport interface StepPattern {\n  /** Pattern name for debugging */\n  name: string;\n  /** Regex pattern with named groups */\n  regex: RegExp;\n  /** IR primitive type this pattern produces */\n  primitiveType: IRPrimitive['type'];\n  /** Extract IR primitive from match (prefix with _ if unused) */\n  extract: (_match: RegExpMatchArray) => IRPrimitive | null;\n}\n\n/**\n * Create a locator spec from pattern match\n */\nexport function createLocatorFromMatch(\n  strategy: LocatorStrategy,\n  value: string,\n  name?: string\n): LocatorSpec {\n  const locator: LocatorSpec = { strategy, value };\n  if (name) {\n    locator.options = { name };\n  }\n  return locator;\n}\n\n/**\n * Create a value spec from text\n */\nexport function createValueFromText(text: string): ValueSpec {\n  // Actor reference: {{email}}, {{password}}, etc.\n  if (/^\\{\\{.+\\}\\}$/.test(text)) {\n    const path = text.slice(2, -2).trim();\n    return { type: 'actor', value: path };\n  }\n\n  // Test data reference: $user.email, $testData.field\n  if (/^\\$.+/.test(text)) {\n    return { type: 'testData', value: text.slice(1) };\n  }\n\n  // Generated value: ${runId}, ${timestamp}\n  if (/\\$\\{.+\\}/.test(text)) {\n    return { type: 'generated', value: text };\n  }\n\n  // Literal value\n  return { type: 'literal', value: text };\n}\n\n/**\n * Navigation patterns\n */\nexport const navigationPatterns: StepPattern[] = [\n  {\n    name: 'navigate-to-url',\n    regex: /^(?:user\\s+)?(?:navigates?|go(?:es)?|opens?)\\s+(?:to\\s+)?(?:the\\s+)?[\"']?([^\"'\\s]+)[\"']?$/i,\n    primitiveType: 'goto',\n    extract: (match) => ({\n      type: 'goto',\n      url: match[1]!,\n      waitForLoad: true,\n    }),\n  },\n  {\n    name: 'navigate-to-page',\n    regex: /^(?:user\\s+)?(?:navigates?|go(?:es)?|opens?)\\s+(?:to\\s+)?(?:the\\s+)?(.+?)\\s+page$/i,\n    primitiveType: 'goto',\n    extract: (match) => ({\n      type: 'goto',\n      url: `/${match[1]!.toLowerCase().replace(/\\s+/g, '-')}`,\n      waitForLoad: true,\n    }),\n  },\n  {\n    name: 'wait-for-url-change',\n    // \"Wait for URL to change to '/dashboard'\" or \"Wait until URL contains '/settings'\"\n    regex: /^(?:user\\s+)?waits?\\s+(?:for\\s+)?(?:the\\s+)?url\\s+(?:to\\s+)?(?:change\\s+to|contain|include)\\s+[\"']?([^\"']+)[\"']?$/i,\n    primitiveType: 'waitForURL',\n    extract: (match) => ({\n      type: 'waitForURL',\n      pattern: match[1]!,\n    }),\n  },\n];\n\n/**\n * Click patterns\n */\nexport const clickPatterns: StepPattern[] = [\n  {\n    name: 'click-button-quoted',\n    regex: /^(?:user\\s+)?(?:clicks?|presses?|taps?|selects?)\\s+(?:on\\s+)?(?:the\\s+)?[\"']([^\"']+)[\"']\\s+button$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('role', 'button', match[1]!),\n    }),\n  },\n  {\n    name: 'click-link-quoted',\n    regex: /^(?:user\\s+)?(?:clicks?|presses?|taps?|selects?)\\s+(?:on\\s+)?(?:the\\s+)?[\"']([^\"']+)[\"']\\s+link$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('role', 'link', match[1]!),\n    }),\n  },\n  {\n    name: 'click-menuitem-quoted',\n    // \"Click the 'Settings' menu item\" or \"Click on 'Edit' menuitem\"\n    regex: /^(?:user\\s+)?(?:clicks?|selects?)\\s+(?:on\\s+)?(?:the\\s+)?[\"']([^\"']+)[\"']\\s+menu\\s*item$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('role', 'menuitem', match[1]!),\n    }),\n  },\n  {\n    name: 'click-tab-quoted',\n    // \"Click the 'Details' tab\" or \"Select the 'Overview' tab\"\n    regex: /^(?:user\\s+)?(?:clicks?|selects?)\\s+(?:on\\s+)?(?:the\\s+)?[\"']([^\"']+)[\"']\\s+tab$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('role', 'tab', match[1]!),\n    }),\n  },\n  {\n    name: 'click-element-quoted',\n    regex: /^(?:user\\s+)?(?:clicks?|presses?|taps?|selects?)\\s+(?:on\\s+)?(?:the\\s+)?[\"']([^\"']+)[\"']$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'click-element-generic',\n    regex: /^(?:user\\s+)?(?:clicks?|presses?|taps?|selects?)\\s+(?:on\\s+)?(?:the\\s+)?(.+?)\\s+(?:button|link|icon|menu|tab)$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n];\n\n/**\n * Fill/Input patterns\n */\nexport const fillPatterns: StepPattern[] = [\n  {\n    name: 'fill-field-quoted-value',\n    regex: /^(?:user\\s+)?(?:enters?|types?|fills?\\s+in?|inputs?)\\s+[\"']([^\"']+)[\"']\\s+(?:in|into)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']\\s*(?:field|input)?$/i,\n    primitiveType: 'fill',\n    extract: (match) => ({\n      type: 'fill',\n      locator: createLocatorFromMatch('label', match[2]!),\n      value: createValueFromText(match[1]!),\n    }),\n  },\n  {\n    name: 'fill-field-actor-value',\n    regex: /^(?:user\\s+)?(?:enters?|types?|fills?\\s+in?|inputs?)\\s+(\\{\\{[^}]+\\}\\})\\s+(?:in|into)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']\\s*(?:field|input)?$/i,\n    primitiveType: 'fill',\n    extract: (match) => ({\n      type: 'fill',\n      locator: createLocatorFromMatch('label', match[2]!),\n      value: createValueFromText(match[1]!),\n    }),\n  },\n  {\n    name: 'fill-placeholder-field',\n    // \"Fill 'test@example.com' in the field with placeholder 'Enter email'\"\n    // or \"Type 'value' into input with placeholder 'Search'\"\n    regex: /^(?:user\\s+)?(?:enters?|types?|fills?)\\s+[\"']([^\"']+)[\"']\\s+(?:in|into)\\s+(?:the\\s+)?(?:field|input)\\s+with\\s+placeholder\\s+[\"']([^\"']+)[\"']$/i,\n    primitiveType: 'fill',\n    extract: (match) => ({\n      type: 'fill',\n      locator: createLocatorFromMatch('placeholder', match[2]!),\n      value: createValueFromText(match[1]!),\n    }),\n  },\n  {\n    name: 'fill-field-generic',\n    regex: /^(?:user\\s+)?(?:enters?|types?|fills?\\s+in?|inputs?)\\s+(.+?)\\s+(?:in|into)\\s+(?:the\\s+)?(.+?)\\s*(?:field|input)?$/i,\n    primitiveType: 'fill',\n    extract: (match) => ({\n      type: 'fill',\n      locator: createLocatorFromMatch('label', match[2]!.replace(/[\"']/g, '')),\n      value: createValueFromText(match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n];\n\n/**\n * Select patterns\n */\nexport const selectPatterns: StepPattern[] = [\n  {\n    name: 'select-option',\n    regex: /^(?:user\\s+)?(?:selects?|chooses?)\\s+[\"']([^\"']+)[\"']\\s+(?:from|in)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']\\s*(?:dropdown|select|menu)?$/i,\n    primitiveType: 'select',\n    extract: (match) => ({\n      type: 'select',\n      locator: createLocatorFromMatch('label', match[2]!),\n      option: match[1]!,\n    }),\n  },\n];\n\n/**\n * Check/Uncheck patterns\n */\nexport const checkPatterns: StepPattern[] = [\n  {\n    name: 'check-checkbox',\n    regex: /^(?:user\\s+)?(?:checks?|enables?|ticks?)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']\\s*(?:checkbox|option)?$/i,\n    primitiveType: 'check',\n    extract: (match) => ({\n      type: 'check',\n      locator: createLocatorFromMatch('label', match[1]!),\n    }),\n  },\n  {\n    // \"Check the terms checkbox\" - unquoted checkbox name\n    name: 'check-checkbox-unquoted',\n    regex: /^(?:user\\s+)?(?:checks?|enables?|ticks?)\\s+(?:the\\s+)?(\\w+(?:\\s+\\w+)*)\\s+checkbox$/i,\n    primitiveType: 'check',\n    extract: (match) => ({\n      type: 'check',\n      locator: createLocatorFromMatch('label', match[1]!),\n    }),\n  },\n  {\n    name: 'uncheck-checkbox',\n    regex: /^(?:user\\s+)?(?:unchecks?|disables?|unticks?)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']\\s*(?:checkbox|option)?$/i,\n    primitiveType: 'uncheck',\n    extract: (match) => ({\n      type: 'uncheck',\n      locator: createLocatorFromMatch('label', match[1]!),\n    }),\n  },\n  {\n    // \"Uncheck the newsletter checkbox\" - unquoted checkbox name\n    name: 'uncheck-checkbox-unquoted',\n    regex: /^(?:user\\s+)?(?:unchecks?|disables?|unticks?)\\s+(?:the\\s+)?(\\w+(?:\\s+\\w+)*)\\s+checkbox$/i,\n    primitiveType: 'uncheck',\n    extract: (match) => ({\n      type: 'uncheck',\n      locator: createLocatorFromMatch('label', match[1]!),\n    }),\n  },\n];\n\n/**\n * Visibility assertion patterns\n */\nexport const visibilityPatterns: StepPattern[] = [\n  {\n    name: 'should-see-text',\n    regex: /^(?:user\\s+)?(?:should\\s+)?(?:sees?|views?)\\s+(?:the\\s+)?[\"']([^\"']+)[\"']$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'is-visible',\n    regex: /^[\"']?([^\"']+)[\"']?\\s+(?:is\\s+)?(?:visible|displayed|shown)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'should-see-element',\n    regex: /^(?:user\\s+)?(?:should\\s+)?(?:sees?|views?)\\s+(?:the\\s+)?(.+?)\\s+(?:heading|button|link|form|page|element)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'page-displayed',\n    regex: /^(?:the\\s+)?(.+?)\\s+(?:page|screen|view)\\s+(?:is\\s+)?(?:displayed|shown|visible)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n];\n\n/**\n * Toast/notification patterns\n */\nexport const toastPatterns: StepPattern[] = [\n  {\n    name: 'success-toast-message',\n    // \"A success toast with 'Account created' appears\" (pre-verb, quoted)\n    regex: /^(?:a\\s+)?success\\s+toast\\s+(?:with\\s+)?[\"']([^\"']+)[\"']\\s*(?:message\\s+)?(?:appears?|is\\s+shown|displays?)$/i,\n    primitiveType: 'expectToast',\n    extract: (match) => ({\n      type: 'expectToast',\n      toastType: 'success',\n      message: match[1]!,\n    }),\n  },\n  {\n    name: 'success-toast-appears-with',\n    // \"A success toast appears with Account created\" (post-verb, unquoted)\n    regex: /^(?:a\\s+)?success\\s+toast\\s+(?:appears?|is\\s+shown|displays?)\\s+(?:with\\s+)?(?:(?:message|text)\\s+)?[\"']?(.+?)[\"']?$/i,\n    primitiveType: 'expectToast',\n    extract: (match) => ({\n      type: 'expectToast',\n      toastType: 'success',\n      message: match[1]!,\n    }),\n  },\n  {\n    name: 'error-toast-message',\n    // \"An error toast with 'Invalid email' appears\" (pre-verb, quoted)\n    regex: /^(?:an?\\s+)?error\\s+toast\\s+(?:with\\s+)?[\"']([^\"']+)[\"']\\s*(?:message\\s+)?(?:appears?|is\\s+shown|displays?)$/i,\n    primitiveType: 'expectToast',\n    extract: (match) => ({\n      type: 'expectToast',\n      toastType: 'error',\n      message: match[1]!,\n    }),\n  },\n  {\n    name: 'error-toast-appears-with',\n    // \"An error toast appears with Invalid email\" (post-verb, unquoted)\n    regex: /^(?:an?\\s+)?error\\s+toast\\s+(?:appears?|is\\s+shown|displays?)\\s+(?:with\\s+)?(?:(?:message|text)\\s+)?[\"']?(.+?)[\"']?$/i,\n    primitiveType: 'expectToast',\n    extract: (match) => ({\n      type: 'expectToast',\n      toastType: 'error',\n      message: match[1]!,\n    }),\n  },\n  {\n    name: 'toast-appears',\n    // \"A success toast appears\" or \"A toast notification appears\"\n    regex: /^(?:a\\s+)?(?:(success|error|info|warning)\\s+)?toast\\s+(?:notification\\s+)?(?:appears?|is\\s+shown|displays?)$/i,\n    primitiveType: 'expectToast',\n    extract: (match) => ({\n      type: 'expectToast',\n      toastType: (match[1]?.toLowerCase() ?? 'info') as 'success' | 'error' | 'info' | 'warning',\n    }),\n  },\n  {\n    name: 'toast-with-text',\n    // \"Toast with text 'Hello' appears\" (quoted) or \"Toast with text Hello appears\" (unquoted)\n    regex: /^(?:a\\s+)?(?:toast|notification)\\s+(?:with\\s+)?(?:(?:text|message)\\s+)?[\"']?(.+?)[\"']?\\s+(?:appears?|is\\s+shown|displays?)$/i,\n    primitiveType: 'expectToast',\n    extract: (match) => ({\n      type: 'expectToast',\n      toastType: 'info',\n      message: match[1]!,\n    }),\n  },\n  {\n    name: 'status-message-visible',\n    // \"A status message 'Processing...' is visible\" or \"The status shows 'Loading'\"\n    regex: /^(?:a\\s+)?status\\s+(?:message\\s+)?[\"']([^\"']+)[\"']\\s+(?:is\\s+)?(?:visible|shown|displayed)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('role', 'status', match[1]!),\n    }),\n  },\n  {\n    name: 'verify-status-message',\n    // \"Verify the status message shows 'Complete'\"\n    regex: /^(?:verify|check)\\s+(?:that\\s+)?(?:the\\s+)?status\\s+(?:message\\s+)?(?:shows?|displays?|contains?)\\s+[\"']([^\"']+)[\"']$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('role', 'status', match[1]!),\n    }),\n  },\n];\n\n/**\n * URL assertion patterns\n */\nexport const urlPatterns: StepPattern[] = [\n  {\n    name: 'url-contains',\n    regex: /^(?:the\\s+)?url\\s+(?:should\\s+)?(?:contains?|includes?)\\s+[\"']?([^\"'\\s]+)[\"']?$/i,\n    primitiveType: 'expectURL',\n    extract: (match) => ({\n      type: 'expectURL',\n      pattern: match[1]!,\n    }),\n  },\n  {\n    name: 'url-is',\n    regex: /^(?:the\\s+)?url\\s+(?:should\\s+)?(?:is|equals?|be)\\s+[\"']?([^\"'\\s]+)[\"']?$/i,\n    primitiveType: 'expectURL',\n    extract: (match) => ({\n      type: 'expectURL',\n      pattern: match[1]!,\n    }),\n  },\n  {\n    name: 'redirected-to',\n    regex: /^(?:user\\s+)?(?:is\\s+)?redirected\\s+to\\s+[\"']?([^\"'\\s]+)[\"']?$/i,\n    primitiveType: 'expectURL',\n    extract: (match) => ({\n      type: 'expectURL',\n      pattern: match[1]!,\n    }),\n  },\n];\n\n/**\n * Module call patterns (authentication)\n */\nexport const authPatterns: StepPattern[] = [\n  {\n    name: 'user-login',\n    regex: /^(?:user\\s+)?(?:logs?\\s*in|login\\s+is\\s+performed|authenticates?)$/i,\n    primitiveType: 'callModule',\n    extract: (_match) => ({\n      type: 'callModule',\n      module: 'auth',\n      method: 'login',\n    }),\n  },\n  {\n    name: 'user-logout',\n    regex: /^(?:user\\s+)?(?:logs?\\s*out|logout\\s+is\\s+performed|signs?\\s*out)$/i,\n    primitiveType: 'callModule',\n    extract: (_match) => ({\n      type: 'callModule',\n      module: 'auth',\n      method: 'logout',\n    }),\n  },\n  {\n    name: 'login-as-role',\n    regex: /^(?:user\\s+)?logs?\\s*in\\s+as\\s+(?:an?\\s+)?(.+?)(?:\\s+user)?$/i,\n    primitiveType: 'callModule',\n    extract: (match) => ({\n      type: 'callModule',\n      module: 'auth',\n      method: 'loginAs',\n      args: [match[1]!.toLowerCase()],\n    }),\n  },\n];\n\n/**\n * Wait patterns\n */\nexport const waitPatterns: StepPattern[] = [\n  {\n    name: 'wait-for-navigation',\n    regex: /^(?:user\\s+)?(?:waits?\\s+)?(?:for\\s+)?navigation\\s+to\\s+[\"']?([^\"'\\s]+)[\"']?$/i,\n    primitiveType: 'waitForURL',\n    extract: (match) => ({\n      type: 'waitForURL',\n      pattern: match[1]!,\n    }),\n  },\n  {\n    name: 'wait-for-page',\n    regex: /^(?:user\\s+)?(?:waits?\\s+)?(?:for\\s+)?(?:the\\s+)?(.+?)\\s+(?:page|screen)\\s+to\\s+load$/i,\n    primitiveType: 'waitForLoadingComplete',\n    extract: (_match) => ({\n      type: 'waitForLoadingComplete',\n    }),\n  },\n];\n\n/**\n * Helper function to convert natural language selectors to Playwright locator strategies\n */\nexport function parseSelectorToLocator(selector: string): { strategy: LocatorStrategy; value: string; name?: string } {\n  // Remove leading \"the\" if present\n  const cleanSelector = selector.replace(/^the\\s+/i, '').trim();\n\n  // Match button patterns\n  if (/button$/i.test(cleanSelector)) {\n    const buttonName = cleanSelector.replace(/\\s*button$/i, '').trim();\n    return { strategy: 'role', value: 'button', name: buttonName };\n  }\n\n  // Match link patterns\n  if (/link$/i.test(cleanSelector)) {\n    const linkName = cleanSelector.replace(/\\s*link$/i, '').trim();\n    return { strategy: 'role', value: 'link', name: linkName };\n  }\n\n  // Match input/field patterns\n  if (/(?:input|field)$/i.test(cleanSelector)) {\n    const labelName = cleanSelector.replace(/\\s*(?:input|field)$/i, '').trim();\n    return { strategy: 'label', value: labelName };\n  }\n\n  // Default to text locator\n  return { strategy: 'text', value: cleanSelector };\n}\n\n/**\n * Structured step patterns for Journey markdown format\n * Matches patterns like:\n * - **Action**: Click the login button\n * - **Wait for**: Dashboard to load\n * - **Assert**: User name is visible\n */\nexport const structuredPatterns: StepPattern[] = [\n  // Action patterns\n  {\n    name: 'structured-action-click',\n    regex: /^\\*\\*Action\\*\\*:\\s*[Cc]lick\\s+(?:the\\s+)?['\"]?(.+?)['\"]?\\s*(?:button|link)?$/i,\n    primitiveType: 'click',\n    extract: (match) => {\n      const target = match[1]!;\n      const locatorInfo = parseSelectorToLocator(target + ' button');\n      return {\n        type: 'click',\n        locator: locatorInfo.name\n          ? createLocatorFromMatch(locatorInfo.strategy, locatorInfo.value, locatorInfo.name)\n          : { strategy: locatorInfo.strategy, value: locatorInfo.value },\n      };\n    },\n  },\n  {\n    name: 'structured-action-fill',\n    regex: /^\\*\\*Action\\*\\*:\\s*[Ff]ill\\s+(?:in\\s+)?['\"]?(.+?)['\"]?\\s+with\\s+['\"]?(.+?)['\"]?$/i,\n    primitiveType: 'fill',\n    extract: (match) => {\n      const target = match[1]!;\n      const value = match[2]!;\n      const locatorInfo = parseSelectorToLocator(target);\n      return {\n        type: 'fill',\n        locator: locatorInfo.name\n          ? createLocatorFromMatch(locatorInfo.strategy, locatorInfo.value, locatorInfo.name)\n          : { strategy: locatorInfo.strategy, value: locatorInfo.value },\n        value: createValueFromText(value),\n      };\n    },\n  },\n  {\n    name: 'structured-action-navigate',\n    regex: /^\\*\\*Action\\*\\*:\\s*[Nn]avigate\\s+to\\s+['\"]?(.+?)['\"]?$/i,\n    primitiveType: 'goto',\n    extract: (match) => ({\n      type: 'goto',\n      url: match[1]!,\n      waitForLoad: true,\n    }),\n  },\n\n  // Wait patterns\n  {\n    name: 'structured-wait-for-visible',\n    regex: /^\\*\\*Wait for\\*\\*:\\s*(.+?)\\s+(?:to\\s+)?(?:be\\s+)?(?:visible|appear|load)/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => {\n      const target = match[1]!;\n      const locatorInfo = parseSelectorToLocator(target);\n      return {\n        type: 'expectVisible',\n        locator: locatorInfo.name\n          ? createLocatorFromMatch(locatorInfo.strategy, locatorInfo.value, locatorInfo.name)\n          : { strategy: locatorInfo.strategy, value: locatorInfo.value },\n      };\n    },\n  },\n\n  // Assert patterns\n  {\n    name: 'structured-assert-visible',\n    regex: /^\\*\\*Assert\\*\\*:\\s*(.+?)\\s+(?:is\\s+)?visible$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => {\n      const target = match[1]!;\n      const locatorInfo = parseSelectorToLocator(target);\n      return {\n        type: 'expectVisible',\n        locator: locatorInfo.name\n          ? createLocatorFromMatch(locatorInfo.strategy, locatorInfo.value, locatorInfo.name)\n          : { strategy: locatorInfo.strategy, value: locatorInfo.value },\n      };\n    },\n  },\n  {\n    name: 'structured-assert-text',\n    regex: /^\\*\\*Assert\\*\\*:\\s*(.+?)\\s+(?:contains|has text)\\s+['\"]?(.+?)['\"]?$/i,\n    primitiveType: 'expectText',\n    extract: (match) => {\n      const target = match[1]!;\n      const text = match[2]!;\n      const locatorInfo = parseSelectorToLocator(target);\n      return {\n        type: 'expectText',\n        locator: locatorInfo.name\n          ? createLocatorFromMatch(locatorInfo.strategy, locatorInfo.value, locatorInfo.name)\n          : { strategy: locatorInfo.strategy, value: locatorInfo.value },\n        text,\n      };\n    },\n  },\n];\n\n/**\n * Extended click patterns - Common variations missed by core patterns\n * Added in v1.1.0 based on telemetry analysis\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md Phase 3\n */\nexport const extendedClickPatterns: StepPattern[] = [\n  {\n    name: 'click-on-element',\n    // \"Click on Submit\" or \"Click on the Submit button\" or \"Select on the item\"\n    regex: /^(?:user\\s+)?(?:clicks?|selects?)\\s+on\\s+(?:the\\s+)?(.+?)(?:\\s+button|\\s+link)?$/i,\n    primitiveType: 'click',\n    extract: (match) => ({\n      type: 'click',\n      locator: createLocatorFromMatch('text', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n  {\n    name: 'press-enter-key',\n    // \"Press Enter\" or \"Press the Enter key\" or \"Hit Enter\"\n    regex: /^(?:user\\s+)?(?:press(?:es)?|hits?)\\s+(?:the\\s+)?(?:enter|return)(?:\\s+key)?$/i,\n    primitiveType: 'press',\n    extract: () => ({\n      type: 'press',\n      key: 'Enter',\n    }),\n  },\n  {\n    name: 'press-tab-key',\n    // \"Press Tab\" or \"Press the Tab key\"\n    regex: /^(?:user\\s+)?(?:press(?:es)?|hits?)\\s+(?:the\\s+)?tab(?:\\s+key)?$/i,\n    primitiveType: 'press',\n    extract: () => ({\n      type: 'press',\n      key: 'Tab',\n    }),\n  },\n  {\n    name: 'press-escape-key',\n    // \"Press Escape\" or \"Press Esc\"\n    regex: /^(?:user\\s+)?(?:press(?:es)?|hits?)\\s+(?:the\\s+)?(?:escape|esc)(?:\\s+key)?$/i,\n    primitiveType: 'press',\n    extract: () => ({\n      type: 'press',\n      key: 'Escape',\n    }),\n  },\n  {\n    name: 'double-click',\n    // \"Double click on\" or \"Double-click the\"\n    regex: /^(?:user\\s+)?double[-\\s]?clicks?\\s+(?:on\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?$/i,\n    primitiveType: 'dblclick',\n    extract: (match) => ({\n      type: 'dblclick',\n      locator: createLocatorFromMatch('text', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n  {\n    name: 'right-click',\n    // \"Right click on\" or \"Right-click the\"\n    regex: /^(?:user\\s+)?right[-\\s]?clicks?\\s+(?:on\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?$/i,\n    primitiveType: 'rightClick',\n    extract: (match) => ({\n      type: 'rightClick',\n      locator: createLocatorFromMatch('text', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n  {\n    name: 'submit-form',\n    // \"Submit the form\" or \"Submits form\"\n    regex: /^(?:user\\s+)?submits?\\s+(?:the\\s+)?form$/i,\n    primitiveType: 'click',\n    extract: () => ({\n      type: 'click',\n      locator: createLocatorFromMatch('role', 'button', 'Submit'),\n    }),\n  },\n];\n\n/**\n * Extended fill patterns - Common variations missed by core patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const extendedFillPatterns: StepPattern[] = [\n  {\n    name: 'fill-field-with-value',\n    // \"Fill the username field with john\" or \"Fill the 'description' field with 'the value'\"\n    regex: /^(?:user\\s+)?(?:fills?|enters?|types?|inputs?)(?:\\s+in)?\\s+(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:field|input)\\s+with\\s+[\"']?(.+?)[\"']?$/i,\n    primitiveType: 'fill',\n    extract: (match) => ({\n      type: 'fill',\n      locator: createLocatorFromMatch('label', match[1]!.replace(/[\"']/g, '')),\n      value: createValueFromText(match[2]!.replace(/[\"']/g, '')),\n    }),\n  },\n  {\n    name: 'type-into-field',\n    // \"Type 'password' into the Password field\"\n    regex: /^(?:user\\s+)?types?\\s+['\"](.+?)['\"]\\s+into\\s+(?:the\\s+)?[\"']?(.+?)[\"']?\\s*(?:field|input)?$/i,\n    primitiveType: 'fill',\n    extract: (match) => ({\n      type: 'fill',\n      locator: createLocatorFromMatch('label', match[2]!),\n      value: createValueFromText(match[1]!),\n    }),\n  },\n  {\n    name: 'fill-in-field-no-value',\n    // \"Fill in the email address\" (without explicit value - uses actor data)\n    regex: /^(?:user\\s+)?fills?\\s+in\\s+(?:the\\s+)?[\"']?(.+?)[\"']?\\s*(?:field|input)?$/i,\n    primitiveType: 'fill',\n    extract: (match) => {\n      const fieldName = match[1]!.replace(/[\"']/g, '');\n      return {\n        type: 'fill',\n        locator: createLocatorFromMatch('label', fieldName),\n        value: { type: 'actor', value: fieldName.toLowerCase().replace(/\\s+/g, '_') },\n      };\n    },\n  },\n  {\n    name: 'clear-field',\n    // \"Clear the email field\" or \"Clears the input\"\n    regex: /^(?:user\\s+)?clears?\\s+(?:the\\s+)?[\"']?(.+?)[\"']?\\s*(?:field|input)?$/i,\n    primitiveType: 'clear',\n    extract: (match) => ({\n      type: 'clear',\n      locator: createLocatorFromMatch('label', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n  {\n    name: 'set-value',\n    // \"Set the value to 'test'\" or \"Sets field to 'value'\"\n    regex: /^(?:user\\s+)?sets?\\s+(?:the\\s+)?(?:value\\s+)?(?:of\\s+)?[\"']?(.+?)[\"']?\\s+to\\s+['\"](.+?)['\"]$/i,\n    primitiveType: 'fill',\n    extract: (match) => ({\n      type: 'fill',\n      locator: createLocatorFromMatch('label', match[1]!),\n      value: createValueFromText(match[2]!),\n    }),\n  },\n];\n\n/**\n * Extended assertion patterns - Common variations missed by core patterns\n * Added in v1.1.0 based on telemetry analysis\n *\n * IMPORTANT: Patterns are ordered by SPECIFICITY (most specific first)\n * - \"is not visible\" patterns must come before generic \"is visible\" patterns\n * - \"URL contains\" patterns must come before generic \"contains\" patterns\n * - Specific state assertions (enabled, disabled, checked) before generic visibility\n */\nexport const extendedAssertionPatterns: StepPattern[] = [\n  // \n  // MOST SPECIFIC: Negative assertions (must come before positive counterparts)\n  // \n  {\n    name: 'verify-not-visible',\n    // \"Verify the error container is not visible\"\n    regex: /^(?:verify|confirm|check)\\s+(?:that\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+is\\s+not\\s+visible$/i,\n    primitiveType: 'expectHidden',\n    extract: (match) => ({\n      type: 'expectHidden',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'element-should-not-be-visible',\n    // \"The error should not be visible\" or \"Error message is not displayed\"\n    regex: /^(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:should\\s+)?(?:not\\s+be|is\\s+not)\\s+(?:visible|displayed|shown)$/i,\n    primitiveType: 'expectHidden',\n    extract: (match) => ({\n      type: 'expectHidden',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n\n  // \n  // URL AND TITLE: Specific patterns that match \"URL\" or \"title\" keywords\n  // \n  {\n    name: 'verify-url-contains',\n    // \"Verify the URL contains '/dashboard'\"\n    regex: /^(?:verify|confirm|check)\\s+(?:that\\s+)?(?:the\\s+)?url\\s+contains?\\s+[\"']([^\"']+)[\"']$/i,\n    primitiveType: 'expectURL',\n    extract: (match) => ({\n      type: 'expectURL',\n      pattern: match[1]!,\n    }),\n  },\n  {\n    name: 'verify-title-is',\n    // \"Verify the page title is 'Settings'\"\n    regex: /^(?:verify|confirm|check)\\s+(?:that\\s+)?(?:the\\s+)?(?:page\\s+)?title\\s+(?:is|equals?)\\s+[\"']([^\"']+)[\"']$/i,\n    primitiveType: 'expectTitle',\n    extract: (match) => ({\n      type: 'expectTitle',\n      title: match[1]!,\n    }),\n  },\n\n  // \n  // SPECIFIC STATE ASSERTIONS: enabled, disabled, checked, value, count\n  // \n  {\n    name: 'verify-field-value',\n    // \"Verify the username field has value 'testuser'\"\n    regex: /^(?:verify|confirm|check)\\s+(?:that\\s+)?(?:the\\s+)?[\"']?(\\w+)[\"']?\\s+(?:field\\s+)?has\\s+value\\s+[\"']([^\"']+)[\"']$/i,\n    primitiveType: 'expectValue',\n    extract: (match) => ({\n      type: 'expectValue',\n      locator: createLocatorFromMatch('label', match[1]!),\n      value: match[2]!,\n    }),\n  },\n  {\n    name: 'verify-element-enabled',\n    // \"Verify the submit button is enabled\"\n    regex: /^(?:verify|confirm|check)\\s+(?:that\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:button\\s+)?is\\s+enabled$/i,\n    primitiveType: 'expectEnabled',\n    extract: (match) => ({\n      type: 'expectEnabled',\n      locator: createLocatorFromMatch('label', match[1]!),\n    }),\n  },\n  {\n    name: 'verify-element-disabled',\n    // \"Verify the disabled input is disabled\"\n    regex: /^(?:verify|confirm|check)\\s+(?:that\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:input\\s+)?is\\s+disabled$/i,\n    primitiveType: 'expectDisabled',\n    extract: (match) => ({\n      type: 'expectDisabled',\n      locator: createLocatorFromMatch('label', match[1]!),\n    }),\n  },\n  {\n    name: 'verify-checkbox-checked',\n    // \"Verify the checkbox is checked\"\n    regex: /^(?:verify|confirm|check)\\s+(?:that\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:checkbox\\s+)?is\\s+checked$/i,\n    primitiveType: 'expectChecked',\n    extract: (match) => ({\n      type: 'expectChecked',\n      locator: createLocatorFromMatch('label', match[1]!),\n    }),\n  },\n  {\n    name: 'verify-count',\n    // \"Verify 5 items are shown\" or \"Verify 3 elements exist\"\n    regex: /^(?:verify|confirm|check)\\s+(?:that\\s+)?(\\d+)\\s+(?:items?|elements?|rows?)\\s+(?:are\\s+)?(?:shown|displayed|exist|visible)$/i,\n    primitiveType: 'expectCount',\n    extract: (match) => ({\n      type: 'expectCount',\n      locator: { strategy: 'text', value: 'item' },\n      count: parseInt(match[1]!, 10),\n    }),\n  },\n\n  // \n  // GENERIC VISIBILITY: Catch-all patterns for \"is visible/displayed/showing\"\n  // These must come AFTER specific patterns to avoid over-matching\n  // \n  {\n    name: 'verify-element-showing',\n    // \"Verify the dashboard is showing/displayed\"\n    regex: /^(?:verify|confirm|ensure)\\s+(?:that\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:is\\s+)?(?:showing|displayed|visible)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'page-should-show',\n    // \"The page should show 'Welcome'\" or \"Page should display 'text'\"\n    regex: /^(?:the\\s+)?page\\s+should\\s+(?:show|display|contain)\\s+['\"](.+?)['\"]$/i,\n    primitiveType: 'expectText',\n    extract: (match) => ({\n      type: 'expectText',\n      locator: { strategy: 'role', value: 'main' },\n      text: match[1]!,\n    }),\n  },\n  {\n    name: 'make-sure-assertion',\n    // \"Make sure the button is visible\" or \"Make sure user sees 'text'\"\n    regex: /^make\\s+sure\\s+(?:that\\s+)?(?:the\\s+)?(.+?)\\s+(?:is\\s+)?(?:visible|displayed|shown)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'confirm-that-assertion',\n    // \"Confirm that the message appears\", \"Verify success message appears\", or \"Confirm the error is shown\"\n    regex: /^(?:verify|confirm)\\s+(?:that\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:appears?|is\\s+shown|displays?)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'check-element-exists',\n    // \"Check that the element exists\" or \"Check the button is present\"\n    regex: /^check\\s+(?:that\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:exists?|is\\s+present)$/i,\n    primitiveType: 'expectVisible',\n    extract: (match) => ({\n      type: 'expectVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n\n  // \n  // GENERIC TEXT ASSERTIONS: \"contains\" patterns (must be last to avoid conflicts)\n  // \n  {\n    name: 'element-contains-text',\n    // \"The header contains 'Welcome'\" or \"Element should contain 'text'\"\n    regex: /^(?:the\\s+)?[\"']?(.+?)[\"']?\\s+(?:should\\s+)?contains?\\s+['\"](.+?)['\"]$/i,\n    primitiveType: 'expectText',\n    extract: (match) => ({\n      type: 'expectText',\n      locator: createLocatorFromMatch('text', match[1]!),\n      text: match[2]!,\n    }),\n  },\n];\n\n/**\n * Extended wait patterns - Common variations missed by core patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const extendedWaitPatterns: StepPattern[] = [\n  {\n    name: 'wait-for-element-visible',\n    // \"Wait for the loading spinner to disappear\"\n    regex: /^(?:user\\s+)?waits?\\s+(?:for\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+to\\s+(?:disappear|be\\s+hidden)$/i,\n    primitiveType: 'waitForHidden',\n    extract: (match) => ({\n      type: 'waitForHidden',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'wait-for-element-appear',\n    // \"Wait for the modal to appear\" or \"Wait for dialog to show\"\n    regex: /^(?:user\\s+)?waits?\\s+(?:for\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?\\s+to\\s+(?:appear|show|be\\s+visible)$/i,\n    primitiveType: 'waitForVisible',\n    extract: (match) => ({\n      type: 'waitForVisible',\n      locator: createLocatorFromMatch('text', match[1]!),\n    }),\n  },\n  {\n    name: 'wait-until-loaded',\n    // \"Wait until the page is loaded\" or \"Wait until content loads\"\n    regex: /^(?:user\\s+)?waits?\\s+until\\s+(?:the\\s+)?(?:page|content|data)\\s+(?:is\\s+)?loaded$/i,\n    primitiveType: 'waitForLoadingComplete',\n    extract: () => ({\n      type: 'waitForLoadingComplete',\n    }),\n  },\n  {\n    name: 'wait-seconds',\n    // \"Wait for 2 seconds\" or \"Wait 3 seconds\"\n    regex: /^(?:user\\s+)?waits?\\s+(?:for\\s+)?(\\d+)\\s+seconds?$/i,\n    primitiveType: 'waitForTimeout',\n    extract: (match) => ({\n      type: 'waitForTimeout',\n      ms: parseInt(match[1]!, 10) * 1000,\n    }),\n  },\n  {\n    name: 'wait-for-network',\n    // \"Wait for network to be idle\" or \"Wait for network idle\"\n    regex: /^(?:user\\s+)?waits?\\s+(?:for\\s+)?(?:the\\s+)?network\\s+(?:to\\s+be\\s+)?idle$/i,\n    primitiveType: 'waitForNetworkIdle',\n    extract: () => ({\n      type: 'waitForNetworkIdle',\n    }),\n  },\n];\n\n/**\n * Extended navigation patterns - Common variations missed by core patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const extendedNavigationPatterns: StepPattern[] = [\n  {\n    name: 'refresh-page',\n    // \"Refresh the page\" or \"Reload the page\"\n    regex: /^(?:user\\s+)?(?:refresh(?:es)?|reloads?)\\s+(?:the\\s+)?page$/i,\n    primitiveType: 'reload',\n    extract: () => ({\n      type: 'reload',\n    }),\n  },\n  {\n    name: 'go-back',\n    // \"Go back\" or \"Navigate back\" or \"User goes back\"\n    regex: /^(?:user\\s+)?(?:go(?:es)?|navigates?)\\s+back$/i,\n    primitiveType: 'goBack',\n    extract: () => ({\n      type: 'goBack',\n    }),\n  },\n  {\n    name: 'go-forward',\n    // \"Go forward\" or \"Navigate forward\"\n    regex: /^(?:user\\s+)?(?:go(?:es)?|navigates?)\\s+forward$/i,\n    primitiveType: 'goForward',\n    extract: () => ({\n      type: 'goForward',\n    }),\n  },\n];\n\n/**\n * Extended select/dropdown patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const extendedSelectPatterns: StepPattern[] = [\n  {\n    name: 'select-from-named-dropdown',\n    // \"Select 'USA' from the country dropdown\" or \"Select 'Large' from the size selector\"\n    regex: /^(?:user\\s+)?(?:selects?|chooses?)\\s+[\"'](.+?)[\"']\\s+from\\s+(?:the\\s+)?(.+?)\\s*(?:dropdown|select|selector|menu|list)$/i,\n    primitiveType: 'select',\n    extract: (match) => ({\n      type: 'select',\n      locator: createLocatorFromMatch('label', match[2]!.trim()),\n      option: match[1]!,\n    }),\n  },\n  {\n    name: 'select-from-dropdown',\n    // \"Select 'Option' from dropdown\" or \"Choose 'Value' from the dropdown\"\n    regex: /^(?:user\\s+)?(?:selects?|chooses?)\\s+['\"](.+?)['\"]\\s+from\\s+(?:the\\s+)?dropdown$/i,\n    primitiveType: 'select',\n    extract: (match) => ({\n      type: 'select',\n      locator: { strategy: 'role', value: 'combobox' },\n      option: match[1]!,\n    }),\n  },\n  {\n    name: 'select-option-named',\n    // \"Select option 'Value'\" or \"Select option named 'Premium'\" or \"Choose the 'Option' option\"\n    regex: /^(?:user\\s+)?(?:selects?|chooses?)\\s+(?:the\\s+)?(?:option\\s+)?(?:named\\s+)?[\"'](.+?)[\"'](?:\\s+option)?$/i,\n    primitiveType: 'select',\n    extract: (match) => ({\n      type: 'select',\n      locator: { strategy: 'role', value: 'combobox' },\n      option: match[1]!,\n    }),\n  },\n];\n\n/**\n * Hover patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const hoverPatterns: StepPattern[] = [\n  {\n    name: 'hover-over-element',\n    // \"Hover over the menu\" or \"User hovers on button\"\n    regex: /^(?:user\\s+)?hovers?\\s+(?:over|on)\\s+(?:the\\s+)?[\"']?(.+?)[\"']?$/i,\n    primitiveType: 'hover',\n    extract: (match) => ({\n      type: 'hover',\n      locator: createLocatorFromMatch('text', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n  {\n    name: 'mouse-over',\n    // \"Mouse over the element\" or \"Mouseover the button\"\n    regex: /^(?:user\\s+)?mouse\\s*over\\s+(?:the\\s+)?[\"']?(.+?)[\"']?$/i,\n    primitiveType: 'hover',\n    extract: (match) => ({\n      type: 'hover',\n      locator: createLocatorFromMatch('text', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n];\n\n/**\n * Focus patterns\n * Added in v1.1.0 based on telemetry analysis\n */\nexport const focusPatterns: StepPattern[] = [\n  {\n    name: 'focus-on-element',\n    // \"Focus on the input\" or \"User focuses the field\"\n    regex: /^(?:user\\s+)?focus(?:es)?\\s+(?:on\\s+)?(?:the\\s+)?[\"']?(.+?)[\"']?$/i,\n    primitiveType: 'focus',\n    extract: (match) => ({\n      type: 'focus',\n      locator: createLocatorFromMatch('label', match[1]!.replace(/[\"']/g, '')),\n    }),\n  },\n];\n\n/**\n * Modal and Alert patterns\n * Added in v1.1.0 for comprehensive E2E coverage\n */\nexport const modalAlertPatterns: StepPattern[] = [\n  {\n    name: 'dismiss-modal',\n    // \"Dismiss the modal\" or \"Close the modal dialog\"\n    regex: /^(?:dismiss|close)\\s+(?:the\\s+)?(?:modal|dialog)(?:\\s+dialog)?$/i,\n    primitiveType: 'dismissModal',\n    extract: () => ({\n      type: 'dismissModal',\n    }),\n  },\n  {\n    name: 'accept-alert',\n    // \"Accept the alert\" or \"Click OK on alert\"\n    regex: /^(?:accept|confirm|ok)\\s+(?:the\\s+)?alert$/i,\n    primitiveType: 'acceptAlert',\n    extract: () => ({\n      type: 'acceptAlert',\n    }),\n  },\n  {\n    name: 'dismiss-alert',\n    // \"Dismiss the alert\" or \"Cancel the alert\"\n    regex: /^(?:dismiss|cancel|close)\\s+(?:the\\s+)?alert$/i,\n    primitiveType: 'dismissAlert',\n    extract: () => ({\n      type: 'dismissAlert',\n    }),\n  },\n];\n\n/**\n * All patterns in priority order (more specific patterns first)\n * Structured patterns come first to prioritize the Journey markdown format\n */\nexport const allPatterns: StepPattern[] = [\n  ...structuredPatterns,\n  ...authPatterns,\n  ...toastPatterns,\n  ...modalAlertPatterns, // Modal/alert patterns for dialog handling\n  // Extended patterns come BEFORE base patterns to match more specific cases first\n  ...extendedNavigationPatterns, // Must be before navigationPatterns (e.g., \"Go back\" vs \"Go to\")\n  ...navigationPatterns,\n  ...extendedClickPatterns, // Must be before clickPatterns (e.g., \"Click on\" vs \"Click\")\n  ...clickPatterns,\n  ...extendedFillPatterns,\n  ...fillPatterns,\n  ...extendedSelectPatterns,\n  ...selectPatterns,\n  ...checkPatterns,\n  ...extendedAssertionPatterns, // Must be before visibilityPatterns (e.g., \"not be visible\")\n  ...visibilityPatterns,\n  ...urlPatterns,\n  ...extendedWaitPatterns,\n  ...waitPatterns,\n  ...hoverPatterns,\n  ...focusPatterns,\n];\n\n/**\n * Match text against all patterns and return the first matching primitive\n */\nexport function matchPattern(text: string): IRPrimitive | null {\n  const trimmedText = text.trim();\n\n  for (const pattern of allPatterns) {\n    const match = trimmedText.match(pattern.regex);\n    if (match) {\n      const primitive = pattern.extract(match);\n      if (primitive) {\n        return primitive;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Get all pattern matches for debugging\n */\nexport function getPatternMatches(text: string): Array<{ pattern: string; match: IRPrimitive }> {\n  const trimmedText = text.trim();\n  const matches: Array<{ pattern: string; match: IRPrimitive }> = [];\n\n  for (const pattern of allPatterns) {\n    const match = trimmedText.match(pattern.regex);\n    if (match) {\n      const primitive = pattern.extract(match);\n      if (primitive) {\n        matches.push({ pattern: pattern.name, match: primitive });\n      }\n    }\n  }\n\n  return matches;\n}\n\n/**\n * Get all pattern names for CLI listing\n */\nexport function getAllPatternNames(): string[] {\n  return allPatterns.map((p) => p.name);\n}\n\n/**\n * Get pattern count by category\n */\nexport function getPatternCountByCategory(): Record<string, number> {\n  const counts: Record<string, number> = {};\n\n  for (const pattern of allPatterns) {\n    const category = pattern.name.split('-')[0] || 'other';\n    counts[category] = (counts[category] || 0) + 1;\n  }\n\n  return counts;\n}\n\n/**\n * Get pattern metadata for a specific pattern\n */\nexport function getPatternMetadata(patternName: string): PatternMetadata | null {\n  const pattern = allPatterns.find((p) => p.name === patternName);\n  if (!pattern) return null;\n\n  // Determine version based on pattern name prefix\n  const isExtended =\n    patternName.includes('extended') ||\n    patternName.startsWith('hover') ||\n    patternName.startsWith('focus') ||\n    patternName.startsWith('press-') ||\n    patternName.startsWith('double-') ||\n    patternName.startsWith('right-');\n\n  return {\n    name: pattern.name,\n    version: isExtended ? '1.1.0' : '1.0.0',\n    addedDate: isExtended ? '2026-01-27' : '2026-01-02',\n    source: 'core',\n    category: pattern.name.split('-')[0] || 'other',\n  };\n}\n\n/**\n * Find patterns that match a given text (for debugging)\n */\nexport function findMatchingPatterns(text: string): string[] {\n  const trimmedText = text.trim();\n  const matchingNames: string[] = [];\n\n  for (const pattern of allPatterns) {\n    if (pattern.regex.test(trimmedText)) {\n      matchingNames.push(pattern.name);\n    }\n  }\n\n  return matchingNames;\n}\n","/**\n * Result type pattern for structured error handling\n *\n * Replaces boolean returns with structured results that include:\n * - Success/failure status\n * - Value on success\n * - Error information on failure\n * - Optional warnings for partial success cases\n *\n * @see research/2026-01-15_code_quality_standards.md Category 2 (Silent Failures)\n */\n\n/**\n * A Result type representing either success with a value or failure with an error\n *\n * @example\n * ```typescript\n * function parseConfig(path: string): Result<Config, ConfigError> {\n *   if (!fileExists(path)) {\n *     return { success: false, error: { code: 'NOT_FOUND', message: 'Config file not found' } };\n *   }\n *   const config = JSON.parse(readFile(path));\n *   return { success: true, value: config };\n * }\n *\n * const result = parseConfig('config.json');\n * if (result.success) {\n *   console.log(result.value); // Config object\n * } else {\n *   console.error(result.error); // ConfigError\n * }\n * ```\n */\nexport type Result<T, E = string> =\n  | { success: true; value: T; warnings?: string[] }\n  | { success: false; error: E };\n\n/**\n * Create a successful result\n *\n * @param value - The success value\n * @param warnings - Optional warnings to include\n * @returns A success Result\n *\n * @example\n * ```typescript\n * return ok({ name: 'test', count: 5 });\n * return ok(true, ['Some warning about the operation']);\n * ```\n */\nexport function ok<T>(value: T, warnings?: string[]): Result<T, never> {\n  return warnings?.length\n    ? { success: true, value, warnings }\n    : { success: true, value };\n}\n\n/**\n * Create a failed result\n *\n * @param error - The error information\n * @returns A failure Result\n *\n * @example\n * ```typescript\n * return err('File not found');\n * return err({ code: 'NOT_FOUND', path: '/missing.txt' });\n * ```\n */\nexport function err<E>(error: E): Result<never, E> {\n  return { success: false, error };\n}\n\n/**\n * Check if a result is successful\n *\n * @param result - The result to check\n * @returns True if the result is successful\n */\nexport function isOk<T, E>(result: Result<T, E>): result is { success: true; value: T; warnings?: string[] } {\n  return result.success;\n}\n\n/**\n * Check if a result is a failure\n *\n * @param result - The result to check\n * @returns True if the result is a failure\n */\nexport function isErr<T, E>(result: Result<T, E>): result is { success: false; error: E } {\n  return !result.success;\n}\n\n/**\n * Unwrap a result, throwing if it's a failure\n *\n * @param result - The result to unwrap\n * @param errorMessage - Optional custom error message\n * @returns The success value\n * @throws Error if the result is a failure\n *\n * @example\n * ```typescript\n * const config = unwrap(parseConfig('config.json'));\n * // Throws if parsing failed\n * ```\n */\nexport function unwrap<T, E>(result: Result<T, E>, errorMessage?: string): T {\n  if (result.success) {\n    return result.value;\n  }\n  const message = errorMessage\n    ? `${errorMessage}: ${String(result.error)}`\n    : String(result.error);\n  throw new Error(message);\n}\n\n/**\n * Unwrap a result or return a default value\n *\n * @param result - The result to unwrap\n * @param defaultValue - The default value to return on failure\n * @returns The success value or default\n *\n * @example\n * ```typescript\n * const config = unwrapOr(parseConfig('config.json'), defaultConfig);\n * ```\n */\nexport function unwrapOr<T, E>(result: Result<T, E>, defaultValue: T): T {\n  return result.success ? result.value : defaultValue;\n}\n\n/**\n * Map a successful result to a new value\n *\n * @param result - The result to map\n * @param fn - The mapping function\n * @returns A new result with the mapped value\n *\n * @example\n * ```typescript\n * const nameResult = map(parseConfig('config.json'), config => config.name);\n * ```\n */\nexport function map<T, U, E>(result: Result<T, E>, fn: (_value: T) => U): Result<U, E> {\n  if (result.success) {\n    return ok(fn(result.value), result.warnings);\n  }\n  return result;\n}\n\n/**\n * Map a failed result to a new error\n *\n * @param result - The result to map\n * @param fn - The error mapping function\n * @returns A new result with the mapped error\n */\nexport function mapErr<T, E, F>(result: Result<T, E>, fn: (_error: E) => F): Result<T, F> {\n  if (!result.success) {\n    return err(fn(result.error));\n  }\n  return result;\n}\n\n/**\n * Chain result operations (flatMap)\n *\n * @param result - The result to chain from\n * @param fn - The function returning a new result\n * @returns The chained result\n *\n * @example\n * ```typescript\n * const result = andThen(\n *   parseConfig('config.json'),\n *   config => validateConfig(config)\n * );\n * ```\n */\nexport function andThen<T, U, E>(\n  result: Result<T, E>,\n  fn: (_value: T) => Result<U, E>\n): Result<U, E> {\n  if (result.success) {\n    const newResult = fn(result.value);\n    // Merge warnings\n    if (newResult.success && result.warnings?.length) {\n      return ok(newResult.value, [\n        ...result.warnings,\n        ...(newResult.warnings || []),\n      ]);\n    }\n    return newResult;\n  }\n  return result;\n}\n\n/**\n * Collect an array of results into a result of an array\n *\n * @param results - Array of results to collect\n * @returns A single result containing all values or the first error\n *\n * @example\n * ```typescript\n * const configs = collect([\n *   parseConfig('a.json'),\n *   parseConfig('b.json'),\n *   parseConfig('c.json'),\n * ]);\n * // Either Result<Config[], E> with all configs or first error\n * ```\n */\nexport function collect<T, E>(results: Result<T, E>[]): Result<T[], E> {\n  const values: T[] = [];\n  const allWarnings: string[] = [];\n\n  for (const result of results) {\n    if (!result.success) {\n      return result;\n    }\n    values.push(result.value);\n    if (result.warnings) {\n      allWarnings.push(...result.warnings);\n    }\n  }\n\n  return allWarnings.length > 0\n    ? ok(values, allWarnings)\n    : ok(values);\n}\n\n/**\n * Partition an array of results into successes and failures\n *\n * @param results - Array of results to partition\n * @returns Object with values and errors arrays\n *\n * @example\n * ```typescript\n * const { values, errors } = partition([\n *   parseConfig('a.json'),\n *   parseConfig('b.json'),\n *   parseConfig('c.json'),\n * ]);\n * console.log(`${values.length} succeeded, ${errors.length} failed`);\n * ```\n */\nexport function partition<T, E>(\n  results: Result<T, E>[]\n): { values: T[]; errors: E[]; warnings: string[] } {\n  const values: T[] = [];\n  const errors: E[] = [];\n  const warnings: string[] = [];\n\n  for (const result of results) {\n    if (result.success) {\n      values.push(result.value);\n      if (result.warnings) {\n        warnings.push(...result.warnings);\n      }\n    } else {\n      errors.push(result.error);\n    }\n  }\n\n  return { values, errors, warnings };\n}\n\n/**\n * Try to execute a function and wrap the result\n *\n * @param fn - Function to execute\n * @returns Result with the return value or caught error\n *\n * @example\n * ```typescript\n * const result = tryCatch(() => JSON.parse(jsonString));\n * if (result.success) {\n *   console.log(result.value);\n * } else {\n *   console.error('Parse failed:', result.error);\n * }\n * ```\n */\nexport function tryCatch<T>(fn: () => T): Result<T, Error> {\n  try {\n    return ok(fn());\n  } catch (error) {\n    return err(error instanceof Error ? error : new Error(String(error)));\n  }\n}\n\n/**\n * Try to execute an async function and wrap the result\n *\n * @param fn - Async function to execute\n * @returns Promise of Result with the return value or caught error\n *\n * @example\n * ```typescript\n * const result = await tryCatchAsync(() => fetch('/api/data').then(r => r.json()));\n * ```\n */\nexport async function tryCatchAsync<T>(fn: () => Promise<T>): Promise<Result<T, Error>> {\n  try {\n    return ok(await fn());\n  } catch (error) {\n    return err(error instanceof Error ? error : new Error(String(error)));\n  }\n}\n\n/**\n * Error class with code, message, and optional details.\n *\n * Can be used both with Result type and thrown directly.\n * Extends Error to provide proper stack traces and instanceof checks.\n *\n * @example\n * ```typescript\n * // With Result type\n * return err(new CodedError('NOT_FOUND', 'File not found', { path: '/missing.txt' }));\n *\n * // Thrown directly\n * throw new CodedError('VALIDATION_ERROR', 'Invalid input');\n *\n * // Caught with instanceof\n * try {\n *   riskyOperation();\n * } catch (error) {\n *   if (error instanceof CodedError) {\n *     console.error(`[${error.code}] ${error.message}`);\n *   }\n * }\n * ```\n */\nexport class CodedError extends Error {\n  readonly code: string;\n  readonly details?: Record<string, unknown>;\n\n  constructor(code: string, message: string, details?: Record<string, unknown>) {\n    super(message);\n    this.name = 'CodedError';\n    this.code = code;\n    this.details = details;\n\n    // Maintains proper stack trace in V8 environments (Node.js, Chrome)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, CodedError);\n    }\n  }\n\n  /**\n   * Create a CodedError (convenience factory, same as constructor)\n   */\n  static create(code: string, message: string, details?: Record<string, unknown>): CodedError {\n    return new CodedError(code, message, details);\n  }\n\n  /**\n   * Convert to plain object (for serialization/logging)\n   */\n  toJSON(): { code: string; message: string; details?: Record<string, unknown>; stack?: string } {\n    return {\n      code: this.code,\n      message: this.message,\n      ...(this.details && { details: this.details }),\n      ...(this.stack && { stack: this.stack }),\n    };\n  }\n\n  /**\n   * Format error for display\n   */\n  toString(): string {\n    const base = `[${this.code}] ${this.message}`;\n    if (this.details) {\n      return `${base} ${JSON.stringify(this.details)}`;\n    }\n    return base;\n  }\n}\n\n/**\n * Create a coded error (convenience factory function)\n *\n * @param code - Error code (e.g., 'NOT_FOUND', 'VALIDATION_ERROR')\n * @param message - Human-readable error message\n * @param details - Optional additional details\n * @returns A CodedError instance\n *\n * @example\n * ```typescript\n * return err(codedError('PARSE_ERROR', 'Invalid JSON', { line: 42 }));\n * ```\n */\nexport function codedError(\n  code: string,\n  message: string,\n  details?: Record<string, unknown>\n): CodedError {\n  return new CodedError(code, message, details);\n}\n","/**\n * Journey Parser - Parse YAML frontmatter + markdown body\n * @see research/2026-01-02_autogen-refined-plan.md Section 8\n */\nimport { readFileSync, existsSync } from 'node:fs';\nimport { resolve } from 'node:path';\nimport { parse as parseYaml } from 'yaml';\nimport {\n  JourneyFrontmatterSchema,\n  JourneyStatusSchema,\n  type JourneyFrontmatter,\n  type JourneyStatus,\n  validateForAutoGen,\n} from './schema.js';\nimport { matchPattern } from '../mapping/patterns.js';\nimport { type Result, ok, err, CodedError } from '../utils/result.js';\n\n// Re-export for convenience\nexport { JourneyFrontmatterSchema, JourneyStatusSchema };\nexport type { JourneyFrontmatter, JourneyStatus };\n\n/**\n * Error thrown when journey parsing fails\n */\nexport class JourneyParseError extends Error {\n  public readonly filePath: string;\n  public readonly cause?: unknown;\n\n  constructor(\n    message: string,\n    filePath: string,\n    cause?: unknown\n  ) {\n    super(message);\n    this.name = 'JourneyParseError';\n    this.filePath = filePath;\n    this.cause = cause;\n  }\n}\n\n/**\n * Parsed journey structure\n */\nexport interface ParsedJourney {\n  /** Journey frontmatter (validated) */\n  frontmatter: JourneyFrontmatter;\n  /** Raw markdown body (everything after frontmatter) */\n  body: string;\n  /** Acceptance Criteria section */\n  acceptanceCriteria: AcceptanceCriterion[];\n  /** Procedural Steps section */\n  proceduralSteps: ProceduralStep[];\n  /** Data/Environment notes */\n  dataNotes: string[];\n  /** Source file path */\n  sourcePath: string;\n}\n\n/**\n * Acceptance criterion from journey body\n */\nexport interface AcceptanceCriterion {\n  /** Criterion ID (e.g., 'AC-1') */\n  id: string;\n  /** Title/description */\n  title: string;\n  /** Bullet points under this criterion */\n  steps: string[];\n  /** Raw markdown content */\n  rawContent: string;\n}\n\n/**\n * Procedural step from journey body\n */\nexport interface ProceduralStep {\n  /** Step number */\n  number: number;\n  /** Step text */\n  text: string;\n  /** Associated AC (if any) */\n  linkedAC?: string;\n}\n\n/**\n * Structured step action from journey body\n */\nexport interface StructuredStepAction {\n  /** Action type: 'action', 'wait', or 'assert' */\n  type: 'action' | 'wait' | 'assert';\n  /** The parsed action string */\n  action: string;\n  /** Target element or condition */\n  target: string;\n  /** Optional value for the action */\n  value?: string;\n}\n\n/**\n * Structured step from journey body\n */\nexport interface StructuredStep {\n  /** Step number */\n  stepNumber: number;\n  /** Step name/title */\n  stepName: string;\n  /** Array of parsed actions */\n  actions: StructuredStepAction[];\n}\n\n/**\n * Regex patterns for parsing\n */\nconst FRONTMATTER_REGEX = /^---\\r?\\n([\\s\\S]*?)\\r?\\n---/;\n\n/**\n * Extract frontmatter from markdown content\n */\nfunction extractFrontmatter(content: string): {\n  frontmatter: string;\n  body: string;\n} {\n  const match = FRONTMATTER_REGEX.exec(content);\n  if (!match) {\n    throw new Error('No YAML frontmatter found (content should start with ---)');\n  }\n\n  return {\n    frontmatter: match[1]!,\n    body: content.slice(match[0]!.length).trim(),\n  };\n}\n\n/**\n * Parse acceptance criteria from markdown body\n */\nfunction parseAcceptanceCriteria(body: string): AcceptanceCriterion[] {\n  const criteria: AcceptanceCriterion[] = [];\n\n  // Find the Acceptance Criteria section\n  const acSectionMatch = body.match(/##\\s*Acceptance\\s*Criteria\\s*\\n([\\s\\S]*?)(?=\\n##\\s[^#]|$)/i);\n  if (!acSectionMatch) {\n    return criteria;\n  }\n\n  const acSection = acSectionMatch[1]!;\n\n  // Split by AC headers (### AC-N or ## AC-N)\n  const acPattern = /^###?\\s*(AC-\\d+)[:\\s]*(.*?)$/gim;\n  const parts: Array<{ id: string; title: string; startIndex: number }> = [];\n\n  let match;\n  while ((match = acPattern.exec(acSection)) !== null) {\n    parts.push({\n      id: match[1]!.toUpperCase(),\n      title: match[2]!.trim(),\n      startIndex: match.index + match[0]!.length,\n    });\n  }\n\n  // Extract content for each AC\n  for (let i = 0; i < parts.length; i++) {\n    const part = parts[i]!;\n\n    // Get content between this AC header and the next\n    const contentStart = part.startIndex;\n    const contentEnd = i + 1 < parts.length\n      ? acSection.lastIndexOf('###', parts[i + 1]!.startIndex)\n      : acSection.length;\n\n    const content = acSection.slice(contentStart, contentEnd > contentStart ? contentEnd : acSection.length);\n\n    // Extract bullet points as steps\n    const steps: string[] = [];\n    const bulletPattern = /^[-*]\\s+(.+)$/gm;\n    let bulletMatch;\n    while ((bulletMatch = bulletPattern.exec(content)) !== null) {\n      steps.push(bulletMatch[1]!.trim());\n    }\n\n    // Build raw content\n    const headerMatch = acSection.match(new RegExp(`###?\\\\s*${part.id}[:\\\\s]*${part.title.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}`, 'i'));\n    const rawContent = headerMatch\n      ? headerMatch[0]! + content.slice(0, content.indexOf('\\n###') > 0 ? content.indexOf('\\n###') : content.length)\n      : content;\n\n    criteria.push({\n      id: part.id,\n      title: part.title,\n      steps,\n      rawContent: rawContent.trim(),\n    });\n  }\n\n  return criteria;\n}\n\n/**\n * Parse procedural steps from markdown body\n */\nfunction parseProceduralSteps(body: string): ProceduralStep[] {\n  const steps: ProceduralStep[] = [];\n\n  // Find the Procedural Steps section\n  const psMatch = body.match(\n    /##\\s*Procedural\\s*Steps?\\s*\\n([\\s\\S]*?)(?=\\n##\\s[^#]|$)/i\n  );\n  if (!psMatch) {\n    return steps;\n  }\n\n  const psSection = psMatch[1]!;\n\n  // Parse numbered steps\n  const numberedPattern = /^\\d+\\.\\s+(.+)$/gm;\n  let match;\n  let stepNumber = 1;\n\n  while ((match = numberedPattern.exec(psSection)) !== null) {\n    const text = match[1]!.trim();\n\n    // Check for AC reference in text (e.g., \"(AC-1)\")\n    const acRef = text.match(/\\(AC-(\\d+)\\)/i);\n\n    steps.push({\n      number: stepNumber++,\n      text: text.replace(/\\s*\\(AC-\\d+\\)\\s*/gi, '').trim(),\n      linkedAC: acRef ? `AC-${acRef[1]!}` : undefined,\n    });\n  }\n\n  // Also parse bullet points if no numbered steps\n  if (steps.length === 0) {\n    const bulletPattern = /^[-*]\\s+(.+)$/gm;\n    while ((match = bulletPattern.exec(psSection)) !== null) {\n      const text = match[1]!.trim();\n      const acRef = text.match(/\\(AC-(\\d+)\\)/i);\n\n      steps.push({\n        number: stepNumber++,\n        text: text.replace(/\\s*\\(AC-\\d+\\)\\s*/gi, '').trim(),\n        linkedAC: acRef ? `AC-${acRef[1]!}` : undefined,\n      });\n    }\n  }\n\n  return steps;\n}\n\n/**\n * Parse data/environment notes from markdown body\n */\nfunction parseDataNotes(body: string): string[] {\n  const notes: string[] = [];\n\n  // Find Data/Environment section\n  const dataMatch = body.match(\n    /##\\s*(Data|Environment|Data\\/Environment)\\s*(Notes?)?\\s*\\n([\\s\\S]*?)(?=\\n##\\s[^#]|$)/i\n  );\n  if (!dataMatch) {\n    return notes;\n  }\n\n  const dataSection = dataMatch[3]!;\n\n  // Extract bullet points\n  const bulletPattern = /^[-*]\\s+(.+)$/gm;\n  let match;\n  while ((match = bulletPattern.exec(dataSection)) !== null) {\n    notes.push(match[1]!.trim());\n  }\n\n  return notes;\n}\n\n/**\n * Parse structured steps from markdown content\n * Parses the new structured format with Action/Wait for/Assert bullets\n * @param content - The markdown content containing structured steps\n * @returns Array of parsed structured steps\n */\nexport function parseStructuredSteps(content: string): StructuredStep[] {\n  const steps: StructuredStep[] = [];\n\n  // Split content by step headers\n  const sections = content.split(/(?=^###\\s*Step\\s+\\d+:)/m);\n\n  for (const section of sections) {\n    // Match the step header\n    const headerMatch = section.match(/^###\\s*Step\\s+(\\d+):\\s*(.+)$/m);\n    if (!headerMatch) continue;\n\n    const step: StructuredStep = {\n      stepNumber: parseInt(headerMatch[1]!, 10),\n      stepName: headerMatch[2]!.trim(),\n      actions: [],\n    };\n\n    // Parse bullet points in this section\n    let bulletMatch: RegExpExecArray | null;\n    // Create a fresh regex for each section to reset lastIndex\n    const sectionBulletRegex = /^-\\s*\\*\\*(Action|Wait for|Assert)\\*\\*:\\s*(.+)$/gm;\n\n    while ((bulletMatch = sectionBulletRegex.exec(section)) !== null) {\n      const [, type, text] = bulletMatch;\n\n      // Determine action type\n      const actionType = type!.toLowerCase() === 'action' ? 'action'\n        : type!.toLowerCase() === 'wait for' ? 'wait'\n        : 'assert';\n\n      // Try to parse the text using pattern matching\n      const primitive = matchPattern(text!.trim());\n\n      if (primitive) {\n        // Extract meaningful info from the primitive\n        let action = '';\n        let target = '';\n        let value: string | undefined;\n\n        switch (primitive.type) {\n          case 'goto':\n            action = 'navigate';\n            target = primitive.url;\n            break;\n          case 'click':\n            action = 'click';\n            target = primitive.locator.value;\n            break;\n          case 'fill':\n            action = 'fill';\n            target = primitive.locator.value;\n            value = primitive.value.value;\n            break;\n          case 'select':\n            action = 'select';\n            target = primitive.locator.value;\n            value = primitive.option;\n            break;\n          case 'check':\n            action = 'check';\n            target = primitive.locator.value;\n            break;\n          case 'uncheck':\n            action = 'uncheck';\n            target = primitive.locator.value;\n            break;\n          case 'expectVisible':\n            action = 'expectVisible';\n            target = primitive.locator.value;\n            break;\n          case 'expectToast':\n            action = 'expectToast';\n            target = primitive.toastType || 'info';\n            value = primitive.message;\n            break;\n          case 'expectURL':\n            action = 'expectURL';\n            target = typeof primitive.pattern === 'string' ? primitive.pattern : primitive.pattern.source;\n            break;\n          case 'callModule':\n            action = `${primitive.module}.${primitive.method}`;\n            target = primitive.args?.join(', ') || '';\n            break;\n          case 'waitForURL':\n            action = 'waitForURL';\n            target = typeof primitive.pattern === 'string' ? primitive.pattern : primitive.pattern.source;\n            break;\n          case 'waitForLoadingComplete':\n            action = 'waitForLoadingComplete';\n            target = '';\n            break;\n          default:\n            // Fallback for unknown primitive types\n            action = text!.trim();\n            target = '';\n        }\n\n        step.actions.push({\n          type: actionType,\n          action,\n          target,\n          value,\n        });\n      } else {\n        // If pattern matching fails, store the raw text\n        step.actions.push({\n          type: actionType,\n          action: text!.trim(),\n          target: '',\n          value: undefined,\n        });\n      }\n    }\n\n    // Only add steps that have actions\n    if (step.actions.length > 0) {\n      steps.push(step);\n    }\n  }\n\n  return steps;\n}\n\n/**\n * Parse a journey markdown file\n * @param filePath - Path to the journey file\n * @returns Parsed journey structure\n * @throws JourneyParseError if parsing fails\n */\nexport function parseJourney(filePath: string): ParsedJourney {\n  const resolvedPath = resolve(filePath);\n\n  if (!existsSync(resolvedPath)) {\n    throw new JourneyParseError(\n      `Journey file not found: ${resolvedPath}`,\n      resolvedPath\n    );\n  }\n\n  let content: string;\n  try {\n    content = readFileSync(resolvedPath, 'utf-8');\n  } catch (err) {\n    throw new JourneyParseError(\n      `Failed to read journey file: ${resolvedPath}`,\n      resolvedPath,\n      err\n    );\n  }\n\n  // Extract frontmatter and body\n  let frontmatterStr: string;\n  let body: string;\n  try {\n    const extracted = extractFrontmatter(content);\n    frontmatterStr = extracted.frontmatter;\n    body = extracted.body;\n  } catch (err) {\n    throw new JourneyParseError(\n      `Invalid frontmatter in journey file: ${resolvedPath}`,\n      resolvedPath,\n      err\n    );\n  }\n\n  // Parse YAML frontmatter\n  let rawFrontmatter: unknown;\n  try {\n    rawFrontmatter = parseYaml(frontmatterStr);\n  } catch (err) {\n    throw new JourneyParseError(\n      `Invalid YAML in journey frontmatter: ${resolvedPath}`,\n      resolvedPath,\n      err\n    );\n  }\n\n  // Validate frontmatter with Zod\n  const result = JourneyFrontmatterSchema.safeParse(rawFrontmatter);\n  if (!result.success) {\n    const issues = result.error.issues\n      .map((i) => `  - ${i.path.join('.')}: ${i.message}`)\n      .join('\\n');\n    throw new JourneyParseError(\n      `Invalid journey frontmatter in ${resolvedPath}:\\n${issues}`,\n      resolvedPath,\n      result.error\n    );\n  }\n\n  // Parse body sections\n  const acceptanceCriteria = parseAcceptanceCriteria(body);\n  const proceduralSteps = parseProceduralSteps(body);\n  const dataNotes = parseDataNotes(body);\n\n  return {\n    frontmatter: result.data,\n    body,\n    acceptanceCriteria,\n    proceduralSteps,\n    dataNotes,\n    sourcePath: resolvedPath,\n  };\n}\n\n/**\n * Parse and validate a journey for AutoGen (must be clarified)\n */\nexport function parseJourneyForAutoGen(filePath: string): ParsedJourney {\n  const parsed = parseJourney(filePath);\n\n  const validation = validateForAutoGen(parsed.frontmatter);\n  if (!validation.valid) {\n    throw new JourneyParseError(\n      `Journey not ready for AutoGen:\\n${validation.errors.map((e) => `  - ${e}`).join('\\n')}`,\n      filePath\n    );\n  }\n\n  return parsed;\n}\n\n/**\n * Parse journey from string content (for testing)\n */\nexport function parseJourneyContent(\n  content: string,\n  virtualPath = 'virtual.journey.md'\n): ParsedJourney {\n  // Extract frontmatter and body\n  const { frontmatter: frontmatterStr, body } = extractFrontmatter(content);\n\n  // Parse YAML frontmatter\n  const rawFrontmatter = parseYaml(frontmatterStr);\n\n  // Validate frontmatter with Zod\n  const result = JourneyFrontmatterSchema.safeParse(rawFrontmatter);\n  if (!result.success) {\n    const issues = result.error.issues\n      .map((i) => `  - ${i.path.join('.')}: ${i.message}`)\n      .join('\\n');\n    throw new JourneyParseError(\n      `Invalid journey frontmatter:\\n${issues}`,\n      virtualPath,\n      result.error\n    );\n  }\n\n  // Parse body sections\n  const acceptanceCriteria = parseAcceptanceCriteria(body);\n  const proceduralSteps = parseProceduralSteps(body);\n  const dataNotes = parseDataNotes(body);\n\n  return {\n    frontmatter: result.data,\n    body,\n    acceptanceCriteria,\n    proceduralSteps,\n    dataNotes,\n    sourcePath: virtualPath,\n  };\n}\n\n/**\n * Parse journey from string content with Result type (no exceptions)\n *\n * This is the recommended way to parse journey content as it returns\n * structured errors via Result type instead of throwing exceptions.\n *\n * @param content - Raw markdown content to parse\n * @param virtualPath - Virtual path for error reporting (default: 'virtual.journey.md')\n * @returns Result with ParsedJourney on success or CodedError on failure\n *\n * @example\n * ```typescript\n * const result = tryParseJourneyContent(markdownContent);\n * if (result.success) {\n *   console.log('Parsed:', result.value.frontmatter.id);\n * } else {\n *   console.error(`[${result.error.code}] ${result.error.message}`);\n * }\n * ```\n */\nexport function tryParseJourneyContent(\n  content: string,\n  virtualPath = 'virtual.journey.md'\n): Result<ParsedJourney, CodedError> {\n  // Extract frontmatter and body\n  const frontmatterMatch = FRONTMATTER_REGEX.exec(content);\n  if (!frontmatterMatch) {\n    return err(new CodedError(\n      'FRONTMATTER_NOT_FOUND',\n      'No YAML frontmatter found (content should start with ---)',\n      { path: virtualPath }\n    ));\n  }\n\n  const frontmatterStr = frontmatterMatch[1]!;\n  const body = content.slice(frontmatterMatch[0]!.length).trim();\n\n  // Parse YAML frontmatter\n  let rawFrontmatter: unknown;\n  try {\n    rawFrontmatter = parseYaml(frontmatterStr);\n  } catch (yamlError) {\n    return err(new CodedError(\n      'YAML_PARSE_ERROR',\n      'Invalid YAML in journey frontmatter',\n      {\n        path: virtualPath,\n        cause: yamlError instanceof Error ? yamlError.message : String(yamlError)\n      }\n    ));\n  }\n\n  // Validate frontmatter with Zod\n  const zodResult = JourneyFrontmatterSchema.safeParse(rawFrontmatter);\n  if (!zodResult.success) {\n    const issues = zodResult.error.issues\n      .map((i) => `${i.path.join('.')}: ${i.message}`)\n      .join('; ');\n    return err(new CodedError(\n      'FRONTMATTER_VALIDATION_ERROR',\n      `Invalid journey frontmatter: ${issues}`,\n      {\n        path: virtualPath,\n        issues: zodResult.error.issues.map((i) => ({\n          path: i.path.join('.'),\n          message: i.message,\n          code: i.code,\n        }))\n      }\n    ));\n  }\n\n  // Parse body sections\n  const acceptanceCriteria = parseAcceptanceCriteria(body);\n  const proceduralSteps = parseProceduralSteps(body);\n  const dataNotes = parseDataNotes(body);\n\n  return ok({\n    frontmatter: zodResult.data,\n    body,\n    acceptanceCriteria,\n    proceduralSteps,\n    dataNotes,\n    sourcePath: virtualPath,\n  });\n}\n","/**\n * Glossary Loader - Load and resolve synonyms for step text normalization\n * @see research/2026-01-02_autogen-refined-plan.md Section 10\n * @see research/2026-01-23_llkb-autogen-integration-specification.md (LLKB integration)\n */\nimport { readFileSync, existsSync } from 'node:fs';\nimport { resolve } from 'node:path';\nimport { pathToFileURL } from 'node:url';\nimport { parse as parseYaml } from 'yaml';\nimport { z } from 'zod';\nimport type { IRPrimitive } from '../ir/types.js';\n\n/**\n * Glossary entry schema\n */\nconst GlossaryEntrySchema = z.object({\n  canonical: z.string(),\n  synonyms: z.array(z.string()),\n});\n\n/**\n * Label alias entry schema (maps display labels to testids/selectors)\n * @see T082 - Extend glossary schema for labelAliases\n */\nconst LabelAliasSchema = z.object({\n  label: z.string(),\n  testid: z.string().optional(),\n  role: z.string().optional(),\n  selector: z.string().optional(),\n});\n\n/**\n * Module method mapping schema (maps phrases to module.method calls)\n * @see T082 - Module method resolution\n */\nconst ModuleMethodMappingSchema = z.object({\n  phrase: z.string(),\n  module: z.string(),\n  method: z.string(),\n  params: z.record(z.string()).optional(),\n});\n\n/**\n * Glossary file schema\n */\nconst GlossarySchema = z.object({\n  version: z.number().default(1),\n  entries: z.array(GlossaryEntrySchema),\n  labelAliases: z.array(LabelAliasSchema).default([]),\n  moduleMethods: z.array(ModuleMethodMappingSchema).default([]),\n});\n\nexport type LabelAlias = z.infer<typeof LabelAliasSchema>;\nexport type ModuleMethodMapping = z.infer<typeof ModuleMethodMappingSchema>;\n\nexport type GlossaryEntry = z.infer<typeof GlossaryEntrySchema>;\nexport type Glossary = z.infer<typeof GlossarySchema>;\n\n/**\n * Default glossary entries for common terms\n */\nexport const defaultGlossary: Glossary = {\n  version: 1,\n  labelAliases: [\n    // Common label-to-selector mappings\n    { label: 'email', testid: 'email-input', role: 'textbox' },\n    { label: 'password', testid: 'password-input', role: 'textbox' },\n    { label: 'username', testid: 'username-input', role: 'textbox' },\n    { label: 'search', testid: 'search-input', role: 'searchbox' },\n    { label: 'submit', testid: 'submit-button', role: 'button' },\n    { label: 'cancel', testid: 'cancel-button', role: 'button' },\n    { label: 'close', testid: 'close-button', role: 'button' },\n  ],\n  moduleMethods: [\n    // Common phrase-to-module mappings\n    { phrase: 'log in', module: 'auth', method: 'login' },\n    { phrase: 'login', module: 'auth', method: 'login' },\n    { phrase: 'sign in', module: 'auth', method: 'login' },\n    { phrase: 'log out', module: 'auth', method: 'logout' },\n    { phrase: 'logout', module: 'auth', method: 'logout' },\n    { phrase: 'sign out', module: 'auth', method: 'logout' },\n    { phrase: 'navigate to', module: 'navigation', method: 'goToPath' },\n    { phrase: 'go to', module: 'navigation', method: 'goToPath' },\n    { phrase: 'open', module: 'navigation', method: 'goToPath' },\n    { phrase: 'fill form', module: 'forms', method: 'fillForm' },\n    { phrase: 'submit form', module: 'forms', method: 'submitForm' },\n    { phrase: 'wait for', module: 'waits', method: 'waitForSignal' },\n  ],\n  entries: [\n    {\n      canonical: 'click',\n      synonyms: ['press', 'tap', 'hit'],\n    },\n    {\n      canonical: 'enter',\n      synonyms: ['type', 'fill', 'input', 'write'],\n    },\n    {\n      canonical: 'navigate',\n      synonyms: ['go', 'open', 'visit', 'browse'],\n    },\n    {\n      canonical: 'see',\n      synonyms: ['view', 'observe', 'notice', 'find'],\n    },\n    {\n      canonical: 'visible',\n      synonyms: ['displayed', 'shown', 'present'],\n    },\n    {\n      canonical: 'button',\n      synonyms: ['btn', 'action', 'cta'],\n    },\n    {\n      canonical: 'field',\n      synonyms: ['input', 'textbox', 'text field', 'text input'],\n    },\n    {\n      canonical: 'dropdown',\n      synonyms: ['combo', 'combobox', 'picker'],\n    },\n    {\n      canonical: 'checkbox',\n      synonyms: ['check', 'tick', 'toggle'],\n    },\n    {\n      canonical: 'login',\n      synonyms: ['log in', 'sign in', 'authenticate'],\n    },\n    {\n      canonical: 'logout',\n      synonyms: ['log out', 'sign out', 'exit'],\n    },\n    {\n      canonical: 'submit',\n      synonyms: ['send', 'save', 'confirm', 'ok'],\n    },\n    {\n      canonical: 'cancel',\n      synonyms: ['close', 'dismiss', 'abort', 'back'],\n    },\n    {\n      canonical: 'success',\n      synonyms: ['passed', 'completed', 'done', 'finished'],\n    },\n    {\n      canonical: 'error',\n      synonyms: ['failure', 'failed', 'problem', 'issue'],\n    },\n    {\n      canonical: 'toast',\n      synonyms: ['notification', 'message', 'alert', 'snackbar'],\n    },\n    {\n      canonical: 'modal',\n      synonyms: ['dialog', 'popup', 'overlay', 'lightbox'],\n    },\n    {\n      canonical: 'user',\n      synonyms: ['customer', 'visitor', 'member', 'client'],\n    },\n    {\n      canonical: 'page',\n      synonyms: ['screen', 'view', 'section'],\n    },\n    {\n      canonical: 'form',\n      synonyms: ['questionnaire', 'survey', 'wizard'],\n    },\n  ],\n};\n\n/**\n * Loaded glossary cache\n */\nlet glossaryCache: Glossary | null = null;\nlet synonymMap: Map<string, string> | null = null;\n\n/**\n * Build a synonym lookup map from glossary\n */\nfunction buildSynonymMap(glossary: Glossary): Map<string, string> {\n  const map = new Map<string, string>();\n\n  for (const entry of glossary.entries) {\n    // Map canonical to itself\n    map.set(entry.canonical.toLowerCase(), entry.canonical);\n\n    // Map all synonyms to canonical\n    for (const synonym of entry.synonyms) {\n      map.set(synonym.toLowerCase(), entry.canonical);\n    }\n  }\n\n  return map;\n}\n\n/**\n * Load glossary from file\n * @param glossaryPath - Path to glossary YAML file\n */\nexport function loadGlossary(glossaryPath: string): Glossary {\n  const resolvedPath = resolve(glossaryPath);\n\n  if (!existsSync(resolvedPath)) {\n    console.warn(`Glossary file not found at ${resolvedPath}, using defaults`);\n    return defaultGlossary;\n  }\n\n  try {\n    const content = readFileSync(resolvedPath, 'utf-8');\n    const parsed = parseYaml(content);\n    const result = GlossarySchema.safeParse(parsed);\n\n    if (!result.success) {\n      console.warn(`Invalid glossary file at ${resolvedPath}, using defaults`);\n      return defaultGlossary;\n    }\n\n    // Merge with defaults\n    return mergeGlossaries(defaultGlossary, result.data);\n  } catch {\n    console.warn(`Failed to load glossary from ${resolvedPath}, using defaults`);\n    return defaultGlossary;\n  }\n}\n\n/**\n * Merge two glossaries (user glossary extends defaults)\n */\nexport function mergeGlossaries(base: Glossary, extension: Glossary): Glossary {\n  const merged: Glossary = {\n    version: Math.max(base.version, extension.version),\n    entries: [...base.entries],\n    labelAliases: [...(base.labelAliases ?? [])],\n    moduleMethods: [...(base.moduleMethods ?? [])],\n  };\n\n  // Add or extend entries from extension\n  for (const extEntry of extension.entries) {\n    const existing = merged.entries.find(\n      (e) => e.canonical.toLowerCase() === extEntry.canonical.toLowerCase()\n    );\n\n    if (existing) {\n      // Merge synonyms\n      const allSynonyms = new Set([...existing.synonyms, ...extEntry.synonyms]);\n      existing.synonyms = Array.from(allSynonyms);\n    } else {\n      // Add new entry\n      merged.entries.push(extEntry);\n    }\n  }\n\n  // Add or extend label aliases from extension\n  for (const extAlias of extension.labelAliases ?? []) {\n    const existing = merged.labelAliases.find(\n      (a) => a.label.toLowerCase() === extAlias.label.toLowerCase()\n    );\n\n    if (!existing) {\n      merged.labelAliases.push(extAlias);\n    } else {\n      // Override with extension values\n      Object.assign(existing, extAlias);\n    }\n  }\n\n  // Add or extend module methods from extension\n  for (const extMethod of extension.moduleMethods ?? []) {\n    const existing = merged.moduleMethods.find(\n      (m) => m.phrase.toLowerCase() === extMethod.phrase.toLowerCase()\n    );\n\n    if (!existing) {\n      merged.moduleMethods.push(extMethod);\n    } else {\n      // Override with extension values\n      Object.assign(existing, extMethod);\n    }\n  }\n\n  return merged;\n}\n\n/**\n * Initialize the glossary (call once at startup)\n * @param glossaryPath - Optional path to custom glossary\n */\nexport function initGlossary(glossaryPath?: string): void {\n  if (glossaryPath) {\n    glossaryCache = loadGlossary(glossaryPath);\n  } else {\n    glossaryCache = defaultGlossary;\n  }\n  synonymMap = buildSynonymMap(glossaryCache);\n}\n\n/**\n * Get the current glossary\n */\nexport function getGlossary(): Glossary {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n  return glossaryCache!;\n}\n\n/**\n * Resolve a term to its canonical form\n * @param term - Term to resolve\n * @returns Canonical form or original term if not found\n */\nexport function resolveCanonical(term: string): string {\n  if (!synonymMap) {\n    initGlossary();\n  }\n  return synonymMap!.get(term.toLowerCase()) ?? term;\n}\n\n/**\n * Normalize step text by replacing synonyms with canonical terms\n * @param text - Step text to normalize\n * @returns Normalized text\n */\nexport function normalizeStepText(text: string): string {\n  if (!synonymMap) {\n    initGlossary();\n  }\n\n  // Split into words, preserving quoted strings\n  const parts: string[] = [];\n  const regex = /(['\"][^'\"]+['\"])|(\\S+)/g;\n  let match;\n\n  while ((match = regex.exec(text)) !== null) {\n    const part = match[0];\n\n    // Don't normalize quoted strings\n    if (part.startsWith('\"') || part.startsWith(\"'\")) {\n      parts.push(part);\n    } else {\n      // Check if this word has a canonical form\n      // Lowercase for consistent matching (LLKB pattern matching requires this)\n      const lowerPart = part.toLowerCase();\n      const canonical = synonymMap!.get(lowerPart);\n      parts.push(canonical ?? lowerPart);\n    }\n  }\n\n  return parts.join(' ');\n}\n\n/**\n * Get all synonyms for a canonical term\n */\nexport function getSynonyms(canonical: string): string[] {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n\n  const entry = glossaryCache!.entries.find(\n    (e) => e.canonical.toLowerCase() === canonical.toLowerCase()\n  );\n\n  return entry?.synonyms ?? [];\n}\n\n/**\n * Check if a term is a synonym of a canonical term\n */\nexport function isSynonymOf(term: string, canonical: string): boolean {\n  const resolved = resolveCanonical(term);\n  return resolved.toLowerCase() === canonical.toLowerCase();\n}\n\n/**\n * Reset the glossary cache (for testing)\n */\nexport function resetGlossaryCache(): void {\n  glossaryCache = null;\n  synonymMap = null;\n}\n\n/**\n * Find a label alias by label text\n * @see T082 - Label alias matching\n */\nexport function findLabelAlias(label: string): LabelAlias | null {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n\n  const normalizedLabel = label.toLowerCase().trim();\n\n  return (\n    glossaryCache!.labelAliases?.find(\n      (alias) => alias.label.toLowerCase() === normalizedLabel\n    ) ?? null\n  );\n}\n\n/**\n * Get locator info from label alias\n */\nexport function getLocatorFromLabel(label: string): { strategy: string; value: string } | null {\n  const alias = findLabelAlias(label);\n  if (!alias) return null;\n\n  // Priority: testid > role > selector\n  if (alias.testid) {\n    return { strategy: 'testid', value: alias.testid };\n  }\n  if (alias.role) {\n    return { strategy: 'role', value: alias.role };\n  }\n  if (alias.selector) {\n    return { strategy: 'css', value: alias.selector };\n  }\n\n  return null;\n}\n\n/**\n * Find a module method mapping by phrase\n * @see T083 - Module method resolution in step mapper\n */\nexport function findModuleMethod(text: string): ModuleMethodMapping | null {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n\n  const normalizedText = text.toLowerCase().trim();\n\n  // Find the best matching phrase (longest match wins)\n  let bestMatch: ModuleMethodMapping | null = null;\n  let bestMatchLength = 0;\n\n  for (const mapping of glossaryCache!.moduleMethods ?? []) {\n    const phrase = mapping.phrase.toLowerCase();\n    if (normalizedText.includes(phrase) && phrase.length > bestMatchLength) {\n      bestMatch = mapping;\n      bestMatchLength = phrase.length;\n    }\n  }\n\n  return bestMatch;\n}\n\n/**\n * Resolve a step to a module method call if it matches\n */\nexport function resolveModuleMethod(\n  text: string\n): { module: string; method: string; params?: Record<string, string> } | null {\n  const mapping = findModuleMethod(text);\n  if (!mapping) return null;\n\n  return {\n    module: mapping.module,\n    method: mapping.method,\n    params: mapping.params,\n  };\n}\n\n/**\n * Get all label aliases\n */\nexport function getLabelAliases(): LabelAlias[] {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n  return glossaryCache!.labelAliases ?? [];\n}\n\n/**\n * Get all module method mappings\n */\nexport function getModuleMethods(): ModuleMethodMapping[] {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n  return glossaryCache!.moduleMethods ?? [];\n}\n\n// ============================================================================\n// LLKB Extended Glossary Support\n// @see research/2026-01-23_llkb-autogen-integration-specification.md\n// ============================================================================\n\n/**\n * Extended glossary metadata from LLKB export\n */\nexport interface ExtendedGlossaryMeta {\n  exportedAt: string;\n  entryCount: number;\n  minConfidence?: number;\n  sourceComponents?: string[];\n  sourceLessons?: string[];\n}\n\n/**\n * Extended glossary loaded from LLKB export\n */\nlet extendedGlossary: Map<string, IRPrimitive> | null = null;\nlet extendedGlossaryMeta: ExtendedGlossaryMeta | null = null;\n\n/**\n * Load extended glossary from LLKB export file\n * @param glossaryPath - Path to the LLKB-generated glossary TypeScript file\n * @returns Loading result with entry count and metadata\n */\nexport async function loadExtendedGlossary(glossaryPath: string): Promise<{\n  loaded: boolean;\n  entryCount: number;\n  exportedAt: string | null;\n  error?: string;\n}> {\n  try {\n    const resolvedPath = resolve(glossaryPath);\n\n    if (!existsSync(resolvedPath)) {\n      return {\n        loaded: false,\n        entryCount: 0,\n        exportedAt: null,\n        error: `Glossary file not found: ${resolvedPath}`,\n      };\n    }\n\n    // Dynamic import of the generated glossary file\n    // Use file:// URL for Windows compatibility\n    const fileUrl = pathToFileURL(resolvedPath).href;\n    const module = await import(fileUrl);\n\n    if (module.llkbGlossary instanceof Map) {\n      const glossaryMap: Map<string, IRPrimitive> = module.llkbGlossary;\n      extendedGlossary = glossaryMap;\n      extendedGlossaryMeta = module.llkbGlossaryMeta ?? null;\n\n      return {\n        loaded: true,\n        entryCount: glossaryMap.size,\n        exportedAt: extendedGlossaryMeta?.exportedAt ?? null,\n      };\n    }\n\n    // If llkbGlossary is a plain object, convert to Map\n    if (module.llkbGlossary && typeof module.llkbGlossary === 'object') {\n      const glossaryMap = new Map<string, IRPrimitive>(\n        Object.entries(module.llkbGlossary) as [string, IRPrimitive][]\n      );\n      extendedGlossary = glossaryMap;\n      extendedGlossaryMeta = module.llkbGlossaryMeta ?? null;\n\n      return {\n        loaded: true,\n        entryCount: glossaryMap.size,\n        exportedAt: extendedGlossaryMeta?.exportedAt ?? null,\n      };\n    }\n\n    return {\n      loaded: false,\n      entryCount: 0,\n      exportedAt: null,\n      error: 'Invalid glossary format: llkbGlossary not found or not a Map/object',\n    };\n  } catch (err) {\n    return {\n      loaded: false,\n      entryCount: 0,\n      exportedAt: null,\n      error: `Failed to load glossary: ${err instanceof Error ? err.message : String(err)}`,\n    };\n  }\n}\n\n/**\n * Clear extended glossary (for testing)\n */\nexport function clearExtendedGlossary(): void {\n  extendedGlossary = null;\n  extendedGlossaryMeta = null;\n}\n\n/**\n * Check if a term exactly matches a core glossary phrase\n * (not just a partial/substring match)\n */\nfunction isExactCoreMatch(term: string): boolean {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n\n  const normalizedTerm = term.toLowerCase().trim();\n\n  // Check if any module method phrase exactly matches the term\n  for (const mapping of glossaryCache!.moduleMethods ?? []) {\n    if (mapping.phrase.toLowerCase() === normalizedTerm) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Lookup a term in both core glossary and extended LLKB glossary\n * Core glossary takes precedence for exact matches (LLKB only extends, never overrides)\n * @param term - Term to look up\n * @returns IR primitive if found, undefined otherwise\n */\nexport function lookupGlossary(term: string): IRPrimitive | undefined {\n  const normalizedTerm = term.toLowerCase().trim();\n\n  // First check if core glossary has an EXACT match for this term\n  // Core always wins for exact matches (LLKB never overrides core)\n  if (isExactCoreMatch(normalizedTerm)) {\n    const coreMapping = findModuleMethod(normalizedTerm);\n    if (coreMapping) {\n      return {\n        type: 'callModule',\n        module: coreMapping.module,\n        method: coreMapping.method,\n        args: coreMapping.params ? [coreMapping.params] : undefined,\n      };\n    }\n  }\n\n  // Then check extended glossary for exact match\n  // LLKB extends core glossary with new terms\n  if (extendedGlossary) {\n    const extendedMatch = extendedGlossary.get(normalizedTerm);\n    if (extendedMatch) {\n      return extendedMatch;\n    }\n  }\n\n  // Finally, check core glossary for partial/substring matches\n  // This allows core patterns like \"wait for\" to match \"wait for something\"\n  const coreMapping = findModuleMethod(normalizedTerm);\n  if (coreMapping) {\n    return {\n      type: 'callModule',\n      module: coreMapping.module,\n      method: coreMapping.method,\n      args: coreMapping.params ? [coreMapping.params] : undefined,\n    };\n  }\n\n  return undefined;\n}\n\n/**\n * Lookup a term in core glossary only (for priority enforcement)\n * Used when LLKB should NOT override core mappings\n * @param term - Term to look up\n * @returns IR primitive if found, undefined otherwise\n */\nexport function lookupCoreGlossary(term: string): IRPrimitive | undefined {\n  const normalizedTerm = term.toLowerCase().trim();\n\n  const coreMapping = findModuleMethod(normalizedTerm);\n  if (coreMapping) {\n    return {\n      type: 'callModule',\n      module: coreMapping.module,\n      method: coreMapping.method,\n      args: coreMapping.params ? [coreMapping.params] : undefined,\n    };\n  }\n\n  return undefined;\n}\n\n/**\n * Get glossary statistics\n */\nexport function getGlossaryStats(): {\n  coreEntries: number;\n  extendedEntries: number;\n  extendedExportedAt: string | null;\n  extendedMeta: ExtendedGlossaryMeta | null;\n} {\n  if (!glossaryCache) {\n    initGlossary();\n  }\n\n  return {\n    coreEntries: glossaryCache!.moduleMethods?.length ?? 0,\n    extendedEntries: extendedGlossary?.size ?? 0,\n    extendedExportedAt: extendedGlossaryMeta?.exportedAt ?? null,\n    extendedMeta: extendedGlossaryMeta,\n  };\n}\n\n/**\n * Check if extended glossary is loaded\n */\nexport function hasExtendedGlossary(): boolean {\n  return extendedGlossary !== null && extendedGlossary.size > 0;\n}\n","/**\n * Machine Hint Syntax Patterns - Define regex patterns for parsing hints\n * @see T071 - Define machine hint syntax regex patterns\n */\n\n/**\n * Machine hint types\n */\nexport type HintType =\n  | 'role'       // ARIA role hint: (role=button)\n  | 'testid'     // Test ID hint: (testid=submit-btn)\n  | 'label'      // Label hint: (label=\"Email Address\")\n  | 'text'       // Text hint: (text=\"Submit\")\n  | 'exact'      // Exact matching: (exact=true)\n  | 'level'      // Heading level: (level=2)\n  | 'signal'     // Signal hint: (signal=loading-done)\n  | 'module'     // Module method hint: (module=auth.login)\n  | 'wait'       // Wait strategy: (wait=networkidle)\n  | 'timeout';   // Timeout hint: (timeout=5000)\n\n/**\n * Parsed machine hint\n */\nexport interface MachineHint {\n  /** Hint type */\n  type: HintType;\n  /** Hint value */\n  value: string;\n  /** Raw hint string */\n  raw: string;\n}\n\n/**\n * Pattern for detecting hint blocks: (key=value) or (key=\"value with spaces\")\n */\nexport const HINT_BLOCK_PATTERN = /\\(([a-z]+)=(?:\"([^\"]+)\"|'([^']+)'|([^,)\\s]+))\\)/gi;\n\n/**\n * Pattern for a complete hints section: (...hints...)\n */\nexport const HINTS_SECTION_PATTERN = /\\((?:[a-z]+=(?:\"[^\"]+\"|'[^']+'|[^,)\\s]+)(?:,\\s*)?)+\\)/gi;\n\n/**\n * Individual hint patterns for validation\n */\nexport const HINT_PATTERNS: Record<HintType, RegExp> = {\n  role: /role=(?:\"([^\"]+)\"|'([^']+)'|([a-z]+))/i,\n  testid: /testid=(?:\"([^\"]+)\"|'([^']+)'|([a-z0-9_-]+))/i,\n  label: /label=(?:\"([^\"]+)\"|'([^']+)')/i,\n  text: /text=(?:\"([^\"]+)\"|'([^']+)')/i,\n  exact: /exact=(true|false)/i,\n  level: /level=([1-6])/i,\n  signal: /signal=(?:\"([^\"]+)\"|'([^']+)'|([a-z0-9_-]+))/i,\n  module: /module=(?:\"([^\"]+)\"|'([^']+)'|([a-z0-9_.]+))/i,\n  wait: /wait=(networkidle|domcontentloaded|load|commit)/i,\n  timeout: /timeout=(\\d+)/i,\n};\n\n/**\n * Valid ARIA roles for validation\n */\nexport const VALID_ROLES = [\n  'alert',\n  'alertdialog',\n  'application',\n  'article',\n  'banner',\n  'button',\n  'cell',\n  'checkbox',\n  'columnheader',\n  'combobox',\n  'complementary',\n  'contentinfo',\n  'definition',\n  'dialog',\n  'directory',\n  'document',\n  'feed',\n  'figure',\n  'form',\n  'grid',\n  'gridcell',\n  'group',\n  'heading',\n  'img',\n  'link',\n  'list',\n  'listbox',\n  'listitem',\n  'log',\n  'main',\n  'marquee',\n  'math',\n  'menu',\n  'menubar',\n  'menuitem',\n  'menuitemcheckbox',\n  'menuitemradio',\n  'navigation',\n  'none',\n  'note',\n  'option',\n  'presentation',\n  'progressbar',\n  'radio',\n  'radiogroup',\n  'region',\n  'row',\n  'rowgroup',\n  'rowheader',\n  'scrollbar',\n  'search',\n  'searchbox',\n  'separator',\n  'slider',\n  'spinbutton',\n  'status',\n  'switch',\n  'tab',\n  'table',\n  'tablist',\n  'tabpanel',\n  'term',\n  'textbox',\n  'timer',\n  'toolbar',\n  'tooltip',\n  'tree',\n  'treegrid',\n  'treeitem',\n];\n\n/**\n * Check if a role is valid\n */\nexport function isValidRole(role: string): boolean {\n  return VALID_ROLES.includes(role.toLowerCase());\n}\n\n/**\n * Extract hint value from a match (handles quoted and unquoted values)\n */\nexport function extractHintValue(match: RegExpMatchArray): string | null {\n  // Try quoted values first, then unquoted\n  for (let i = 1; i < match.length; i++) {\n    if (match[i] !== undefined) {\n      return match[i] ?? null;\n    }\n  }\n  return null;\n}\n\n/**\n * Check if text contains machine hints\n */\nexport function containsHints(text: string): boolean {\n  // Reset lastIndex for global regex\n  HINTS_SECTION_PATTERN.lastIndex = 0;\n  return HINTS_SECTION_PATTERN.test(text);\n}\n\n/**\n * Remove hints section from step text\n */\nexport function removeHints(text: string): string {\n  return text.replace(HINTS_SECTION_PATTERN, '').trim();\n}\n","/**\n * Machine Hint Parser - Extract hints from Journey step text\n * @see T072 - Implement machine hint parser\n */\nimport {\n  type HintType,\n  type MachineHint,\n  HINT_BLOCK_PATTERN,\n  HINT_PATTERNS,\n  isValidRole,\n  containsHints,\n  removeHints,\n} from './hintPatterns.js';\n\n/**\n * Parsed hints result\n */\nexport interface ParsedHints {\n  /** All parsed hints */\n  hints: MachineHint[];\n  /** Step text with hints removed */\n  cleanText: string;\n  /** Original text */\n  originalText: string;\n  /** Validation warnings */\n  warnings: string[];\n}\n\n/**\n * Locator hints extracted for code generation\n */\nexport interface LocatorHints {\n  /** ARIA role */\n  role?: string;\n  /** Test ID */\n  testid?: string;\n  /** Label text */\n  label?: string;\n  /** Text content */\n  text?: string;\n  /** Exact matching */\n  exact?: boolean;\n  /** Heading level (for role=heading) */\n  level?: number;\n}\n\n/**\n * Behavioral hints extracted for code generation\n */\nexport interface BehaviorHints {\n  /** Signal to wait for */\n  signal?: string;\n  /** Module method to call */\n  module?: string;\n  /** Wait strategy */\n  wait?: 'networkidle' | 'domcontentloaded' | 'load' | 'commit';\n  /** Timeout in ms */\n  timeout?: number;\n}\n\n/**\n * Complete hint extraction result\n */\nexport interface ExtractedHints {\n  /** Locator-related hints */\n  locator: LocatorHints;\n  /** Behavior-related hints */\n  behavior: BehaviorHints;\n  /** Whether any hints were found */\n  hasHints: boolean;\n  /** Clean step text */\n  cleanText: string;\n  /** Warnings */\n  warnings: string[];\n}\n\n/**\n * Parse machine hints from step text\n */\nexport function parseHints(text: string): ParsedHints {\n  const hints: MachineHint[] = [];\n  const warnings: string[] = [];\n\n  if (!containsHints(text)) {\n    return {\n      hints: [],\n      cleanText: text,\n      originalText: text,\n      warnings: [],\n    };\n  }\n\n  // Extract all hint blocks\n  HINT_BLOCK_PATTERN.lastIndex = 0;\n  let match;\n\n  while ((match = HINT_BLOCK_PATTERN.exec(text)) !== null) {\n    const key = match[1]!.toLowerCase() as HintType;\n    const value = match[2] || match[3] || match[4];\n\n    if (!value) {\n      warnings.push(`Empty value for hint: ${key}`);\n      continue;\n    }\n\n    // Validate the hint type\n    if (!(key in HINT_PATTERNS)) {\n      warnings.push(`Unknown hint type: ${key}`);\n      continue;\n    }\n\n    // Validate role values\n    if (key === 'role' && !isValidRole(value)) {\n      warnings.push(`Invalid ARIA role: ${value}`);\n    }\n\n    hints.push({\n      type: key,\n      value,\n      raw: match[0],\n    });\n  }\n\n  return {\n    hints,\n    cleanText: removeHints(text),\n    originalText: text,\n    warnings,\n  };\n}\n\n/**\n * Extract structured hints for code generation\n */\nexport function extractHints(text: string): ExtractedHints {\n  const parsed = parseHints(text);\n\n  const locator: LocatorHints = {};\n  const behavior: BehaviorHints = {};\n\n  for (const hint of parsed.hints) {\n    switch (hint.type) {\n      case 'role':\n        locator.role = hint.value;\n        break;\n      case 'testid':\n        locator.testid = hint.value;\n        break;\n      case 'label':\n        locator.label = hint.value;\n        break;\n      case 'text':\n        locator.text = hint.value;\n        break;\n      case 'exact':\n        locator.exact = hint.value.toLowerCase() === 'true';\n        break;\n      case 'level':\n        locator.level = parseInt(hint.value, 10);\n        break;\n      case 'signal':\n        behavior.signal = hint.value;\n        break;\n      case 'module':\n        behavior.module = hint.value;\n        break;\n      case 'wait':\n        behavior.wait = hint.value as BehaviorHints['wait'];\n        break;\n      case 'timeout':\n        behavior.timeout = parseInt(hint.value, 10);\n        break;\n    }\n  }\n\n  return {\n    locator,\n    behavior,\n    hasHints: parsed.hints.length > 0,\n    cleanText: parsed.cleanText,\n    warnings: parsed.warnings,\n  };\n}\n\n/**\n * Check if hints specify a locator strategy\n */\nexport function hasLocatorHints(hints: ExtractedHints): boolean {\n  const { locator } = hints;\n  return !!(locator.role || locator.testid || locator.label || locator.text);\n}\n\n/**\n * Check if hints specify behavioral modifications\n */\nexport function hasBehaviorHints(hints: ExtractedHints): boolean {\n  const { behavior } = hints;\n  return !!(behavior.signal || behavior.module || behavior.wait || behavior.timeout);\n}\n\n/**\n * Generate locator code from hints\n */\nexport function generateLocatorFromHints(hints: LocatorHints): string | null {\n  // Priority: testid > role > label > text\n  if (hints.testid) {\n    return `page.getByTestId('${hints.testid}')`;\n  }\n\n  if (hints.role) {\n    const options: string[] = [];\n    if (hints.label) {\n      options.push(`name: '${hints.label}'`);\n    }\n    if (hints.exact) {\n      options.push('exact: true');\n    }\n    if (hints.level && hints.role === 'heading') {\n      options.push(`level: ${hints.level}`);\n    }\n\n    if (options.length > 0) {\n      return `page.getByRole('${hints.role}', { ${options.join(', ')} })`;\n    }\n    return `page.getByRole('${hints.role}')`;\n  }\n\n  if (hints.label) {\n    if (hints.exact) {\n      return `page.getByLabel('${hints.label}', { exact: true })`;\n    }\n    return `page.getByLabel('${hints.label}')`;\n  }\n\n  if (hints.text) {\n    if (hints.exact) {\n      return `page.getByText('${hints.text}', { exact: true })`;\n    }\n    return `page.getByText('${hints.text}')`;\n  }\n\n  return null;\n}\n\n/**\n * Parse module hint into module name and method\n */\nexport function parseModuleHint(moduleHint: string): { module: string; method: string } | null {\n  const parts = moduleHint.split('.');\n  if (parts.length !== 2) {\n    return null;\n  }\n  return {\n    module: parts[0]!,\n    method: parts[1]!,\n  };\n}\n\n/**\n * Validate hints for consistency\n */\nexport function validateHints(hints: ExtractedHints): string[] {\n  const errors: string[] = [];\n\n  // Check for conflicting locator hints\n  const locatorCount = [\n    hints.locator.testid,\n    hints.locator.role,\n    hints.locator.label && !hints.locator.role, // label with role is fine\n    hints.locator.text,\n  ].filter(Boolean).length;\n\n  if (locatorCount > 1) {\n    errors.push('Multiple conflicting locator hints specified');\n  }\n\n  // Check for level without heading role\n  if (hints.locator.level && hints.locator.role !== 'heading') {\n    errors.push('level hint only applies to role=heading');\n  }\n\n  // Check for module hint format\n  if (hints.behavior.module) {\n    const parsed = parseModuleHint(hints.behavior.module);\n    if (!parsed) {\n      errors.push('module hint must be in format: moduleName.methodName');\n    }\n  }\n\n  return errors;\n}\n\n/**\n * Merge hints with inferred locator (hints take priority)\n */\nexport function mergeWithInferred(\n  hints: LocatorHints,\n  inferred: { strategy: string; value: string }\n): { strategy: string; value: string; options?: Record<string, unknown> } {\n  // If hints specify a locator, use it\n  if (hints.testid) {\n    return { strategy: 'testid', value: hints.testid };\n  }\n\n  if (hints.role) {\n    const options: Record<string, unknown> = {};\n    if (hints.label) {\n      options.name = hints.label;\n    }\n    if (hints.exact) {\n      options.exact = true;\n    }\n    if (hints.level) {\n      options.level = hints.level;\n    }\n    return { strategy: 'role', value: hints.role, options };\n  }\n\n  if (hints.label) {\n    const options: Record<string, unknown> = {};\n    if (hints.exact) {\n      options.exact = true;\n    }\n    return { strategy: 'label', value: hints.label, options };\n  }\n\n  if (hints.text) {\n    const options: Record<string, unknown> = {};\n    if (hints.exact) {\n      options.exact = true;\n    }\n    return { strategy: 'text', value: hints.text, options };\n  }\n\n  // Add exact option to inferred if specified\n  if (hints.exact) {\n    return { ...inferred, options: { exact: true } };\n  }\n\n  // Fall back to inferred\n  return inferred;\n}\n","/**\n * Cross-module-system path utilities\n *\n * Provides directory resolution that works in both ESM and CJS environments.\n *\n * IMPORTANT: This module uses a dual-strategy approach:\n * - In CJS: Uses __dirname (injected by Node.js module wrapper)\n * - In ESM: Uses import.meta.url (only available in ESM)\n *\n * The TypeScript source uses import.meta.url, which works for ESM builds.\n * For CJS builds, we detect that __dirname is available and use it instead.\n */\nimport { join, dirname, resolve, relative, isAbsolute } from 'node:path';\nimport { readFileSync, existsSync, realpathSync } from 'node:fs';\nimport { fileURLToPath } from 'node:url';\n\n// CJS-specific globals - these are injected by Node.js module wrapper in CJS context\n// They will be undefined in ESM context\ndeclare const __dirname: string | undefined;\n \ndeclare const require: ((_id: string) => any) & { resolve: (_id: string) => string } | undefined;\n\n/**\n * Cached package root to avoid repeated lookups\n */\nlet cachedPackageRoot: string | undefined;\n\n/**\n * Cached module directory\n */\nlet cachedModuleDir: string | undefined;\n\n/**\n * Get the directory where this module file is located.\n * Works in both ESM and CJS environments.\n */\nfunction getModuleDir(): string {\n  if (cachedModuleDir) {\n    return cachedModuleDir;\n  }\n\n  // In CJS, __dirname is injected by Node.js module wrapper\n  // It will be undefined in ESM context\n  if (typeof __dirname === 'string' && __dirname.length > 0) {\n    cachedModuleDir = __dirname;\n    return cachedModuleDir;\n  }\n\n  // In ESM, use import.meta.url directly\n  // For CJS builds, this block is removed by post-build script (not needed since __dirname works)\n  // __ESM_ONLY_START__\n  try {\n    // @ts-ignore - Valid in ESM, removed from CJS by post-build\n    const metaUrl: string | undefined = import.meta.url;\n    if (metaUrl) {\n      cachedModuleDir = dirname(fileURLToPath(metaUrl));\n      return cachedModuleDir;\n    }\n  } catch {\n    // import.meta not available\n  }\n  // __ESM_ONLY_END__\n\n  // Fallback: try to find via require.resolve (CJS only)\n  try {\n    if (typeof require !== 'undefined' && require?.resolve) {\n      const resolved = require.resolve('@artk/core-autogen/package.json');\n      cachedModuleDir = dirname(resolved);\n      return cachedModuleDir;\n    }\n  } catch {\n    // Package not found via require.resolve\n  }\n\n  // Last resort: use process.cwd()\n  // This is unreliable but better than crashing\n  cachedModuleDir = process.cwd();\n  return cachedModuleDir;\n}\n\n/**\n * Get the package root directory.\n *\n * Strategy:\n * 1. Check ARTK_AUTOGEN_ROOT env var (for testing/override)\n * 2. Use module location to find package root\n * 3. Fallback to cwd-based search\n */\nexport function getPackageRoot(): string {\n  if (cachedPackageRoot) {\n    return cachedPackageRoot;\n  }\n\n  // 1. Check environment variable override\n  const envRoot = process.env['ARTK_AUTOGEN_ROOT'];\n  if (envRoot && existsSync(join(envRoot, 'package.json'))) {\n    cachedPackageRoot = envRoot;\n    return cachedPackageRoot;\n  }\n\n  // 2. Find package root from module location\n  // This file is at: <package-root>/dist[-variant]/utils/paths.js\n  // So we go up 2 levels to find package root\n  const moduleDir = getModuleDir();\n  const possibleRoots = [\n    join(moduleDir, '..', '..'),     // from dist/utils/ or dist-cjs/utils/\n    join(moduleDir, '..'),           // from dist/ directly\n    moduleDir,                        // if already at root\n  ];\n\n  for (const root of possibleRoots) {\n    const pkgPath = join(root, 'package.json');\n    if (existsSync(pkgPath)) {\n      try {\n        const pkg = JSON.parse(readFileSync(pkgPath, 'utf-8'));\n        if (pkg.name === '@artk/core-autogen') {\n          cachedPackageRoot = root;\n          return cachedPackageRoot;\n        }\n      } catch {\n        // Continue searching\n      }\n    }\n  }\n\n  // 3. Fallback to cwd-based search (for vendored installations)\n  const cwdPaths = [\n    join(process.cwd(), 'node_modules', '@artk', 'core-autogen'),\n    join(process.cwd(), 'artk-e2e', 'vendor', 'artk-core-autogen'),\n    process.cwd(),\n  ];\n\n  for (const searchPath of cwdPaths) {\n    const pkgPath = join(searchPath, 'package.json');\n    if (existsSync(pkgPath)) {\n      try {\n        const pkg = JSON.parse(readFileSync(pkgPath, 'utf-8'));\n        if (pkg.name === '@artk/core-autogen') {\n          cachedPackageRoot = searchPath;\n          return cachedPackageRoot;\n        }\n      } catch {\n        // Continue searching\n      }\n    }\n  }\n\n  // Final fallback - use module directory's parent\n  cachedPackageRoot = join(moduleDir, '..', '..');\n  return cachedPackageRoot;\n}\n\n/**\n * Get the templates directory path.\n *\n * Templates are copied to dist/codegen/templates/ during build.\n * When installed, only one dist variant exists.\n */\nexport function getTemplatesDir(): string {\n  const root = getPackageRoot();\n  const moduleDir = getModuleDir();\n\n  // First, try relative to the module itself (most reliable)\n  // Module is at dist[-variant]/utils/paths.js\n  // Templates are at dist[-variant]/codegen/templates/\n  const relativeToModule = join(moduleDir, '..', 'codegen', 'templates');\n  if (existsSync(relativeToModule)) {\n    return relativeToModule;\n  }\n\n  // Fallback: check standard locations from package root\n  const possiblePaths = [\n    join(root, 'dist', 'codegen', 'templates'),\n    join(root, 'dist-cjs', 'codegen', 'templates'),\n    join(root, 'dist-legacy-16', 'codegen', 'templates'),\n    join(root, 'dist-legacy-14', 'codegen', 'templates'),\n  ];\n\n  for (const templatesPath of possiblePaths) {\n    if (existsSync(templatesPath)) {\n      return templatesPath;\n    }\n  }\n\n  // Final fallback\n  return possiblePaths[0] ?? join(root, 'dist', 'codegen', 'templates');\n}\n\n/**\n * Get the path to a specific template file.\n */\nexport function getTemplatePath(templateName: string): string {\n  return join(getTemplatesDir(), templateName);\n}\n\n/**\n * Clear cached paths (for testing)\n */\nexport function clearPathCache(): void {\n  cachedPackageRoot = undefined;\n  cachedModuleDir = undefined;\n  cachedHarnessRoot = undefined;\n}\n\n/**\n * Cached harness root to avoid repeated lookups\n */\nlet cachedHarnessRoot: string | undefined;\n\n/**\n * Get the ARTK harness root directory (artk-e2e/).\n *\n * This function infers the correct harness root by checking:\n * 1. ARTK_HARNESS_ROOT environment variable (explicit override)\n * 2. artk-e2e/ subdirectory from cwd (standard installation)\n * 3. Current directory if it contains artk.config.yml (inside harness)\n * 4. Fallback to cwd (backwards compatibility)\n *\n * @returns Path to the harness root directory\n */\nexport function getHarnessRoot(): string {\n  if (cachedHarnessRoot) {\n    return cachedHarnessRoot;\n  }\n\n  // 1. Check environment variable override\n  const envRoot = process.env['ARTK_HARNESS_ROOT'];\n  if (envRoot && existsSync(envRoot)) {\n    cachedHarnessRoot = envRoot;\n    return cachedHarnessRoot;\n  }\n\n  // 2. Check for artk-e2e/ in cwd (standard installation)\n  const artkE2eFromCwd = join(process.cwd(), 'artk-e2e');\n  if (existsSync(artkE2eFromCwd)) {\n    cachedHarnessRoot = artkE2eFromCwd;\n    return cachedHarnessRoot;\n  }\n\n  // 3. Check if we're already inside artk-e2e (cwd has artk.config.yml)\n  const configInCwd = join(process.cwd(), 'artk.config.yml');\n  if (existsSync(configInCwd)) {\n    cachedHarnessRoot = process.cwd();\n    return cachedHarnessRoot;\n  }\n\n  // 4. Walk up from cwd looking for artk-e2e/ or artk.config.yml\n  let searchDir = process.cwd();\n  const root = dirname(searchDir);\n  while (searchDir !== root) {\n    // Check if this is artk-e2e (has artk.config.yml)\n    if (existsSync(join(searchDir, 'artk.config.yml'))) {\n      cachedHarnessRoot = searchDir;\n      return cachedHarnessRoot;\n    }\n    // Check if artk-e2e is a sibling\n    const sibling = join(searchDir, 'artk-e2e');\n    if (existsSync(sibling)) {\n      cachedHarnessRoot = sibling;\n      return cachedHarnessRoot;\n    }\n    searchDir = dirname(searchDir);\n  }\n\n  // 5. Fallback to cwd (backwards compatibility)\n  cachedHarnessRoot = process.cwd();\n  return cachedHarnessRoot;\n}\n\n/**\n * Get the LLKB root directory (.artk/llkb inside harness root).\n *\n * @param explicitRoot - Optional explicit path override\n * @returns Path to the LLKB root directory\n */\nexport function getLlkbRoot(explicitRoot?: string): string {\n  if (explicitRoot) {\n    return explicitRoot;\n  }\n  return join(getHarnessRoot(), '.artk', 'llkb');\n}\n\n/**\n * Get the .artk directory inside harness root.\n *\n * @param explicitBaseDir - Optional explicit path override\n * @returns Path to the .artk directory\n */\nexport function getArtkDir(explicitBaseDir?: string): string {\n  if (explicitBaseDir) {\n    return join(explicitBaseDir, '.artk');\n  }\n  return join(getHarnessRoot(), '.artk');\n}\n\n// \n// AUTOGEN ARTIFACT PATHS\n// \n\n/**\n * Autogen artifact types\n */\nexport type AutogenArtifact =\n  | 'analysis'      // analysis.json - Journey analysis results\n  | 'plan'          // plan.json - Test generation plan\n  | 'state'         // pipeline-state.json - Pipeline execution state\n  | 'results'       // results.json - Test execution results\n  | 'samples'       // samples/ directory - Multi-sample outputs\n  | 'agreement'     // samples/agreement.json - Sample agreement analysis\n  | 'telemetry';    // telemetry.json - Session telemetry\n\n/**\n * Get the autogen artifacts directory (.artk/autogen inside harness root).\n *\n * @param explicitBaseDir - Optional explicit path override\n * @returns Path to the autogen directory\n */\nexport function getAutogenDir(explicitBaseDir?: string): string {\n  return join(getArtkDir(explicitBaseDir), 'autogen');\n}\n\n/**\n * Get the path to a specific autogen artifact.\n *\n * @param artifact - The artifact type to get path for\n * @param explicitBaseDir - Optional explicit path override\n * @returns Path to the artifact\n */\nexport function getAutogenArtifact(artifact: AutogenArtifact, explicitBaseDir?: string): string {\n  const dir = getAutogenDir(explicitBaseDir);\n  switch (artifact) {\n    case 'analysis':\n      return join(dir, 'analysis.json');\n    case 'plan':\n      return join(dir, 'plan.json');\n    case 'state':\n      return join(dir, 'pipeline-state.json');\n    case 'results':\n      return join(dir, 'results.json');\n    case 'samples':\n      return join(dir, 'samples');\n    case 'agreement':\n      return join(dir, 'samples', 'agreement.json');\n    case 'telemetry':\n      return join(dir, 'telemetry.json');\n  }\n}\n\n/**\n * Ensure the autogen directory structure exists.\n *\n * Creates:\n * - <harnessRoot>/.artk/autogen/\n * - <harnessRoot>/.artk/autogen/samples/\n *\n * @param explicitBaseDir - Optional explicit path override\n */\nexport async function ensureAutogenDir(explicitBaseDir?: string): Promise<void> {\n  const { mkdir } = await import('node:fs/promises');\n  const dir = getAutogenDir(explicitBaseDir);\n  await mkdir(dir, { recursive: true });\n  await mkdir(join(dir, 'samples'), { recursive: true });\n}\n\n/**\n * Clean all autogen artifacts for a fresh start.\n *\n * Removes and recreates the autogen directory.\n *\n * @param explicitBaseDir - Optional explicit path override\n */\nexport async function cleanAutogenArtifacts(explicitBaseDir?: string): Promise<void> {\n  const { rm } = await import('node:fs/promises');\n  const dir = getAutogenDir(explicitBaseDir);\n  if (existsSync(dir)) {\n    await rm(dir, { recursive: true });\n  }\n  await ensureAutogenDir(explicitBaseDir);\n}\n\n/**\n * Check if autogen artifacts exist.\n *\n * @param explicitBaseDir - Optional explicit path override\n * @returns true if the autogen directory exists and contains artifacts\n */\nexport function hasAutogenArtifacts(explicitBaseDir?: string): boolean {\n  const dir = getAutogenDir(explicitBaseDir);\n  if (!existsSync(dir)) {\n    return false;\n  }\n  // Check for at least one artifact\n  const artifactTypes: AutogenArtifact[] = ['analysis', 'plan', 'state', 'results'];\n  return artifactTypes.some(artifact => existsSync(getAutogenArtifact(artifact, explicitBaseDir)));\n}\n\n// \n// PATH VALIDATION\n// \n\n/**\n * Custom error for path traversal attempts.\n */\nexport class PathTraversalError extends Error {\n  public readonly resolvedPath: string;\n\n  constructor(\n    public readonly userPath: string,\n    public readonly allowedRoot: string,\n    resolvedPath: string\n  ) {\n    super(`Path traversal detected: \"${userPath}\" resolves outside allowed root \"${allowedRoot}\"`);\n    this.name = 'PathTraversalError';\n    this.resolvedPath = resolvedPath;\n  }\n}\n\n/**\n * Validate that a user-provided path stays within an allowed root directory.\n *\n * Security: This function prevents path traversal attacks by:\n * 1. Resolving the path to an absolute path\n * 2. Resolving symlinks to their real targets\n * 3. Checking that the resolved path is within the allowed root\n *\n * @param userPath - The user-provided path (relative or absolute)\n * @param allowedRoot - The root directory that the path must stay within\n * @returns The resolved absolute path (safe to use)\n * @throws PathTraversalError if the path would escape the allowed root\n *\n * @example\n * // Valid paths\n * validatePath('tests/login.spec.ts', '/project') // => '/project/tests/login.spec.ts'\n * validatePath('./src/index.ts', '/project') // => '/project/src/index.ts'\n *\n * // Invalid paths (throw PathTraversalError)\n * validatePath('../../../etc/passwd', '/project') // throws\n * validatePath('/etc/passwd', '/project') // throws (absolute path outside root)\n */\nexport function validatePath(userPath: string, allowedRoot: string): string {\n  // Handle empty path\n  if (!userPath || userPath.trim() === '') {\n    throw new PathTraversalError(userPath, allowedRoot, '');\n  }\n\n  // Security: Check for dangerous characters that could bypass validation\n  // Null bytes can truncate strings in some file system APIs\n  // Newlines can be used for log injection or command splitting\n  if (userPath.includes('\\0') || userPath.includes('\\n') || userPath.includes('\\r')) {\n    throw new PathTraversalError(userPath, allowedRoot, 'invalid-characters');\n  }\n\n  // Windows-specific security checks\n  if (process.platform === 'win32') {\n    // Block Alternate Data Streams (ADS) - e.g., file.txt:Zone.Identifier\n    // ADS format: filename:streamname or filename::$DATA\n    // Only allow : as second character (drive letter like C:)\n    const colonIndex = userPath.indexOf(':');\n    if (colonIndex !== -1 && colonIndex !== 1) {\n      throw new PathTraversalError(userPath, allowedRoot, 'alternate-data-stream');\n    }\n\n    // Block UNC paths - \\\\server\\share or //server/share\n    if (userPath.startsWith('\\\\\\\\') || userPath.startsWith('//')) {\n      throw new PathTraversalError(userPath, allowedRoot, 'unc-path');\n    }\n\n    // Block Windows reserved device names (CON, PRN, AUX, NUL, COM1-9, LPT1-9)\n    // These can cause unexpected behavior or be used for attacks\n    // Check the base name of the path (without extension)\n    const pathParts = userPath.split(/[/\\\\]/);\n    const baseName = pathParts[pathParts.length - 1] || '';\n    const nameWithoutExt = baseName.split('.')[0] || '';\n    const upperName = nameWithoutExt.toUpperCase();\n    const reservedNames = ['CON', 'PRN', 'AUX', 'NUL'];\n    const reservedPrefixes = ['COM', 'LPT'];\n\n    if (reservedNames.includes(upperName)) {\n      throw new PathTraversalError(userPath, allowedRoot, 'reserved-device-name');\n    }\n    for (const prefix of reservedPrefixes) {\n      if (upperName.startsWith(prefix) && /^(COM|LPT)[1-9]$/.test(upperName)) {\n        throw new PathTraversalError(userPath, allowedRoot, 'reserved-device-name');\n      }\n    }\n  }\n\n  // Resolve the user path relative to the allowed root\n  const resolved = resolve(allowedRoot, userPath);\n\n  // Try to resolve symlinks - if the file doesn't exist yet, just use the resolved path\n  let realResolved: string;\n  let realRoot: string;\n\n  try {\n    realRoot = realpathSync(allowedRoot);\n  } catch {\n    // If allowed root doesn't exist, use the resolved version\n    realRoot = resolve(allowedRoot);\n  }\n\n  try {\n    realResolved = realpathSync(resolved);\n  } catch {\n    // File doesn't exist yet - try to resolve the parent directory chain\n    // to ensure we get a consistent path (handles /var -> /private/var on macOS)\n    let current = resolved;\n    let parentResolved = resolved;\n    while (current !== dirname(current)) {\n      const parent = dirname(current);\n      try {\n        // Find the deepest existing directory and resolve from there\n        const realParent = realpathSync(parent);\n        const relativePart = relative(parent, resolved);\n        parentResolved = join(realParent, relativePart);\n        break;\n      } catch {\n        current = parent;\n      }\n    }\n    realResolved = parentResolved;\n  }\n\n  // Calculate relative path from root to resolved\n  const rel = relative(realRoot, realResolved);\n\n  // Check for traversal:\n  // - Path starts with '..' (escapes upward)\n  // - Path is absolute and different from root (e.g., /etc/passwd resolved)\n  if (rel.startsWith('..') || (isAbsolute(rel) && !rel.startsWith(realRoot))) {\n    throw new PathTraversalError(userPath, allowedRoot, realResolved);\n  }\n\n  return realResolved;\n}\n\n/**\n * Validate multiple paths and return only the valid ones.\n *\n * @param paths - Array of user-provided paths\n * @param allowedRoot - The root directory that paths must stay within\n * @param onInvalid - Optional callback for invalid paths (for logging/reporting)\n * @returns Array of validated absolute paths (invalid paths are filtered out)\n */\nexport function validatePaths(\n  paths: string[],\n  allowedRoot: string,\n  onInvalid?: (_invalidPath: string) => void\n): string[] {\n  const validPaths: string[] = [];\n\n  for (const userPath of paths) {\n    try {\n      const validated = validatePath(userPath, allowedRoot);\n      validPaths.push(validated);\n    } catch (e) {\n      if (e instanceof PathTraversalError && onInvalid) {\n        onInvalid(userPath);\n      }\n      // Skip invalid paths\n    }\n  }\n\n  return validPaths;\n}\n","/**\n * Pattern distance calculation for finding nearest matching patterns\n */\n\nimport type { StepPattern } from './patterns.js';\n\n/**\n * Extended pattern definition with examples for distance calculation\n */\nexport interface PatternDefinition extends StepPattern {\n  examples?: string[];\n  requiredKeywords?: string[];\n}\n\nexport interface NearestPatternResult {\n  name: string;\n  distance: number;\n  exampleMatch: string;\n  mismatchReason: string;\n}\n\n/**\n * Calculate Levenshtein distance between two strings\n */\nexport function levenshteinDistance(a: string, b: string): number {\n  const matrix: number[][] = [];\n\n  for (let i = 0; i <= b.length; i++) {\n    matrix[i] = [i];\n  }\n\n  for (let j = 0; j <= a.length; j++) {\n    matrix[0]![j] = j;\n  }\n\n  for (let i = 1; i <= b.length; i++) {\n    for (let j = 1; j <= a.length; j++) {\n      if (b.charAt(i - 1) === a.charAt(j - 1)) {\n        matrix[i]![j] = matrix[i - 1]![j - 1]!;\n      } else {\n        matrix[i]![j] = Math.min(\n          matrix[i - 1]![j - 1]! + 1, // substitution\n          matrix[i]![j - 1]! + 1,     // insertion\n          matrix[i - 1]![j]! + 1      // deletion\n        );\n      }\n    }\n  }\n\n  return matrix[b.length]![a.length]!;\n}\n\n/**\n * Calculate normalized similarity between two strings (0-1)\n */\nexport function calculateSimilarity(a: string, b: string): number {\n  const distance = levenshteinDistance(a.toLowerCase(), b.toLowerCase());\n  const maxLength = Math.max(a.length, b.length);\n  if (maxLength === 0) return 1;\n  return 1 - distance / maxLength;\n}\n\n/**\n * Extract example text from a regex pattern\n * This is a heuristic - it tries to create a plausible example from the regex\n */\nfunction generateExampleFromRegex(regex: RegExp, patternName: string): string {\n  // Reserved for future regex-based example generation\n  void regex.source;\n\n  // Navigation patterns\n  if (patternName.includes('navigate')) {\n    return 'User navigates to /path';\n  }\n\n  // Click patterns\n  if (patternName.includes('click')) {\n    return 'User clicks \"Button\" button';\n  }\n\n  // Fill patterns\n  if (patternName.includes('fill') || patternName.includes('enter') || patternName.includes('type')) {\n    return 'User enters \"value\" in \"Field\" field';\n  }\n\n  // Assertion patterns\n  if (patternName.includes('see') || patternName.includes('visible') || patternName.includes('expect')) {\n    return 'User should see \"Content\"';\n  }\n\n  // Wait patterns\n  if (patternName.includes('wait')) {\n    return 'Wait for network idle';\n  }\n\n  // Generic fallback\n  return `Step matching ${patternName}`;\n}\n\n/**\n * Find the nearest pattern for a given step text\n */\nexport function findNearestPattern(\n  text: string,\n  patterns: Map<string, PatternDefinition> | StepPattern[]\n): NearestPatternResult | null {\n  let nearest: NearestPatternResult | null = null;\n  let minDistance = Infinity;\n\n  const normalizedText = text.toLowerCase().trim();\n\n  // Convert to array if it's a Map\n  const patternArray: Array<[string, PatternDefinition | StepPattern]> =\n    patterns instanceof Map\n      ? Array.from(patterns.entries())\n      : patterns.map(p => [p.name, p] as [string, PatternDefinition | StepPattern]);\n\n  for (const [name, pattern] of patternArray) {\n    // Get examples - either from PatternDefinition or generate from regex\n    const examples = 'examples' in pattern && pattern.examples\n      ? pattern.examples\n      : [generateExampleFromRegex(pattern.regex, pattern.name)];\n\n    // Compare against pattern examples\n    for (const example of examples) {\n      const distance = levenshteinDistance(normalizedText, example.toLowerCase());\n      if (distance < minDistance) {\n        minDistance = distance;\n        nearest = {\n          name,\n          distance,\n          exampleMatch: example,\n          mismatchReason: explainMismatch(text, pattern),\n        };\n      }\n    }\n  }\n\n  // Only return if similarity is above threshold (> 50%)\n  if (nearest && nearest.exampleMatch) {\n    const similarity = calculateSimilarity(text, nearest.exampleMatch);\n    if (similarity > 0.5) {\n      return nearest;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Explain why a pattern didn't match\n */\nexport function explainMismatch(text: string, pattern: StepPattern | PatternDefinition): string {\n  const reasons: string[] = [];\n  const lowerText = text.toLowerCase();\n\n  // Check for missing keywords based on pattern type\n  const requiredKeywords = 'requiredKeywords' in pattern\n    ? pattern.requiredKeywords\n    : inferRequiredKeywords(pattern);\n\n  if (requiredKeywords) {\n    const missing = requiredKeywords.filter(\n      kw => !lowerText.includes(kw.toLowerCase())\n    );\n    if (missing.length > 0) {\n      reasons.push(`Missing keywords: ${missing.join(', ')}`);\n    }\n  }\n\n  // Check for missing locator hints\n  if (!text.includes('(') && !text.includes('testid=') && !text.includes('role=')) {\n    reasons.push('Missing locator hint (e.g., testid=..., role=button)');\n  }\n\n  // Check for ambiguous target based on pattern type\n  if (pattern.primitiveType === 'click' && !text.match(/['\"].+?['\"]/)) {\n    reasons.push('Target element name not quoted');\n  }\n\n  return reasons.length > 0 ? reasons.join('; ') : 'Pattern format mismatch';\n}\n\n/**\n * Infer required keywords from a pattern\n */\nfunction inferRequiredKeywords(pattern: StepPattern): string[] | undefined {\n  const name = pattern.name.toLowerCase();\n\n  if (name.includes('navigate')) {\n    return ['navigate', 'go', 'open'];\n  }\n\n  if (name.includes('click')) {\n    return ['click', 'press', 'tap'];\n  }\n\n  if (name.includes('fill') || name.includes('enter')) {\n    return ['enter', 'type', 'fill', 'input'];\n  }\n\n  if (name.includes('see') || name.includes('visible')) {\n    return ['see', 'visible', 'shown'];\n  }\n\n  if (name.includes('wait')) {\n    return ['wait'];\n  }\n\n  return undefined;\n}\n","/**\n * LLKB Pattern Extension - Learning and promotion of patterns from LLKB\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md Phase 4\n * @see Task 2 - Fuzzy matching support added 2026-02-04\n */\nimport { existsSync, readFileSync, writeFileSync, mkdirSync, unlinkSync, renameSync, statSync } from 'node:fs';\nimport { join, dirname } from 'node:path';\nimport type { IRPrimitive } from '../ir/types.js';\n// Use the same normalizer as stepMapper for consistent pattern matching\n// This ensures patterns learned during recording match during lookup\nimport { normalizeStepText } from '../mapping/glossary.js';\nimport { getLlkbRoot as getInferredLlkbRoot } from '../utils/paths.js';\nimport { calculateSimilarity } from '../mapping/patternDistance.js';\n\n/**\n * Layer priority order for discovered patterns.\n * app-specific beats framework beats universal.\n */\nconst LAYER_PRIORITY: Record<string, number> = {\n  'app-specific': 3,\n  'framework': 2,\n  'universal': 1,\n};\n\n/**\n * Map selector hint strategies to Playwright LocatorStrategy names.\n */\nconst SELECTOR_STRATEGY_MAP: Record<string, import('../ir/types.js').LocatorStrategy> = {\n  'data-testid': 'testid',\n  'data-cy': 'testid',\n  'data-test': 'testid',\n  'role': 'role',\n  'aria-label': 'label',\n  'css': 'css',\n  'text': 'text',\n  'xpath': 'css', // fallback  xpath not directly supported in LocatorStrategy\n};\n\n/**\n * Create a best-effort IRPrimitive from a string type name and optional selector hints.\n *\n * Discovered patterns store `mappedPrimitive` as a string (e.g., \"click\", \"fill\").\n * This function constructs a valid IRPrimitive object so discovered patterns can\n * participate in AutoGen matching and code generation.\n *\n * Returns null only for unrecognized type names.\n */\nfunction createIRPrimitiveFromDiscovered(\n  typeName: string,\n  selectorHints?: Array<{ strategy: string; value: string; confidence?: number }>\n): IRPrimitive | null {\n  // Build a LocatorSpec from the best selector hint\n  const locator = buildLocatorFromHints(selectorHints);\n\n  switch (typeName) {\n    // Interactions\n    case 'click':\n      return { type: 'click', locator };\n    case 'dblclick':\n      return { type: 'dblclick', locator };\n    case 'fill':\n      return { type: 'fill', locator, value: { type: 'literal', value: '{{input}}' } };\n    case 'check':\n      return { type: 'check', locator };\n    case 'uncheck':\n      return { type: 'uncheck', locator };\n    case 'select':\n      return { type: 'select', locator, option: '{{option}}' };\n    case 'hover':\n      return { type: 'hover', locator };\n    case 'clear':\n      return { type: 'clear', locator };\n    case 'press':\n      return { type: 'press', key: 'Enter', locator };\n\n    // Navigation\n    case 'navigate':\n    case 'goto':\n      return { type: 'goto', url: '{{url}}' };\n    case 'goBack':\n      return { type: 'goBack' };\n    case 'reload':\n      return { type: 'reload' };\n\n    // Assertions\n    case 'assert':\n    case 'expectVisible':\n      return { type: 'expectVisible', locator };\n    case 'expectNotVisible':\n      return { type: 'expectNotVisible', locator };\n    case 'expectHidden':\n      return { type: 'expectHidden', locator };\n    case 'expectText':\n      return { type: 'expectText', locator, text: '{{text}}' };\n    case 'expectURL':\n      return { type: 'expectURL', pattern: '{{pattern}}' };\n    case 'expectTitle':\n      return { type: 'expectTitle', title: '{{title}}' };\n    case 'expectValue':\n      return { type: 'expectValue', locator, value: '{{value}}' };\n    case 'expectChecked':\n      return { type: 'expectChecked', locator };\n    case 'expectEnabled':\n      return { type: 'expectEnabled', locator };\n    case 'expectDisabled':\n      return { type: 'expectDisabled', locator };\n    case 'expectCount':\n      return { type: 'expectCount', locator, count: 0 };\n    case 'expectContainsText':\n      return { type: 'expectContainsText', locator, text: '{{text}}' };\n\n    // Signals (toasts, modals, alerts)\n    case 'expectToast':\n      return { type: 'expectToast', toastType: 'success' };\n    case 'dismissModal':\n      return { type: 'dismissModal' };\n    case 'acceptAlert':\n      return { type: 'acceptAlert' };\n    case 'dismissAlert':\n      return { type: 'dismissAlert' };\n\n    // Wait\n    case 'waitForVisible':\n      return { type: 'waitForVisible', locator };\n    case 'waitForHidden':\n      return { type: 'waitForHidden', locator };\n    case 'waitForURL':\n      return { type: 'waitForURL', pattern: '{{pattern}}' };\n    case 'waitForNetworkIdle':\n      return { type: 'waitForNetworkIdle' };\n    case 'waitForTimeout':\n      return { type: 'waitForTimeout', ms: 1000 };\n    case 'waitForResponse':\n      return { type: 'waitForResponse', urlPattern: '{{pattern}}' };\n    case 'waitForLoadingComplete':\n      return { type: 'waitForLoadingComplete' };\n\n    // Navigation (additional)\n    case 'goForward':\n      return { type: 'goForward' };\n\n    // File upload\n    case 'upload':\n      return { type: 'upload', locator, files: ['{{file}}'] };\n\n    // Additional interactions\n    case 'rightClick':\n      return { type: 'rightClick', locator };\n    case 'focus':\n      return { type: 'focus', locator };\n\n    // Keyboard shortcut (template-generators uses 'keyboard' for modal Escape etc.)\n    case 'keyboard':\n      return { type: 'press', key: 'Escape', locator };\n\n    // Drag has no IR type  patterns using 'drag' (e.g., column resize) cannot\n    // be mapped to code generation yet. Return null so they are skipped gracefully.\n    case 'drag':\n      return null;\n\n    default:\n      return null;\n  }\n}\n\n/**\n * Build a LocatorSpec from discovered pattern selector hints.\n * Falls back to a generic testid locator if no hints available.\n */\nfunction buildLocatorFromHints(\n  hints?: Array<{ strategy: string; value: string; confidence?: number }>\n): import('../ir/types.js').LocatorSpec {\n  if (!hints || hints.length === 0) {\n    return { strategy: 'testid', value: '{{locator}}' };\n  }\n\n  // Sort by confidence descending, pick the best\n  const sorted = [...hints].sort((a, b) => (b.confidence ?? 0) - (a.confidence ?? 0));\n  const best = sorted[0]!;\n\n  const strategy = SELECTOR_STRATEGY_MAP[best.strategy] ?? 'testid';\n  return { strategy, value: best.value };\n}\n\n// =============================================================================\n// File Locking (inline implementation for autogen package)\n// Prevents lost writes when concurrent generate calls race on learned-patterns.json\n// =============================================================================\n\nconst LOCK_MAX_WAIT_MS = 5000;\nconst STALE_LOCK_THRESHOLD_MS = 30000;\nconst LOCK_RETRY_INTERVAL_MS = 50;\n\nfunction acquireFileLock(filePath: string): boolean {\n  const lockPath = `${filePath}.lock`;\n  try {\n    // Ensure parent directory exists before creating lock file\n    const dir = dirname(lockPath);\n    if (!existsSync(dir)) {\n      mkdirSync(dir, { recursive: true });\n    }\n    if (existsSync(lockPath)) {\n      const lockAge = Date.now() - statSync(lockPath).mtimeMs;\n      if (lockAge > STALE_LOCK_THRESHOLD_MS) {\n        unlinkSync(lockPath);\n      } else {\n        return false;\n      }\n    }\n    writeFileSync(lockPath, String(Date.now()), { flag: 'wx' });\n    return true;\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === 'EEXIST') return false;\n    throw error;\n  }\n}\n\nfunction releaseFileLock(filePath: string): void {\n  const lockPath = `${filePath}.lock`;\n  try { if (existsSync(lockPath)) unlinkSync(lockPath); } catch { /* ignore */ }\n}\n\nfunction withFileLockSync<T>(filePath: string, fn: () => T): T {\n  const start = Date.now();\n  while (Date.now() - start < LOCK_MAX_WAIT_MS) {\n    if (acquireFileLock(filePath)) {\n      try {\n        return fn();\n      } finally {\n        releaseFileLock(filePath);\n      }\n    }\n    // Busy-wait retry\n    const end = Date.now() + LOCK_RETRY_INTERVAL_MS;\n    while (Date.now() < end) { /* spin */ }\n  }\n  // Timeout  proceed without lock rather than failing silently\n  console.warn(`[LLKB] Could not acquire lock on ${filePath} within ${LOCK_MAX_WAIT_MS}ms, proceeding without lock`);\n  return fn();\n}\n\n/**\n * Type guard: check if a value is a valid IRPrimitive object.\n * Discovered patterns store mappedPrimitive as a string type name (\"click\", \"fill\"),\n * while learned patterns store the full IRPrimitive object ({type: 'click', locator: ...}).\n * This guard distinguishes the two cases safely.\n */\nfunction isIRPrimitiveObject(value: unknown): value is IRPrimitive {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    'type' in value &&\n    typeof (value as Record<string, unknown>).type === 'string'\n  );\n}\n\n/**\n * A discovered pattern loaded from discovered-patterns.json\n */\ninterface DiscoveredPatternEntry {\n  id: string;\n  normalizedText: string;\n  originalText: string;\n  mappedPrimitive: string;\n  confidence: number;\n  layer: 'app-specific' | 'framework' | 'universal';\n  category?: string;\n  selectorHints?: Array<{ strategy: string; value: string; confidence?: number }>;\n  sourceJourneys?: string[];\n  successCount?: number;\n  failCount?: number;\n}\n\n/**\n * Cache for discovered patterns (separate from learned patterns cache)\n */\ninterface DiscoveredPatternCache {\n  patterns: DiscoveredPatternEntry[];\n  llkbRoot: string;\n  loadedAt: number;\n}\n\nlet discoveredPatternCache: DiscoveredPatternCache | null = null;\nconst DISCOVERED_CACHE_TTL_MS = 10_000; // 10 second cache TTL (less volatile than learned patterns)\n\n/**\n * Load discovered patterns from discovered-patterns.json\n */\nfunction loadDiscoveredPatternsForMatching(llkbRoot: string): DiscoveredPatternEntry[] {\n  const now = Date.now();\n\n  // Check cache\n  if (\n    discoveredPatternCache &&\n    discoveredPatternCache.llkbRoot === llkbRoot &&\n    now - discoveredPatternCache.loadedAt < DISCOVERED_CACHE_TTL_MS\n  ) {\n    return discoveredPatternCache.patterns;\n  }\n\n  const filePath = join(llkbRoot, 'discovered-patterns.json');\n  if (!existsSync(filePath)) {\n    discoveredPatternCache = { patterns: [], llkbRoot, loadedAt: now };\n    return [];\n  }\n\n  try {\n    const content = readFileSync(filePath, 'utf-8');\n    const data = JSON.parse(content);\n    // SEC-F03: Runtime shape validation after JSON.parse\n    if (typeof data !== 'object' || data === null) {\n      console.warn(`[LLKB] Invalid discovered patterns shape in ${filePath}`);\n      discoveredPatternCache = { patterns: [], llkbRoot, loadedAt: now };\n      return [];\n    }\n    const patterns: DiscoveredPatternEntry[] = Array.isArray(data.patterns) ? data.patterns : [];\n\n    discoveredPatternCache = { patterns, llkbRoot, loadedAt: now };\n    return patterns;\n  } catch (err) {\n    console.warn(`[LLKB] Failed to load discovered patterns from ${filePath}: ${err instanceof Error ? err.message : String(err)}`);\n    discoveredPatternCache = { patterns: [], llkbRoot, loadedAt: now };\n    return [];\n  }\n}\n\n/**\n * Invalidate the discovered pattern cache\n */\nexport function invalidateDiscoveredPatternCache(): void {\n  discoveredPatternCache = null;\n}\n\n/**\n * A pattern learned from successful step mappings (runtime matching format).\n *\n * This is the rich runtime type used by AutoGen for pattern matching during\n * test generation. It stores `mappedPrimitive` as a full `IRPrimitive` object.\n *\n * NOTE: This is distinct from core LLKB's `LearnedPattern` (aka `LearnedPatternEntry`)\n * in pattern-generation.ts, which stores `irPrimitive` as a string type name for\n * persistence/merge operations. See I-01 in the review for context.\n */\nexport interface LearnedPattern {\n  /** Unique identifier */\n  id: string;\n  /** Original step text that was learned from */\n  originalText: string;\n  /** Normalized form for matching */\n  normalizedText: string;\n  /** The IR primitive this text maps to */\n  mappedPrimitive: IRPrimitive;\n  /** Confidence score (0-1) */\n  confidence: number;\n  /** Journey IDs where this pattern was used */\n  sourceJourneys: string[];\n  /** Number of successful uses */\n  successCount: number;\n  /** Number of failed uses */\n  failCount: number;\n  /** Timestamp of last use */\n  lastUsed: string;\n  /** Timestamp when created */\n  createdAt: string;\n  /** Whether this pattern has been promoted to core */\n  promotedToCore: boolean;\n  /** Promotion timestamp if promoted */\n  promotedAt?: string;\n}\n\n/**\n * Pattern ready for promotion to core\n */\nexport interface PromotedPattern {\n  /** The learned pattern being promoted */\n  pattern: LearnedPattern;\n  /** Generated regex string for the pattern */\n  generatedRegex: string;\n  /** Priority score for ordering */\n  priority: number;\n}\n\n/**\n * LLKB pattern match result\n */\nexport interface LlkbPatternMatch {\n  /** Pattern ID that matched */\n  patternId: string;\n  /** The IR primitive */\n  primitive: IRPrimitive;\n  /** Confidence of the match */\n  confidence: number;\n}\n\n/**\n * Options for pruning patterns\n */\nexport interface PruneOptions {\n  /** Minimum confidence to keep */\n  minConfidence?: number;\n  /** Minimum success count to keep */\n  minSuccess?: number;\n  /** Maximum age in days to keep */\n  maxAgeDays?: number;\n}\n\n/**\n * Storage file for learned patterns\n */\nconst PATTERNS_FILE = 'learned-patterns.json';\n\n/**\n * Pattern cache for performance optimization\n * Avoids repeated file reads during step mapping\n */\ninterface PatternCache {\n  patterns: LearnedPattern[];\n  llkbRoot: string;\n  loadedAt: number;\n}\n\nlet patternCache: PatternCache | null = null;\nconst CACHE_TTL_MS = 5000; // 5 second cache TTL\n\n/**\n * Invalidate the pattern cache\n * Call this after any write operation\n */\nexport function invalidatePatternCache(): void {\n  patternCache = null;\n}\n\n/**\n * Get the path to the patterns file.\n *\n * Automatically infers the correct LLKB directory location by:\n * 1. Using explicit llkbRoot if provided\n * 2. Finding artk-e2e/.artk/llkb from project root\n * 3. Finding .artk/llkb in current directory if inside harness\n *\n * @param llkbRoot - Optional explicit LLKB root directory override\n * @returns Path to the patterns file\n */\nexport function getPatternsFilePath(llkbRoot?: string): string {\n  const root = getInferredLlkbRoot(llkbRoot);\n  return join(root, PATTERNS_FILE);\n}\n\n/**\n * Generate a unique pattern ID\n */\nexport function generatePatternId(): string {\n  return `LP${Date.now().toString(36)}${Math.random().toString(36).slice(2, 6)}`.toUpperCase();\n}\n\n/**\n * Load learned patterns from storage (with caching for performance)\n */\nexport function loadLearnedPatterns(options: { llkbRoot?: string; bypassCache?: boolean } = {}): LearnedPattern[] {\n  const llkbRoot = getInferredLlkbRoot(options.llkbRoot);\n  const now = Date.now();\n\n  // Check cache validity (same llkbRoot and not expired)\n  if (\n    !options.bypassCache &&\n    patternCache &&\n    patternCache.llkbRoot === llkbRoot &&\n    now - patternCache.loadedAt < CACHE_TTL_MS\n  ) {\n    return patternCache.patterns;\n  }\n\n  const filePath = getPatternsFilePath(options.llkbRoot);\n\n  if (!existsSync(filePath)) {\n    // Cache empty result\n    patternCache = { patterns: [], llkbRoot, loadedAt: now };\n    return [];\n  }\n\n  try {\n    const content = readFileSync(filePath, 'utf-8');\n    const data = JSON.parse(content);\n    // SEC-F03: Runtime shape validation after JSON.parse\n    if (typeof data !== 'object' || data === null) {\n      console.warn(`[LLKB] Invalid learned patterns shape in ${filePath}`);\n      patternCache = { patterns: [], llkbRoot, loadedAt: now };\n      return [];\n    }\n    const rawPatterns = Array.isArray(data.patterns) ? data.patterns : [];\n\n    // Normalize persistence-format patterns (from universal seeds or mergeDiscoveredPatterns)\n    // into runtime format. Persistence format has `irPrimitive: string` instead of\n    // `mappedPrimitive: IRPrimitive` and may lack `id`, `lastUsed`, `createdAt`, `promotedToCore`.\n    const patterns: LearnedPattern[] = rawPatterns.map((p: Record<string, unknown>) => {\n      // Already in runtime format  has mappedPrimitive object\n      if (p.mappedPrimitive && typeof p.mappedPrimitive === 'object') {\n        return p as unknown as LearnedPattern;\n      }\n      // Persistence format  needs conversion\n      if (typeof p.irPrimitive === 'string') {\n        const primitive = createIRPrimitiveFromDiscovered(p.irPrimitive);\n        if (!primitive) {\n          return null; // Unrecognized IR type  skip\n        }\n        const nowIso = new Date().toISOString();\n        return {\n          id: (p.id as string) || generatePatternId(),\n          originalText: (p.originalText as string) || '',\n          normalizedText: (p.normalizedText as string) || '',\n          mappedPrimitive: primitive,\n          confidence: typeof p.confidence === 'number' ? p.confidence : 0.5,\n          sourceJourneys: Array.isArray(p.sourceJourneys) ? p.sourceJourneys as string[] : [],\n          successCount: typeof p.successCount === 'number' ? p.successCount : 0,\n          failCount: typeof p.failCount === 'number' ? p.failCount : 0,\n          lastUsed: (p.lastUpdated as string) || (p.lastUsed as string) || nowIso,\n          createdAt: (p.createdAt as string) || nowIso,\n          promotedToCore: (p.promotedToCore as boolean) || false,\n        } satisfies LearnedPattern;\n      }\n      // Unknown format  skip\n      return null;\n    }).filter((p: LearnedPattern | null): p is LearnedPattern => p !== null);\n\n    // Update cache\n    patternCache = { patterns, llkbRoot, loadedAt: now };\n    return patterns;\n  } catch (err) {\n    console.warn(`[LLKB] Failed to load learned patterns from ${filePath}: ${err instanceof Error ? err.message : String(err)}`);\n    patternCache = { patterns: [], llkbRoot, loadedAt: now };\n    return [];\n  }\n}\n\n/**\n * Save learned patterns to storage\n */\nexport function saveLearnedPatterns(\n  patterns: LearnedPattern[],\n  options: { llkbRoot?: string } = {}\n): void {\n  const filePath = getPatternsFilePath(options.llkbRoot);\n  const dir = dirname(filePath);\n\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n\n  const data = {\n    version: '1.0.0',\n    lastUpdated: new Date().toISOString(),\n    patterns,\n  };\n\n  // SEC-F08: Use atomic write via temp file + rename to prevent corruption\n  const content = JSON.stringify(data, null, 2);\n  const tempPath = `${filePath}.tmp.${Date.now()}`;\n  try {\n    writeFileSync(tempPath, content, 'utf-8');\n    renameSync(tempPath, filePath);\n  } catch (err) {\n    // Clean up temp file on failure\n    try { if (existsSync(tempPath)) unlinkSync(tempPath); } catch { /* ignore */ }\n    throw err;\n  }\n\n  // Invalidate cache after write\n  invalidatePatternCache();\n}\n\n/**\n * Calculate confidence from success/fail counts\n * Uses Wilson score interval for small sample sizes\n */\nexport function calculateConfidence(successCount: number, failCount: number): number {\n  const total = successCount + failCount;\n  if (total === 0) return 0.5;\n\n  const p = successCount / total;\n  const z = 1.96; // 95% confidence\n  const n = total;\n\n  // Wilson score lower bound\n  const denominator = 1 + (z * z) / n;\n  const center = p + (z * z) / (2 * n);\n  const spread = z * Math.sqrt((p * (1 - p) + (z * z) / (4 * n)) / n);\n\n  return Math.max(0, Math.min(1, (center - spread) / denominator));\n}\n\n/**\n * Record a successful pattern transformation\n */\nexport function recordPatternSuccess(\n  originalText: string,\n  primitive: IRPrimitive,\n  journeyId: string,\n  options: { llkbRoot?: string } = {}\n): LearnedPattern {\n  const filePath = getPatternsFilePath(options.llkbRoot);\n\n  return withFileLockSync(filePath, () => {\n    // Re-load inside lock to prevent lost-write race condition\n    const patterns = loadLearnedPatterns({ ...options, bypassCache: true });\n    const normalizedText = normalizeStepText(originalText);\n\n    let pattern = patterns.find((p) => p.normalizedText === normalizedText);\n\n    if (pattern) {\n      pattern.successCount++;\n      pattern.confidence = calculateConfidence(pattern.successCount, pattern.failCount);\n      pattern.lastUsed = new Date().toISOString();\n      if (!pattern.sourceJourneys.includes(journeyId)) {\n        pattern.sourceJourneys.push(journeyId);\n      }\n    } else {\n      pattern = {\n        id: generatePatternId(),\n        originalText,\n        normalizedText,\n        mappedPrimitive: primitive,\n        confidence: 0.5,\n        sourceJourneys: [journeyId],\n        successCount: 1,\n        failCount: 0,\n        lastUsed: new Date().toISOString(),\n        createdAt: new Date().toISOString(),\n        promotedToCore: false,\n      };\n      patterns.push(pattern);\n    }\n\n    saveLearnedPatterns(patterns, options);\n    return pattern;\n  });\n}\n\n/**\n * Record a failed pattern use\n */\nexport function recordPatternFailure(\n  originalText: string,\n  _journeyId: string,\n  options: { llkbRoot?: string } = {}\n): LearnedPattern | null {\n  const filePath = getPatternsFilePath(options.llkbRoot);\n\n  return withFileLockSync(filePath, () => {\n    // Re-load inside lock to prevent lost-write race condition\n    const patterns = loadLearnedPatterns({ ...options, bypassCache: true });\n    const normalizedText = normalizeStepText(originalText);\n\n    const pattern = patterns.find((p) => p.normalizedText === normalizedText);\n\n    if (pattern) {\n      pattern.failCount++;\n      pattern.confidence = calculateConfidence(pattern.successCount, pattern.failCount);\n      pattern.lastUsed = new Date().toISOString();\n      saveLearnedPatterns(patterns, options);\n      return pattern;\n    }\n\n    return null;\n  });\n}\n\n/**\n * Options for LLKB pattern matching\n */\nexport interface LlkbMatchOptions {\n  /** LLKB root directory */\n  llkbRoot?: string;\n  /** Minimum pattern confidence to consider (default: 0.5) */\n  minConfidence?: number;\n  /** Minimum text similarity for fuzzy match (default: 0.7) */\n  minSimilarity?: number;\n  /** Whether to use fuzzy matching (default: true) */\n  useFuzzyMatch?: boolean;\n}\n\n/**\n * Match text against learned LLKB patterns and discovered patterns.\n *\n * Search order with layer priority:\n * 1. Learned patterns (exact match, then fuzzy match)\n * 2. Discovered patterns (exact match, then fuzzy match)\n *    - Layer priority: app-specific > framework > universal\n *\n * When both sources return a match, the higher-layer discovered pattern\n * wins if it has equal or higher confidence than the learned pattern match.\n */\nexport function matchLlkbPattern(\n  text: string,\n  options: LlkbMatchOptions = {}\n): LlkbPatternMatch | null {\n  const normalizedText = normalizeStepText(text);\n  const minConfidence = options.minConfidence ?? 0.5;\n  const minSimilarity = options.minSimilarity ?? 0.7;\n  const useFuzzyMatch = options.useFuzzyMatch ?? true;\n\n  // --- Phase 1: Search learned patterns ---\n  const learnedMatch = matchLearnedPatterns(normalizedText, minConfidence, minSimilarity, useFuzzyMatch, options);\n\n  // --- Phase 2: Search discovered patterns (layer-priority) ---\n  const discoveredMatch = matchDiscoveredPatterns(normalizedText, minConfidence, minSimilarity, useFuzzyMatch, options);\n\n  // No matches at all\n  if (!learnedMatch && !discoveredMatch) {\n    return null;\n  }\n\n  // Only one source matched\n  if (!discoveredMatch) return learnedMatch;\n  if (!learnedMatch) return discoveredMatch;\n\n  // Both matched - discovered pattern with higher layer priority wins on ties\n  if (discoveredMatch.confidence >= learnedMatch.confidence) {\n    return discoveredMatch;\n  }\n\n  return learnedMatch;\n}\n\n/**\n * Match against learned patterns (original logic extracted)\n */\nfunction matchLearnedPatterns(\n  normalizedText: string,\n  minConfidence: number,\n  minSimilarity: number,\n  useFuzzyMatch: boolean,\n  options: LlkbMatchOptions\n): LlkbPatternMatch | null {\n  const patterns = loadLearnedPatterns(options);\n\n  // Exact match (fast path)\n  const exactMatch = patterns.find(\n    (p) => p.normalizedText === normalizedText && p.confidence >= minConfidence && !p.promotedToCore\n  );\n\n  if (exactMatch) {\n    return {\n      patternId: exactMatch.id,\n      primitive: exactMatch.mappedPrimitive,\n      confidence: exactMatch.confidence,\n    };\n  }\n\n  // Fuzzy match\n  if (useFuzzyMatch) {\n    let bestMatch: LearnedPattern | null = null;\n    let bestSimilarity = 0;\n\n    for (const pattern of patterns) {\n      if (pattern.promotedToCore || pattern.confidence < minConfidence) {\n        continue;\n      }\n\n      const similarity = calculateSimilarity(normalizedText, pattern.normalizedText);\n\n      if (similarity >= minSimilarity && similarity > bestSimilarity) {\n        bestSimilarity = similarity;\n        bestMatch = pattern;\n      }\n    }\n\n    if (bestMatch) {\n      return {\n        patternId: bestMatch.id,\n        primitive: bestMatch.mappedPrimitive,\n        confidence: bestMatch.confidence * bestSimilarity,\n      };\n    }\n  }\n\n  return null;\n}\n\n/**\n * Match against discovered patterns with layer priority.\n * Among exact matches, the highest-layer pattern wins.\n * Falls back to fuzzy matching if no exact match found.\n */\nfunction matchDiscoveredPatterns(\n  normalizedText: string,\n  minConfidence: number,\n  minSimilarity: number,\n  useFuzzyMatch: boolean,\n  options: LlkbMatchOptions\n): LlkbPatternMatch | null {\n  const llkbRoot = getInferredLlkbRoot(options.llkbRoot);\n  const patterns = loadDiscoveredPatternsForMatching(llkbRoot);\n\n  if (patterns.length === 0) return null;\n\n  // Exact matches - collect all, pick highest layer priority\n  const exactMatches = patterns.filter(\n    (p) => p.normalizedText === normalizedText && p.confidence >= minConfidence\n  );\n\n  if (exactMatches.length > 0) {\n    // Sort by layer priority (highest first), then by confidence\n    exactMatches.sort((a, b) => {\n      const layerDiff = (LAYER_PRIORITY[b.layer] ?? 0) - (LAYER_PRIORITY[a.layer] ?? 0);\n      return layerDiff !== 0 ? layerDiff : b.confidence - a.confidence;\n    });\n\n    const best = exactMatches[0]!;\n    // Discovered patterns store type name strings; learned patterns store full IR objects.\n    let primitive: IRPrimitive | null;\n    if (isIRPrimitiveObject(best.mappedPrimitive)) {\n      primitive = best.mappedPrimitive;\n    } else {\n      // Convert string type name (e.g. \"click\") to a full IRPrimitive object\n      primitive = createIRPrimitiveFromDiscovered(\n        best.mappedPrimitive as unknown as string,\n        best.selectorHints\n      );\n    }\n    if (!primitive) return null; // unrecognized type name\n    return {\n      patternId: best.id,\n      primitive,\n      confidence: best.confidence,\n    };\n  }\n\n  // Fuzzy match with layer priority\n  if (useFuzzyMatch) {\n    let bestMatch: DiscoveredPatternEntry | null = null;\n    let bestSimilarity = 0;\n    let bestLayerPriority = 0;\n\n    for (const pattern of patterns) {\n      if (pattern.confidence < minConfidence) continue;\n\n      const similarity = calculateSimilarity(normalizedText, pattern.normalizedText);\n\n      if (similarity < minSimilarity) continue;\n\n      const layerPriority = LAYER_PRIORITY[pattern.layer] ?? 0;\n\n      // Prefer higher layer, then higher similarity\n      if (\n        layerPriority > bestLayerPriority ||\n        (layerPriority === bestLayerPriority && similarity > bestSimilarity)\n      ) {\n        bestMatch = pattern;\n        bestSimilarity = similarity;\n        bestLayerPriority = layerPriority;\n      }\n    }\n\n    if (bestMatch) {\n      // Discovered patterns store type name strings; learned patterns store full IR objects.\n      let primitive: IRPrimitive | null;\n      if (isIRPrimitiveObject(bestMatch.mappedPrimitive)) {\n        primitive = bestMatch.mappedPrimitive;\n      } else {\n        primitive = createIRPrimitiveFromDiscovered(\n          bestMatch.mappedPrimitive as unknown as string,\n          bestMatch.selectorHints\n        );\n      }\n      if (!primitive) return null; // unrecognized type name\n      return {\n        patternId: bestMatch.id,\n        primitive,\n        confidence: bestMatch.confidence * bestSimilarity,\n      };\n    }\n  }\n\n  return null;\n}\n\n/**\n * Generate a regex pattern from a learned text pattern\n * This is a heuristic approach - complex patterns may need manual refinement\n */\nexport function generateRegexFromText(text: string): string {\n  const pattern = text\n    .toLowerCase()\n    // Escape special regex chars\n    .replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n    // Replace quoted values with capture groups\n    .replace(/\"[^\"]+\"/g, '\"([^\"]+)\"')\n    .replace(/'[^']+'/g, \"'([^']+)'\")\n    // Make articles optional\n    .replace(/\\b(the|a|an)\\b/g, '(?:$1\\\\s+)?')\n    // Make \"user\" prefix optional\n    .replace(/^user\\s+/, '(?:user\\\\s+)?')\n    // Handle common verbs\n    .replace(/\\bclicks?\\b/g, 'clicks?')\n    .replace(/\\bfills?\\b/g, 'fills?')\n    .replace(/\\bselects?\\b/g, 'selects?')\n    .replace(/\\btypes?\\b/g, 'types?')\n    .replace(/\\bsees?\\b/g, 'sees?')\n    .replace(/\\bwaits?\\b/g, 'waits?');\n\n  return `^${pattern}$`;\n}\n\n/**\n * Get patterns ready for promotion to core\n */\nexport function getPromotablePatterns(options: { llkbRoot?: string } = {}): PromotedPattern[] {\n  const patterns = loadLearnedPatterns(options);\n\n  const promotable = patterns.filter(\n    (p) =>\n      p.confidence >= 0.9 &&\n      p.successCount >= 5 &&\n      p.sourceJourneys.length >= 2 &&\n      !p.promotedToCore\n  );\n\n  return promotable.map((pattern) => ({\n    pattern,\n    generatedRegex: generateRegexFromText(pattern.originalText),\n    priority: pattern.successCount * pattern.confidence,\n  }));\n}\n\n/**\n * Mark patterns as promoted\n */\nexport function markPatternsPromoted(\n  patternIds: string[],\n  options: { llkbRoot?: string } = {}\n): void {\n  const patterns = loadLearnedPatterns(options);\n  const now = new Date().toISOString();\n\n  for (const pattern of patterns) {\n    if (patternIds.includes(pattern.id)) {\n      pattern.promotedToCore = true;\n      pattern.promotedAt = now;\n    }\n  }\n\n  saveLearnedPatterns(patterns, options);\n}\n\n/**\n * Prune low-quality patterns\n */\nexport function prunePatterns(options: PruneOptions & { llkbRoot?: string } = {}): {\n  removed: number;\n  remaining: number;\n} {\n  const patterns = loadLearnedPatterns(options);\n  const now = Date.now();\n  const maxAge = (options.maxAgeDays ?? 90) * 24 * 60 * 60 * 1000;\n  const minConfidence = options.minConfidence ?? 0.3;\n  const minSuccess = options.minSuccess ?? 1;\n\n  const filtered = patterns.filter((p) => {\n    // Keep if already promoted\n    if (p.promotedToCore) return true;\n\n    // Remove if below minimum confidence\n    if (p.confidence < minConfidence) return false;\n\n    // Remove if no successes and required\n    if (minSuccess > 0 && p.successCount < minSuccess) return false;\n\n    // Remove if too old and never successful\n    const age = now - new Date(p.createdAt).getTime();\n    if (age > maxAge && p.successCount === 0) return false;\n\n    return true;\n  });\n\n  const removed = patterns.length - filtered.length;\n\n  if (removed > 0) {\n    saveLearnedPatterns(filtered, options);\n  }\n\n  return {\n    removed,\n    remaining: filtered.length,\n  };\n}\n\n/**\n * Get pattern statistics\n */\nexport function getPatternStats(options: { llkbRoot?: string } = {}): {\n  total: number;\n  promoted: number;\n  highConfidence: number;\n  lowConfidence: number;\n  avgConfidence: number;\n  totalSuccesses: number;\n  totalFailures: number;\n} {\n  const patterns = loadLearnedPatterns(options);\n\n  if (patterns.length === 0) {\n    return {\n      total: 0,\n      promoted: 0,\n      highConfidence: 0,\n      lowConfidence: 0,\n      avgConfidence: 0,\n      totalSuccesses: 0,\n      totalFailures: 0,\n    };\n  }\n\n  const promoted = patterns.filter((p) => p.promotedToCore).length;\n  const highConfidence = patterns.filter((p) => p.confidence >= 0.7).length;\n  const lowConfidence = patterns.filter((p) => p.confidence < 0.3).length;\n  const totalConfidence = patterns.reduce((sum, p) => sum + p.confidence, 0);\n  const totalSuccesses = patterns.reduce((sum, p) => sum + p.successCount, 0);\n  const totalFailures = patterns.reduce((sum, p) => sum + p.failCount, 0);\n\n  return {\n    total: patterns.length,\n    promoted,\n    highConfidence,\n    lowConfidence,\n    avgConfidence: totalConfidence / patterns.length,\n    totalSuccesses,\n    totalFailures,\n  };\n}\n\n/**\n * Export learned patterns to LLKB config format\n */\nexport function exportPatternsToConfig(options: {\n  llkbRoot?: string;\n  outputPath?: string;\n  minConfidence?: number;\n}): { exported: number; path: string } {\n  const patterns = loadLearnedPatterns(options);\n  const minConfidence = options.minConfidence ?? 0.7;\n\n  const exportable = patterns.filter((p) => p.confidence >= minConfidence && !p.promotedToCore);\n\n  const config = {\n    version: '1.0.0',\n    exportedAt: new Date().toISOString(),\n    patterns: exportable.map((p) => ({\n      id: p.id,\n      trigger: generateRegexFromText(p.originalText),\n      primitive: p.mappedPrimitive,\n      confidence: p.confidence,\n      sourceCount: p.sourceJourneys.length,\n    })),\n  };\n\n  const outputPath =\n    options.outputPath || join(dirname(getPatternsFilePath(options.llkbRoot)), 'autogen-patterns.json');\n\n  writeFileSync(outputPath, JSON.stringify(config, null, 2), 'utf-8');\n\n  return {\n    exported: exportable.length,\n    path: outputPath,\n  };\n}\n\n/**\n * Clear all learned patterns (for testing)\n */\nexport function clearLearnedPatterns(options: { llkbRoot?: string } = {}): void {\n  const filePath = getPatternsFilePath(options.llkbRoot);\n  if (existsSync(filePath)) {\n    unlinkSync(filePath);\n  }\n  // Invalidate cache when clearing patterns\n  invalidatePatternCache();\n}\n","/**\n * Step Mapper - Convert step text to IR primitives\n * @see research/2026-01-02_autogen-refined-plan.md Section 10\n * @see T073 - Update step mapper to prioritize explicit hints over inference\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md Phase 4 - LLKB integration\n */\nimport type {\n  IRPrimitive,\n  IRStep,\n  LocatorSpec,\n} from '../ir/types.js';\nimport type { AcceptanceCriterion, ProceduralStep } from '../journey/parseJourney.js';\nimport { matchPattern } from './patterns.js';\nimport { normalizeStepText } from './glossary.js';\nimport {\n  extractHints,\n  hasLocatorHints,\n  hasBehaviorHints,\n  parseModuleHint,\n  type ExtractedHints,\n} from '../journey/parseHints.js';\n\n// LLKB integration types - imported dynamically to avoid hard dependency\ntype LlkbPatternMatch = {\n  patternId: string;\n  primitive: IRPrimitive;\n  confidence: number;\n};\n\n// LLKB module reference - loaded lazily\nlet llkbModule: {\n  matchLlkbPattern: (_text: string, _options?: { llkbRoot?: string; minConfidence?: number }) => LlkbPatternMatch | null;\n  recordPatternSuccess: (_text: string, _primitive: IRPrimitive, _journeyId: string, _options?: { llkbRoot?: string }) => void;\n} | null = null;\n\n// Track if we've attempted to load LLKB\nlet llkbLoadAttempted = false;\n\n/**\n * Lazily load LLKB module (graceful degradation if not available)\n */\nasync function loadLlkbModule(): Promise<typeof llkbModule> {\n  if (llkbLoadAttempted) return llkbModule;\n  llkbLoadAttempted = true;\n\n  try {\n    const mod = await import('../llkb/patternExtension.js');\n    llkbModule = {\n      matchLlkbPattern: mod.matchLlkbPattern,\n      recordPatternSuccess: mod.recordPatternSuccess,\n    };\n  } catch {\n    // LLKB not available - this is fine, graceful degradation\n    llkbModule = null;\n  }\n\n  return llkbModule;\n}\n\n/**\n * Synchronously check LLKB (for non-async contexts)\n * Uses previously loaded module if available.\n *\n * NOTE: initializeLlkb() should be called before using mapStepText with useLlkb=true.\n * If not initialized, LLKB matching will be skipped silently (graceful degradation).\n */\nfunction tryLlkbMatch(text: string, options?: { llkbRoot?: string; minConfidence?: number }): LlkbPatternMatch | null {\n  if (!llkbModule) {\n    // If module not loaded, attempt lazy initialization (non-blocking)\n    // This won't block, but will start loading for future calls\n    if (!llkbLoadAttempted) {\n      void loadLlkbModule();\n    }\n    return null;\n  }\n  return llkbModule.matchLlkbPattern(text, options);\n}\n\n/**\n * Options for step mapping\n */\nexport interface StepMapperOptions {\n  /** Whether to normalize text before matching */\n  normalizeText?: boolean;\n  /** Whether to include blocked steps for unmatched text */\n  includeBlocked?: boolean;\n  /** Default timeout for assertions */\n  defaultTimeout?: number;\n  /** Whether to use LLKB patterns as fallback (default: true) */\n  useLlkb?: boolean;\n  /** LLKB root directory (default: .artk/llkb) */\n  llkbRoot?: string;\n  /** Minimum confidence for LLKB pattern matches (default: 0.7) */\n  llkbMinConfidence?: number;\n  /** Journey ID for LLKB recording (optional) */\n  journeyId?: string;\n}\n\n/**\n * Result of mapping a single step\n */\nexport interface StepMappingResult {\n  /** The parsed primitive, or null if not matched */\n  primitive: IRPrimitive | null;\n  /** Original text that was mapped */\n  sourceText: string;\n  /** Whether this is an assertion (expect*) or action */\n  isAssertion: boolean;\n  /** Warning or error message if any */\n  message?: string;\n  /** Source of the match */\n  matchSource?: 'pattern' | 'llkb' | 'hints' | 'none';\n  /** LLKB pattern ID if matched via LLKB */\n  llkbPatternId?: string;\n  /** LLKB match confidence if matched via LLKB */\n  llkbConfidence?: number;\n}\n\n/**\n * Result of mapping an acceptance criterion\n */\nexport interface ACMappingResult {\n  /** The mapped IR step */\n  step: IRStep;\n  /** Individual step mapping results */\n  mappings: StepMappingResult[];\n  /** Number of successfully mapped steps */\n  mappedCount: number;\n  /** Number of blocked/unmatched steps */\n  blockedCount: number;\n}\n\n/**\n * Check if a primitive is an assertion\n */\nfunction isAssertion(primitive: IRPrimitive): boolean {\n  return primitive.type.startsWith('expect');\n}\n\n/**\n * Map a single text step to an IR primitive\n */\nexport function mapStepText(\n  text: string,\n  options: StepMapperOptions = {}\n): StepMappingResult {\n  const {\n    normalizeText = true,\n    useLlkb = true,\n    llkbRoot,\n    llkbMinConfidence = 0.7,\n  } = options;\n\n  // Extract machine hints first (T073 - hints take priority)\n  const hints = extractHints(text);\n  const cleanText = hints.hasHints ? hints.cleanText : text;\n\n  // Normalize text if enabled\n  const processedText = normalizeText ? normalizeStepText(cleanText) : cleanText;\n\n  // Try to match against core patterns first\n  let primitive = matchPattern(processedText);\n  let matchSource: 'pattern' | 'llkb' | 'hints' | 'none' = primitive ? 'pattern' : 'none';\n\n  // If we have hints, enhance or override the primitive\n  if (primitive && hints.hasHints) {\n    primitive = applyHintsToPrimitive(primitive, hints);\n  }\n\n  // If no core pattern match, try LLKB patterns (Phase 4 integration)\n  let llkbPatternId: string | undefined;\n  let llkbConfidence: number | undefined;\n\n  if (!primitive && useLlkb) {\n    const llkbMatch = tryLlkbMatch(processedText, {\n      llkbRoot,\n      minConfidence: llkbMinConfidence,\n    });\n\n    if (llkbMatch) {\n      primitive = llkbMatch.primitive;\n      matchSource = 'llkb';\n      llkbPatternId = llkbMatch.patternId;\n      llkbConfidence = llkbMatch.confidence;\n\n      // Record successful pattern match to close the learning loop\n      // This increases confidence for future matches\n      if (llkbModule && options.journeyId) {\n        try {\n          llkbModule.recordPatternSuccess(\n            text, // Original text, not processed\n            llkbMatch.primitive,\n            options.journeyId,\n            { llkbRoot }\n          );\n        } catch {\n          // Don't fail mapping if recording fails - graceful degradation\n        }\n      }\n\n      // Apply hints to LLKB-matched primitive if available\n      if (hints.hasHints) {\n        primitive = applyHintsToPrimitive(primitive, hints);\n      }\n    }\n  }\n\n  // If still no match but we have locator hints, try to create primitive from hints\n  if (!primitive && hasLocatorHints(hints)) {\n    primitive = createPrimitiveFromHints(processedText, hints);\n    if (primitive) {\n      matchSource = 'hints';\n    }\n  }\n\n  if (primitive) {\n    return {\n      primitive,\n      sourceText: text,\n      isAssertion: isAssertion(primitive),\n      matchSource,\n      llkbPatternId,\n      llkbConfidence,\n    };\n  }\n\n  // No match - return blocked with actionable hint\n  return {\n    primitive: null,\n    sourceText: text,\n    isAssertion: false,\n    message: getBlockedReason(processedText, text),\n    matchSource: 'none',\n  };\n}\n\n/**\n * Apply hints to an existing primitive (override inferred values)\n */\nfunction applyHintsToPrimitive(primitive: IRPrimitive, hints: ExtractedHints): IRPrimitive {\n  // Clone the primitive to avoid mutation\n  const enhanced = { ...primitive };\n\n  // Apply locator hints if present\n  if (hasLocatorHints(hints)) {\n    const locatorSpec = buildLocatorFromHints(hints);\n    if (locatorSpec && 'locator' in enhanced) {\n      (enhanced as { locator: LocatorSpec }).locator = locatorSpec;\n    }\n  }\n\n  // Apply behavior hints\n  if (hasBehaviorHints(hints)) {\n    if (hints.behavior.timeout !== undefined && 'timeout' in enhanced) {\n      (enhanced as { timeout: number }).timeout = hints.behavior.timeout;\n    }\n    if (hints.behavior.signal && 'signal' in enhanced) {\n      (enhanced as { signal: string }).signal = hints.behavior.signal;\n    }\n    if (hints.behavior.module) {\n      const parsed = parseModuleHint(hints.behavior.module);\n      if (parsed) {\n        (enhanced as { module?: string; method?: string }).module = parsed.module;\n        (enhanced as { module?: string; method?: string }).method = parsed.method;\n      }\n    }\n  }\n\n  return enhanced;\n}\n\n/**\n * Build LocatorSpec from hints\n */\nfunction buildLocatorFromHints(hints: ExtractedHints): LocatorSpec | null {\n  const { locator } = hints;\n\n  if (locator.testid) {\n    return { strategy: 'testid', value: locator.testid };\n  }\n\n  if (locator.role) {\n    const options: Record<string, unknown> = {};\n    if (locator.label) options.name = locator.label;\n    if (locator.exact) options.exact = true;\n    if (locator.level) options.level = locator.level;\n    return {\n      strategy: 'role',\n      value: locator.role,\n      options: Object.keys(options).length > 0 ? options : undefined,\n    };\n  }\n\n  if (locator.label) {\n    return {\n      strategy: 'label',\n      value: locator.label,\n      options: locator.exact ? { exact: true } : undefined,\n    };\n  }\n\n  if (locator.text) {\n    return {\n      strategy: 'text',\n      value: locator.text,\n      options: locator.exact ? { exact: true } : undefined,\n    };\n  }\n\n  return null;\n}\n\n/**\n * Create a primitive from hints when no pattern matched\n */\nfunction createPrimitiveFromHints(text: string, hints: ExtractedHints): IRPrimitive | null {\n  const locator = buildLocatorFromHints(hints);\n  if (!locator) return null;\n\n  const lowerText = text.toLowerCase();\n\n  // Infer action type from text\n  if (lowerText.includes('click') || lowerText.includes('press')) {\n    return { type: 'click', locator };\n  }\n\n  if (lowerText.includes('enter') || lowerText.includes('type') || lowerText.includes('fill')) {\n    // Try to extract value from text\n    const valueMatch = text.match(/['\"]([^'\"]+)['\"]/);\n    return {\n      type: 'fill',\n      locator,\n      value: { type: 'literal', value: valueMatch ? valueMatch[1]! : '' },\n    };\n  }\n\n  if (lowerText.includes('see') || lowerText.includes('visible') || lowerText.includes('display')) {\n    return { type: 'expectVisible', locator };\n  }\n\n  if (lowerText.includes('check') || lowerText.includes('select')) {\n    return { type: 'check', locator };\n  }\n\n  // Default to click if we have a locator but can't determine action\n  return { type: 'click', locator };\n}\n\n/**\n * Map an acceptance criterion to an IR step\n */\nexport function mapAcceptanceCriterion(\n  ac: AcceptanceCriterion,\n  proceduralSteps: ProceduralStep[],\n  options: StepMapperOptions = {}\n): ACMappingResult {\n  const { includeBlocked = true } = options;\n\n  const actions: IRPrimitive[] = [];\n  const assertions: IRPrimitive[] = [];\n  const mappings: StepMappingResult[] = [];\n  const notes: string[] = [];\n\n  // Find procedural steps linked to this AC\n  const linkedProcedural = proceduralSteps.filter((ps) => ps.linkedAC === ac.id);\n\n  // Map all bullet points from the AC\n  for (const stepText of ac.steps) {\n    const result = mapStepText(stepText, options);\n    mappings.push(result);\n\n    if (result.primitive) {\n      if (result.isAssertion) {\n        assertions.push(result.primitive);\n      } else {\n        actions.push(result.primitive);\n      }\n    } else if (includeBlocked) {\n      actions.push({\n        type: 'blocked',\n        reason: result.message || 'Could not map step',\n        sourceText: stepText,\n      });\n    }\n  }\n\n  // Also map linked procedural steps\n  for (const ps of linkedProcedural) {\n    const result = mapStepText(ps.text, options);\n    // Don't duplicate in mappings, but add to actions if different from AC steps\n    if (result.primitive && !ac.steps.includes(ps.text)) {\n      if (result.isAssertion) {\n        assertions.push(result.primitive);\n      } else {\n        actions.push(result.primitive);\n      }\n    }\n  }\n\n  // Add note if no assertions\n  if (assertions.length === 0 && ac.title) {\n    notes.push(`TODO: Add assertion for: ${ac.title}`);\n  }\n\n  const step: IRStep = {\n    id: ac.id,\n    description: ac.title || `Step ${ac.id}`,\n    actions,\n    assertions,\n    sourceText: ac.rawContent,\n    notes: notes.length > 0 ? notes : undefined,\n  };\n\n  return {\n    step,\n    mappings,\n    mappedCount: mappings.filter((m) => m.primitive !== null).length,\n    blockedCount: mappings.filter((m) => m.primitive === null).length,\n  };\n}\n\n/**\n * Map a procedural step to an IR step\n */\nexport function mapProceduralStep(\n  ps: ProceduralStep,\n  options: StepMapperOptions = {}\n): ACMappingResult {\n  const { includeBlocked = true } = options;\n\n  const result = mapStepText(ps.text, options);\n  const actions: IRPrimitive[] = [];\n  const assertions: IRPrimitive[] = [];\n\n  if (result.primitive) {\n    if (result.isAssertion) {\n      assertions.push(result.primitive);\n    } else {\n      actions.push(result.primitive);\n    }\n  } else if (includeBlocked) {\n    actions.push({\n      type: 'blocked',\n      reason: result.message || 'Could not map procedural step',\n      sourceText: ps.text,\n    });\n  }\n\n  const step: IRStep = {\n    id: `PS-${ps.number}`,\n    description: ps.text,\n    actions,\n    assertions,\n  };\n\n  return {\n    step,\n    mappings: [result],\n    mappedCount: result.primitive ? 1 : 0,\n    blockedCount: result.primitive ? 0 : 1,\n  };\n}\n\n/**\n * Batch map multiple steps\n */\nexport function mapSteps(\n  steps: string[],\n  options: StepMapperOptions = {}\n): StepMappingResult[] {\n  return steps.map((step) => mapStepText(step, options));\n}\n\n/**\n * Get mapping statistics (enhanced with LLKB stats)\n */\nexport function getMappingStats(mappings: StepMappingResult[]): {\n  total: number;\n  mapped: number;\n  blocked: number;\n  actions: number;\n  assertions: number;\n  mappingRate: number;\n  /** Steps matched by core patterns */\n  patternMatches: number;\n  /** Steps matched by LLKB patterns */\n  llkbMatches: number;\n  /** Steps matched by hints */\n  hintMatches: number;\n} {\n  const mapped = mappings.filter((m) => m.primitive !== null);\n  const blocked = mappings.filter((m) => m.primitive === null);\n  const actions = mapped.filter((m) => !m.isAssertion);\n  const assertions = mapped.filter((m) => m.isAssertion);\n\n  const patternMatches = mappings.filter((m) => m.matchSource === 'pattern').length;\n  const llkbMatches = mappings.filter((m) => m.matchSource === 'llkb').length;\n  const hintMatches = mappings.filter((m) => m.matchSource === 'hints').length;\n\n  return {\n    total: mappings.length,\n    mapped: mapped.length,\n    blocked: blocked.length,\n    actions: actions.length,\n    assertions: assertions.length,\n    mappingRate: mappings.length > 0 ? mapped.length / mappings.length : 0,\n    patternMatches,\n    llkbMatches,\n    hintMatches,\n  };\n}\n\n/**\n * Initialize LLKB module for use with step mapping\n * Call this once at the start of generation to enable LLKB patterns\n */\nexport async function initializeLlkb(): Promise<boolean> {\n  const mod = await loadLlkbModule();\n  return mod !== null;\n}\n\n/**\n * Check if LLKB is available for use\n */\nexport function isLlkbAvailable(): boolean {\n  return llkbModule !== null;\n}\n\n/**\n * Suggest improvements for blocked steps\n */\nexport function suggestImprovements(blockedSteps: StepMappingResult[]): string[] {\n  const suggestions: string[] = [];\n\n  for (const step of blockedSteps) {\n    const text = step.sourceText.toLowerCase();\n\n    // Navigation suggestions\n    if (text.includes('go') || text.includes('open') || text.includes('navigate')) {\n      suggestions.push(\n        `\"${step.sourceText}\" - Try: \"User navigates to /path\" or \"User opens /path\"`\n      );\n    }\n    // Click suggestions\n    else if (text.includes('click') || text.includes('press') || text.includes('button')) {\n      suggestions.push(\n        `\"${step.sourceText}\" - Try: \"User clicks 'Button Name' button\" or \"Click the 'Label' button\"`\n      );\n    }\n    // Fill suggestions\n    else if (text.includes('enter') || text.includes('type') || text.includes('field')) {\n      suggestions.push(\n        `\"${step.sourceText}\" - Try: \"User enters 'value' in 'Field Label' field\"`\n      );\n    }\n    // Visibility suggestions\n    else if (text.includes('see') || text.includes('visible') || text.includes('display')) {\n      suggestions.push(\n        `\"${step.sourceText}\" - Try: \"User should see 'Text'\" or \"'Element' is visible\"`\n      );\n    }\n    // Generic suggestion\n    else {\n      suggestions.push(\n        `\"${step.sourceText}\" - Could not determine intent. Check the patterns documentation.`\n      );\n    }\n  }\n\n  return suggestions;\n}\n\n/**\n * Generate an actionable blocked reason explaining WHY a step failed and HOW to fix it\n */\nfunction getBlockedReason(normalizedText: string, originalText: string): string {\n  const text = normalizedText.toLowerCase();\n\n  // Check for missing locator anchor (no quoted text, no role, no testid)\n  const hasQuotedText = /[\"']/.test(originalText);\n  const hasRole = /button|link|heading|checkbox|radio|textbox|combobox/.test(text);\n\n  // Click without identifiable target\n  if ((text.includes('click') || text.includes('press') || text.includes('tap')) && !hasQuotedText && !hasRole) {\n    return `Could not map step: \"${originalText}\" | Reason: No identifiable UI anchor (role, label, testid, or text content) | Suggestion: Rewrite as \"Click the 'Label' button\" or \"Click the button with text 'Label'\"`;\n  }\n\n  // Visibility without specific element\n  if ((text.includes('see') || text.includes('visible') || text.includes('shown') || text.includes('displayed')) && !hasQuotedText) {\n    return `Could not map step: \"${originalText}\" | Reason: No specific element text or label to locate | Suggestion: Rewrite as \"User should see 'Specific Text'\" or \"'Element Name' is visible\"`;\n  }\n\n  // Fill without proper structure\n  if (text.includes('fill') || text.includes('enter') || text.includes('type') || text.includes('input')) {\n    return `Could not map step: \"${originalText}\" | Reason: Could not parse field name and value | Suggestion: Rewrite as \"Fill 'value' in 'Field Name' field\" or \"Fill the 'Field Name' field with 'value'\"`;\n  }\n\n  // Toast/notification\n  if (text.includes('toast') || text.includes('notification') || text.includes('snackbar')) {\n    return `Could not map step: \"${originalText}\" | Reason: Could not parse toast type or message | Suggestion: Rewrite as \"A success toast appears with 'Message'\" or \"Toast with text 'Message' appears\"`;\n  }\n\n  // Select/dropdown\n  if (text.includes('select') || text.includes('choose') || text.includes('dropdown')) {\n    return `Could not map step: \"${originalText}\" | Reason: Could not parse option and dropdown | Suggestion: Rewrite as \"Select 'Option' from 'Dropdown Name'\" or \"Select 'Option' from dropdown\"`;\n  }\n\n  // Navigation\n  if (text.includes('go') || text.includes('open') || text.includes('navigate') || text.includes('visit')) {\n    return `Could not map step: \"${originalText}\" | Reason: Could not parse navigation target | Suggestion: Rewrite as \"User navigates to '/path'\" or \"User opens '/url'\"`;\n  }\n\n  // Generic fallback\n  return `Could not map step: \"${originalText}\" | Reason: No matching pattern found | Suggestion: Check supported patterns with 'artk-autogen patterns list'`;\n}\n","/**\n * Shared escaping utilities for code generation.\n * Consolidates escapeRegex and escapeString from multiple locations.\n */\n\n/**\n * Escape special regex characters in a string.\n * Includes forward slash for URL patterns.\n */\nexport function escapeRegex(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\\\/]/g, '\\\\$&');\n}\n\n/**\n * Escape a string for use in generated JavaScript/TypeScript code.\n * Handles quotes, backslashes, newlines, and carriage returns.\n */\nexport function escapeString(str: string): string {\n  return str\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/'/g, \"\\\\'\")\n    .replace(/\"/g, '\\\\\"')\n    .replace(/\\n/g, '\\\\n')\n    .replace(/\\r/g, '\\\\r');\n}\n\n/**\n * Escape a selector string for use in Playwright locators.\n * Handles quotes that would break the selector syntax.\n */\nexport function escapeSelector(str: string): string {\n  return str.replace(/'/g, \"\\\\'\");\n}\n","/**\n * Journey Normalizer - Convert parsed Journey to IR\n * @see research/2026-01-02_autogen-refined-plan.md Section 9\n */\nimport type { ParsedJourney, AcceptanceCriterion, ProceduralStep } from './parseJourney.js';\nimport type {\n  IRJourney,\n  IRStep,\n  IRPrimitive,\n  IRMappingResult,\n  ModuleDependencies,\n  CompletionSignal,\n  JourneyDataConfig,\n  LocatorSpec,\n} from '../ir/types.js';\nimport { mapStepText } from '../mapping/stepMapper.js';\nimport { escapeRegex } from '../utils/escaping.js';\n\n/**\n * Options for normalizing a Journey\n */\nexport interface NormalizeOptions {\n  /** Include blocked steps in output */\n  includeBlocked?: boolean;\n  /** Strict mode - fail on any blocked step */\n  strict?: boolean;\n  /** Default timeout for assertions (ms) */\n  defaultTimeout?: number;\n}\n\n/**\n * Normalize a parsed Journey into IR format\n */\nexport function normalizeJourney(\n  parsed: ParsedJourney,\n  options: NormalizeOptions = {}\n): IRMappingResult {\n  const { includeBlocked = true, strict = false } = options;\n\n  const blockedSteps: IRMappingResult['blockedSteps'] = [];\n  const warnings: string[] = [];\n\n  // Map acceptance criteria to IR steps\n  const steps: IRStep[] = [];\n\n  for (const ac of parsed.acceptanceCriteria) {\n    const step = mapAcceptanceCriterionToStep(ac, parsed.proceduralSteps, warnings);\n\n    // Check for blocked primitives\n    const blockedPrimitives = [\n      ...step.actions.filter((a) => a.type === 'blocked'),\n      ...step.assertions.filter((a) => a.type === 'blocked'),\n    ] as Array<{ type: 'blocked'; reason: string; sourceText: string }>;\n\n    if (blockedPrimitives.length > 0) {\n      for (const blocked of blockedPrimitives) {\n        blockedSteps.push({\n          stepId: step.id,\n          sourceText: blocked.sourceText,\n          reason: blocked.reason,\n        });\n      }\n\n      if (strict) {\n        continue; // Skip blocked steps in strict mode\n      }\n    }\n\n    if (includeBlocked || blockedPrimitives.length === 0) {\n      steps.push(step);\n    }\n  }\n\n  // If no AC-based steps, create steps from procedural steps\n  if (steps.length === 0 && parsed.proceduralSteps.length > 0) {\n    for (const ps of parsed.proceduralSteps) {\n      const step = mapProceduralStepToIRStep(ps, warnings);\n      steps.push(step);\n    }\n  }\n\n  // Build module dependencies\n  const moduleDependencies: ModuleDependencies = {\n    foundation: parsed.frontmatter.modules?.foundation ?? [],\n    feature: parsed.frontmatter.modules?.features ?? [],\n  };\n\n  // Map completion signals\n  const completion: CompletionSignal[] | undefined = parsed.frontmatter.completion?.map((c) => ({\n    type: c.type,\n    value: c.value,\n    options: c.options,\n  }));\n\n  // Map data config\n  const data: JourneyDataConfig | undefined = parsed.frontmatter.data\n    ? {\n        strategy: parsed.frontmatter.data.strategy,\n        cleanup: parsed.frontmatter.data.cleanup,\n      }\n    : undefined;\n\n  // Build the IR Journey\n  const journey: IRJourney = {\n    id: parsed.frontmatter.id,\n    title: parsed.frontmatter.title,\n    tier: parsed.frontmatter.tier,\n    scope: parsed.frontmatter.scope,\n    actor: parsed.frontmatter.actor,\n    tags: buildTags(parsed),\n    moduleDependencies,\n    data,\n    completion,\n    steps,\n    revision: parsed.frontmatter.revision,\n    prerequisites: parsed.frontmatter.prerequisites,\n    negativePaths: parsed.frontmatter.negativePaths,\n    sourcePath: parsed.sourcePath,\n    // P3 Feature fields - pass through from frontmatter\n    testData: parsed.frontmatter.testData,\n    visualRegression: parsed.frontmatter.visualRegression,\n    accessibility: parsed.frontmatter.accessibility,\n    performance: parsed.frontmatter.performance,\n  };\n\n  // Calculate stats\n  const stats = {\n    totalSteps: parsed.acceptanceCriteria.length || parsed.proceduralSteps.length,\n    mappedSteps: steps.length,\n    blockedSteps: blockedSteps.length,\n    totalActions: steps.reduce((sum, s) => sum + s.actions.length, 0),\n    totalAssertions: steps.reduce((sum, s) => sum + s.assertions.length, 0),\n  };\n\n  return {\n    journey,\n    blockedSteps,\n    warnings,\n    stats,\n  };\n}\n\n/**\n * Map an acceptance criterion to an IR step\n */\nfunction mapAcceptanceCriterionToStep(\n  ac: AcceptanceCriterion,\n  proceduralSteps: ProceduralStep[],\n  warnings: string[]\n): IRStep {\n  const actions: IRPrimitive[] = [];\n  const assertions: IRPrimitive[] = [];\n  const notes: string[] = [];\n\n  // Find related procedural steps\n  const relatedProcedural = proceduralSteps.filter((ps) => ps.linkedAC === ac.id);\n\n  // Process bullet points as potential actions/assertions\n  for (const stepText of ac.steps) {\n    const result = mapStepText(stepText, { normalizeText: false });\n\n    if (result.primitive) {\n      if (isAssertion(result.primitive)) {\n        assertions.push(result.primitive);\n      } else {\n        actions.push(result.primitive);\n      }\n    } else {\n      // Cannot parse - add as blocked\n      actions.push({\n        type: 'blocked',\n        reason: result.message || 'Could not parse step into primitive',\n        sourceText: stepText,\n      });\n      if (result.message) {\n        warnings.push(result.message);\n      }\n    }\n  }\n\n  // Add related procedural steps as actions\n  for (const ps of relatedProcedural) {\n    const result = mapStepText(ps.text, { normalizeText: false });\n    if (result.primitive) {\n      if (isAssertion(result.primitive)) {\n        assertions.push(result.primitive);\n      } else {\n        actions.push(result.primitive);\n      }\n    } else if (result.message) {\n      warnings.push(result.message);\n    }\n  }\n\n  // If no assertions from steps, add a visibility check for the AC title\n  if (assertions.length === 0 && ac.title) {\n    notes.push(`TODO: Add assertion for: ${ac.title}`);\n  }\n\n  return {\n    id: ac.id,\n    description: ac.title || `Step ${ac.id}`,\n    actions,\n    assertions,\n    sourceText: ac.rawContent,\n    notes: notes.length > 0 ? notes : undefined,\n  };\n}\n\n/**\n * Map a procedural step to an IR step\n */\nfunction mapProceduralStepToIRStep(ps: ProceduralStep, warnings: string[]): IRStep {\n  const actions: IRPrimitive[] = [];\n  const assertions: IRPrimitive[] = [];\n\n  const result = mapStepText(ps.text, { normalizeText: false });\n  if (result.primitive) {\n    if (isAssertion(result.primitive)) {\n      assertions.push(result.primitive);\n    } else {\n      actions.push(result.primitive);\n    }\n  } else {\n    actions.push({\n      type: 'blocked',\n      reason: result.message || 'Could not parse procedural step',\n      sourceText: ps.text,\n    });\n    if (result.message) {\n      warnings.push(result.message);\n    }\n  }\n\n  return {\n    id: `PS-${ps.number}`,\n    description: ps.text,\n    actions,\n    assertions,\n  };\n}\n\n/**\n * Check if a primitive is an assertion\n */\nfunction isAssertion(primitive: IRPrimitive): boolean {\n  return primitive.type.startsWith('expect');\n}\n\n/**\n * Build tags for the journey\n */\nfunction buildTags(parsed: ParsedJourney): string[] {\n  const tags = new Set<string>();\n\n  // Standard tags\n  tags.add('@artk');\n  tags.add('@journey');\n  tags.add(`@${parsed.frontmatter.id}`);\n  tags.add(`@tier-${parsed.frontmatter.tier}`);\n  tags.add(`@scope-${parsed.frontmatter.scope}`);\n  tags.add(`@actor-${parsed.frontmatter.actor}`);\n\n  // User-defined tags\n  if (parsed.frontmatter.tags) {\n    for (const tag of parsed.frontmatter.tags) {\n      tags.add(tag.startsWith('@') ? tag : `@${tag}`);\n    }\n  }\n\n  return Array.from(tags);\n}\n\n/**\n * Convert completion signals to IR primitives (final assertions)\n */\nexport function completionSignalsToAssertions(\n  signals: CompletionSignal[]\n): IRPrimitive[] {\n  return signals.map(signal => {\n    switch (signal.type) {\n      case 'url':\n        return {\n          type: 'expectURL',\n          pattern: signal.options?.exact\n            ? signal.value\n            : new RegExp(escapeRegex(signal.value)),\n        } as IRPrimitive;\n\n      case 'toast': {\n        // Parse toast type from value if it contains \"success\", \"error\", \"info\", or \"warning\"\n        const lowerValue = signal.value.toLowerCase();\n        let toastType: 'success' | 'error' | 'info' | 'warning' = 'success';\n        if (lowerValue.includes('error')) {\n          toastType = 'error';\n        } else if (lowerValue.includes('warning')) {\n          toastType = 'warning';\n        } else if (lowerValue.includes('info')) {\n          toastType = 'info';\n        }\n\n        return {\n          type: 'expectToast',\n          toastType,\n          message: signal.value,\n        } as IRPrimitive;\n      }\n\n      case 'element': {\n        const state = signal.options?.state || 'visible';\n        return {\n          type: state === 'hidden' || state === 'detached'\n            ? 'expectNotVisible'\n            : 'expectVisible',\n          locator: parseLocatorFromSelector(signal.value),\n          timeout: signal.options?.timeout,\n        } as IRPrimitive;\n      }\n\n      case 'text':\n        return {\n          type: 'expectVisible',\n          locator: { strategy: 'text', value: signal.value },\n          timeout: signal.options?.timeout,\n        } as IRPrimitive;\n\n      case 'title':\n        return {\n          type: 'expectTitle',\n          title: signal.options?.exact\n            ? signal.value\n            : new RegExp(escapeRegex(signal.value)),\n        } as IRPrimitive;\n\n      case 'api':\n        return {\n          type: 'waitForResponse',\n          urlPattern: signal.value,\n        } as IRPrimitive;\n\n      default:\n        throw new Error(`Unknown completion signal type: ${(signal as CompletionSignal).type}`);\n    }\n  });\n}\n\n/**\n * Parse a selector string to LocatorSpec\n */\nfunction parseLocatorFromSelector(selector: string): LocatorSpec {\n  // data-testid\n  if (selector.includes('data-testid')) {\n    const match = selector.match(/\\[data-testid=['\"]([^'\"]+)['\"]\\]/);\n    if (match) {\n      return { strategy: 'testid', value: match[1]! };\n    }\n  }\n\n  // Role selector\n  if (selector.startsWith('role=')) {\n    return { strategy: 'role', value: selector.slice(5) };\n  }\n\n  // Text selector\n  if (selector.startsWith('text=')) {\n    return { strategy: 'text', value: selector.slice(5) };\n  }\n\n  // Label selector\n  if (selector.startsWith('label=')) {\n    return { strategy: 'label', value: selector.slice(6) };\n  }\n\n  // Placeholder selector\n  if (selector.startsWith('placeholder=')) {\n    return { strategy: 'placeholder', value: selector.slice(12) };\n  }\n\n  // Default to CSS\n  return { strategy: 'css', value: selector };\n}\n\n/**\n * Validate that a Journey is ready for code generation\n */\nexport function validateJourneyForCodeGen(result: IRMappingResult): {\n  valid: boolean;\n  errors: string[];\n} {\n  const errors: string[] = [];\n\n  // Must have at least one step\n  if (result.journey.steps.length === 0) {\n    errors.push('Journey has no steps');\n  }\n\n  // Must have completion signals\n  if (!result.journey.completion || result.journey.completion.length === 0) {\n    errors.push('Journey has no completion signals');\n  }\n\n  // Should not have too many blocked steps\n  if (result.stats.blockedSteps > result.stats.mappedSteps) {\n    errors.push(`Too many blocked steps: ${result.stats.blockedSteps} blocked vs ${result.stats.mappedSteps} mapped`);\n  }\n\n  // Must have at least one assertion\n  if (result.stats.totalAssertions === 0) {\n    errors.push('Journey has no assertions');\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n","/**\n * Selector Priority - Playwright best practices for selector selection\n * @see research/2026-01-02_autogen-refined-plan.md Section 11\n *\n * Priority order (per Playwright docs):\n * 1. role - ARIA roles (most stable, semantic)\n * 2. label - Form labels (accessible)\n * 3. placeholder - Input placeholders\n * 4. text - Visible text content\n * 5. testid - data-testid attributes\n * 6. css - CSS selectors (last resort)\n */\nimport type { LocatorSpec, LocatorStrategy } from '../ir/types.js';\nimport type { AutogenConfig } from '../config/schema.js';\n\n/**\n * Default selector priority\n */\nexport const DEFAULT_SELECTOR_PRIORITY: LocatorStrategy[] = [\n  'role',\n  'label',\n  'placeholder',\n  'text',\n  'testid',\n  'css',\n];\n\n/**\n * Map from element type to preferred selector strategies\n */\nexport const ELEMENT_TYPE_STRATEGIES: Record<string, LocatorStrategy[]> = {\n  button: ['role', 'text', 'testid'],\n  link: ['role', 'text', 'testid'],\n  textbox: ['role', 'label', 'placeholder', 'testid'],\n  checkbox: ['role', 'label', 'testid'],\n  radio: ['role', 'label', 'testid'],\n  combobox: ['role', 'label', 'testid'],\n  heading: ['role', 'text', 'testid'],\n  listitem: ['role', 'text', 'testid'],\n  menuitem: ['role', 'text', 'testid'],\n  tab: ['role', 'text', 'testid'],\n  dialog: ['role', 'testid'],\n  alert: ['role', 'testid'],\n  generic: ['text', 'testid', 'css'],\n};\n\n/**\n * ARIA roles that can have accessible names\n */\nexport const NAMEABLE_ROLES = [\n  'button',\n  'link',\n  'textbox',\n  'checkbox',\n  'radio',\n  'combobox',\n  'heading',\n  'tab',\n  'menuitem',\n  'listitem',\n  'option',\n  'cell',\n  'row',\n  'columnheader',\n  'rowheader',\n];\n\n/**\n * Get selector priority from config or use defaults\n */\nexport function getSelectorPriority(config?: AutogenConfig): LocatorStrategy[] {\n  if (config?.selectorPolicy?.priority) {\n    // Map config selector strategies to LocatorStrategy\n    return config.selectorPolicy.priority.map((s) => {\n      // Handle strategy name mapping if needed\n      return s as LocatorStrategy;\n    });\n  }\n  return DEFAULT_SELECTOR_PRIORITY;\n}\n\n/**\n * Check if a selector strategy is forbidden by config\n */\nexport function isForbiddenSelector(\n  locator: LocatorSpec,\n  config?: AutogenConfig\n): boolean {\n  const forbiddenPatterns = config?.selectorPolicy?.forbiddenPatterns ?? [];\n\n  for (const pattern of forbiddenPatterns) {\n    const regex = new RegExp(pattern);\n    if (regex.test(locator.value)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Score a locator based on priority (lower is better)\n */\nexport function scoreLocator(\n  locator: LocatorSpec,\n  priority: LocatorStrategy[] = DEFAULT_SELECTOR_PRIORITY\n): number {\n  const index = priority.indexOf(locator.strategy);\n  return index >= 0 ? index : priority.length;\n}\n\n/**\n * Compare two locators and return the better one\n */\nexport function compareLocators(\n  a: LocatorSpec,\n  b: LocatorSpec,\n  priority: LocatorStrategy[] = DEFAULT_SELECTOR_PRIORITY\n): LocatorSpec {\n  const scoreA = scoreLocator(a, priority);\n  const scoreB = scoreLocator(b, priority);\n  return scoreA <= scoreB ? a : b;\n}\n\n/**\n * Select the best locator from alternatives\n */\nexport function selectBestLocator(\n  alternatives: LocatorSpec[],\n  config?: AutogenConfig\n): LocatorSpec | null {\n  if (alternatives.length === 0) {\n    return null;\n  }\n\n  const priority = getSelectorPriority(config);\n\n  // Filter out forbidden selectors\n  const allowed = alternatives.filter((loc) => !isForbiddenSelector(loc, config));\n\n  if (allowed.length === 0) {\n    // All forbidden, return first original\n    return alternatives[0] ?? null;\n  }\n\n  // Sort by priority\n  allowed.sort((a, b) => scoreLocator(a, priority) - scoreLocator(b, priority));\n\n  return allowed[0] ?? null;\n}\n\n/**\n * Check if a locator is a role locator\n */\nexport function isRoleLocator(locator: LocatorSpec): boolean {\n  return locator.strategy === 'role';\n}\n\n/**\n * Check if a locator uses semantic selectors (role, label, text)\n */\nexport function isSemanticLocator(locator: LocatorSpec): boolean {\n  return ['role', 'label', 'text', 'placeholder'].includes(locator.strategy);\n}\n\n/**\n * Check if a locator is a test ID locator\n */\nexport function isTestIdLocator(locator: LocatorSpec): boolean {\n  return locator.strategy === 'testid';\n}\n\n/**\n * Check if a locator is a CSS locator (last resort)\n */\nexport function isCssLocator(locator: LocatorSpec): boolean {\n  return locator.strategy === 'css';\n}\n\n/**\n * Get recommended strategies for an element type\n */\nexport function getRecommendedStrategies(elementType: string): LocatorStrategy[] {\n  return ELEMENT_TYPE_STRATEGIES[elementType] ?? ELEMENT_TYPE_STRATEGIES.generic!;\n}\n\n/**\n * Validate a locator against best practices\n */\nexport function validateLocator(\n  locator: LocatorSpec,\n  config?: AutogenConfig\n): { valid: boolean; warnings: string[] } {\n  const warnings: string[] = [];\n\n  // Check if forbidden\n  if (isForbiddenSelector(locator, config)) {\n    warnings.push(`Selector matches forbidden pattern: ${locator.value}`);\n  }\n\n  // Warn about CSS selectors\n  if (isCssLocator(locator)) {\n    warnings.push(\n      `CSS selector \"${locator.value}\" is fragile. Consider using role, label, or testid.`\n    );\n  }\n\n  // Warn about XPath-like patterns in CSS\n  if (locator.value.includes('//') || locator.value.includes('..')) {\n    warnings.push(`Selector \"${locator.value}\" appears to use XPath syntax in CSS.`);\n  }\n\n  // Warn about nth-child selectors\n  if (locator.value.includes('nth-child') || locator.value.includes('nth-of-type')) {\n    warnings.push(`Selector \"${locator.value}\" uses nth-child which is position-dependent.`);\n  }\n\n  // Warn about ID selectors that might be dynamic\n  if (locator.strategy === 'css' && /^#[a-z]+-\\d+$/i.test(locator.value)) {\n    warnings.push(`Selector \"${locator.value}\" appears to have a dynamic ID.`);\n  }\n\n  return {\n    valid: warnings.length === 0,\n    warnings,\n  };\n}\n\n/**\n * Generate Playwright locator code from LocatorSpec\n */\nexport function toPlaywrightLocator(locator: LocatorSpec): string {\n  switch (locator.strategy) {\n    case 'role': {\n      const opts: string[] = [];\n      if (locator.options?.name) {\n        opts.push(`name: '${escapeString(locator.options.name)}'`);\n      }\n      if (locator.options?.exact) {\n        opts.push('exact: true');\n      }\n      if (locator.options?.level) {\n        opts.push(`level: ${locator.options.level}`);\n      }\n      const optsStr = opts.length > 0 ? `, { ${opts.join(', ')} }` : '';\n      return `getByRole('${locator.value}'${optsStr})`;\n    }\n    case 'label': {\n      const exact = locator.options?.exact ? ', { exact: true }' : '';\n      return `getByLabel('${escapeString(locator.value)}'${exact})`;\n    }\n    case 'placeholder': {\n      const exact = locator.options?.exact ? ', { exact: true }' : '';\n      return `getByPlaceholder('${escapeString(locator.value)}'${exact})`;\n    }\n    case 'text': {\n      const exact = locator.options?.exact ? ', { exact: true }' : '';\n      return `getByText('${escapeString(locator.value)}'${exact})`;\n    }\n    case 'testid':\n      return `getByTestId('${escapeString(locator.value)}')`;\n    case 'css':\n      return `locator('${escapeString(locator.value)}')`;\n    default:\n      return `locator('${escapeString(locator.value)}')`;\n  }\n}\n\n/**\n * Escape string for use in generated code\n */\nfunction escapeString(str: string): string {\n  return str.replace(/'/g, \"\\\\'\").replace(/\\n/g, '\\\\n');\n}\n","/**\n * Selector Catalog Schema - Define structure for repo-local selector catalog\n * @see T088 - Define selector catalog JSON schema\n */\nimport { z } from 'zod';\n\n/**\n * Selector entry in the catalog\n */\nexport const SelectorEntrySchema = z.object({\n  /** Unique identifier for this selector */\n  id: z.string(),\n  /** Human-readable description */\n  description: z.string().optional(),\n  /** The selector strategy */\n  strategy: z.enum(['testid', 'role', 'label', 'text', 'css', 'xpath']),\n  /** The selector value */\n  value: z.string(),\n  /** Additional options for the locator */\n  options: z\n    .object({\n      name: z.string().optional(),\n      exact: z.boolean().optional(),\n      level: z.number().optional(),\n    })\n    .optional(),\n  /** Component or page this selector belongs to */\n  component: z.string().optional(),\n  /** File where this selector was discovered */\n  sourceFile: z.string().optional(),\n  /** Line number in source file */\n  sourceLine: z.number().optional(),\n  /** Tags for categorization */\n  tags: z.array(z.string()).optional(),\n  /** Whether this is a stable selector (not likely to change) */\n  stable: z.boolean().default(true),\n  /** Last verified timestamp */\n  lastVerified: z.string().optional(),\n});\n\n/**\n * Component entry in the catalog\n */\nexport const ComponentEntrySchema = z.object({\n  /** Component name */\n  name: z.string(),\n  /** Component file path */\n  path: z.string().optional(),\n  /** Selectors within this component */\n  selectors: z.array(z.string()), // References to selector IDs\n  /** Child components */\n  children: z.array(z.string()).optional(),\n});\n\n/**\n * Page entry in the catalog\n */\nexport const PageEntrySchema = z.object({\n  /** Page name */\n  name: z.string(),\n  /** Route pattern */\n  route: z.string().optional(),\n  /** Page file path */\n  path: z.string().optional(),\n  /** Components on this page */\n  components: z.array(z.string()).optional(),\n  /** Direct selectors on this page */\n  selectors: z.array(z.string()).optional(),\n});\n\n/**\n * CSS debt entry - tracks CSS selectors that should be migrated\n */\nexport const CSSDebtEntrySchema = z.object({\n  /** The CSS selector being used */\n  selector: z.string(),\n  /** Files using this selector */\n  usages: z.array(\n    z.object({\n      file: z.string(),\n      line: z.number(),\n    })\n  ),\n  /** Suggested replacement */\n  suggestedReplacement: z\n    .object({\n      strategy: z.string(),\n      value: z.string(),\n    })\n    .optional(),\n  /** Priority for migration (higher = more urgent) */\n  priority: z.enum(['low', 'medium', 'high']).default('medium'),\n  /** Reason this is considered debt */\n  reason: z.string().optional(),\n});\n\n/**\n * Complete selector catalog schema\n */\nexport const SelectorCatalogSchema = z.object({\n  /** Schema version */\n  version: z.string().default('1.0.0'),\n  /** Generation timestamp */\n  generatedAt: z.string(),\n  /** Source directory that was scanned */\n  sourceDir: z.string().optional(),\n  /** All selectors indexed by ID */\n  selectors: z.record(SelectorEntrySchema),\n  /** Components indexed by name */\n  components: z.record(ComponentEntrySchema).default({}),\n  /** Pages indexed by name */\n  pages: z.record(PageEntrySchema).default({}),\n  /** TestIDs found in the codebase */\n  testIds: z.array(z.string()).default([]),\n  /** CSS debt entries */\n  cssDebt: z.array(CSSDebtEntrySchema).default([]),\n  /** Statistics */\n  stats: z\n    .object({\n      totalSelectors: z.number(),\n      byStrategy: z.record(z.number()),\n      stableCount: z.number(),\n      unstableCount: z.number(),\n      cssDebtCount: z.number(),\n    })\n    .optional(),\n});\n\nexport type SelectorEntry = z.infer<typeof SelectorEntrySchema>;\nexport type ComponentEntry = z.infer<typeof ComponentEntrySchema>;\nexport type PageEntry = z.infer<typeof PageEntrySchema>;\nexport type CSSDebtEntry = z.infer<typeof CSSDebtEntrySchema>;\nexport type SelectorCatalog = z.infer<typeof SelectorCatalogSchema>;\n\n/**\n * Create an empty catalog\n */\nexport function createEmptyCatalog(): SelectorCatalog {\n  return {\n    version: '1.0.0',\n    generatedAt: new Date().toISOString(),\n    selectors: {},\n    components: {},\n    pages: {},\n    testIds: [],\n    cssDebt: [],\n  };\n}\n\n/**\n * Validate a catalog object\n */\nexport function validateCatalog(catalog: unknown): {\n  valid: boolean;\n  errors: string[];\n  catalog?: SelectorCatalog;\n} {\n  const result = SelectorCatalogSchema.safeParse(catalog);\n\n  if (result.success) {\n    return { valid: true, errors: [], catalog: result.data };\n  }\n\n  return {\n    valid: false,\n    errors: result.error.errors.map((e) => `${e.path.join('.')}: ${e.message}`),\n  };\n}\n","/**\n * Selector Catalog Loader - Load and query the selector catalog\n * @see T089 - Implement catalog loader\n */\nimport { readFileSync, existsSync, writeFileSync } from 'node:fs';\nimport { resolve, dirname } from 'node:path';\nimport { mkdirSync } from 'node:fs';\nimport {\n  type SelectorCatalog,\n  type SelectorEntry,\n  createEmptyCatalog,\n  validateCatalog,\n} from './catalogSchema.js';\n\n/**\n * Default catalog file path\n */\nconst DEFAULT_CATALOG_PATH = 'config/selector-catalog.json';\n\n/**\n * Catalog cache\n */\nlet catalogCache: SelectorCatalog | null = null;\nlet catalogPath: string | null = null;\n\n/**\n * Load selector catalog from file\n * @param path - Path to catalog JSON file\n */\nexport function loadCatalog(path?: string): SelectorCatalog {\n  const resolvedPath = resolve(path ?? DEFAULT_CATALOG_PATH);\n\n  if (!existsSync(resolvedPath)) {\n    console.warn(`Selector catalog not found at ${resolvedPath}, using empty catalog`);\n    return createEmptyCatalog();\n  }\n\n  try {\n    const content = readFileSync(resolvedPath, 'utf-8');\n    const parsed = JSON.parse(content);\n    const result = validateCatalog(parsed);\n\n    if (!result.valid) {\n      console.warn(`Invalid selector catalog at ${resolvedPath}: ${result.errors.join(', ')}`);\n      return createEmptyCatalog();\n    }\n\n    catalogCache = result.catalog!;\n    catalogPath = resolvedPath;\n    return catalogCache;\n  } catch (_err) {\n    console.warn(`Failed to load selector catalog from ${resolvedPath}`);\n    return createEmptyCatalog();\n  }\n}\n\n/**\n * Save catalog to file\n * @param catalog - Catalog to save\n * @param path - Path to save to\n */\nexport function saveCatalog(catalog: SelectorCatalog, path?: string): void {\n  const resolvedPath = resolve(path ?? catalogPath ?? DEFAULT_CATALOG_PATH);\n\n  // Ensure directory exists\n  const dir = dirname(resolvedPath);\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n\n  // Update generation timestamp\n  catalog.generatedAt = new Date().toISOString();\n\n  // Calculate stats\n  catalog.stats = calculateStats(catalog);\n\n  writeFileSync(resolvedPath, JSON.stringify(catalog, null, 2));\n  catalogCache = catalog;\n  catalogPath = resolvedPath;\n}\n\n/**\n * Calculate catalog statistics\n */\nfunction calculateStats(\n  catalog: SelectorCatalog\n): SelectorCatalog['stats'] {\n  const selectors = Object.values(catalog.selectors);\n  const byStrategy: Record<string, number> = {};\n\n  let stableCount = 0;\n  let unstableCount = 0;\n\n  for (const selector of selectors) {\n    byStrategy[selector.strategy] = (byStrategy[selector.strategy] ?? 0) + 1;\n    if (selector.stable) {\n      stableCount++;\n    } else {\n      unstableCount++;\n    }\n  }\n\n  return {\n    totalSelectors: selectors.length,\n    byStrategy,\n    stableCount,\n    unstableCount,\n    cssDebtCount: catalog.cssDebt?.length ?? 0,\n  };\n}\n\n/**\n * Get the current catalog (loads if not cached)\n */\nexport function getCatalog(): SelectorCatalog {\n  if (!catalogCache) {\n    catalogCache = loadCatalog();\n  }\n  return catalogCache;\n}\n\n/**\n * Reset catalog cache (for testing)\n */\nexport function resetCatalogCache(): void {\n  catalogCache = null;\n  catalogPath = null;\n}\n\n/**\n * Find a selector by ID\n */\nexport function findSelectorById(id: string): SelectorEntry | null {\n  const catalog = getCatalog();\n  return catalog.selectors[id] ?? null;\n}\n\n/**\n * Find selectors by testid\n */\nexport function findByTestId(testId: string): SelectorEntry | null {\n  const catalog = getCatalog();\n\n  for (const selector of Object.values(catalog.selectors)) {\n    if (selector.strategy === 'testid' && selector.value === testId) {\n      return selector;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Find selectors by component name\n */\nexport function findByComponent(componentName: string): SelectorEntry[] {\n  const catalog = getCatalog();\n  const component = catalog.components[componentName];\n\n  if (!component) {\n    return [];\n  }\n\n  return component.selectors\n    .map((id) => catalog.selectors[id])\n    .filter((s): s is SelectorEntry => s !== undefined);\n}\n\n/**\n * Find selectors by page name\n */\nexport function findByPage(pageName: string): SelectorEntry[] {\n  const catalog = getCatalog();\n  const page = catalog.pages[pageName];\n\n  if (!page) {\n    return [];\n  }\n\n  const selectorIds = new Set<string>();\n\n  // Add direct page selectors\n  for (const id of page.selectors ?? []) {\n    selectorIds.add(id);\n  }\n\n  // Add component selectors\n  for (const componentName of page.components ?? []) {\n    const component = catalog.components[componentName];\n    if (component) {\n      for (const id of component.selectors) {\n        selectorIds.add(id);\n      }\n    }\n  }\n\n  return Array.from(selectorIds)\n    .map((id) => catalog.selectors[id])\n    .filter((s): s is SelectorEntry => s !== undefined);\n}\n\n/**\n * Search selectors by text (searches description, value, tags)\n */\nexport function searchSelectors(query: string): SelectorEntry[] {\n  const catalog = getCatalog();\n  const lowerQuery = query.toLowerCase();\n\n  return Object.values(catalog.selectors).filter((selector) => {\n    if (selector.value.toLowerCase().includes(lowerQuery)) return true;\n    if (selector.description?.toLowerCase().includes(lowerQuery)) return true;\n    if (selector.component?.toLowerCase().includes(lowerQuery)) return true;\n    if (selector.tags?.some((t) => t.toLowerCase().includes(lowerQuery))) return true;\n    return false;\n  });\n}\n\n/**\n * Get all testids in the catalog\n */\nexport function getAllTestIds(): string[] {\n  const catalog = getCatalog();\n  return catalog.testIds;\n}\n\n/**\n * Check if a testid exists in the catalog\n */\nexport function hasTestId(testId: string): boolean {\n  const catalog = getCatalog();\n  return catalog.testIds.includes(testId);\n}\n\n/**\n * Add a selector to the catalog\n */\nexport function addSelector(selector: SelectorEntry): void {\n  const catalog = getCatalog();\n  catalog.selectors[selector.id] = selector;\n\n  // Track testids\n  if (selector.strategy === 'testid' && !catalog.testIds.includes(selector.value)) {\n    catalog.testIds.push(selector.value);\n  }\n}\n\n/**\n * Remove a selector from the catalog\n */\nexport function removeSelector(id: string): boolean {\n  const catalog = getCatalog();\n  if (catalog.selectors[id]) {\n    delete catalog.selectors[id];\n    return true;\n  }\n  return false;\n}\n\n/**\n * Get selectors that need migration (CSS debt)\n */\nexport function getCSSDebt(): SelectorCatalog['cssDebt'] {\n  return getCatalog().cssDebt ?? [];\n}\n\n/**\n * Get stable selectors for a given element description\n * Useful for test generation to find the best available selector\n */\nexport function suggestSelector(description: string): SelectorEntry | null {\n  const results = searchSelectors(description);\n\n  if (results.length === 0) {\n    return null;\n  }\n\n  // Prefer stable selectors, then by strategy priority\n  const strategyPriority: Record<string, number> = {\n    testid: 1,\n    role: 2,\n    label: 3,\n    text: 4,\n    css: 5,\n    xpath: 6,\n  };\n\n  return results.sort((a, b) => {\n    // Stable first\n    if (a.stable && !b.stable) return -1;\n    if (!a.stable && b.stable) return 1;\n\n    // Then by strategy priority\n    return (strategyPriority[a.strategy] ?? 99) - (strategyPriority[b.strategy] ?? 99);\n  })[0] ?? null;\n}\n","/**\n * Selector Inference - Infer selectors from step text\n * @see research/2026-01-02_autogen-refined-plan.md Section 11\n * @see T092 - Integrate catalog querying into selector inference\n */\nimport type { LocatorSpec, LocatorStrategy } from '../ir/types.js';\nimport {\n  NAMEABLE_ROLES,\n  selectBestLocator,\n} from './priority.js';\nimport { suggestSelector, hasTestId } from './catalog.js';\n\n/**\n * Common element type keywords\n */\nconst ELEMENT_KEYWORDS: Record<string, string> = {\n  button: 'button',\n  btn: 'button',\n  submit: 'button',\n  link: 'link',\n  anchor: 'link',\n  input: 'textbox',\n  textbox: 'textbox',\n  field: 'textbox',\n  textarea: 'textbox',\n  checkbox: 'checkbox',\n  check: 'checkbox',\n  radio: 'radio',\n  dropdown: 'combobox',\n  select: 'combobox',\n  combo: 'combobox',\n  heading: 'heading',\n  title: 'heading',\n  header: 'heading',\n  menu: 'menu',\n  menuitem: 'menuitem',\n  tab: 'tab',\n  dialog: 'dialog',\n  modal: 'dialog',\n  alert: 'alert',\n  list: 'list',\n  listitem: 'listitem',\n  table: 'table',\n  row: 'row',\n  cell: 'cell',\n};\n\n/**\n * Infer the element type from text\n */\nexport function inferElementType(text: string): string | null {\n  const lowerText = text.toLowerCase();\n\n  for (const [keyword, elementType] of Object.entries(ELEMENT_KEYWORDS)) {\n    if (lowerText.includes(keyword)) {\n      return elementType;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Infer the ARIA role from element type\n */\nexport function inferRole(elementType: string): string | null {\n  // Most element types map directly to roles\n  const roleMap: Record<string, string> = {\n    button: 'button',\n    link: 'link',\n    textbox: 'textbox',\n    checkbox: 'checkbox',\n    radio: 'radio',\n    combobox: 'combobox',\n    heading: 'heading',\n    menu: 'menu',\n    menuitem: 'menuitem',\n    tab: 'tab',\n    dialog: 'dialog',\n    alert: 'alert',\n    list: 'list',\n    listitem: 'listitem',\n    table: 'table',\n    row: 'row',\n    cell: 'cell',\n  };\n\n  return roleMap[elementType] ?? null;\n}\n\n/**\n * Extract a name/label from text\n */\nexport function extractName(text: string): string | null {\n  // Look for quoted strings\n  const quotedMatch = text.match(/['\"]([^'\"]+)['\"]/);\n  if (quotedMatch) {\n    return quotedMatch[1] ?? null;\n  }\n\n  // Look for \"the X button\" pattern\n  const theMatch = text.match(/(?:the\\s+)?['\"]?([^'\"]+?)['\"]?\\s+(?:button|link|field|input|checkbox|dropdown)/i);\n  if (theMatch) {\n    return theMatch[1]!.trim();\n  }\n\n  return null;\n}\n\n/**\n * Infer selector alternatives from step text\n */\nexport function inferSelectors(text: string): LocatorSpec[] {\n  const alternatives: LocatorSpec[] = [];\n  const elementType = inferElementType(text);\n  const name = extractName(text);\n  const role = elementType ? inferRole(elementType) : null;\n\n  // Try role-based selector if we have a role\n  if (role && NAMEABLE_ROLES.includes(role)) {\n    if (name) {\n      alternatives.push({\n        strategy: 'role',\n        value: role,\n        options: { name },\n      });\n    } else {\n      alternatives.push({\n        strategy: 'role',\n        value: role,\n      });\n    }\n  }\n\n  // Try label selector for form elements\n  if (name && ['textbox', 'checkbox', 'radio', 'combobox'].includes(elementType || '')) {\n    alternatives.push({\n      strategy: 'label',\n      value: name,\n    });\n  }\n\n  // Try text selector\n  if (name) {\n    alternatives.push({\n      strategy: 'text',\n      value: name,\n    });\n  }\n\n  return alternatives;\n}\n\n/**\n * Infer the best selector from step text\n */\nexport function inferBestSelector(text: string): LocatorSpec | null {\n  const alternatives = inferSelectors(text);\n  return selectBestLocator(alternatives);\n}\n\n/**\n * Infer selector for a button element\n */\nexport function inferButtonSelector(name: string): LocatorSpec {\n  return {\n    strategy: 'role',\n    value: 'button',\n    options: { name },\n  };\n}\n\n/**\n * Infer selector for a link element\n */\nexport function inferLinkSelector(name: string): LocatorSpec {\n  return {\n    strategy: 'role',\n    value: 'link',\n    options: { name },\n  };\n}\n\n/**\n * Infer selector for an input field\n */\nexport function inferInputSelector(labelOrPlaceholder: string): LocatorSpec {\n  return {\n    strategy: 'label',\n    value: labelOrPlaceholder,\n  };\n}\n\n/**\n * Infer selector for a checkbox\n */\nexport function inferCheckboxSelector(label: string): LocatorSpec {\n  return {\n    strategy: 'role',\n    value: 'checkbox',\n    options: { name: label },\n  };\n}\n\n/**\n * Infer selector for a heading\n */\nexport function inferHeadingSelector(text: string, level?: number): LocatorSpec {\n  const locator: LocatorSpec = {\n    strategy: 'role',\n    value: 'heading',\n    options: { name: text },\n  };\n  if (level) {\n    locator.options!.level = level;\n  }\n  return locator;\n}\n\n/**\n * Infer selector for a tab\n */\nexport function inferTabSelector(name: string): LocatorSpec {\n  return {\n    strategy: 'role',\n    value: 'tab',\n    options: { name },\n  };\n}\n\n/**\n * Infer selector for generic text content\n */\nexport function inferTextSelector(text: string): LocatorSpec {\n  return {\n    strategy: 'text',\n    value: text,\n  };\n}\n\n/**\n * Infer selector from a test ID\n */\nexport function inferTestIdSelector(testId: string): LocatorSpec {\n  return {\n    strategy: 'testid',\n    value: testId,\n  };\n}\n\n/**\n * Create a CSS selector (last resort)\n */\nexport function createCssSelector(selector: string): LocatorSpec {\n  return {\n    strategy: 'css',\n    value: selector,\n  };\n}\n\n/**\n * Analyze text and suggest the best selector approach\n */\nexport function suggestSelectorApproach(text: string): {\n  elementType: string | null;\n  role: string | null;\n  name: string | null;\n  recommendedStrategy: LocatorStrategy;\n  alternatives: LocatorSpec[];\n} {\n  const elementType = inferElementType(text);\n  const role = elementType ? inferRole(elementType) : null;\n  const name = extractName(text);\n  const alternatives = inferSelectors(text);\n\n  // Determine recommended strategy\n  let recommendedStrategy: LocatorStrategy = 'text';\n\n  if (role && NAMEABLE_ROLES.includes(role)) {\n    recommendedStrategy = 'role';\n  } else if (name && ['textbox', 'checkbox', 'radio', 'combobox'].includes(elementType || '')) {\n    recommendedStrategy = 'label';\n  } else if (name) {\n    recommendedStrategy = 'text';\n  }\n\n  return {\n    elementType,\n    role,\n    name,\n    recommendedStrategy,\n    alternatives,\n  };\n}\n\n/**\n * Infer selector with catalog lookup (T092)\n * First checks the catalog for a known selector, then falls back to inference\n */\nexport function inferSelectorWithCatalog(\n  text: string,\n  options?: { useCatalog?: boolean }\n): LocatorSpec | null {\n  const useCatalog = options?.useCatalog ?? true;\n\n  // Try catalog first if enabled\n  if (useCatalog) {\n    const catalogEntry = suggestSelector(text);\n    if (catalogEntry) {\n      return {\n        strategy: catalogEntry.strategy as LocatorStrategy,\n        value: catalogEntry.value,\n        options: catalogEntry.options,\n      };\n    }\n\n    // Also try extracting a name and checking if it's a known testid\n    const name = extractName(text);\n    if (name) {\n      // Try common testid patterns\n      const possibleTestIds = [\n        name.toLowerCase().replace(/\\s+/g, '-'),\n        name.toLowerCase().replace(/\\s+/g, '_'),\n        name,\n      ];\n\n      for (const testId of possibleTestIds) {\n        if (hasTestId(testId)) {\n          return {\n            strategy: 'testid',\n            value: testId,\n          };\n        }\n      }\n    }\n  }\n\n  // Fall back to inference\n  return inferBestSelector(text);\n}\n\n/**\n * Infer selectors with catalog augmentation (T092)\n * Returns catalog-based selectors first, then inferred alternatives\n */\nexport function inferSelectorsWithCatalog(\n  text: string,\n  options?: { useCatalog?: boolean }\n): LocatorSpec[] {\n  const useCatalog = options?.useCatalog ?? true;\n  const alternatives: LocatorSpec[] = [];\n\n  // Try catalog first if enabled\n  if (useCatalog) {\n    const catalogEntry = suggestSelector(text);\n    if (catalogEntry) {\n      alternatives.push({\n        strategy: catalogEntry.strategy as LocatorStrategy,\n        value: catalogEntry.value,\n        options: catalogEntry.options,\n      });\n    }\n  }\n\n  // Add inferred selectors\n  alternatives.push(...inferSelectors(text));\n\n  // Deduplicate by strategy+value\n  const seen = new Set<string>();\n  return alternatives.filter((loc) => {\n    const key = `${loc.strategy}:${loc.value}`;\n    if (seen.has(key)) return false;\n    seen.add(key);\n    return true;\n  });\n}\n","/**\n * TestID Scanner - Scan source files for data-testid attributes\n * @see T090 - Implement testid scanner\n */\nimport { readFileSync, existsSync } from 'node:fs';\nimport { resolve, relative, basename, extname } from 'node:path';\nimport fg from 'fast-glob';\nimport {\n  type SelectorCatalog,\n  type SelectorEntry,\n  type CSSDebtEntry,\n  createEmptyCatalog,\n} from './catalogSchema.js';\n\n/**\n * Scanner options\n */\nexport interface ScannerOptions {\n  /** Source directory to scan */\n  sourceDir: string;\n  /** Test ID attribute name */\n  testIdAttribute?: string;\n  /** File patterns to include */\n  include?: string[];\n  /** File patterns to exclude */\n  exclude?: string[];\n  /** Whether to track CSS selector debt */\n  trackCSSDebt?: boolean;\n  /** Existing catalog to merge with */\n  existingCatalog?: SelectorCatalog;\n}\n\n/**\n * Scanner result\n */\nexport interface ScannerResult {\n  /** Generated catalog */\n  catalog: SelectorCatalog;\n  /** Files scanned */\n  filesScanned: number;\n  /** TestIDs found */\n  testIdsFound: number;\n  /** CSS debt entries found */\n  cssDebtFound: number;\n  /** Warnings during scanning */\n  warnings: string[];\n}\n\n/**\n * Default file patterns for scanning\n */\nconst DEFAULT_INCLUDE = [\n  '**/*.tsx',\n  '**/*.jsx',\n  '**/*.ts',\n  '**/*.js',\n  '**/*.vue',\n  '**/*.svelte',\n];\n\nconst DEFAULT_EXCLUDE = [\n  '**/node_modules/**',\n  '**/dist/**',\n  '**/build/**',\n  '**/*.test.*',\n  '**/*.spec.*',\n  '**/__tests__/**',\n];\n\n/**\n * Regex patterns for extracting testids\n */\nconst TESTID_PATTERNS = {\n  // data-testid=\"value\" or data-testid='value'\n  dataTestId: /data-testid=[\"']([^\"']+)[\"']/gi,\n  // data-test=\"value\" or data-test='value'\n  dataTest: /data-test=[\"']([^\"']+)[\"']/gi,\n  // data-cy=\"value\" (Cypress)\n  dataCy: /data-cy=[\"']([^\"']+)[\"']/gi,\n  // testID=\"value\" (React Native)\n  testID: /testID=[\"']([^\"']+)[\"']/gi,\n  // getByTestId('value') in tests\n  getByTestId: /getByTestId\\s*\\(\\s*[\"']([^\"']+)[\"']\\s*\\)/gi,\n};\n\n/**\n * Regex patterns for detecting CSS selectors (debt tracking)\n */\nconst CSS_DEBT_PATTERNS = {\n  // .className selectors in locator/querySelector\n  classSelector: /(?:locator|querySelector|querySelectorAll)\\s*\\(\\s*[\"']\\.([a-zA-Z_-][a-zA-Z0-9_-]*)[\"']/gi,\n  // #id selectors\n  idSelector: /(?:locator|querySelector)\\s*\\(\\s*[\"']#([a-zA-Z_-][a-zA-Z0-9_-]*)[\"']/gi,\n  // Complex CSS selectors\n  complexSelector: /(?:locator|querySelector)\\s*\\(\\s*[\"']([^\"']+\\s+[^\"']+)[\"']/gi,\n};\n\n/**\n * Extract component name from file path\n */\nfunction extractComponentName(filePath: string): string {\n  const baseName = basename(filePath, extname(filePath));\n  // Remove common suffixes\n  return baseName\n    .replace(/\\.(component|page|view|screen|container)$/i, '')\n    .replace(/[-_]/g, ' ')\n    .split(' ')\n    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))\n    .join('');\n}\n\n/**\n * Infer selector description from testid\n */\nfunction inferDescription(testId: string): string {\n  return testId\n    .replace(/[-_]/g, ' ')\n    .replace(/([a-z])([A-Z])/g, '$1 $2')\n    .toLowerCase();\n}\n\n/**\n * Generate a unique selector ID\n */\nfunction generateSelectorId(testId: string, component: string): string {\n  return `${component.toLowerCase()}-${testId}`;\n}\n\n/**\n * Scan a single file for testids\n */\nfunction scanFile(\n  filePath: string,\n  testIdAttribute: string,\n  trackCSSDebt: boolean\n): {\n  selectors: SelectorEntry[];\n  testIds: string[];\n  cssDebt: CSSDebtEntry[];\n} {\n  const content = readFileSync(filePath, 'utf-8');\n  const component = extractComponentName(filePath);\n  const selectors: SelectorEntry[] = [];\n  const testIds: string[] = [];\n  const cssDebt: CSSDebtEntry[] = [];\n  const seenTestIds = new Set<string>();\n\n  // Determine which pattern to use based on attribute name\n  let primaryPattern: RegExp;\n  if (testIdAttribute === 'data-testid') {\n    primaryPattern = TESTID_PATTERNS.dataTestId;\n  } else if (testIdAttribute === 'data-test') {\n    primaryPattern = TESTID_PATTERNS.dataTest;\n  } else if (testIdAttribute === 'data-cy') {\n    primaryPattern = TESTID_PATTERNS.dataCy;\n  } else {\n    // Generic pattern for custom attributes\n    primaryPattern = new RegExp(`${testIdAttribute}=[\"']([^\"']+)[\"']`, 'gi');\n  }\n\n  // Scan for primary testid pattern\n  primaryPattern.lastIndex = 0;\n  let match;\n  while ((match = primaryPattern.exec(content)) !== null) {\n    const testId = match[1]!; // Capture group guaranteed by pattern\n    if (!seenTestIds.has(testId)) {\n      seenTestIds.add(testId);\n      testIds.push(testId);\n\n      // Find line number\n      const lineNumber = content.substring(0, match.index).split('\\n').length;\n\n      selectors.push({\n        id: generateSelectorId(testId, component),\n        description: inferDescription(testId),\n        strategy: 'testid',\n        value: testId,\n        component,\n        sourceFile: filePath,\n        sourceLine: lineNumber,\n        stable: true,\n      });\n    }\n  }\n\n  // Also scan for getByTestId in test files\n  TESTID_PATTERNS.getByTestId.lastIndex = 0;\n  while ((match = TESTID_PATTERNS.getByTestId.exec(content)) !== null) {\n    const testId = match[1]!; // Capture group guaranteed by pattern\n    if (!seenTestIds.has(testId)) {\n      seenTestIds.add(testId);\n      testIds.push(testId);\n    }\n  }\n\n  // Track CSS debt if enabled\n  if (trackCSSDebt) {\n    for (const [patternName, pattern] of Object.entries(CSS_DEBT_PATTERNS)) {\n      pattern.lastIndex = 0;\n      while ((match = pattern.exec(content)) !== null) {\n        const selector = match[1]!; // Capture group guaranteed by pattern\n        const lineNumber = content.substring(0, match.index).split('\\n').length;\n\n        // Check if we already have this debt entry\n        const existing = cssDebt.find((d) => d.selector === selector);\n        if (existing) {\n          existing.usages.push({ file: filePath, line: lineNumber });\n        } else {\n          cssDebt.push({\n            selector: patternName === 'classSelector' ? `.${selector}` : selector,\n            usages: [{ file: filePath, line: lineNumber }],\n            priority: 'medium',\n            reason: `CSS ${patternName} found - consider using testid or role`,\n          });\n        }\n      }\n    }\n  }\n\n  return { selectors, testIds, cssDebt };\n}\n\n/**\n * Scan source directory for testids\n */\nexport async function scanForTestIds(options: ScannerOptions): Promise<ScannerResult> {\n  const {\n    sourceDir,\n    testIdAttribute = 'data-testid',\n    include = DEFAULT_INCLUDE,\n    exclude = DEFAULT_EXCLUDE,\n    trackCSSDebt = true,\n    existingCatalog,\n  } = options;\n\n  const resolvedDir = resolve(sourceDir);\n  const warnings: string[] = [];\n\n  if (!existsSync(resolvedDir)) {\n    return {\n      catalog: existingCatalog ?? createEmptyCatalog(),\n      filesScanned: 0,\n      testIdsFound: 0,\n      cssDebtFound: 0,\n      warnings: [`Source directory not found: ${resolvedDir}`],\n    };\n  }\n\n  // Find files to scan\n  const files = await fg(include, {\n    cwd: resolvedDir,\n    ignore: exclude,\n    absolute: true,\n  });\n\n  // Start with existing or empty catalog\n  const catalog: SelectorCatalog = existingCatalog ?? createEmptyCatalog();\n  catalog.sourceDir = sourceDir;\n  const allTestIds = new Set<string>(catalog.testIds);\n\n  let filesScanned = 0;\n  let testIdsFound = 0;\n  let cssDebtFound = 0;\n\n  // Scan each file\n  for (const filePath of files) {\n    try {\n      const result = scanFile(filePath, testIdAttribute, trackCSSDebt);\n      filesScanned++;\n\n      // Add selectors\n      for (const selector of result.selectors) {\n        // Use relative path for sourceFile\n        selector.sourceFile = relative(resolvedDir, filePath);\n        catalog.selectors[selector.id] = selector;\n      }\n\n      // Track testids\n      for (const testId of result.testIds) {\n        if (!allTestIds.has(testId)) {\n          allTestIds.add(testId);\n          testIdsFound++;\n        }\n      }\n\n      // Track CSS debt\n      for (const debt of result.cssDebt) {\n        // Convert file paths to relative\n        debt.usages = debt.usages.map((u) => ({\n          ...u,\n          file: relative(resolvedDir, u.file),\n        }));\n\n        // Merge with existing debt\n        const existing = catalog.cssDebt?.find((d) => d.selector === debt.selector);\n        if (existing) {\n          existing.usages.push(...debt.usages);\n        } else {\n          catalog.cssDebt = catalog.cssDebt ?? [];\n          catalog.cssDebt.push(debt);\n          cssDebtFound++;\n        }\n      }\n    } catch (err) {\n      warnings.push(`Failed to scan ${filePath}: ${err}`);\n    }\n  }\n\n  // Update catalog testIds\n  catalog.testIds = Array.from(allTestIds).sort();\n\n  return {\n    catalog,\n    filesScanned,\n    testIdsFound,\n    cssDebtFound,\n    warnings,\n  };\n}\n\n/**\n * Quick scan to just get testids (faster, no full catalog)\n */\nexport async function quickScanTestIds(\n  sourceDir: string,\n  testIdAttribute = 'data-testid'\n): Promise<string[]> {\n  const result = await scanForTestIds({\n    sourceDir,\n    testIdAttribute,\n    trackCSSDebt: false,\n  });\n  return result.catalog.testIds;\n}\n","/**\n * Selector Debt Tracker - Track CSS selector usage and generate debt reports\n * @see T093 - Implement selector debt tracker\n */\nimport { type CSSDebtEntry, type SelectorCatalog } from './catalogSchema.js';\nimport { getCatalog } from './catalog.js';\n\n/**\n * Debt report summary\n */\nexport interface DebtReportSummary {\n  /** Total number of CSS debt entries */\n  totalDebt: number;\n  /** Breakdown by priority */\n  byPriority: {\n    high: number;\n    medium: number;\n    low: number;\n  };\n  /** Total usage count across all debt */\n  totalUsages: number;\n  /** Files with most debt */\n  topDebtFiles: Array<{\n    file: string;\n    count: number;\n  }>;\n  /** Most common problematic selectors */\n  topSelectors: Array<{\n    selector: string;\n    usageCount: number;\n    priority: string;\n  }>;\n}\n\n/**\n * Debt migration plan\n */\nexport interface MigrationPlan {\n  /** Entries to migrate */\n  entries: Array<{\n    debt: CSSDebtEntry;\n    suggestedFix: string;\n    effort: 'low' | 'medium' | 'high';\n  }>;\n  /** Estimated total effort */\n  estimatedEffort: string;\n  /** Recommended migration order */\n  migrationOrder: string[];\n}\n\n/**\n * Record CSS selector usage as debt\n */\nexport function recordCSSDebt(\n  selector: string,\n  file: string,\n  line: number,\n  reason?: string\n): void {\n  const catalog = getCatalog();\n\n  // Find or create debt entry\n  let debt = catalog.cssDebt?.find((d) => d.selector === selector);\n\n  if (!debt) {\n    debt = {\n      selector,\n      usages: [],\n      priority: determinePriority(selector),\n      reason: reason ?? inferDebtReason(selector),\n    };\n    catalog.cssDebt = catalog.cssDebt ?? [];\n    catalog.cssDebt.push(debt);\n  }\n\n  // Add usage if not already tracked\n  const existingUsage = debt.usages.find((u) => u.file === file && u.line === line);\n  if (!existingUsage) {\n    debt.usages.push({ file, line });\n  }\n}\n\n/**\n * Determine priority based on selector type\n */\nfunction determinePriority(selector: string): 'low' | 'medium' | 'high' {\n  // High priority: dynamic or fragile selectors\n  if (selector.includes('[class*=') || selector.includes('[class^=')) {\n    return 'high';\n  }\n  if (selector.match(/\\d+/)) {\n    // Contains numbers (likely auto-generated)\n    return 'high';\n  }\n  if (selector.split(' ').length > 3) {\n    // Complex nested selector\n    return 'high';\n  }\n\n  // Medium priority: class selectors\n  if (selector.startsWith('.')) {\n    return 'medium';\n  }\n\n  // Low priority: ID selectors (more stable)\n  if (selector.startsWith('#')) {\n    return 'low';\n  }\n\n  return 'medium';\n}\n\n/**\n * Infer reason for debt based on selector pattern\n */\nfunction inferDebtReason(selector: string): string {\n  if (selector.includes('[class*=') || selector.includes('[class^=')) {\n    return 'Partial class matching is fragile - may break with CSS changes';\n  }\n  if (selector.match(/\\d+/)) {\n    return 'Selector contains numbers - may be auto-generated and unstable';\n  }\n  if (selector.split(' ').length > 3) {\n    return 'Complex nested selector - hard to maintain and fragile';\n  }\n  if (selector.startsWith('.')) {\n    return 'Class selector - consider using testid or role';\n  }\n  if (selector.startsWith('#')) {\n    return 'ID selector - consider using testid for test stability';\n  }\n  return 'CSS selector - consider using semantic locators';\n}\n\n/**\n * Suggest replacement for a CSS selector\n */\nexport function suggestReplacement(selector: string): {\n  strategy: string;\n  value: string;\n  code: string;\n} {\n  // Extract meaningful name from selector\n  let name = selector\n    .replace(/[.#\\[\\]=\"'^*~$]/g, ' ')\n    .trim()\n    .split(/\\s+/)\n    .filter((s) => s.length > 2)\n    .join('-')\n    .toLowerCase();\n\n  if (!name) {\n    name = 'element';\n  }\n\n  // Generate testid suggestion\n  const testId = name.replace(/\\s+/g, '-');\n\n  return {\n    strategy: 'testid',\n    value: testId,\n    code: `page.getByTestId('${testId}')`,\n  };\n}\n\n/**\n * Generate debt report summary\n */\nexport function generateDebtReport(catalog?: SelectorCatalog): DebtReportSummary {\n  const cat = catalog ?? getCatalog();\n  const debt = cat.cssDebt ?? [];\n\n  // Count by priority\n  const byPriority = { high: 0, medium: 0, low: 0 };\n  let totalUsages = 0;\n  const fileUsages: Record<string, number> = {};\n\n  for (const entry of debt) {\n    byPriority[entry.priority]++;\n    totalUsages += entry.usages.length;\n\n    for (const usage of entry.usages) {\n      fileUsages[usage.file] = (fileUsages[usage.file] ?? 0) + 1;\n    }\n  }\n\n  // Top debt files\n  const topDebtFiles = Object.entries(fileUsages)\n    .sort(([, a], [, b]) => b - a)\n    .slice(0, 10)\n    .map(([file, count]) => ({ file, count }));\n\n  // Top selectors\n  const topSelectors = debt\n    .sort((a, b) => b.usages.length - a.usages.length)\n    .slice(0, 10)\n    .map((d) => ({\n      selector: d.selector,\n      usageCount: d.usages.length,\n      priority: d.priority,\n    }));\n\n  return {\n    totalDebt: debt.length,\n    byPriority,\n    totalUsages,\n    topDebtFiles,\n    topSelectors,\n  };\n}\n\n/**\n * Generate migration plan for addressing debt\n */\nexport function generateMigrationPlan(catalog?: SelectorCatalog): MigrationPlan {\n  const cat = catalog ?? getCatalog();\n  const debt = cat.cssDebt ?? [];\n\n  const entries = debt.map((d) => {\n    const suggestion = suggestReplacement(d.selector);\n    const effort = d.priority === 'high' ? 'high' : d.usages.length > 5 ? 'medium' : 'low';\n\n    return {\n      debt: d,\n      suggestedFix: suggestion.code,\n      effort: effort as 'low' | 'medium' | 'high',\n    };\n  });\n\n  // Sort by priority (high first) then by usage count (most used first)\n  entries.sort((a, b) => {\n    const priorityOrder = { high: 0, medium: 1, low: 2 };\n    const pDiff = priorityOrder[a.debt.priority] - priorityOrder[b.debt.priority];\n    if (pDiff !== 0) return pDiff;\n    return b.debt.usages.length - a.debt.usages.length;\n  });\n\n  // Calculate estimated effort\n  const effortCounts = { low: 0, medium: 0, high: 0 };\n  for (const entry of entries) {\n    effortCounts[entry.effort]++;\n  }\n\n  let estimatedEffort: string;\n  if (effortCounts.high > 10 || effortCounts.medium > 20) {\n    estimatedEffort = 'Large refactoring effort required';\n  } else if (effortCounts.high > 5 || effortCounts.medium > 10) {\n    estimatedEffort = 'Medium refactoring effort required';\n  } else {\n    estimatedEffort = 'Small refactoring effort required';\n  }\n\n  // Migration order\n  const migrationOrder = entries.slice(0, 20).map((e) => e.debt.selector);\n\n  return {\n    entries,\n    estimatedEffort,\n    migrationOrder,\n  };\n}\n\n/**\n * Clear all debt entries (for testing or after migration)\n */\nexport function clearDebt(): void {\n  const catalog = getCatalog();\n  catalog.cssDebt = [];\n}\n\n/**\n * Remove specific debt entry\n */\nexport function removeDebt(selector: string): boolean {\n  const catalog = getCatalog();\n  const index = catalog.cssDebt?.findIndex((d) => d.selector === selector) ?? -1;\n\n  if (index >= 0) {\n    catalog.cssDebt?.splice(index, 1);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Update debt priority\n */\nexport function updateDebtPriority(\n  selector: string,\n  priority: 'low' | 'medium' | 'high'\n): boolean {\n  const catalog = getCatalog();\n  const debt = catalog.cssDebt?.find((d) => d.selector === selector);\n\n  if (debt) {\n    debt.priority = priority;\n    return true;\n  }\n  return false;\n}\n\n/**\n * Generate markdown debt report\n */\nexport function generateDebtMarkdown(catalog?: SelectorCatalog): string {\n  const report = generateDebtReport(catalog);\n  const plan = generateMigrationPlan(catalog);\n\n  const lines: string[] = [\n    '# Selector Debt Report',\n    '',\n    `Generated: ${new Date().toISOString()}`,\n    '',\n    '## Summary',\n    '',\n    `- **Total Debt Entries:** ${report.totalDebt}`,\n    `- **Total Usages:** ${report.totalUsages}`,\n    `- **High Priority:** ${report.byPriority.high}`,\n    `- **Medium Priority:** ${report.byPriority.medium}`,\n    `- **Low Priority:** ${report.byPriority.low}`,\n    '',\n    `**Effort Estimate:** ${plan.estimatedEffort}`,\n    '',\n    '## Top Selectors to Address',\n    '',\n    '| Selector | Usages | Priority | Suggested Fix |',\n    '|----------|--------|----------|---------------|',\n  ];\n\n  for (const entry of plan.entries.slice(0, 15)) {\n    lines.push(\n      `| \\`${entry.debt.selector}\\` | ${entry.debt.usages.length} | ${entry.debt.priority} | \\`${entry.suggestedFix}\\` |`\n    );\n  }\n\n  lines.push('', '## Files with Most Debt', '');\n\n  for (const file of report.topDebtFiles.slice(0, 10)) {\n    lines.push(`- \\`${file.file}\\`: ${file.count} debt usages`);\n  }\n\n  lines.push('', '## Migration Order', '', 'Address these selectors first:', '');\n\n  for (let i = 0; i < Math.min(10, plan.migrationOrder.length); i++) {\n    lines.push(`${i + 1}. \\`${plan.migrationOrder[i]}\\``);\n  }\n\n  return lines.join('\\n');\n}\n","/**\n * Managed Blocks - Alternative to AST editing for simpler code regeneration\n * @see research/2026-01-03_autogen-remaining-features-plan.md Feature 4\n */\n\n/**\n * Block markers for generated code boundaries\n */\nexport const BLOCK_START = '// ARTK:BEGIN GENERATED';\nexport const BLOCK_END = '// ARTK:END GENERATED';\nexport const BLOCK_ID_PATTERN = /ARTK:BEGIN GENERATED(?:\\s+id=([a-zA-Z0-9_-]+))?/;\n\n/**\n * Represents a managed block of generated code\n */\nexport interface ManagedBlock {\n  /** Optional identifier for the block */\n  id?: string;\n  /** Starting line number (0-indexed) */\n  startLine: number;\n  /** Ending line number (0-indexed) */\n  endLine: number;\n  /** Content between markers (excluding markers themselves) */\n  content: string;\n}\n\n/**\n * Information about a malformed block\n */\nexport interface BlockWarning {\n  /** Type of warning */\n  type: 'nested' | 'unclosed';\n  /** Line number where the issue occurred */\n  line: number;\n  /** Human-readable message */\n  message: string;\n}\n\n/**\n * Result of extracting managed blocks from code\n */\nexport interface BlockExtractionResult {\n  /** All managed blocks found */\n  blocks: ManagedBlock[];\n  /** Code outside of managed blocks */\n  preservedCode: string[];\n  /** Whether any blocks were found */\n  hasBlocks: boolean;\n  /** Warnings about malformed blocks */\n  warnings: BlockWarning[];\n}\n\n/**\n * Options for injecting managed blocks\n */\nexport interface InjectBlocksOptions {\n  /** Existing file content */\n  existingCode: string;\n  /** New blocks to inject */\n  newBlocks: Array<{\n    id?: string;\n    content: string;\n  }>;\n  /** Whether to preserve block order (default: true) */\n  preserveOrder?: boolean;\n}\n\n/**\n * Extract managed blocks from existing code\n *\n * @param code - Source code to analyze\n * @returns Extraction result with blocks and preserved code\n *\n * @example\n * ```typescript\n * const result = extractManagedBlocks(`\n *   // User code\n *   // ARTK:BEGIN GENERATED id=test-1\n *   test('example', () => {});\n *   // ARTK:END GENERATED\n *   // More user code\n * `);\n * // result.blocks.length === 1\n * // result.blocks[0].id === 'test-1'\n * ```\n */\nexport function extractManagedBlocks(code: string): BlockExtractionResult {\n  const lines = code.split('\\n');\n  const blocks: ManagedBlock[] = [];\n  const preservedCode: string[] = [];\n  const warnings: BlockWarning[] = [];\n\n  let inBlock = false;\n  let currentBlock: Partial<ManagedBlock> | null = null;\n  let blockContent: string[] = [];\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i]!;\n\n    // Check for block start\n    if (line.includes(BLOCK_START)) {\n      if (inBlock) {\n        // Nested block detected - close the previous block and record warning\n        warnings.push({\n          type: 'nested',\n          line: i + 1,\n          message: `Nested managed block detected at line ${i + 1}. Previous block starting at line ${(currentBlock?.startLine ?? 0) + 1} will be closed.`,\n        });\n        // Save the incomplete previous block\n        if (currentBlock) {\n          blocks.push({\n            ...currentBlock,\n            endLine: i - 1,\n            content: blockContent.join('\\n'),\n          } as ManagedBlock);\n        }\n      }\n      inBlock = true;\n      const match = line.match(BLOCK_ID_PATTERN);\n      currentBlock = {\n        id: match?.[1],\n        startLine: i,\n      };\n      blockContent = [];\n      continue;\n    }\n\n    // Check for block end\n    if (line.includes(BLOCK_END) && inBlock) {\n      inBlock = false;\n      if (currentBlock) {\n        blocks.push({\n          ...currentBlock,\n          endLine: i,\n          content: blockContent.join('\\n'),\n        } as ManagedBlock);\n      }\n      currentBlock = null;\n      blockContent = [];\n      continue;\n    }\n\n    // Collect content\n    if (inBlock) {\n      blockContent.push(line);\n    } else {\n      preservedCode.push(line);\n    }\n  }\n\n  // Handle unclosed block\n  if (inBlock && currentBlock) {\n    warnings.push({\n      type: 'unclosed',\n      line: (currentBlock.startLine ?? 0) + 1,\n      message: `Unclosed managed block starting at line ${(currentBlock.startLine ?? 0) + 1} - block will be ignored`,\n    });\n  }\n\n  return {\n    blocks,\n    preservedCode,\n    hasBlocks: blocks.length > 0,\n    warnings,\n  };\n}\n\n/**\n * Wrap content in managed block markers\n *\n * @param content - Code to wrap\n * @param id - Optional block identifier\n * @returns Wrapped content with markers\n *\n * @example\n * ```typescript\n * const wrapped = wrapInBlock(\"test('foo', () => {});\", 'test-foo');\n * // Returns:\n * // // ARTK:BEGIN GENERATED id=test-foo\n * // test('foo', () => {});\n * // // ARTK:END GENERATED\n * ```\n */\nexport function wrapInBlock(content: string, id?: string): string {\n  const startMarker = id\n    ? `${BLOCK_START} id=${id}`\n    : BLOCK_START;\n\n  return `${startMarker}\\n${content}\\n${BLOCK_END}`;\n}\n\n/**\n * Inject managed blocks into code, preserving user code outside blocks\n *\n * Behavior:\n * - If existing code has no blocks: append new blocks at end\n * - If existing code has blocks: replace matching blocks by ID\n * - If block ID not found: append new block at end\n * - All code outside blocks is preserved\n *\n * @param options - Injection options\n * @returns Updated code with injected blocks\n *\n * @example\n * ```typescript\n * const result = injectManagedBlocks({\n *   existingCode: `\n *     // User helper\n *     // ARTK:BEGIN GENERATED id=old-test\n *     test('old', () => {});\n *     // ARTK:END GENERATED\n *   `,\n *   newBlocks: [\n *     { id: 'old-test', content: \"test('new', () => {});\" }\n *   ]\n * });\n * // result contains replaced block with new content\n * ```\n */\nexport function injectManagedBlocks(options: InjectBlocksOptions): string {\n  const { existingCode, newBlocks } = options;\n\n  // If no existing code, just wrap new blocks\n  if (!existingCode.trim()) {\n    return newBlocks\n      .map(block => wrapInBlock(block.content, block.id))\n      .join('\\n\\n');\n  }\n\n  const { preservedCode, hasBlocks } =\n    extractManagedBlocks(existingCode);\n\n  if (!hasBlocks) {\n    // No existing blocks - append new blocks at end\n    const preserved = preservedCode.join('\\n').trim();\n    const newContent = newBlocks\n      .map(block => wrapInBlock(block.content, block.id))\n      .join('\\n\\n');\n\n    return preserved ? `${preserved}\\n\\n${newContent}` : newContent;\n  }\n\n  // Replace existing blocks by ID, preserve structure\n  const result: string[] = [];\n  const processedIds = new Set<string>();\n  // Track id-less blocks separately by position to avoid ambiguous matching\n  let idLessBlockIndex = 0;\n  const idLessNewBlocks = newBlocks.filter(b => !b.id);\n  const processedIdLessIndices = new Set<number>();\n\n  // Re-scan to maintain structure\n  const lines = existingCode.split('\\n');\n  let inBlock = false;\n  let currentBlockId: string | undefined;\n  let skipUntilEnd = false;\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i]!;\n\n    if (line.includes(BLOCK_START)) {\n      inBlock = true;\n      const match = line.match(BLOCK_ID_PATTERN);\n      currentBlockId = match?.[1];\n\n      // Find replacement block\n      let replacement;\n      if (currentBlockId) {\n        // Match by ID for blocks with IDs\n        replacement = newBlocks.find(b => b.id === currentBlockId);\n        if (replacement) {\n          processedIds.add(currentBlockId);\n        }\n      } else {\n        // Match id-less blocks by position\n        if (idLessBlockIndex < idLessNewBlocks.length) {\n          replacement = idLessNewBlocks[idLessBlockIndex];\n          processedIdLessIndices.add(idLessBlockIndex);\n        }\n        idLessBlockIndex++;\n      }\n\n      if (replacement) {\n        result.push(wrapInBlock(replacement.content, replacement.id));\n        skipUntilEnd = true;\n      } else {\n        // Keep original block\n        result.push(line);\n        skipUntilEnd = false;\n      }\n      continue;\n    }\n\n    if (line.includes(BLOCK_END) && inBlock) {\n      inBlock = false;\n      if (!skipUntilEnd) {\n        result.push(line);\n      }\n      currentBlockId = undefined;\n      skipUntilEnd = false;\n      continue;\n    }\n\n    // Add content\n    if (!inBlock) {\n      result.push(line);\n    } else if (!skipUntilEnd) {\n      result.push(line);\n    }\n  }\n\n  // Append new blocks that weren't replacements\n  for (let i = 0; i < newBlocks.length; i++) {\n    const block = newBlocks[i]!;\n    if (block.id) {\n      // Check if this ID was processed\n      if (!processedIds.has(block.id)) {\n        result.push('');\n        result.push(wrapInBlock(block.content, block.id));\n      }\n    } else {\n      // Check if this id-less block was processed (by its index in idLessNewBlocks)\n      const idLessIndex = idLessNewBlocks.indexOf(block);\n      if (!processedIdLessIndices.has(idLessIndex)) {\n        result.push('');\n        result.push(wrapInBlock(block.content, block.id));\n      }\n    }\n  }\n\n  return result.join('\\n');\n}\n","/**\n * Journey Frontmatter Updater - Enable bi-directional traceability\n * @see research/2026-01-03_autogen-remaining-features-plan.md Section 1\n */\nimport { readFileSync, writeFileSync } from 'node:fs';\nimport { parse as parseYaml, stringify as stringifyYaml } from 'yaml';\nimport { createHash } from 'node:crypto';\n\n/**\n * Journey test entry with generation metadata\n */\nexport interface JourneyTestEntry {\n  /** Path to generated test file (relative to project root) */\n  path: string;\n  /** Timestamp when test was generated */\n  generated: string;\n  /** Content hash for change detection (first 8 chars of SHA-256) */\n  hash: string;\n}\n\n/**\n * Options for updating journey frontmatter\n */\nexport interface JourneyUpdateOptions {\n  /** Path to the journey markdown file */\n  journeyPath: string;\n  /** Path to the generated test file */\n  testPath: string;\n  /** Content of the generated test (for hash calculation) */\n  testContent: string;\n  /** Module dependencies to add (foundation or feature module names) */\n  modules?: {\n    foundation?: string[];\n    features?: string[];\n  };\n}\n\n/**\n * Result of journey frontmatter update\n */\nexport interface JourneyUpdateResult {\n  /** Whether update succeeded */\n  success: boolean;\n  /** Previous tests array before update */\n  previousTests: JourneyTestEntry[];\n  /** Updated tests array after update */\n  updatedTests: JourneyTestEntry[];\n  /** Modules added (not previously in the list) */\n  modulesAdded: {\n    foundation: string[];\n    features: string[];\n  };\n}\n\n/**\n * Split journey content into frontmatter and body\n */\nfunction splitJourneyContent(content: string): {\n  frontmatter: string;\n  body: string;\n} {\n  const match = content.match(/^---\\r?\\n([\\s\\S]*?)\\r?\\n---\\r?\\n([\\s\\S]*)$/);\n\n  if (!match) {\n    throw new Error(\n      'Invalid Journey format: missing frontmatter delimiters (content should be wrapped in --- ... ---)'\n    );\n  }\n\n  return {\n    frontmatter: match[1]!,\n    body: match[2]!,\n  };\n}\n\n/**\n * Calculate SHA-256 hash of content (first 8 characters)\n */\nfunction calculateContentHash(content: string): string {\n  return createHash('sha256').update(content).digest('hex').substring(0, 8);\n}\n\n/**\n * Update Journey frontmatter with generated test info\n *\n * This enables bi-directional traceability by:\n * 1. Recording which tests were generated from this Journey\n * 2. Tracking when tests were generated\n * 3. Detecting test changes via content hash\n * 4. Linking module dependencies\n *\n * @param options - Update options\n * @returns Update result with previous and new state\n * @throws Error if journey file is invalid or cannot be written\n */\nexport function updateJourneyFrontmatter(\n  options: JourneyUpdateOptions\n): JourneyUpdateResult {\n  const {\n    journeyPath,\n    testPath,\n    testContent,\n    modules = { foundation: [], features: [] },\n  } = options;\n\n  // Read journey file\n  const content = readFileSync(journeyPath, 'utf-8');\n\n  // Split frontmatter and body\n  const { frontmatter, body } = splitJourneyContent(content);\n\n  // Parse YAML frontmatter\n  const parsed = parseYaml(frontmatter) as Record<string, unknown>;\n\n  // Store previous state (deep copy to avoid mutation)\n  const previousTests = Array.isArray(parsed.tests)\n    ? (parsed.tests as JourneyTestEntry[]).map((t) =>\n        typeof t === 'string' ? { path: t, generated: '', hash: '' } : { ...t }\n      )\n    : [];\n\n  // Calculate content hash\n  const hash = calculateContentHash(testContent);\n\n  // Create/update test entry\n  const testEntry: JourneyTestEntry = {\n    path: testPath,\n    generated: new Date().toISOString(),\n    hash,\n  };\n\n  // Ensure tests array exists\n  if (!Array.isArray(parsed.tests)) {\n    parsed.tests = [];\n  }\n\n  // Find existing test entry by path\n  const existingIndex = (parsed.tests as JourneyTestEntry[]).findIndex(\n    (t) =>\n      typeof t === 'string'\n        ? t === testPath\n        : (t as JourneyTestEntry).path === testPath\n  );\n\n  // Update or add test entry\n  if (existingIndex >= 0) {\n    (parsed.tests as JourneyTestEntry[])[existingIndex]! = testEntry;\n  } else {\n    (parsed.tests as JourneyTestEntry[]).push(testEntry);\n  }\n\n  // Update modules\n  const modulesAdded = {\n    foundation: [] as string[],\n    features: [] as string[],\n  };\n\n  // Ensure modules structure exists\n  if (!parsed.modules || typeof parsed.modules !== 'object') {\n    parsed.modules = { foundation: [], features: [] };\n  }\n\n  const parsedModules = parsed.modules as {\n    foundation?: string[];\n    features?: string[];\n  };\n\n  // Ensure foundation and features arrays exist\n  if (!Array.isArray(parsedModules.foundation)) {\n    parsedModules.foundation = [];\n  }\n  if (!Array.isArray(parsedModules.features)) {\n    parsedModules.features = [];\n  }\n\n  // Add foundation modules (deduplicate)\n  if (modules.foundation) {\n    const existingFoundation = new Set(parsedModules.foundation!);\n    for (const mod of modules.foundation) {\n      if (!existingFoundation.has(mod)) {\n        modulesAdded.foundation.push(mod);\n        parsedModules.foundation!.push(mod);\n      }\n    }\n    // Sort for consistency\n    parsedModules.foundation!.sort();\n  }\n\n  // Add feature modules (deduplicate)\n  if (modules.features) {\n    const existingFeatures = new Set(parsedModules.features);\n    for (const mod of modules.features) {\n      if (!existingFeatures.has(mod)) {\n        modulesAdded.features.push(mod);\n        parsedModules.features.push(mod);\n      }\n    }\n    // Sort for consistency\n    parsedModules.features.sort();\n  }\n\n  // Reconstruct file with updated frontmatter\n  const newFrontmatter = stringifyYaml(parsed, {\n    lineWidth: 0, // Prevent line wrapping\n    defaultKeyType: 'PLAIN',\n    defaultStringType: 'QUOTE_DOUBLE',\n  });\n\n  const newContent = `---\\n${newFrontmatter}---\\n${body}`;\n\n  // Write back to file\n  writeFileSync(journeyPath, newContent, 'utf-8');\n\n  return {\n    success: true,\n    previousTests,\n    updatedTests: parsed.tests as JourneyTestEntry[],\n    modulesAdded,\n  };\n}\n\n/**\n * Check if a Journey's test is up-to-date based on content hash\n *\n * @param journeyPath - Path to the journey file\n * @param testPath - Path to the test file to check\n * @param testContent - Current content of the test file\n * @returns True if the test hash matches the recorded hash\n */\nexport function isJourneyTestCurrent(\n  journeyPath: string,\n  testPath: string,\n  testContent: string\n): boolean {\n  const content = readFileSync(journeyPath, 'utf-8');\n  const { frontmatter } = splitJourneyContent(content);\n  const parsed = parseYaml(frontmatter) as Record<string, unknown>;\n\n  if (!Array.isArray(parsed.tests)) {\n    return false;\n  }\n\n  // Find test entry\n  const testEntry = (parsed.tests as JourneyTestEntry[]).find((t) =>\n    typeof t === 'string' ? t === testPath : t.path === testPath\n  );\n\n  if (!testEntry || typeof testEntry === 'string') {\n    return false;\n  }\n\n  // Calculate current hash\n  const currentHash = calculateContentHash(testContent);\n\n  return testEntry.hash === currentHash;\n}\n","/**\n * Version utilities for generated code branding\n *\n * Supports build-time version injection via:\n * - Environment variable: ARTK_VERSION\n * - Build tool define: __ARTK_VERSION__ (e.g., via esbuild/rollup define)\n *\n * Falls back to runtime package.json reading if not injected.\n */\nimport { readFileSync, existsSync } from 'node:fs';\nimport { join } from 'node:path';\nimport { getPackageRoot } from './paths.js';\n\n/**\n * Build-time injected version (can be replaced by bundlers like esbuild/rollup)\n * Usage: define({ '__ARTK_VERSION__': JSON.stringify('1.0.0') })\n */\ndeclare const __ARTK_VERSION__: string | undefined;\n\n/** Cached version to avoid repeated lookups */\nlet cachedVersion: string | undefined;\n\n/**\n * Get the package version\n *\n * Priority:\n * 1. Build-time define (__ARTK_VERSION__)\n * 2. Environment variable (ARTK_VERSION)\n * 3. Runtime package.json reading (fallback)\n */\nexport function getPackageVersion(): string {\n  // Return cached version if available\n  if (cachedVersion) {\n    return cachedVersion;\n  }\n\n  // 1. Check build-time define (set by bundlers)\n  try {\n    if (typeof __ARTK_VERSION__ !== 'undefined' && __ARTK_VERSION__) {\n      cachedVersion = __ARTK_VERSION__;\n      return cachedVersion;\n    }\n  } catch {\n    // __ARTK_VERSION__ not defined, continue to fallbacks\n  }\n\n  // 2. Check environment variable (useful for CI/CD)\n  const envVersion = process.env['ARTK_VERSION'];\n  if (envVersion) {\n    cachedVersion = envVersion;\n    return cachedVersion;\n  }\n\n  // 3. Fall back to runtime package.json reading\n  try {\n    const packageRoot = getPackageRoot();\n    const pkgPath = join(packageRoot, 'package.json');\n\n    if (existsSync(pkgPath)) {\n      const pkg = JSON.parse(readFileSync(pkgPath, 'utf-8')) as { version?: string };\n      if (pkg.version) {\n        cachedVersion = pkg.version;\n        return cachedVersion;\n      }\n    }\n  } catch {\n    // Package.json lookup failed\n  }\n\n  cachedVersion = 'unknown';\n  return cachedVersion;\n}\n\n/**\n * Get ISO timestamp for generated file headers\n */\nexport function getGeneratedTimestamp(): string {\n  return new Date().toISOString();\n}\n\n/**\n * Generate a standard header comment for generated files\n */\nexport interface GeneratedHeaderOptions {\n  title?: string;\n  journeyId?: string;\n  tags?: string[];\n  tier?: string;\n  scope?: string;\n  actor?: string;\n}\n\nexport function generateFileHeader(options: GeneratedHeaderOptions = {}): string {\n  const version = getPackageVersion();\n  const timestamp = getGeneratedTimestamp();\n\n  const lines = [\n    '/**',\n    options.title ? ` * ${options.title}` : ' * Generated file',\n    options.journeyId ? ` * Journey: ${options.journeyId}` : null,\n    ` *`,\n    ` * @generated by @artk/core-autogen v${version}`,\n    ` * @timestamp ${timestamp}`,\n    ` * @warning Generated regions (ARTK:BEGIN/END GENERATED) will be overwritten.`,\n    ` *          Code outside these blocks is preserved on regeneration.`,\n  ];\n\n  if (options.tags && options.tags.length > 0) {\n    lines.push(` * @tags ${options.tags.join(', ')}`);\n  }\n  if (options.tier) {\n    lines.push(` * @tier ${options.tier}`);\n  }\n  if (options.scope) {\n    lines.push(` * @scope ${options.scope}`);\n  }\n  if (options.actor) {\n    lines.push(` * @actor ${options.actor}`);\n  }\n\n  lines.push(' */');\n\n  return lines.filter(l => l !== null).join('\\n');\n}\n\n/**\n * Branding string for inline comments\n */\nexport function getBrandingComment(): string {\n  const version = getPackageVersion();\n  return `@artk/core-autogen v${version}`;\n}\n","/**\n * Variant detection and feature flags for AutoGen\n */\n\nexport interface VariantInfo {\n  id: 'modern-esm' | 'modern-cjs' | 'legacy-16' | 'legacy-14';\n  nodeVersion: number;\n  moduleSystem: 'esm' | 'cjs';\n  playwrightVersion: string;\n  features: VariantFeatures;\n}\n\nexport interface VariantFeatures {\n  ariaSnapshots: boolean;\n  clockApi: boolean;\n  topLevelAwait: boolean;\n  promiseAny: boolean;\n}\n\n/**\n * Detect the current runtime variant based on Node.js version\n */\nexport function detectVariant(): VariantInfo {\n  const nodeVersionStr = process.version.slice(1);\n  const nodeVersion = parseInt(nodeVersionStr.split('.')[0] ?? '18', 10);\n\n  // Check if running in ESM context\n  const isESM = typeof import.meta !== 'undefined';\n\n  if (nodeVersion >= 18) {\n    return {\n      id: isESM ? 'modern-esm' : 'modern-cjs',\n      nodeVersion,\n      moduleSystem: isESM ? 'esm' : 'cjs',\n      playwrightVersion: '1.57.x',\n      features: {\n        ariaSnapshots: true,\n        clockApi: true,\n        topLevelAwait: true,\n        promiseAny: true,\n      },\n    };\n  } else if (nodeVersion >= 16) {\n    return {\n      id: 'legacy-16',\n      nodeVersion,\n      moduleSystem: 'cjs',\n      playwrightVersion: '1.49.x',\n      features: {\n        ariaSnapshots: true,\n        clockApi: true,\n        topLevelAwait: true,\n        promiseAny: true,\n      },\n    };\n  } else {\n    return {\n      id: 'legacy-14',\n      nodeVersion,\n      moduleSystem: 'cjs',\n      playwrightVersion: '1.33.x',\n      features: {\n        ariaSnapshots: false,\n        clockApi: false,\n        topLevelAwait: false,\n        promiseAny: false,\n      },\n    };\n  }\n}\n\n/**\n * Get feature availability for current variant\n */\nexport function getFeatures(): VariantFeatures {\n  return detectVariant().features;\n}\n\n/**\n * Check if a specific feature is available\n */\nexport function hasFeature(feature: keyof VariantFeatures): boolean {\n  return detectVariant().features[feature];\n}\n","/**\n * Test Generator - Generate Playwright test files from IR\n * @see research/2026-01-02_autogen-refined-plan.md Section 12\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md (variant-aware generation)\n */\nimport { readFileSync, existsSync } from 'node:fs';\nimport { join } from 'node:path';\nimport ejs from 'ejs';\nimport type { IRJourney, IRPrimitive, ValueSpec } from '../ir/types.js';\nimport { toPlaywrightLocator } from '../selectors/priority.js';\nimport { injectManagedBlocks } from './blocks.js';\nimport { updateJourneyFrontmatter } from '../journey/updater.js';\nimport { escapeRegex } from '../utils/escaping.js';\nimport { getPackageVersion, getGeneratedTimestamp } from '../utils/version.js';\nimport { getTemplatePath } from '../utils/paths.js';\nimport { detectVariant, type VariantInfo, type VariantFeatures } from '../variants/index.js';\n\n// Re-export variant types for consumers\nexport type { VariantInfo, VariantFeatures };\n\n/**\n * Import statement for generated test\n */\nexport interface ImportStatement {\n  members: string[];\n  from: string;\n}\n\n/**\n * Options for test generation\n */\nexport interface GenerateTestOptions {\n  /** Custom template path */\n  templatePath?: string;\n  /** Whether to include source comments */\n  includeComments?: boolean;\n  /** Module imports to add */\n  imports?: ImportStatement[];\n  /** Custom test ID attribute */\n  testIdAttribute?: string;\n  /**\n   * Code generation strategy\n   * - 'full': Generate complete file (default)\n   * - 'blocks': Use managed blocks for partial regeneration\n   * - 'ast': Use AST editing to preserve structure\n   */\n  strategy?: 'full' | 'blocks' | 'ast';\n  /** Existing code (required for 'blocks' and 'ast' strategies) */\n  existingCode?: string;\n  /** Whether to update journey frontmatter with test metadata */\n  updateJourney?: boolean;\n  /** Path to the source journey file (required if updateJourney is true) */\n  journeyPath?: string;\n  /** Output path for the generated test file (for journey update) */\n  outputPath?: string;\n  /** LLKB root directory for version tracking (default: .artk/llkb) */\n  llkbRoot?: string;\n  /** Whether to include LLKB version in generated test header (default: true if LLKB exists) */\n  includeLlkbVersion?: boolean;\n  /** Target variant for code generation (auto-detected if not specified) */\n  targetVariant?: VariantInfo;\n  /** Whether to emit warnings for variant-incompatible features (default: true) */\n  warnOnIncompatible?: boolean;\n}\n\n/**\n * Result of test generation\n */\nexport interface GenerateTestResult {\n  /** Generated test code */\n  code: string;\n  /** Journey ID */\n  journeyId: string;\n  /** Suggested filename */\n  filename: string;\n  /** Imports used */\n  imports: ImportStatement[];\n  /** Variant used for generation */\n  variant?: VariantInfo;\n  /** Warnings about variant-incompatible features */\n  variantWarnings?: string[];\n}\n\n/**\n * Context for variant-aware code generation\n */\ninterface VariantContext {\n  /** Variant info for the target environment */\n  variant: VariantInfo;\n  /** Collected warnings for incompatible features */\n  warnings: string[];\n  /** Whether to emit warnings */\n  warnOnIncompatible: boolean;\n}\n\n/**\n * Check if a feature is available in the current variant\n * @internal Reserved for future variant-specific primitive handling\n */\nfunction _checkFeature(\n  ctx: VariantContext,\n  feature: keyof VariantFeatures,\n  featureName: string,\n  primitiveType: string\n): boolean {\n  const available = ctx.variant.features[feature];\n  if (!available && ctx.warnOnIncompatible) {\n    ctx.warnings.push(\n      `Primitive '${primitiveType}' uses ${featureName} which requires ${getFeatureRequirement(feature)}. ` +\n        `Current variant: ${ctx.variant.id} (Playwright ${ctx.variant.playwrightVersion})`\n    );\n  }\n  return available;\n}\n\n// Export for testing (prefixed to avoid unused warning in production)\nexport const __test_checkFeature = _checkFeature;\n\n/**\n * Get human-readable requirement for a feature\n */\nfunction getFeatureRequirement(feature: keyof VariantFeatures): string {\n  switch (feature) {\n    case 'ariaSnapshots':\n      return 'Playwright 1.49+ (Node 16+)';\n    case 'clockApi':\n      return 'Playwright 1.45+ (Node 18+)';\n    case 'topLevelAwait':\n      return 'Node 14.8+ with ESM';\n    case 'promiseAny':\n      return 'Node 15+ or polyfill';\n    default:\n      return 'unknown version';\n  }\n}\n\n/**\n * Escape string for use in generated code\n */\nfunction escapeString(str: string): string {\n  return str\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/'/g, \"\\\\'\")\n    .replace(/\"/g, '\\\\\"')\n    .replace(/\\n/g, '\\\\n')\n    .replace(/\\r/g, '\\\\r');\n}\n\n/**\n * Render a value spec to code\n */\nfunction renderValue(value: ValueSpec): string {\n  switch (value.type) {\n    case 'literal':\n      return `'${escapeString(value.value)}'`;\n    case 'actor':\n      return `actor.${value.value}`;\n    case 'runId':\n      return 'runId';\n    case 'generated':\n      return `\\`${value.value}\\``;\n    case 'testData':\n      return `testData.${value.value}`;\n    default:\n      return `'${escapeString(value.value)}'`;\n  }\n}\n\n/**\n * Render an IR primitive to Playwright code\n * @param primitive The IR primitive to render\n * @param indent Indentation string\n * @param _ctx Optional variant context for compatibility checking (reserved for future use)\n */\nfunction renderPrimitive(primitive: IRPrimitive, indent = '', _ctx?: VariantContext): string {\n  switch (primitive.type) {\n    // Navigation\n    case 'goto':\n      return `${indent}await page.goto('${escapeString(primitive.url)}');`;\n\n    case 'waitForURL':\n      const urlPattern = typeof primitive.pattern === 'string'\n        ? `/${escapeRegex(primitive.pattern)}/`\n        : primitive.pattern.toString();\n      return `${indent}await page.waitForURL(${urlPattern});`;\n\n    case 'waitForResponse':\n      return `${indent}await page.waitForResponse(resp => resp.url().includes('${escapeString(primitive.urlPattern)}'));`;\n\n    case 'waitForLoadingComplete':\n      return `${indent}await page.waitForLoadState('networkidle');`;\n\n    case 'reload':\n      return `${indent}await page.reload();`;\n\n    case 'goBack':\n      return `${indent}await page.goBack();`;\n\n    case 'goForward':\n      return `${indent}await page.goForward();`;\n\n    // Wait primitives\n    case 'waitForVisible':\n      const waitVisibleTimeout = primitive.timeout ? `, timeout: ${primitive.timeout}` : '';\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.waitFor({ state: 'visible'${waitVisibleTimeout} });`;\n\n    case 'waitForHidden':\n      const waitHiddenTimeout = primitive.timeout ? `, timeout: ${primitive.timeout}` : '';\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.waitFor({ state: 'hidden'${waitHiddenTimeout} });`;\n\n    case 'waitForTimeout':\n      return `${indent}await page.waitForTimeout(${primitive.ms});`;\n\n    case 'waitForNetworkIdle':\n      const networkIdleOptions = primitive.timeout ? `, { timeout: ${primitive.timeout} }` : '';\n      return `${indent}await page.waitForLoadState('networkidle'${networkIdleOptions});`;\n\n    // Interactions\n    case 'click':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.click();`;\n\n    case 'dblclick':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.dblclick();`;\n\n    case 'rightClick':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.click({ button: 'right' });`;\n\n    case 'fill':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.fill(${renderValue(primitive.value)});`;\n\n    case 'select':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.selectOption('${escapeString(primitive.option)}');`;\n\n    case 'check':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.check();`;\n\n    case 'uncheck':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.uncheck();`;\n\n    case 'press':\n      if (primitive.locator) {\n        return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.press('${primitive.key}');`;\n      }\n      return `${indent}await page.keyboard.press('${primitive.key}');`;\n\n    case 'hover':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.hover();`;\n\n    case 'focus':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.focus();`;\n\n    case 'clear':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.clear();`;\n\n    case 'upload':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.setInputFiles([${primitive.files.map(f => `'${escapeString(f)}'`).join(', ')}]);`;\n\n    // Assertions\n    case 'expectVisible':\n      const visibleOptions = primitive.timeout ? `{ timeout: ${primitive.timeout} }` : '';\n      return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).toBeVisible(${visibleOptions});`;\n\n    case 'expectNotVisible':\n      return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).not.toBeVisible();`;\n\n    case 'expectHidden':\n      return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).toBeHidden();`;\n\n    case 'expectText':\n      const textPattern = typeof primitive.text === 'string'\n        ? `'${escapeString(primitive.text)}'`\n        : primitive.text.toString();\n      return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).toHaveText(${textPattern});`;\n\n    case 'expectValue':\n      return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).toHaveValue('${escapeString(primitive.value)}');`;\n\n    case 'expectChecked':\n      if (primitive.checked === false) {\n        return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).not.toBeChecked();`;\n      }\n      return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).toBeChecked();`;\n\n    case 'expectEnabled':\n      return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).toBeEnabled();`;\n\n    case 'expectDisabled':\n      return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).toBeDisabled();`;\n\n    case 'expectURL':\n      const urlExpectPattern = typeof primitive.pattern === 'string'\n        ? `/${escapeRegex(primitive.pattern)}/`\n        : primitive.pattern.toString();\n      return `${indent}await expect(page).toHaveURL(${urlExpectPattern});`;\n\n    case 'expectTitle':\n      const titlePattern = typeof primitive.title === 'string'\n        ? `'${escapeString(primitive.title)}'`\n        : primitive.title.toString();\n      return `${indent}await expect(page).toHaveTitle(${titlePattern});`;\n\n    case 'expectCount':\n      return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).toHaveCount(${primitive.count});`;\n\n    case 'expectContainsText':\n      return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).toContainText('${escapeString(primitive.text)}');`;\n\n    // Signals\n    case 'expectToast':\n      const toastSelector = primitive.message\n        ? `getByText('${escapeString(primitive.message)}')`\n        : `getByRole('alert')`;\n      return `${indent}await expect(page.${toastSelector}).toBeVisible();`;\n\n    case 'dismissModal':\n      return `${indent}await page.getByRole('dialog').getByRole('button', { name: /close|cancel|dismiss/i }).click();`;\n\n    case 'acceptAlert':\n      return `${indent}page.on('dialog', dialog => dialog.accept());`;\n\n    case 'dismissAlert':\n      return `${indent}page.on('dialog', dialog => dialog.dismiss());`;\n\n    // Module calls - use factory function to create instance\n    case 'callModule':\n      // Generate factory function name from module name (e.g., LoginModule -> createLoginModule)\n      const factoryName = `create${primitive.module}`;\n      const args = primitive.args ? primitive.args.map(a => JSON.stringify(a)).join(', ') : '';\n      // Create instance via factory and call method\n      return `${indent}await ${factoryName}(page).${primitive.method}(${args});`;\n\n    // Blocked - must throw to fail the test\n    case 'blocked': {\n      const parts = primitive.reason.split(' | ');\n      const mainReason = parts[0] ?? primitive.reason;\n      const reasonDetail = parts.find(p => p.startsWith('Reason:')) ?? '';\n      const suggestion = parts.find(p => p.startsWith('Suggestion:')) ?? '';\n      const lines = [`${indent}// TODO: ${mainReason}`];\n      if (reasonDetail) lines.push(`${indent}// ${reasonDetail}`);\n      if (suggestion) lines.push(`${indent}// ${suggestion}`);\n      lines.push(`${indent}throw new Error('ARTK BLOCKED: ${escapeString(mainReason)}');`);\n      return lines.join('\\n');\n    }\n\n    default:\n      return `${indent}// Unknown primitive type: ${(primitive as { type: string }).type}`;\n  }\n}\n\n/**\n * Create a variant-aware render function for use in templates\n * @internal The ctx parameter is passed through for future variant-specific handling\n */\nfunction createVariantAwareRenderer(ctx: VariantContext): (_primitive: IRPrimitive, _indent?: string) => string {\n  // Note: ctx is passed to renderPrimitive for future variant-specific code generation\n  // Currently no primitives require variant checking, but the infrastructure is in place\n  return (primitive: IRPrimitive, indent = '') => renderPrimitive(primitive, indent, ctx);\n}\n\n/**\n * Load the default test template\n */\nfunction loadDefaultTemplate(): string {\n  const templatePath = getTemplatePath('test.ejs');\n  return readFileSync(templatePath, 'utf-8');\n}\n\n/**\n * Collect module imports from journey\n *\n * Imports factory functions (e.g., createLoginModule) for module calls.\n * The factory function naming follows the pattern: create{ModuleName}\n */\nfunction collectImports(journey: IRJourney): ImportStatement[] {\n  const imports: ImportStatement[] = [];\n  // Track unique module names to avoid duplicate imports\n  const usedModules = new Set<string>();\n\n  // Collect module calls from all steps\n  for (const step of journey.steps) {\n    for (const action of step.actions) {\n      if (action.type === 'callModule') {\n        usedModules.add(action.module);\n      }\n    }\n  }\n\n  // Convert to import statements - import factory functions\n  for (const module of usedModules) {\n    // Use lowercase-first path convention (e.g., @modules/loginModule for LoginModule)\n    const modulePath = module.charAt(0).toLowerCase() + module.slice(1);\n    // Import the factory function (e.g., createLoginModule)\n    const factoryName = `create${module}`;\n    imports.push({\n      members: [factoryName],\n      from: `@modules/${modulePath}`,\n    });\n  }\n\n  return imports;\n}\n\n/**\n * Get LLKB version and entry count if LLKB exists\n */\nfunction getLlkbInfo(llkbRoot: string): { llkbVersion: string | null; llkbEntries: number | null } {\n  const analyticsPath = join(llkbRoot, 'analytics.json');\n\n  if (!existsSync(analyticsPath)) {\n    return { llkbVersion: null, llkbEntries: null };\n  }\n\n  try {\n    const content = readFileSync(analyticsPath, 'utf-8');\n    const analytics = JSON.parse(content) as {\n      lastUpdated?: string;\n      overview?: { totalLessons?: number; totalComponents?: number };\n    };\n\n    const llkbVersion = analytics.lastUpdated || new Date().toISOString();\n    const totalLessons = analytics.overview?.totalLessons || 0;\n    const totalComponents = analytics.overview?.totalComponents || 0;\n    const llkbEntries = totalLessons + totalComponents;\n\n    return { llkbVersion, llkbEntries };\n  } catch {\n    return { llkbVersion: null, llkbEntries: null };\n  }\n}\n\n/**\n * Generate Playwright test code from IR Journey\n */\nexport function generateTest(\n  journey: IRJourney,\n  options: GenerateTestOptions = {}\n): GenerateTestResult {\n  const {\n    templatePath,\n    imports: additionalImports = [],\n    strategy = 'full',\n    existingCode,\n    llkbRoot = '.artk/llkb',\n    includeLlkbVersion = true,\n    targetVariant,\n    warnOnIncompatible = true,\n  } = options;\n\n  // Detect or use provided variant for variant-aware generation\n  const variant = targetVariant || detectVariant();\n\n  // Create variant context for compatibility checking\n  const variantCtx: VariantContext = {\n    variant,\n    warnings: [],\n    warnOnIncompatible,\n  };\n\n  // Load template\n  const template = templatePath\n    ? readFileSync(templatePath, 'utf-8')\n    : loadDefaultTemplate();\n\n  // Collect imports\n  const imports = [...collectImports(journey), ...additionalImports];\n\n  // Get LLKB version info if enabled\n  let llkbVersion: string | null = null;\n  let llkbEntries: number | null = null;\n\n  if (includeLlkbVersion) {\n    const llkbInfo = getLlkbInfo(llkbRoot);\n    llkbVersion = llkbInfo.llkbVersion;\n    llkbEntries = llkbInfo.llkbEntries;\n  }\n\n  // Create variant-aware renderer\n  const variantAwareRenderPrimitive = createVariantAwareRenderer(variantCtx);\n\n  // Render template with version branding and variant info\n  let code = ejs.render(template, {\n    journey,\n    imports,\n    renderPrimitive: variantAwareRenderPrimitive,\n    escapeString,\n    escapeRegex,\n    version: getPackageVersion(),\n    timestamp: getGeneratedTimestamp(),\n    llkbVersion,\n    llkbEntries,\n    variant: variant.id,\n    playwrightVersion: variant.playwrightVersion,\n  });\n\n  // Apply strategy-specific processing\n  if (strategy === 'blocks' && existingCode) {\n    // Use managed blocks strategy: inject generated code into existing file\n    const testBlock = {\n      id: `test-${journey.id}`,\n      content: code.trim(),\n    };\n\n    code = injectManagedBlocks({\n      existingCode,\n      newBlocks: [testBlock],\n    });\n  } else if (strategy === 'ast' && existingCode) {\n    // AST strategy would use astEdit.ts (not implemented in this task)\n    // For now, fall back to full regeneration\n    console.warn('AST strategy not yet implemented for blocks integration, using full generation');\n  }\n\n  // Generate filename\n  const filename = `${journey.id.toLowerCase()}.spec.ts`;\n\n  // Update journey frontmatter if requested\n  if (options.updateJourney && options.journeyPath) {\n    try {\n      const testPath = options.outputPath || filename;\n\n      // Extract module names from journey metadata\n      const modules = {\n        foundation: journey.moduleDependencies?.foundation || [],\n        features: journey.moduleDependencies?.feature || [], // Note: IR uses 'feature' (singular)\n      };\n\n      updateJourneyFrontmatter({\n        journeyPath: options.journeyPath,\n        testPath,\n        testContent: code,\n        modules,\n      });\n    } catch (error) {\n      // Log error but don't fail test generation\n      console.error(\n        `Warning: Failed to update journey frontmatter: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  return {\n    code,\n    journeyId: journey.id,\n    filename,\n    imports,\n    variant,\n    variantWarnings: variantCtx.warnings.length > 0 ? variantCtx.warnings : undefined,\n  };\n}\n\n/**\n * Generate test code as a string (convenience function)\n */\nexport function generateTestCode(journey: IRJourney): string {\n  return generateTest(journey).code;\n}\n","/**\n * Module Generator - Generate Page Object modules from IR\n * @see research/2026-01-02_autogen-refined-plan.md Section 12\n */\nimport { readFileSync } from 'node:fs';\nimport ejs from 'ejs';\nimport type { IRJourney, IRPrimitive, LocatorSpec } from '../ir/types.js';\nimport { toPlaywrightLocator } from '../selectors/priority.js';\nimport { getPackageVersion, getGeneratedTimestamp } from '../utils/version.js';\nimport { getTemplatePath } from '../utils/paths.js';\n\n/**\n * Locator definition for a module\n */\nexport interface ModuleLocator {\n  /** Property name for the locator */\n  name: string;\n  /** Playwright locator string */\n  playwright: string;\n  /** Original locator spec */\n  spec: LocatorSpec;\n  /** Human-readable description */\n  description?: string;\n}\n\n/**\n * Method parameter definition\n */\nexport interface MethodParam {\n  name: string;\n  type: string;\n  optional?: boolean;\n  defaultValue?: string;\n}\n\n/**\n * Method definition for a module\n */\nexport interface ModuleMethod {\n  /** Method name */\n  name: string;\n  /** Method description */\n  description: string;\n  /** Method parameters */\n  params: MethodParam[];\n  /** Return type */\n  returnType: string;\n  /** Method body lines */\n  body: string[];\n}\n\n/**\n * Module definition\n */\nexport interface ModuleDefinition {\n  /** Module name (PascalCase) */\n  moduleName: string;\n  /** Class name (PascalCase with suffix) */\n  className: string;\n  /** Module scope (feature area) */\n  scope: string;\n  /** Locators used by the module */\n  locators: ModuleLocator[];\n  /** Methods provided by the module */\n  methods: ModuleMethod[];\n}\n\n/**\n * Options for module generation\n */\nexport interface GenerateModuleOptions {\n  /** Custom template path */\n  templatePath?: string;\n  /** Module name suffix (default: 'Page') */\n  suffix?: string;\n  /** Whether to include JSDoc comments */\n  includeJsDoc?: boolean;\n}\n\n/**\n * Result of module generation\n */\nexport interface GenerateModuleResult {\n  /** Generated module code */\n  code: string;\n  /** Module name */\n  moduleName: string;\n  /** Suggested filename */\n  filename: string;\n  /** Locators defined */\n  locators: ModuleLocator[];\n  /** Methods defined */\n  methods: ModuleMethod[];\n}\n\n/**\n * Convert a scope/name to PascalCase class name\n */\nfunction toPascalCase(str: string): string {\n  return str\n    .split(/[-_\\s]+/)\n    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n    .join('');\n}\n\n/**\n * Convert a name to camelCase\n */\nfunction toCamelCase(str: string): string {\n  const pascal = toPascalCase(str);\n  return pascal.charAt(0).toLowerCase() + pascal.slice(1);\n}\n\n/**\n * Generate a unique locator name from a locator spec\n */\nfunction generateLocatorName(spec: LocatorSpec, existingNames: Set<string>): string {\n  let baseName: string;\n\n  // Generate base name from spec\n  switch (spec.strategy) {\n    case 'role':\n      baseName = spec.options?.name\n        ? `${toCamelCase(spec.options.name)}${toPascalCase(spec.value)}`\n        : `${toCamelCase(spec.value)}Element`;\n      break;\n    case 'label':\n    case 'placeholder':\n    case 'text':\n      baseName = `${toCamelCase(spec.value)}Field`;\n      break;\n    case 'testid':\n      baseName = toCamelCase(spec.value);\n      break;\n    case 'css':\n      // Extract meaningful name from CSS selector\n      const match = spec.value.match(/[#.]?([a-zA-Z][a-zA-Z0-9_-]*)/);\n      baseName = match ? toCamelCase(match[1]!) : 'element';\n      break;\n    default:\n      baseName = 'element';\n  }\n\n  // Ensure uniqueness\n  let name = baseName;\n  let counter = 1;\n  while (existingNames.has(name)) {\n    name = `${baseName}${counter}`;\n    counter++;\n  }\n  existingNames.add(name);\n\n  return name;\n}\n\n/**\n * Extract locators from journey primitives\n */\nfunction extractLocators(journey: IRJourney): ModuleLocator[] {\n  const locators: ModuleLocator[] = [];\n  const existingNames = new Set<string>();\n  const seenSpecs = new Map<string, ModuleLocator>();\n\n  // Helper to process a primitive\n  const processPrimitive = (primitive: IRPrimitive) => {\n    // Check if primitive has a locator\n    const locatorSpec = (primitive as { locator?: LocatorSpec }).locator;\n    if (!locatorSpec) return;\n\n    // Create a unique key for the locator spec\n    const specKey = JSON.stringify(locatorSpec);\n    if (seenSpecs.has(specKey)) return;\n\n    const name = generateLocatorName(locatorSpec, existingNames);\n    const playwrightLocator = toPlaywrightLocator(locatorSpec);\n\n    const locator: ModuleLocator = {\n      name,\n      playwright: playwrightLocator,\n      spec: locatorSpec,\n      description: `Locator for ${locatorSpec.strategy}: ${locatorSpec.value}`,\n    };\n\n    locators.push(locator);\n    seenSpecs.set(specKey, locator);\n  };\n\n  // Process setup\n  if (journey.setup) {\n    for (const primitive of journey.setup) {\n      processPrimitive(primitive);\n    }\n  }\n\n  // Process steps\n  for (const step of journey.steps) {\n    for (const action of step.actions) {\n      processPrimitive(action);\n    }\n    for (const assertion of step.assertions) {\n      processPrimitive(assertion);\n    }\n  }\n\n  // Process cleanup\n  if (journey.cleanup) {\n    for (const primitive of journey.cleanup) {\n      processPrimitive(primitive);\n    }\n  }\n\n  return locators;\n}\n\n/**\n * Generate methods from journey steps\n */\nfunction generateMethods(journey: IRJourney, locators: ModuleLocator[]): ModuleMethod[] {\n  const methods: ModuleMethod[] = [];\n  const locatorMap = new Map<string, string>();\n\n  // Build locator lookup map\n  for (const locator of locators) {\n    const specKey = JSON.stringify(locator.spec);\n    locatorMap.set(specKey, locator.name);\n  }\n\n  // Helper to get locator reference\n  const getLocatorRef = (spec: LocatorSpec): string => {\n    const specKey = JSON.stringify(spec);\n    const locatorName = locatorMap.get(specKey);\n    return locatorName ? `this.${locatorName}` : `this.page.${toPlaywrightLocator(spec)}`;\n  };\n\n  // Generate a method for each step\n  for (const step of journey.steps) {\n    const methodName = toCamelCase(step.id.replace(/[^a-zA-Z0-9]/g, '_'));\n    const body: string[] = [];\n\n    // Add actions\n    for (const action of step.actions) {\n      const line = primitiveToMethodLine(action, getLocatorRef);\n      if (line) {\n        body.push(line);\n      }\n    }\n\n    // Add assertions\n    for (const assertion of step.assertions) {\n      const line = primitiveToMethodLine(assertion, getLocatorRef);\n      if (line) {\n        body.push(line);\n      }\n    }\n\n    if (body.length > 0) {\n      methods.push({\n        name: methodName,\n        description: step.description,\n        params: [],\n        returnType: 'void',\n        body,\n      });\n    }\n  }\n\n  return methods;\n}\n\n/**\n * Convert a primitive to a method body line\n */\nfunction primitiveToMethodLine(\n  primitive: IRPrimitive,\n  getLocatorRef: (_spec: LocatorSpec) => string\n): string | null {\n  switch (primitive.type) {\n    // Navigation\n    case 'goto':\n      return `await this.page.goto('${escapeString(primitive.url)}');`;\n\n    case 'waitForURL':\n      const urlPattern = typeof primitive.pattern === 'string'\n        ? `'${escapeString(primitive.pattern)}'`\n        : primitive.pattern.toString();\n      return `await this.page.waitForURL(${urlPattern});`;\n\n    case 'waitForLoadingComplete':\n      return `await this.page.waitForLoadState('networkidle');`;\n\n    // Interactions\n    case 'click':\n      return `await ${getLocatorRef(primitive.locator)}.click();`;\n\n    case 'fill':\n      const value = primitive.value.type === 'literal'\n        ? `'${escapeString(primitive.value.value)}'`\n        : primitive.value.value;\n      return `await ${getLocatorRef(primitive.locator)}.fill(${value});`;\n\n    case 'select':\n      return `await ${getLocatorRef(primitive.locator)}.selectOption('${escapeString(primitive.option)}');`;\n\n    case 'check':\n      return `await ${getLocatorRef(primitive.locator)}.check();`;\n\n    case 'uncheck':\n      return `await ${getLocatorRef(primitive.locator)}.uncheck();`;\n\n    case 'press':\n      if (primitive.locator) {\n        return `await ${getLocatorRef(primitive.locator)}.press('${primitive.key}');`;\n      }\n      return `await this.page.keyboard.press('${primitive.key}');`;\n\n    case 'hover':\n      return `await ${getLocatorRef(primitive.locator)}.hover();`;\n\n    case 'focus':\n      return `await ${getLocatorRef(primitive.locator)}.focus();`;\n\n    case 'clear':\n      return `await ${getLocatorRef(primitive.locator)}.clear();`;\n\n    // Assertions (using expect)\n    case 'expectVisible':\n      return `await expect(${getLocatorRef(primitive.locator)}).toBeVisible();`;\n\n    case 'expectNotVisible':\n      return `await expect(${getLocatorRef(primitive.locator)}).not.toBeVisible();`;\n\n    case 'expectText':\n      const textPattern = typeof primitive.text === 'string'\n        ? `'${escapeString(primitive.text)}'`\n        : primitive.text.toString();\n      return `await expect(${getLocatorRef(primitive.locator)}).toHaveText(${textPattern});`;\n\n    case 'expectValue':\n      return `await expect(${getLocatorRef(primitive.locator)}).toHaveValue('${escapeString(primitive.value)}');`;\n\n    case 'expectEnabled':\n      return `await expect(${getLocatorRef(primitive.locator)}).toBeEnabled();`;\n\n    case 'expectDisabled':\n      return `await expect(${getLocatorRef(primitive.locator)}).toBeDisabled();`;\n\n    // Blocked - must throw to fail the test\n    case 'blocked': {\n      const parts = primitive.reason.split(' | ');\n      const mainReason = parts[0] ?? primitive.reason;\n      const reasonDetail = parts.find(p => p.startsWith('Reason:')) ?? '';\n      const suggestion = parts.find(p => p.startsWith('Suggestion:')) ?? '';\n      const lines = [`// TODO: ${mainReason}`];\n      if (reasonDetail) lines.push(`    // ${reasonDetail}`);\n      if (suggestion) lines.push(`    // ${suggestion}`);\n      lines.push(`    throw new Error('ARTK BLOCKED: ${escapeString(mainReason)}');`);\n      return lines.join('\\n');\n    }\n\n    default:\n      return null;\n  }\n}\n\n/**\n * Escape string for code generation\n */\nfunction escapeString(str: string): string {\n  return str\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/'/g, \"\\\\'\")\n    .replace(/\"/g, '\\\\\"')\n    .replace(/\\n/g, '\\\\n')\n    .replace(/\\r/g, '\\\\r');\n}\n\n/**\n * Load the default module template\n */\nfunction loadDefaultTemplate(): string {\n  const templatePath = getTemplatePath('module.ejs');\n  return readFileSync(templatePath, 'utf-8');\n}\n\n/**\n * Generate Page Object module from IR Journey\n */\nexport function generateModule(\n  journey: IRJourney,\n  options: GenerateModuleOptions = {}\n): GenerateModuleResult {\n  const { templatePath, suffix = 'Page' } = options;\n\n  // Load template\n  const template = templatePath\n    ? readFileSync(templatePath, 'utf-8')\n    : loadDefaultTemplate();\n\n  // Generate module/class names\n  const moduleName = toPascalCase(journey.scope);\n  const className = `${moduleName}${suffix}`;\n\n  // Extract locators and generate methods\n  const locators = extractLocators(journey);\n  const methods = generateMethods(journey, locators);\n\n  // Create module definition\n  const moduleDef: ModuleDefinition = {\n    moduleName,\n    className,\n    scope: journey.scope,\n    locators,\n    methods,\n  };\n\n  // Render template with version branding\n  const code = ejs.render(template, {\n    ...moduleDef,\n    version: getPackageVersion(),\n    timestamp: getGeneratedTimestamp(),\n  });\n\n  // Generate filename\n  const filename = `${journey.scope.toLowerCase()}.page.ts`;\n\n  return {\n    code,\n    moduleName,\n    filename,\n    locators,\n    methods,\n  };\n}\n\n/**\n * Generate module code as a string (convenience function)\n */\nexport function generateModuleCode(journey: IRJourney): string {\n  return generateModule(journey).code;\n}\n\n/**\n * Extract module definition from journey without generating code\n */\nexport function extractModuleDefinition(\n  journey: IRJourney,\n  options: GenerateModuleOptions = {}\n): ModuleDefinition {\n  const { suffix = 'Page' } = options;\n\n  const moduleName = toPascalCase(journey.scope);\n  const className = `${moduleName}${suffix}`;\n  const locators = extractLocators(journey);\n  const methods = generateMethods(journey, locators);\n\n  return {\n    moduleName,\n    className,\n    scope: journey.scope,\n    locators,\n    methods,\n  };\n}\n","/**\n * AST-based Code Editing - Safely modify existing TypeScript files\n * @see research/2026-01-02_autogen-refined-plan.md Section 12\n */\nimport {\n  Project,\n  SourceFile,\n  ClassDeclaration,\n  MethodDeclaration,\n  PropertyDeclaration,\n  ImportDeclaration,\n  SyntaxKind,\n  ScriptTarget,\n  ModuleKind,\n} from 'ts-morph';\nimport type { ModuleLocator, ModuleMethod } from './generateModule.js';\n\n/**\n * Result of an AST edit operation\n */\nexport interface AstEditResult {\n  /** Whether any changes were made */\n  modified: boolean;\n  /** List of changes made */\n  changes: string[];\n  /** Updated source code */\n  code: string;\n  /** Any warnings generated */\n  warnings: string[];\n}\n\n/**\n * Options for AST editing\n */\nexport interface AstEditOptions {\n  /** Preserve existing methods (don't overwrite) */\n  preserveExisting?: boolean;\n  /** Add new imports automatically */\n  addImports?: boolean;\n  /** Format code after editing */\n  formatOutput?: boolean;\n}\n\n/**\n * Create a ts-morph project for editing\n */\nexport function createProject(): Project {\n  return new Project({\n    useInMemoryFileSystem: true,\n    compilerOptions: {\n      target: ScriptTarget.ESNext,\n      module: ModuleKind.ESNext,\n      strict: true,\n    },\n  });\n}\n\n/**\n * Load source file from code string\n */\nexport function loadSourceFile(project: Project, code: string, filename = 'temp.ts'): SourceFile {\n  return project.createSourceFile(filename, code, { overwrite: true });\n}\n\n/**\n * Find a class declaration by name\n */\nexport function findClass(sourceFile: SourceFile, className: string): ClassDeclaration | undefined {\n  return sourceFile.getClass(className);\n}\n\n/**\n * Find a method in a class\n */\nexport function findMethod(classDecl: ClassDeclaration, methodName: string): MethodDeclaration | undefined {\n  return classDecl.getMethod(methodName);\n}\n\n/**\n * Find a property in a class\n */\nexport function findProperty(classDecl: ClassDeclaration, propertyName: string): PropertyDeclaration | undefined {\n  return classDecl.getProperty(propertyName);\n}\n\n/**\n * Check if an import exists\n */\nexport function hasImport(sourceFile: SourceFile, moduleSpecifier: string): boolean {\n  return sourceFile.getImportDeclarations().some(\n    imp => imp.getModuleSpecifierValue() === moduleSpecifier\n  );\n}\n\n/**\n * Get import declaration for a module\n */\nexport function getImport(sourceFile: SourceFile, moduleSpecifier: string): ImportDeclaration | undefined {\n  return sourceFile.getImportDeclarations().find(\n    imp => imp.getModuleSpecifierValue() === moduleSpecifier\n  );\n}\n\n/**\n * Add a named import to a file\n */\nexport function addNamedImport(\n  sourceFile: SourceFile,\n  moduleSpecifier: string,\n  namedImport: string\n): boolean {\n  const existingImport = getImport(sourceFile, moduleSpecifier);\n\n  if (existingImport) {\n    // Check if the named import already exists\n    const namedImports = existingImport.getNamedImports();\n    const exists = namedImports.some(ni => ni.getName() === namedImport);\n\n    if (!exists) {\n      existingImport.addNamedImport(namedImport);\n      return true;\n    }\n    return false;\n  }\n\n  // Add new import declaration\n  sourceFile.addImportDeclaration({\n    moduleSpecifier,\n    namedImports: [namedImport],\n  });\n  return true;\n}\n\n/**\n * Result of adding a locator property\n */\nexport interface AddLocatorResult {\n  /** Whether the property was added */\n  added: boolean;\n  /** Whether initialization was complete */\n  initialized: boolean;\n  /** Warning message if initialization was incomplete */\n  warning?: string;\n}\n\n/**\n * Add a locator property to a class\n *\n * @returns Result object with added/initialized status and optional warning\n */\nexport function addLocatorProperty(\n  classDecl: ClassDeclaration,\n  locator: ModuleLocator,\n  options: AstEditOptions = {}\n): AddLocatorResult {\n  const existing = findProperty(classDecl, locator.name);\n\n  if (existing) {\n    if (options.preserveExisting) {\n      return { added: false, initialized: false };\n    }\n    existing.remove();\n  }\n\n  // Add readonly property declaration\n  classDecl.addProperty({\n    name: locator.name,\n    isReadonly: true,\n    type: 'Locator',\n    docs: locator.description ? [{ description: locator.description }] : undefined,\n  });\n\n  const initStatement = `this.${locator.name} = page.${locator.playwright};`;\n\n  // Find or create constructor\n  let constructor = classDecl.getConstructors()[0];\n  if (!constructor) {\n    // Create constructor with page parameter\n    constructor = classDecl.addConstructor({\n      parameters: [{ name: 'page', type: 'Page' }],\n      statements: [`this.page = page;`, initStatement],\n    });\n\n    // Add page property if it doesn't exist\n    if (!findProperty(classDecl, 'page')) {\n      classDecl.insertProperty(0, {\n        name: 'page',\n        isReadonly: true,\n        type: 'Page',\n      });\n    }\n\n    return { added: true, initialized: true };\n  }\n\n  // Ensure constructor has a body\n  let body = constructor.getBody();\n  if (!body) {\n    // Add empty body to constructor\n    constructor.setBodyText('');\n    body = constructor.getBody();\n    if (!body) {\n      return {\n        added: true,\n        initialized: false,\n        warning: `Cannot add body to constructor for '${locator.name}' initialization`,\n      };\n    }\n  }\n\n  // Check if initialization already exists\n  const existingInit = body.getDescendantsOfKind(SyntaxKind.ExpressionStatement)\n    .find(stmt => stmt.getText().includes(`this.${locator.name}`));\n\n  if (!existingInit) {\n    constructor.addStatements(initStatement);\n  }\n\n  return { added: true, initialized: true };\n}\n\n/**\n * Add a method to a class\n */\nexport function addMethod(\n  classDecl: ClassDeclaration,\n  method: ModuleMethod,\n  options: AstEditOptions = {}\n): boolean {\n  const existing = findMethod(classDecl, method.name);\n\n  if (existing) {\n    if (options.preserveExisting) {\n      return false;\n    }\n    existing.remove();\n  }\n\n  // Add the method\n  classDecl.addMethod({\n    name: method.name,\n    isAsync: true,\n    parameters: method.params.map(p => ({\n      name: p.name,\n      type: p.type,\n      hasQuestionToken: p.optional,\n      initializer: p.defaultValue,\n    })),\n    returnType: `Promise<${method.returnType}>`,\n    docs: [{ description: method.description }],\n    statements: method.body.join('\\n'),\n  });\n\n  return true;\n}\n\n/**\n * Update an existing module file with new locators and methods\n */\nexport function updateModuleFile(\n  code: string,\n  className: string,\n  locators: ModuleLocator[],\n  methods: ModuleMethod[],\n  options: AstEditOptions = {}\n): AstEditResult {\n  const project = createProject();\n  const sourceFile = loadSourceFile(project, code);\n  const changes: string[] = [];\n  const warnings: string[] = [];\n\n  // Find the class\n  const classDecl = findClass(sourceFile, className);\n  if (!classDecl) {\n    return {\n      modified: false,\n      changes: [],\n      code,\n      warnings: [`Class '${className}' not found in source file`],\n    };\n  }\n\n  // Ensure Locator import exists\n  if (options.addImports !== false) {\n    if (addNamedImport(sourceFile, '@playwright/test', 'Locator')) {\n      changes.push('Added Locator import');\n    }\n    if (addNamedImport(sourceFile, '@playwright/test', 'expect')) {\n      changes.push('Added expect import');\n    }\n  }\n\n  // Add locators\n  for (const locator of locators) {\n    const result = addLocatorProperty(classDecl, locator, options);\n    if (result.added) {\n      changes.push(`Added locator: ${locator.name}`);\n      if (result.warning) {\n        warnings.push(result.warning);\n      }\n    } else if (options.preserveExisting) {\n      warnings.push(`Skipped existing locator: ${locator.name}`);\n    }\n  }\n\n  // Add methods\n  for (const method of methods) {\n    const added = addMethod(classDecl, method, options);\n    if (added) {\n      changes.push(`Added method: ${method.name}`);\n    } else if (options.preserveExisting) {\n      warnings.push(`Skipped existing method: ${method.name}`);\n    }\n  }\n\n  // Format if requested\n  if (options.formatOutput !== false) {\n    sourceFile.formatText();\n  }\n\n  return {\n    modified: changes.length > 0,\n    changes,\n    code: sourceFile.getFullText(),\n    warnings,\n  };\n}\n\n/**\n * Extract method body text safely\n */\nfunction extractMethodBodyText(method: MethodDeclaration): string {\n  const body = method.getBody();\n  if (!body) return '';\n\n  // Get the text between { and }\n  const fullText = body.getText();\n  // Remove the braces and trim\n  const inner = fullText.slice(1, -1).trim();\n  return inner;\n}\n\n/**\n * Merge two module files, preferring the second for conflicts\n */\nexport function mergeModuleFiles(\n  existingCode: string,\n  newCode: string,\n  className: string,\n  options: AstEditOptions = {}\n): AstEditResult {\n  const project = createProject();\n  const existingFile = loadSourceFile(project, existingCode, 'existing.ts');\n  const newFile = loadSourceFile(project, newCode, 'new.ts');\n  const changes: string[] = [];\n  const warnings: string[] = [];\n\n  // Find classes\n  const existingClass = findClass(existingFile, className);\n  const newClass = findClass(newFile, className);\n\n  if (!existingClass) {\n    return {\n      modified: false,\n      changes: [],\n      code: existingCode,\n      warnings: [`Class '${className}' not found in existing file`],\n    };\n  }\n\n  if (!newClass) {\n    return {\n      modified: false,\n      changes: [],\n      code: existingCode,\n      warnings: [`Class '${className}' not found in new file`],\n    };\n  }\n\n  // Merge imports\n  const newImports = newFile.getImportDeclarations();\n  for (const imp of newImports) {\n    const moduleSpec = imp.getModuleSpecifierValue();\n    for (const namedImp of imp.getNamedImports()) {\n      if (addNamedImport(existingFile, moduleSpec, namedImp.getName())) {\n        changes.push(`Added import: ${namedImp.getName()} from ${moduleSpec}`);\n      }\n    }\n  }\n\n  // Merge properties\n  const newProperties = newClass.getProperties();\n  for (const prop of newProperties) {\n    const propName = prop.getName();\n    const existingProp = findProperty(existingClass, propName);\n\n    if (!existingProp) {\n      existingClass.addProperty({\n        name: propName,\n        isReadonly: prop.isReadonly(),\n        type: prop.getType().getText(),\n      });\n      changes.push(`Added property: ${propName}`);\n    } else if (!options.preserveExisting) {\n      existingProp.remove();\n      existingClass.addProperty({\n        name: propName,\n        isReadonly: prop.isReadonly(),\n        type: prop.getType().getText(),\n      });\n      changes.push(`Updated property: ${propName}`);\n    } else {\n      warnings.push(`Skipped existing property: ${propName}`);\n    }\n  }\n\n  // Merge methods\n  const newMethods = newClass.getMethods();\n  for (const method of newMethods) {\n    const methodName = method.getName();\n    const existingMethod = findMethod(existingClass, methodName);\n\n    if (!existingMethod) {\n      existingClass.addMethod({\n        name: methodName,\n        isAsync: method.isAsync(),\n        parameters: method.getParameters().map(p => ({\n          name: p.getName(),\n          type: p.getType().getText(),\n          hasQuestionToken: p.hasQuestionToken(),\n          initializer: p.getInitializer()?.getText(),\n        })),\n        returnType: method.getReturnType().getText(),\n        statements: extractMethodBodyText(method),\n      });\n      changes.push(`Added method: ${methodName}`);\n    } else if (!options.preserveExisting) {\n      existingMethod.remove();\n      existingClass.addMethod({\n        name: methodName,\n        isAsync: method.isAsync(),\n        parameters: method.getParameters().map(p => ({\n          name: p.getName(),\n          type: p.getType().getText(),\n          hasQuestionToken: p.hasQuestionToken(),\n          initializer: p.getInitializer()?.getText(),\n        })),\n        returnType: method.getReturnType().getText(),\n        statements: extractMethodBodyText(method),\n      });\n      changes.push(`Updated method: ${methodName}`);\n    } else {\n      warnings.push(`Skipped existing method: ${methodName}`);\n    }\n  }\n\n  // Format\n  if (options.formatOutput !== false) {\n    existingFile.formatText();\n  }\n\n  return {\n    modified: changes.length > 0,\n    changes,\n    code: existingFile.getFullText(),\n    warnings,\n  };\n}\n\n/**\n * Extract class structure from source code\n */\nexport function extractClassStructure(code: string, className: string): {\n  properties: string[];\n  methods: string[];\n  imports: string[];\n} | null {\n  const project = createProject();\n  const sourceFile = loadSourceFile(project, code);\n  const classDecl = findClass(sourceFile, className);\n\n  if (!classDecl) {\n    return null;\n  }\n\n  return {\n    properties: classDecl.getProperties().map(p => p.getName()),\n    methods: classDecl.getMethods().map(m => m.getName()),\n    imports: sourceFile.getImportDeclarations()\n      .flatMap(imp => imp.getNamedImports().map(ni => ni.getName())),\n  };\n}\n\n/**\n * Validate TypeScript code syntax\n */\nexport function validateSyntax(code: string): {\n  valid: boolean;\n  errors: string[];\n} {\n  const project = createProject();\n\n  try {\n    const sourceFile = loadSourceFile(project, code);\n    const diagnostics = sourceFile.getPreEmitDiagnostics();\n\n    const errors = diagnostics\n      .filter(d => d.getCategory() === 1) // Error category\n      .map(d => d.getMessageText().toString());\n\n    return {\n      valid: errors.length === 0,\n      errors,\n    };\n  } catch (error) {\n    return {\n      valid: false,\n      errors: [(error as Error).message],\n    };\n  }\n}\n","/**\n * Module Registry - Track and update module index files\n * @see research/2026-01-02_autogen-refined-plan.md Section 12\n */\nimport { readFileSync, writeFileSync, existsSync } from 'node:fs';\nimport { basename, dirname, relative } from 'node:path';\nimport { Project } from 'ts-morph';\nimport type { ModuleDefinition } from './generateModule.js';\n\n/**\n * Module registry entry\n */\nexport interface RegistryEntry {\n  /** Module name (PascalCase) */\n  moduleName: string;\n  /** Class name */\n  className: string;\n  /** File path relative to registry */\n  filePath: string;\n  /** Module scope */\n  scope: string;\n  /** Export type */\n  exportType: 'class' | 'function' | 'const';\n}\n\n/**\n * Module registry state\n */\nexport interface ModuleRegistry {\n  /** Registry file path */\n  registryPath: string;\n  /** Registered modules */\n  entries: RegistryEntry[];\n  /** Last updated timestamp */\n  lastUpdated: Date;\n}\n\n/**\n * Options for registry operations\n */\nexport interface RegistryOptions {\n  /** Create registry file if it doesn't exist */\n  createIfMissing?: boolean;\n  /** Preserve manual exports in index file */\n  preserveManualExports?: boolean;\n  /** Sort exports alphabetically */\n  sortExports?: boolean;\n}\n\n/**\n * Result of registry update\n */\nexport interface RegistryUpdateResult {\n  /** Whether the registry was modified */\n  modified: boolean;\n  /** Entries added */\n  added: string[];\n  /** Entries removed */\n  removed: string[];\n  /** Updated registry content */\n  content: string;\n}\n\n/**\n * Load module registry from an index file\n */\nexport function loadRegistry(indexPath: string): ModuleRegistry | null {\n  if (!existsSync(indexPath)) {\n    return null;\n  }\n\n  const content = readFileSync(indexPath, 'utf-8');\n  const entries = parseIndexFile(content, indexPath);\n\n  return {\n    registryPath: indexPath,\n    entries,\n    lastUpdated: new Date(),\n  };\n}\n\n/**\n * Parse an index.ts file to extract module entries\n */\nexport function parseIndexFile(content: string, _indexPath?: string): RegistryEntry[] {\n  const entries: RegistryEntry[] = [];\n  const project = new Project({ useInMemoryFileSystem: true });\n  const sourceFile = project.createSourceFile('index.ts', content);\n\n  // Parse export declarations\n  const exportDeclarations = sourceFile.getExportDeclarations();\n\n  for (const exportDecl of exportDeclarations) {\n    const moduleSpecifier = exportDecl.getModuleSpecifierValue();\n    if (!moduleSpecifier) continue;\n\n    const namedExports = exportDecl.getNamedExports();\n\n    for (const namedExport of namedExports) {\n      const exportName = namedExport.getName();\n      const aliasNode = namedExport.getAliasNode();\n      const alias = aliasNode ? aliasNode.getText() : exportName;\n\n      // Determine export type from name convention\n      let exportType: 'class' | 'function' | 'const' = 'class';\n      if (exportName.startsWith('create') || exportName.endsWith('Factory')) {\n        exportType = 'function';\n      } else if (exportName === exportName.toUpperCase()) {\n        exportType = 'const';\n      }\n\n      entries.push({\n        moduleName: alias,\n        className: exportName,\n        filePath: moduleSpecifier,\n        scope: extractScope(moduleSpecifier),\n        exportType,\n      });\n    }\n  }\n\n  // Parse re-exports (export * from './module')\n  const starExports = content.match(/export\\s+\\*\\s+from\\s+['\"]([^'\"]+)['\"]/g);\n  if (starExports) {\n    for (const match of starExports) {\n      const pathMatch = match.match(/['\"]([^'\"]+)['\"]/);\n      if (pathMatch) {\n        const modulePath = pathMatch[1]!;\n        entries.push({\n          moduleName: extractModuleName(modulePath),\n          className: '*',\n          filePath: modulePath,\n          scope: extractScope(modulePath),\n          exportType: 'class',\n        });\n      }\n    }\n  }\n\n  return entries;\n}\n\n/**\n * Extract module name from file path\n */\nfunction extractModuleName(filePath: string): string {\n  const base = basename(filePath, '.js').replace('.page', '');\n  return toPascalCase(base);\n}\n\n/**\n * Extract scope from file path\n */\nfunction extractScope(filePath: string): string {\n  // e.g., './auth/login.page.js' -> 'auth'\n  const dir = dirname(filePath);\n  if (dir === '.' || dir === './') {\n    return basename(filePath, '.js').replace('.page', '');\n  }\n  return basename(dir);\n}\n\n/**\n * Convert to PascalCase\n */\nfunction toPascalCase(str: string): string {\n  return str\n    .split(/[-_\\s]+/)\n    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n    .join('');\n}\n\n/**\n * Generate index file content from entries\n */\nexport function generateIndexContent(\n  entries: RegistryEntry[],\n  options: RegistryOptions = {}\n): string {\n  const lines: string[] = [\n    '/**',\n    ' * Module Registry - Auto-generated index',\n    ' * @generated by @artk/core-autogen',\n    ' */',\n  ];\n\n  // Group entries by file path\n  const byFile = new Map<string, RegistryEntry[]>();\n  for (const entry of entries) {\n    const existing = byFile.get(entry.filePath) || [];\n    existing.push(entry);\n    byFile.set(entry.filePath, existing);\n  }\n\n  // Sort if requested\n  let filePaths = Array.from(byFile.keys());\n  if (options.sortExports) {\n    filePaths = filePaths.sort();\n  }\n\n  // Generate exports\n  for (const filePath of filePaths) {\n    const fileEntries = byFile.get(filePath)!;\n\n    // Check if it's a star export\n    if (fileEntries.length === 1 && fileEntries[0]!.className === '*') {\n      lines.push(`export * from '${filePath}';`);\n    } else {\n      // Named exports\n      const exports = fileEntries.map(e => {\n        if (e.moduleName !== e.className) {\n          return `${e.className} as ${e.moduleName}`;\n        }\n        return e.className;\n      });\n\n      if (options.sortExports) {\n        exports.sort();\n      }\n\n      lines.push(`export { ${exports.join(', ')} } from '${filePath}';`);\n    }\n  }\n\n  return lines.join('\\n') + '\\n';\n}\n\n/**\n * Add a module to the registry\n */\nexport function addToRegistry(\n  registry: ModuleRegistry,\n  module: ModuleDefinition,\n  filePath: string\n): RegistryEntry {\n  const entry: RegistryEntry = {\n    moduleName: module.moduleName,\n    className: module.className,\n    filePath,\n    scope: module.scope,\n    exportType: 'class',\n  };\n\n  // Check if already exists\n  const existingIndex = registry.entries.findIndex(\n    e => e.filePath === filePath || e.moduleName === module.moduleName\n  );\n\n  if (existingIndex >= 0) {\n    registry.entries[existingIndex] = entry;\n  } else {\n    registry.entries.push(entry);\n  }\n\n  registry.lastUpdated = new Date();\n  return entry;\n}\n\n/**\n * Remove a module from the registry\n */\nexport function removeFromRegistry(\n  registry: ModuleRegistry,\n  moduleNameOrPath: string\n): boolean {\n  const initialLength = registry.entries.length;\n\n  registry.entries = registry.entries.filter(\n    e => e.moduleName !== moduleNameOrPath && e.filePath !== moduleNameOrPath\n  );\n\n  const removed = registry.entries.length < initialLength;\n  if (removed) {\n    registry.lastUpdated = new Date();\n  }\n\n  return removed;\n}\n\n/**\n * Update index file with new modules\n */\nexport function updateIndexFile(\n  indexPath: string,\n  newModules: Array<{ module: ModuleDefinition; filePath: string }>,\n  options: RegistryOptions = {}\n): RegistryUpdateResult {\n  let registry = loadRegistry(indexPath);\n  const added: string[] = [];\n  const removed: string[] = [];\n\n  if (!registry) {\n    if (!options.createIfMissing) {\n      return {\n        modified: false,\n        added: [],\n        removed: [],\n        content: '',\n      };\n    }\n\n    registry = {\n      registryPath: indexPath,\n      entries: [],\n      lastUpdated: new Date(),\n    };\n  }\n\n  // Track existing entries if preserving\n  const existingNames = new Set(registry.entries.map(e => e.moduleName));\n\n  // Add new modules\n  for (const { module, filePath } of newModules) {\n    const relativePath = filePath.startsWith('.')\n      ? filePath\n      : `./${relative(dirname(indexPath), filePath).replace(/\\\\/g, '/')}`;\n\n    // Remove .ts extension and add .js for ESM\n    const importPath = relativePath.replace(/\\.ts$/, '.js');\n\n    addToRegistry(registry, module, importPath);\n\n    if (!existingNames.has(module.moduleName)) {\n      added.push(module.moduleName);\n    }\n  }\n\n  // Generate updated content\n  const content = generateIndexContent(registry.entries, options);\n\n  return {\n    modified: added.length > 0 || removed.length > 0,\n    added,\n    removed,\n    content,\n  };\n}\n\n/**\n * Scan directory for module files and build registry\n */\nexport function scanModulesDirectory(\n  _dirPath: string,\n  _pattern = '*.page.ts'\n): RegistryEntry[] {\n  // This is a simplified implementation\n  // In production, would use glob to find files\n  // For now, return empty array - actual scanning happens via glob in CLI\n  return [];\n}\n\n/**\n * Create a new empty registry\n */\nexport function createRegistry(indexPath: string): ModuleRegistry {\n  return {\n    registryPath: indexPath,\n    entries: [],\n    lastUpdated: new Date(),\n  };\n}\n\n/**\n * Save registry to disk\n */\nexport function saveRegistry(\n  registry: ModuleRegistry,\n  options: RegistryOptions = {}\n): void {\n  const content = generateIndexContent(registry.entries, options);\n  writeFileSync(registry.registryPath, content, 'utf-8');\n}\n\n/**\n * Find entry by module name\n */\nexport function findEntry(\n  registry: ModuleRegistry,\n  moduleName: string\n): RegistryEntry | undefined {\n  return registry.entries.find(e => e.moduleName === moduleName);\n}\n\n/**\n * Find entry by scope\n */\nexport function findEntriesByScope(\n  registry: ModuleRegistry,\n  scope: string\n): RegistryEntry[] {\n  return registry.entries.filter(e => e.scope === scope);\n}\n\n/**\n * Check if module exists in registry\n */\nexport function hasModule(registry: ModuleRegistry, moduleName: string): boolean {\n  return registry.entries.some(e => e.moduleName === moduleName);\n}\n\n/**\n * Get all module names\n */\nexport function getModuleNames(registry: ModuleRegistry): string[] {\n  return registry.entries.map(e => e.moduleName);\n}\n\n/**\n * Get registry statistics\n */\nexport function getRegistryStats(registry: ModuleRegistry): {\n  totalModules: number;\n  byScope: Record<string, number>;\n  byType: Record<string, number>;\n} {\n  const byScope: Record<string, number> = {};\n  const byType: Record<string, number> = {};\n\n  for (const entry of registry.entries) {\n    byScope[entry.scope] = (byScope[entry.scope] || 0) + 1;\n    byType[entry.exportType] = (byType[entry.exportType] || 0) + 1;\n  }\n\n  return {\n    totalModules: registry.entries.length,\n    byScope,\n    byType,\n  };\n}\n","/**\n * Safe parsing utilities for CLI arguments and configuration values\n *\n * These utilities prevent common issues with parseInt/parseFloat:\n * - NaN propagation from invalid input\n * - Silent failures from unexpected input types\n * - Negative values where only positive are expected\n *\n * @see research/2026-01-15_code_quality_standards.md Category 4\n */\n\n/**\n * Parse integer with validation and fallback\n *\n * @param value - String value to parse (or undefined)\n * @param name - Option name for error messages\n * @param defaultValue - Default value if parsing fails\n * @returns Parsed integer or default value\n *\n * @example\n * ```typescript\n * // Basic usage\n * const timeout = parseIntSafe(args.timeout, 'timeout', 30000);\n *\n * // Handles invalid input gracefully\n * parseIntSafe('abc', 'count', 10); // Returns 10, logs warning\n * parseIntSafe('-5', 'count', 10);  // Returns 10, logs warning\n * parseIntSafe(undefined, 'count', 10); // Returns 10, no warning\n * ```\n */\nexport function parseIntSafe(\n  value: string | undefined,\n  name: string,\n  defaultValue: number\n): number {\n  if (value === undefined) {\n    return defaultValue;\n  }\n\n  // Use Number() instead of parseInt() to reject partial matches like \"42px\"\n  const trimmed = value.trim();\n  const parsed = Number(trimmed);\n\n  if (!Number.isInteger(parsed) || trimmed === '') {\n    console.warn(\n      `Warning: Invalid value '${value}' for --${name}, using default: ${defaultValue}`\n    );\n    return defaultValue;\n  }\n\n  if (parsed < 0) {\n    console.warn(\n      `Warning: Negative value '${value}' for --${name}, using default: ${defaultValue}`\n    );\n    return defaultValue;\n  }\n\n  return parsed;\n}\n\n/**\n * Parse integer allowing negative values\n *\n * @param value - String value to parse (or undefined)\n * @param name - Option name for error messages\n * @param defaultValue - Default value if parsing fails\n * @returns Parsed integer or default value\n */\nexport function parseIntSafeAllowNegative(\n  value: string | undefined,\n  name: string,\n  defaultValue: number\n): number {\n  if (value === undefined) {\n    return defaultValue;\n  }\n\n  // Use Number() instead of parseInt() to reject partial matches like \"42px\"\n  const trimmed = value.trim();\n  const parsed = Number(trimmed);\n\n  if (!Number.isInteger(parsed) || trimmed === '') {\n    console.warn(\n      `Warning: Invalid value '${value}' for --${name}, using default: ${defaultValue}`\n    );\n    return defaultValue;\n  }\n\n  return parsed;\n}\n\n/**\n * Parse float with validation and fallback\n *\n * @param value - String value to parse (or undefined)\n * @param name - Option name for error messages\n * @param defaultValue - Default value if parsing fails\n * @returns Parsed float or default value\n *\n * @example\n * ```typescript\n * const threshold = parseFloatSafe(args.threshold, 'threshold', 0.1);\n * ```\n */\nexport function parseFloatSafe(\n  value: string | undefined,\n  name: string,\n  defaultValue: number\n): number {\n  if (value === undefined) {\n    return defaultValue;\n  }\n\n  // Use Number() instead of parseFloat() to reject partial matches like \"3.14abc\"\n  const trimmed = value.trim();\n  const parsed = Number(trimmed);\n\n  if (isNaN(parsed) || trimmed === '') {\n    console.warn(\n      `Warning: Invalid value '${value}' for --${name}, using default: ${defaultValue}`\n    );\n    return defaultValue;\n  }\n\n  if (parsed < 0) {\n    console.warn(\n      `Warning: Negative value '${value}' for --${name}, using default: ${defaultValue}`\n    );\n    return defaultValue;\n  }\n\n  return parsed;\n}\n\n/**\n * Parse boolean from string with common truthy/falsy values\n *\n * @param value - String value to parse (or undefined)\n * @param defaultValue - Default value if parsing fails\n * @returns Parsed boolean or default value\n *\n * @example\n * ```typescript\n * parseBoolSafe('true', false);  // Returns true\n * parseBoolSafe('yes', false);   // Returns true\n * parseBoolSafe('1', false);     // Returns true\n * parseBoolSafe('false', true);  // Returns false\n * parseBoolSafe('no', true);     // Returns false\n * parseBoolSafe('0', true);      // Returns false\n * parseBoolSafe('invalid', true); // Returns true (default)\n * ```\n */\nexport function parseBoolSafe(\n  value: string | undefined,\n  defaultValue: boolean\n): boolean {\n  if (value === undefined) {\n    return defaultValue;\n  }\n\n  const normalized = value.toLowerCase().trim();\n\n  if (['true', 'yes', '1', 'on'].includes(normalized)) {\n    return true;\n  }\n\n  if (['false', 'no', '0', 'off'].includes(normalized)) {\n    return false;\n  }\n\n  return defaultValue;\n}\n\n/**\n * Parse enum value with validation\n *\n * @param value - String value to parse (or undefined)\n * @param validValues - Array of valid enum values\n * @param name - Option name for error messages\n * @param defaultValue - Default value if parsing fails\n * @returns Parsed enum value or default value\n *\n * @example\n * ```typescript\n * type LogLevel = 'debug' | 'info' | 'warn' | 'error';\n * const level = parseEnumSafe<LogLevel>(\n *   args.level,\n *   ['debug', 'info', 'warn', 'error'],\n *   'level',\n *   'info'\n * );\n * ```\n */\nexport function parseEnumSafe<T extends string>(\n  value: string | undefined,\n  validValues: readonly T[],\n  name: string,\n  defaultValue: T\n): T {\n  if (value === undefined) {\n    return defaultValue;\n  }\n\n  const trimmed = value.trim();\n\n  // Case-insensitive matching: find the valid value that matches\n  const match = validValues.find(\n    v => v.toLowerCase() === trimmed.toLowerCase()\n  );\n\n  if (match !== undefined) {\n    return match; // Return the actual valid value, not the input\n  }\n\n  console.warn(\n    `Warning: Invalid value '${value}' for --${name}, valid values are: ${validValues.join(', ')}. Using default: ${defaultValue}`\n  );\n  return defaultValue;\n}\n\n/**\n * Parse a value with a custom parser function\n *\n * @param value - String value to parse (or undefined)\n * @param parser - Custom parser function\n * @param name - Option name for error messages\n * @param defaultValue - Default value if parsing fails\n * @returns Parsed value or default value\n *\n * @example\n * ```typescript\n * const date = parseWithValidator(\n *   args.date,\n *   (v) => new Date(v),\n *   (d) => !isNaN(d.getTime()),\n *   'date',\n *   new Date()\n * );\n * ```\n */\nexport function parseWithValidator<T>(\n  value: string | undefined,\n  parser: (_value: string) => T,\n  validator: (_parsed: T) => boolean,\n  name: string,\n  defaultValue: T\n): T {\n  if (value === undefined) {\n    return defaultValue;\n  }\n\n  try {\n    const parsed = parser(value);\n    if (validator(parsed)) {\n      return parsed;\n    }\n    console.warn(\n      `Warning: Invalid value '${value}' for --${name}, using default`\n    );\n    return defaultValue;\n  } catch {\n    console.warn(\n      `Warning: Failed to parse '${value}' for --${name}, using default`\n    );\n    return defaultValue;\n  }\n}\n","/**\n * Journey Schema Validation - Validate Journey frontmatter before code generation\n * @see T039 - Journey schema validation (status=clarified check)\n */\nimport type { JourneyFrontmatter } from '../journey/parseJourney.js';\nimport { JourneyFrontmatterSchema, JourneyStatus } from '../journey/parseJourney.js';\n\n/**\n * Validation issue severity\n */\nexport type ValidationSeverity = 'error' | 'warning' | 'info';\n\n/**\n * A single validation issue\n */\nexport interface ValidationIssue {\n  /** Unique code for the issue */\n  code: string;\n  /** Human-readable message */\n  message: string;\n  /** Severity level */\n  severity: ValidationSeverity;\n  /** Field that has the issue, if applicable */\n  field?: string;\n  /** Suggested fix, if available */\n  suggestion?: string;\n}\n\n/**\n * Result of journey validation\n */\nexport interface JourneyValidationResult {\n  /** Whether the journey is valid for code generation */\n  valid: boolean;\n  /** Journey ID from frontmatter */\n  journeyId: string;\n  /** List of validation issues */\n  issues: ValidationIssue[];\n  /** Counts by severity */\n  counts: {\n    errors: number;\n    warnings: number;\n    info: number;\n  };\n}\n\n/**\n * Options for journey validation\n */\nexport interface JourneyValidationOptions {\n  /** Whether to allow draft journeys (status other than clarified) */\n  allowDrafts?: boolean;\n  /** Required tags that must be present */\n  requiredTags?: string[];\n  /** Valid tiers */\n  validTiers?: string[];\n  /** Warn if journey has no acceptance criteria */\n  warnEmptyAC?: boolean;\n}\n\nconst DEFAULT_OPTIONS: JourneyValidationOptions = {\n  allowDrafts: false,\n  requiredTags: [],\n  validTiers: ['smoke', 'release', 'regression'],\n  warnEmptyAC: true,\n};\n\n/**\n * Validate journey frontmatter schema\n */\nexport function validateJourneySchema(\n  frontmatter: unknown\n): { valid: boolean; issues: ValidationIssue[] } {\n  const result = JourneyFrontmatterSchema.safeParse(frontmatter);\n  const issues: ValidationIssue[] = [];\n\n  if (!result.success) {\n    for (const error of result.error.errors) {\n      issues.push({\n        code: 'SCHEMA_INVALID',\n        message: `${error.path.join('.')}: ${error.message}`,\n        severity: 'error',\n        field: error.path.join('.'),\n      });\n    }\n  }\n\n  return { valid: result.success, issues };\n}\n\n/**\n * Validate journey status is appropriate for code generation\n */\nexport function validateJourneyStatus(\n  status: JourneyStatus,\n  options: JourneyValidationOptions = {}\n): ValidationIssue[] {\n  const { allowDrafts = false } = options;\n  const issues: ValidationIssue[] = [];\n\n  // Code generation requires 'clarified' status\n  const validStatuses: JourneyStatus[] = ['clarified', 'implemented'];\n\n  if (!validStatuses.includes(status)) {\n    if (allowDrafts) {\n      issues.push({\n        code: 'STATUS_NOT_READY',\n        message: `Journey status is '${status}', ideally should be 'clarified' for code generation`,\n        severity: 'warning',\n        field: 'status',\n        suggestion: 'Run /journey-clarify to add execution details',\n      });\n    } else {\n      issues.push({\n        code: 'STATUS_NOT_CLARIFIED',\n        message: `Journey status is '${status}', must be 'clarified' for code generation`,\n        severity: 'error',\n        field: 'status',\n        suggestion: 'Run /journey-clarify to add execution details',\n      });\n    }\n  }\n\n  // Warn about quarantined or deprecated\n  if (status === 'quarantined') {\n    issues.push({\n      code: 'STATUS_QUARANTINED',\n      message: 'Journey is quarantined - tests are disabled',\n      severity: 'warning',\n      field: 'status',\n    });\n  }\n\n  if (status === 'deprecated') {\n    issues.push({\n      code: 'STATUS_DEPRECATED',\n      message: 'Journey is deprecated - consider removing',\n      severity: 'warning',\n      field: 'status',\n    });\n  }\n\n  return issues;\n}\n\n/**\n * Validate journey tier is valid\n */\nexport function validateJourneyTier(\n  tier: string,\n  options: JourneyValidationOptions = {}\n): ValidationIssue[] {\n  const { validTiers = ['smoke', 'release', 'regression'] } = options;\n  const issues: ValidationIssue[] = [];\n\n  if (!validTiers.includes(tier)) {\n    issues.push({\n      code: 'TIER_INVALID',\n      message: `Invalid tier '${tier}', expected one of: ${validTiers.join(', ')}`,\n      severity: 'error',\n      field: 'tier',\n    });\n  }\n\n  return issues;\n}\n\n/**\n * Validate journey has required tags\n */\nexport function validateJourneyTags(\n  tags: string[],\n  journeyId: string,\n  options: JourneyValidationOptions = {}\n): ValidationIssue[] {\n  const { requiredTags = [] } = options;\n  const issues: ValidationIssue[] = [];\n\n  // Check for journey ID tag\n  const idTag = `@${journeyId}`;\n  if (!tags.includes(idTag)) {\n    issues.push({\n      code: 'TAG_MISSING_ID',\n      message: `Journey should have ID tag '${idTag}'`,\n      severity: 'warning',\n      field: 'tags',\n      suggestion: `Add '${idTag}' to tags array`,\n    });\n  }\n\n  // Check for required tags\n  for (const requiredTag of requiredTags) {\n    if (!tags.includes(requiredTag)) {\n      issues.push({\n        code: 'TAG_MISSING_REQUIRED',\n        message: `Missing required tag '${requiredTag}'`,\n        severity: 'error',\n        field: 'tags',\n        suggestion: `Add '${requiredTag}' to tags array`,\n      });\n    }\n  }\n\n  return issues;\n}\n\n/**\n * Validate journey frontmatter for code generation\n */\nexport function validateJourneyFrontmatter(\n  frontmatter: JourneyFrontmatter,\n  options: JourneyValidationOptions = {}\n): JourneyValidationResult {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n  const issues: ValidationIssue[] = [];\n\n  // Schema validation\n  const schemaResult = validateJourneySchema(frontmatter);\n  issues.push(...schemaResult.issues);\n\n  // Status validation\n  issues.push(...validateJourneyStatus(frontmatter.status, opts));\n\n  // Tier validation\n  issues.push(...validateJourneyTier(frontmatter.tier, opts));\n\n  // Tags validation\n  issues.push(...validateJourneyTags(frontmatter.tags || [], frontmatter.id, opts));\n\n  // Check for actor\n  if (!frontmatter.actor) {\n    issues.push({\n      code: 'ACTOR_MISSING',\n      message: 'Journey should specify an actor (user role)',\n      severity: 'warning',\n      field: 'actor',\n    });\n  }\n\n  // Check for scope\n  if (!frontmatter.scope) {\n    issues.push({\n      code: 'SCOPE_MISSING',\n      message: 'Journey should specify a scope (feature area)',\n      severity: 'warning',\n      field: 'scope',\n    });\n  }\n\n  // Calculate counts\n  const counts = {\n    errors: issues.filter((i) => i.severity === 'error').length,\n    warnings: issues.filter((i) => i.severity === 'warning').length,\n    info: issues.filter((i) => i.severity === 'info').length,\n  };\n\n  return {\n    valid: counts.errors === 0,\n    journeyId: frontmatter.id,\n    issues,\n    counts,\n  };\n}\n\n/**\n * Quick check if journey is ready for code generation\n */\nexport function isJourneyReady(frontmatter: JourneyFrontmatter): boolean {\n  const result = validateJourneyFrontmatter(frontmatter, { allowDrafts: false });\n  return result.valid;\n}\n","/**\n * Forbidden Pattern Scanner - Detect anti-patterns in generated test code\n * @see T040 - Forbidden pattern scanner (waitForTimeout, force:true, etc.)\n */\nimport type { ValidationIssue, ValidationSeverity } from './journey.js';\n\n/**\n * A forbidden pattern definition\n */\nexport interface ForbiddenPattern {\n  /** Unique identifier */\n  id: string;\n  /** Pattern name */\n  name: string;\n  /** Regex to match the pattern */\n  regex: RegExp;\n  /** Severity of the issue */\n  severity: ValidationSeverity;\n  /** Why this pattern is forbidden */\n  reason: string;\n  /** Suggested alternative */\n  suggestion: string;\n  /** Whether to allow in specific contexts (e.g., setup/cleanup) */\n  allowedContexts?: string[];\n}\n\n/**\n * Result of pattern scanning\n */\nexport interface PatternScanResult {\n  /** Line number (1-based) */\n  line: number;\n  /** Column number (1-based) */\n  column: number;\n  /** The matched text */\n  match: string;\n  /** The full line content */\n  lineContent: string;\n  /** The pattern that was violated */\n  pattern: ForbiddenPattern;\n}\n\n/**\n * Forbidden patterns that indicate flaky or brittle tests\n */\nexport const FORBIDDEN_PATTERNS: ForbiddenPattern[] = [\n  {\n    id: 'WAIT_TIMEOUT',\n    name: 'waitForTimeout',\n    regex: /\\bpage\\.waitForTimeout\\s*\\(\\s*\\d+\\s*\\)/g,\n    severity: 'error',\n    reason: 'Hard-coded waits cause flakiness and slow down tests',\n    suggestion: 'Use waitForSelector, waitForLoadState, or assertion auto-wait',\n  },\n  {\n    id: 'WAIT_ARBITRARY',\n    name: 'arbitrary-wait',\n    regex: /\\bawait\\s+new\\s+Promise\\s*\\(\\s*(?:resolve|r)\\s*=>\\s*setTimeout/g,\n    severity: 'error',\n    reason: 'Custom setTimeout-based waits cause flakiness',\n    suggestion: 'Use Playwright auto-wait assertions instead',\n  },\n  {\n    id: 'FORCE_CLICK',\n    name: 'force-click',\n    regex: /\\.click\\s*\\([^)]*\\{\\s*force\\s*:\\s*true/g,\n    severity: 'warning',\n    reason: 'Force clicking bypasses visibility checks and masks issues',\n    suggestion: 'Ensure element is visible and actionable, or use scrollIntoView',\n  },\n  {\n    id: 'FORCE_FILL',\n    name: 'force-fill',\n    regex: /\\.fill\\s*\\(\\s*[^,]+,\\s*\\{\\s*force\\s*:\\s*true/g,\n    severity: 'warning',\n    reason: 'Force filling bypasses visibility checks',\n    suggestion: 'Ensure input is visible and enabled',\n  },\n  {\n    id: 'CSS_SELECTOR_CLASS',\n    name: 'css-class-selector',\n    regex: /(?:page|locator)\\s*\\.\\s*(?:locator|querySelector)\\s*\\(\\s*['\"][^'\"]*\\.[a-z][a-z0-9_-]*(?:\\s|['\">\\[])/gi,\n    severity: 'warning',\n    reason: 'CSS class selectors are fragile and may change',\n    suggestion: 'Use role, label, placeholder, text, or testid locators',\n  },\n  {\n    id: 'CSS_SELECTOR_TAG',\n    name: 'css-tag-selector',\n    regex: /(?:page|locator)\\s*\\.\\s*locator\\s*\\(\\s*['\"](?:div|span|p|h[1-6]|section|header|footer|main|nav|aside|article)(?:\\s*>|\\s*\\[|['\"])/gi,\n    severity: 'warning',\n    reason: 'Generic tag selectors are too broad and fragile',\n    suggestion: 'Use more specific selectors like role, label, or testid',\n  },\n  {\n    id: 'XPATH_SELECTOR',\n    name: 'xpath-selector',\n    regex: /(?:page|locator)\\s*\\.\\s*locator\\s*\\(\\s*['\"]\\/\\/[^'\"]+['\"]/g,\n    severity: 'warning',\n    reason: 'XPath selectors are verbose and often fragile',\n    suggestion: 'Use role, label, or testid locators instead',\n  },\n  {\n    id: 'NTH_CHILD',\n    name: 'nth-child-selector',\n    regex: /:nth-child\\s*\\(\\s*\\d+\\s*\\)/g,\n    severity: 'warning',\n    reason: 'nth-child selectors break when DOM order changes',\n    suggestion: 'Use unique identifiers like testid or text content',\n  },\n  {\n    id: 'INDEX_LOCATOR',\n    name: 'index-based-locator',\n    regex: /\\.(?:first|last|nth)\\s*\\(\\s*(?:\\d+)?\\s*\\)/g,\n    severity: 'info',\n    reason: 'Index-based locators may break when list order changes',\n    suggestion: 'Consider filtering by unique content or attributes',\n  },\n  {\n    id: 'HARDCODED_URL',\n    name: 'hardcoded-url',\n    regex: /\\bpage\\.goto\\s*\\(\\s*['\"]https?:\\/\\/[^'\"]+['\"]/g,\n    severity: 'warning',\n    reason: 'Hardcoded URLs make tests environment-specific',\n    suggestion: 'Use baseURL from config or relative paths',\n  },\n  {\n    id: 'HARDCODED_CREDENTIALS',\n    name: 'hardcoded-credentials',\n    regex: /(?:password|secret|apikey|api_key|token)\\s*[=:]\\s*['\"][^'\"]+['\"]/gi,\n    severity: 'error',\n    reason: 'Credentials should not be hardcoded in test files',\n    suggestion: 'Use environment variables or secure config',\n  },\n  {\n    id: 'CONSOLE_LOG',\n    name: 'console-log',\n    regex: /\\bconsole\\.(log|info|warn|error)\\s*\\(/g,\n    severity: 'info',\n    reason: 'Console statements should be removed from production tests',\n    suggestion: 'Use test reporter or remove debug statements',\n  },\n  {\n    id: 'MISSING_AWAIT',\n    name: 'missing-await-locator',\n    regex: /(?<!await\\s+)page\\.(?:click|fill|type|check|uncheck|selectOption|press|hover|focus)\\s*\\(/g,\n    severity: 'error',\n    reason: 'Playwright actions must be awaited',\n    suggestion: 'Add await before the action',\n  },\n  {\n    id: 'SKIP_TEST',\n    name: 'test-skip',\n    regex: /\\btest\\.skip\\s*\\(/g,\n    severity: 'info',\n    reason: 'Skipped tests may be forgotten',\n    suggestion: 'Remove skip or convert to fixme with issue link',\n  },\n  {\n    id: 'TEST_ONLY',\n    name: 'test-only',\n    regex: /\\btest\\.only\\s*\\(/g,\n    severity: 'error',\n    reason: 'test.only excludes all other tests',\n    suggestion: 'Remove .only before committing',\n  },\n  {\n    id: 'ELEMENT_HANDLE',\n    name: 'element-handle',\n    regex: /\\.\\$\\s*\\(|\\.\\$\\$\\s*\\(/g,\n    severity: 'warning',\n    reason: 'ElementHandle is deprecated, use locators instead',\n    suggestion: 'Use page.locator() instead of page.$() or page.$$()',\n  },\n  {\n    id: 'EVAL_SELECTOR',\n    name: 'eval-selector',\n    regex: /\\.\\$eval\\s*\\(|\\.\\$\\$eval\\s*\\(/g,\n    severity: 'warning',\n    reason: 'eval methods are fragile and hard to debug',\n    suggestion: 'Use locator methods like textContent(), getAttribute()',\n  },\n  {\n    id: 'SLEEP_IMPORT',\n    name: 'sleep-import',\n    regex: /import\\s*\\{[^}]*sleep[^}]*\\}|require\\s*\\(['\"'][^'\"]*sleep/gi,\n    severity: 'warning',\n    reason: 'Sleep utilities encourage flaky tests',\n    suggestion: 'Use Playwright auto-wait mechanisms',\n  },\n];\n\n/**\n * Scan code for forbidden patterns\n */\nexport function scanForbiddenPatterns(\n  code: string,\n  patterns: ForbiddenPattern[] = FORBIDDEN_PATTERNS\n): PatternScanResult[] {\n  const results: PatternScanResult[] = [];\n  const lines = code.split('\\n');\n\n  for (const pattern of patterns) {\n    // Reset regex state for global patterns\n    pattern.regex.lastIndex = 0;\n\n    for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {\n      const line = lines[lineIndex]!;\n      let match: RegExpExecArray | null;\n\n      // Clone regex to avoid state issues with global flag\n      const regex = new RegExp(pattern.regex.source, pattern.regex.flags);\n\n      while ((match = regex.exec(line)) !== null) {\n        results.push({\n          line: lineIndex + 1,\n          column: match.index + 1,\n          match: match[0]!,\n          lineContent: line!.trim(),\n          pattern,\n        });\n\n        // Prevent infinite loop for zero-length matches\n        if (match.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n      }\n    }\n  }\n\n  // Sort by line number, then column\n  results.sort((a, b) => a.line - b.line || a.column - b.column);\n\n  return results;\n}\n\n/**\n * Convert scan results to validation issues\n */\nexport function scanResultsToIssues(results: PatternScanResult[]): ValidationIssue[] {\n  return results.map((result) => ({\n    code: result.pattern.id,\n    message: `Line ${result.line}: ${result.pattern.name} - ${result.pattern.reason}`,\n    severity: result.pattern.severity,\n    suggestion: result.pattern.suggestion,\n  }));\n}\n\n/**\n * Get pattern statistics\n */\nexport function getPatternStats(\n  results: PatternScanResult[]\n): Record<string, number> {\n  const stats: Record<string, number> = {};\n\n  for (const result of results) {\n    stats[result.pattern.id] = (stats[result.pattern.id] || 0) + 1;\n  }\n\n  return stats;\n}\n\n/**\n * Check if code has any error-level violations\n */\nexport function hasErrorViolations(results: PatternScanResult[]): boolean {\n  return results.some((r) => r.pattern.severity === 'error');\n}\n\n/**\n * Filter results by severity\n */\nexport function filterBySeverity(\n  results: PatternScanResult[],\n  severity: ValidationSeverity\n): PatternScanResult[] {\n  return results.filter((r) => r.pattern.severity === severity);\n}\n\n/**\n * Get a summary of violations by category\n */\nexport function getViolationSummary(results: PatternScanResult[]): {\n  total: number;\n  errors: number;\n  warnings: number;\n  info: number;\n  byPattern: Record<string, number>;\n} {\n  return {\n    total: results.length,\n    errors: filterBySeverity(results, 'error').length,\n    warnings: filterBySeverity(results, 'warning').length,\n    info: filterBySeverity(results, 'info').length,\n    byPattern: getPatternStats(results),\n  };\n}\n","/**\n * ESLint Integration - Run ESLint with Playwright plugin rules\n * @see T041 - ESLint integration with eslint-plugin-playwright\n */\nimport { spawnSync } from 'node:child_process';\nimport { existsSync, writeFileSync, unlinkSync, mkdirSync } from 'node:fs';\nimport { join, dirname } from 'node:path';\nimport { tmpdir } from 'node:os';\nimport type { ValidationIssue, ValidationSeverity } from './journey.js';\n\n/**\n * ESLint message from JSON output\n */\ninterface ESLintMessage {\n  ruleId: string | null;\n  severity: 1 | 2; // 1 = warning, 2 = error\n  message: string;\n  line: number;\n  column: number;\n  endLine?: number;\n  endColumn?: number;\n  fix?: {\n    range: [number, number];\n    text: string;\n  };\n}\n\n/**\n * ESLint file result from JSON output\n */\ninterface ESLintFileResult {\n  filePath: string;\n  messages: ESLintMessage[];\n  errorCount: number;\n  warningCount: number;\n  fixableErrorCount: number;\n  fixableWarningCount: number;\n  source?: string;\n}\n\n/**\n * Result of linting code\n */\nexport interface LintResult {\n  /** Whether linting passed (no errors) */\n  passed: boolean;\n  /** ESLint output */\n  output: string;\n  /** Parsed issues */\n  issues: ValidationIssue[];\n  /** Error count */\n  errorCount: number;\n  /** Warning count */\n  warningCount: number;\n}\n\n/**\n * Options for ESLint\n */\nexport interface LintOptions {\n  /** Additional ESLint rules to enable */\n  rules?: Record<string, unknown>;\n  /** Whether to fix auto-fixable issues */\n  fix?: boolean;\n  /** Custom ESLint config path */\n  configPath?: string;\n  /** Working directory */\n  cwd?: string;\n}\n\n/**\n * Default Playwright ESLint rules\n */\nexport const PLAYWRIGHT_LINT_RULES: Record<string, unknown> = {\n  // Playwright plugin rules\n  'playwright/missing-playwright-await': 'error',\n  'playwright/no-conditional-in-test': 'warn',\n  'playwright/no-element-handle': 'error',\n  'playwright/no-eval': 'error',\n  'playwright/no-focused-test': 'error',\n  'playwright/no-force-option': 'warn',\n  'playwright/no-nested-step': 'warn',\n  'playwright/no-networkidle': 'warn',\n  'playwright/no-page-pause': 'error',\n  'playwright/no-skipped-test': 'warn',\n  'playwright/no-useless-await': 'warn',\n  'playwright/no-useless-not': 'warn',\n  'playwright/no-wait-for-timeout': 'error',\n  'playwright/prefer-lowercase-title': 'off',\n  'playwright/prefer-strict-equal': 'warn',\n  'playwright/prefer-to-be': 'warn',\n  'playwright/prefer-to-contain': 'warn',\n  'playwright/prefer-to-have-count': 'warn',\n  'playwright/prefer-to-have-length': 'warn',\n  'playwright/prefer-web-first-assertions': 'error',\n  'playwright/require-soft-assertions': 'off',\n  'playwright/valid-describe-callback': 'error',\n  'playwright/valid-expect': 'error',\n  'playwright/valid-expect-in-promise': 'error',\n  'playwright/valid-title': 'warn',\n};\n\n/**\n * Generate ESLint flat config for Playwright tests\n */\nexport function generateESLintConfig(\n  rules: Record<string, unknown> = PLAYWRIGHT_LINT_RULES\n): string {\n  return `import playwright from 'eslint-plugin-playwright';\n\nexport default [\n  {\n    files: ['**/*.spec.ts', '**/*.test.ts'],\n    plugins: {\n      playwright,\n    },\n    rules: ${JSON.stringify(rules, null, 2)},\n  },\n];\n`;\n}\n\n/**\n * Check if ESLint and Playwright plugin are available\n */\nexport function isESLintAvailable(cwd?: string): boolean {\n  const result = spawnSync('npx', ['eslint', '--version'], {\n    cwd,\n    stdio: 'pipe',\n    encoding: 'utf-8',\n  });\n  return result.status === 0;\n}\n\n/**\n * Check if eslint-plugin-playwright is installed\n */\nexport function isPlaywrightPluginAvailable(cwd?: string): boolean {\n  const result = spawnSync('npm', ['list', 'eslint-plugin-playwright'], {\n    cwd,\n    stdio: 'pipe',\n    encoding: 'utf-8',\n  });\n  if (result.status !== 0) {\n    return false;\n  }\n  const output = result.stdout || '';\n  return output.includes('eslint-plugin-playwright');\n}\n\n/**\n * Convert ESLint severity to ValidationSeverity\n */\nfunction convertSeverity(eslintSeverity: 1 | 2): ValidationSeverity {\n  return eslintSeverity === 2 ? 'error' : 'warning';\n}\n\n/**\n * Parse ESLint JSON output to validation issues\n */\nexport function parseESLintOutput(output: string): ValidationIssue[] {\n  try {\n    const results: ESLintFileResult[] = JSON.parse(output);\n    const issues: ValidationIssue[] = [];\n\n    for (const file of results) {\n      for (const msg of file.messages) {\n        issues.push({\n          code: msg.ruleId || 'ESLINT_ERROR',\n          message: `Line ${msg.line}:${msg.column} - ${msg.message}`,\n          severity: convertSeverity(msg.severity),\n          suggestion: msg.fix ? 'Auto-fixable with --fix' : undefined,\n        });\n      }\n    }\n\n    return issues;\n  } catch {\n    // If JSON parsing fails, return a single error\n    return [\n      {\n        code: 'ESLINT_PARSE_ERROR',\n        message: 'Failed to parse ESLint output',\n        severity: 'error',\n      },\n    ];\n  }\n}\n\n/**\n * Run ESLint on code string\n * Note: This creates a temporary file for linting\n */\nexport async function lintCode(\n  code: string,\n  filename: string = 'test.spec.ts',\n  options: LintOptions = {}\n): Promise<LintResult> {\n  const { cwd = process.cwd(), fix = false, configPath } = options;\n\n  // Check ESLint availability\n  if (!isESLintAvailable(cwd)) {\n    return {\n      passed: true,\n      output: 'ESLint not available - skipping lint check',\n      issues: [\n        {\n          code: 'ESLINT_NOT_AVAILABLE',\n          message: 'ESLint is not installed',\n          severity: 'info',\n          suggestion: 'Run npm install eslint eslint-plugin-playwright',\n        },\n      ],\n      errorCount: 0,\n      warningCount: 0,\n    };\n  }\n\n  // Create temp file for linting\n  const tempDir = join(tmpdir(), 'autogen-lint');\n  mkdirSync(tempDir, { recursive: true });\n  const tempFile = join(tempDir, filename);\n\n  try {\n    writeFileSync(tempFile, code, 'utf-8');\n\n    // Build ESLint command args\n    const args = ['eslint', '--format', 'json'];\n\n    if (fix) {\n      args.push('--fix');\n    }\n\n    if (configPath && existsSync(configPath)) {\n      args.push('--config', configPath);\n    }\n\n    args.push(tempFile);\n\n    // SECURITY: Use spawnSync with array args to prevent command injection\n    // This avoids shell interpretation of special characters in file paths\n    const result = spawnSync('npx', args, {\n      cwd,\n      stdio: 'pipe',\n      encoding: 'utf-8',\n    });\n\n    const output = result.stdout || '';\n\n    // ESLint exits with non-zero on errors/warnings\n    if (result.status === 0) {\n      return {\n        passed: true,\n        output,\n        issues: parseESLintOutput(output),\n        errorCount: 0,\n        warningCount: 0,\n      };\n    }\n\n    // Handle non-zero exit (errors/warnings found)\n    try {\n      const results: ESLintFileResult[] = JSON.parse(output);\n      const issues = parseESLintOutput(output);\n\n      let errorCount = 0;\n      let warningCount = 0;\n\n      for (const file of results) {\n        errorCount += file.errorCount;\n        warningCount += file.warningCount;\n      }\n\n      return {\n        passed: errorCount === 0,\n        output,\n        issues,\n        errorCount,\n        warningCount,\n      };\n    } catch {\n      return {\n        passed: false,\n        output: output || 'ESLint execution failed',\n        issues: [\n          {\n            code: 'ESLINT_EXECUTION_ERROR',\n            message: 'ESLint execution failed',\n            severity: 'error',\n          },\n        ],\n        errorCount: 1,\n        warningCount: 0,\n      };\n    }\n  } finally {\n    // Cleanup temp file\n    try {\n      unlinkSync(tempFile);\n    } catch {\n      // Ignore cleanup errors\n    }\n  }\n}\n\n/**\n * Lint a file directly\n */\nexport async function lintFile(\n  filePath: string,\n  options: LintOptions = {}\n): Promise<LintResult> {\n  const { cwd = dirname(filePath), fix = false, configPath } = options;\n\n  if (!existsSync(filePath)) {\n    return {\n      passed: false,\n      output: `File not found: ${filePath}`,\n      issues: [\n        {\n          code: 'FILE_NOT_FOUND',\n          message: `File not found: ${filePath}`,\n          severity: 'error',\n        },\n      ],\n      errorCount: 1,\n      warningCount: 0,\n    };\n  }\n\n  // Check ESLint availability\n  if (!isESLintAvailable(cwd)) {\n    return {\n      passed: true,\n      output: 'ESLint not available - skipping lint check',\n      issues: [],\n      errorCount: 0,\n      warningCount: 0,\n    };\n  }\n\n  // Build ESLint command args\n  const args = ['eslint', '--format', 'json'];\n\n  if (fix) {\n    args.push('--fix');\n  }\n\n  if (configPath && existsSync(configPath)) {\n    args.push('--config', configPath);\n  }\n\n  args.push(filePath);\n\n  // SECURITY: Use spawnSync with array args to prevent command injection\n  // This avoids shell interpretation of special characters in file paths\n  const result = spawnSync('npx', args, {\n    cwd,\n    stdio: 'pipe',\n    encoding: 'utf-8',\n  });\n\n  const output = result.stdout || '';\n\n  if (result.status === 0) {\n    return {\n      passed: true,\n      output,\n      issues: parseESLintOutput(output),\n      errorCount: 0,\n      warningCount: 0,\n    };\n  }\n\n  // Handle non-zero exit (errors/warnings found)\n  const issues = parseESLintOutput(output);\n\n  return {\n    passed: issues.filter((i) => i.severity === 'error').length === 0,\n    output,\n    issues,\n    errorCount: issues.filter((i) => i.severity === 'error').length,\n    warningCount: issues.filter((i) => i.severity === 'warning').length,\n  };\n}\n\n/**\n * Quick check if code has lint errors (without full details)\n */\nexport function hasLintErrors(code: string): boolean {\n  // Simple heuristic check for common errors without running ESLint\n  const patterns = [\n    /test\\.only\\s*\\(/g,\n    /\\.waitForTimeout\\s*\\(/g,\n    /page\\.pause\\s*\\(/g,\n  ];\n\n  for (const pattern of patterns) {\n    if (pattern.test(code)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n","/**\n * Tag Validation - Ensure generated tests have correct Playwright tags\n * @see T042 - Tag validation (required @JRN-####, @tier-*, @scope-*)\n */\nimport type { ValidationIssue } from './journey.js';\n\n/**\n * Tag pattern matchers\n */\nexport const TAG_PATTERNS = {\n  journeyId: /^@JRN-\\d{4}$/,\n  tier: /^@tier-(smoke|release|regression)$/,\n  scope: /^@scope-[a-z][a-z0-9-]*$/,\n  actor: /^@actor-[a-z][a-z0-9-]*$/,\n  custom: /^@[a-z][a-z0-9-]*$/,\n};\n\n/**\n * Tag validation options\n */\nexport interface TagValidationOptions {\n  /** Whether journey ID tag is required */\n  requireJourneyId?: boolean;\n  /** Whether tier tag is required */\n  requireTier?: boolean;\n  /** Whether scope tag is required */\n  requireScope?: boolean;\n  /** Whether actor tag is required */\n  requireActor?: boolean;\n  /** Additional required tags */\n  requiredTags?: string[];\n  /** Forbidden tags */\n  forbiddenTags?: string[];\n  /** Maximum number of tags */\n  maxTags?: number;\n}\n\nconst DEFAULT_OPTIONS: TagValidationOptions = {\n  requireJourneyId: true,\n  requireTier: true,\n  requireScope: true,\n  requireActor: false,\n  requiredTags: [],\n  forbiddenTags: [],\n  maxTags: 10,\n};\n\n/**\n * Tag validation result\n */\nexport interface TagValidationResult {\n  /** Whether tags are valid */\n  valid: boolean;\n  /** Validation issues */\n  issues: ValidationIssue[];\n  /** Parsed tags */\n  parsedTags: {\n    journeyId?: string;\n    tier?: string;\n    scope?: string;\n    actor?: string;\n    custom: string[];\n  };\n}\n\n/**\n * Parse tags from generated test code\n */\nexport function parseTagsFromCode(code: string): string[] {\n  // Match tag array in test.describe\n  const tagArrayMatch = code.match(/tag:\\s*\\[([^\\]]*)\\]/);\n  if (!tagArrayMatch) {\n    return [];\n  }\n\n  // Extract individual tags\n  const tagArrayContent = tagArrayMatch[1]!;\n  const tagMatches = tagArrayContent.match(/'[^']+'/g) || [];\n\n  return tagMatches.map((t) => t.replace(/'/g, ''));\n}\n\n/**\n * Parse tags from frontmatter tags array\n */\nexport function parseTagsFromFrontmatter(tags: string[]): string[] {\n  // Normalize tags - remove quotes if present\n  return tags.map((t) => {\n    const cleaned = t.replace(/^['\"]|['\"]$/g, '');\n    // Ensure @ prefix\n    return cleaned.startsWith('@') ? cleaned : `@${cleaned}`;\n  });\n}\n\n/**\n * Categorize tags by type\n */\nexport function categorizeTags(tags: string[]): {\n  journeyId?: string;\n  tier?: string;\n  scope?: string;\n  actor?: string;\n  custom: string[];\n} {\n  const result: {\n    journeyId?: string;\n    tier?: string;\n    scope?: string;\n    actor?: string;\n    custom: string[];\n  } = { custom: [] };\n\n  for (const tag of tags) {\n    if (TAG_PATTERNS.journeyId.test(tag)) {\n      result.journeyId = tag;\n    } else if (TAG_PATTERNS.tier.test(tag)) {\n      result.tier = tag;\n    } else if (TAG_PATTERNS.scope.test(tag)) {\n      result.scope = tag;\n    } else if (TAG_PATTERNS.actor.test(tag)) {\n      result.actor = tag;\n    } else if (TAG_PATTERNS.custom.test(tag)) {\n      result.custom.push(tag);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Validate tags against requirements\n */\nexport function validateTags(\n  tags: string[],\n  journeyId: string,\n  tier: string,\n  scope: string,\n  options: TagValidationOptions = {}\n): TagValidationResult {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n  const issues: ValidationIssue[] = [];\n  const parsedTags = categorizeTags(tags);\n\n  // Check journey ID tag\n  if (opts.requireJourneyId) {\n    const expectedIdTag = `@${journeyId}`;\n    if (!tags.includes(expectedIdTag) && parsedTags.journeyId !== expectedIdTag) {\n      issues.push({\n        code: 'TAG_MISSING_JOURNEY_ID',\n        message: `Missing journey ID tag '${expectedIdTag}'`,\n        severity: 'error',\n        field: 'tags',\n        suggestion: `Add '${expectedIdTag}' to the tags array`,\n      });\n    }\n  }\n\n  // Check tier tag\n  if (opts.requireTier) {\n    const expectedTierTag = `@tier-${tier}`;\n    if (!tags.includes(expectedTierTag) && parsedTags.tier !== expectedTierTag) {\n      // Check if any tier tag exists\n      if (!parsedTags.tier) {\n        issues.push({\n          code: 'TAG_MISSING_TIER',\n          message: `Missing tier tag, expected '${expectedTierTag}'`,\n          severity: 'warning',\n          field: 'tags',\n          suggestion: `Add '${expectedTierTag}' to the tags array`,\n        });\n      } else if (parsedTags.tier !== expectedTierTag) {\n        issues.push({\n          code: 'TAG_TIER_MISMATCH',\n          message: `Tier tag '${parsedTags.tier}' does not match journey tier '${tier}'`,\n          severity: 'warning',\n          field: 'tags',\n          suggestion: `Change to '${expectedTierTag}' or update journey tier`,\n        });\n      }\n    }\n  }\n\n  // Check scope tag\n  if (opts.requireScope) {\n    const expectedScopeTag = `@scope-${scope}`;\n    if (!tags.includes(expectedScopeTag) && parsedTags.scope !== expectedScopeTag) {\n      // Check if any scope tag exists\n      if (!parsedTags.scope) {\n        issues.push({\n          code: 'TAG_MISSING_SCOPE',\n          message: `Missing scope tag, expected '${expectedScopeTag}'`,\n          severity: 'warning',\n          field: 'tags',\n          suggestion: `Add '${expectedScopeTag}' to the tags array`,\n        });\n      } else if (parsedTags.scope !== expectedScopeTag) {\n        issues.push({\n          code: 'TAG_SCOPE_MISMATCH',\n          message: `Scope tag '${parsedTags.scope}' does not match journey scope '${scope}'`,\n          severity: 'warning',\n          field: 'tags',\n          suggestion: `Change to '${expectedScopeTag}' or update journey scope`,\n        });\n      }\n    }\n  }\n\n  // Check required custom tags\n  for (const requiredTag of opts.requiredTags || []) {\n    if (!tags.includes(requiredTag)) {\n      issues.push({\n        code: 'TAG_MISSING_REQUIRED',\n        message: `Missing required tag '${requiredTag}'`,\n        severity: 'error',\n        field: 'tags',\n        suggestion: `Add '${requiredTag}' to the tags array`,\n      });\n    }\n  }\n\n  // Check forbidden tags\n  for (const forbiddenTag of opts.forbiddenTags || []) {\n    if (tags.includes(forbiddenTag)) {\n      issues.push({\n        code: 'TAG_FORBIDDEN',\n        message: `Forbidden tag '${forbiddenTag}' should not be used`,\n        severity: 'error',\n        field: 'tags',\n        suggestion: `Remove '${forbiddenTag}' from the tags array`,\n      });\n    }\n  }\n\n  // Check max tags\n  if (opts.maxTags && tags.length > opts.maxTags) {\n    issues.push({\n      code: 'TAG_TOO_MANY',\n      message: `Too many tags (${tags.length}), maximum is ${opts.maxTags}`,\n      severity: 'warning',\n      field: 'tags',\n      suggestion: 'Remove unnecessary tags',\n    });\n  }\n\n  // Check for invalid tag format\n  for (const tag of tags) {\n    if (!TAG_PATTERNS.custom.test(tag)) {\n      issues.push({\n        code: 'TAG_INVALID_FORMAT',\n        message: `Invalid tag format '${tag}', tags should start with @ followed by lowercase letters`,\n        severity: 'warning',\n        field: 'tags',\n        suggestion: `Rename to a valid format like '@${tag.replace(/[^a-z0-9-]/gi, '-').toLowerCase()}'`,\n      });\n    }\n  }\n\n  // Check for duplicate tags\n  const duplicates = tags.filter((tag, index) => tags.indexOf(tag) !== index);\n  for (const duplicate of new Set(duplicates)) {\n    issues.push({\n      code: 'TAG_DUPLICATE',\n      message: `Duplicate tag '${duplicate}'`,\n      severity: 'warning',\n      field: 'tags',\n      suggestion: 'Remove duplicate tags',\n    });\n  }\n\n  return {\n    valid: issues.filter((i) => i.severity === 'error').length === 0,\n    issues,\n    parsedTags,\n  };\n}\n\n/**\n * Generate expected tags for a journey\n */\nexport function generateExpectedTags(\n  journeyId: string,\n  tier: string,\n  scope: string,\n  additionalTags: string[] = []\n): string[] {\n  return [\n    `@${journeyId}`,\n    `@tier-${tier}`,\n    `@scope-${scope}`,\n    ...additionalTags,\n  ];\n}\n\n/**\n * Validate tags in generated test code\n */\nexport function validateTagsInCode(\n  code: string,\n  journeyId: string,\n  tier: string,\n  scope: string,\n  options: TagValidationOptions = {}\n): TagValidationResult {\n  const tags = parseTagsFromCode(code);\n  return validateTags(tags, journeyId, tier, scope, options);\n}\n","/**\n * AC Coverage Validation - Check that all acceptance criteria have test steps\n * @see T043 - ACtest.step mapping completeness check\n */\nimport type { ValidationIssue } from './journey.js';\nimport type { AcceptanceCriterion } from '../journey/parseJourney.js';\nimport type { IRJourney, IRStep } from '../ir/types.js';\n\n/**\n * Coverage result for a single AC\n */\nexport interface ACCoverageResult {\n  /** AC identifier */\n  acId: string;\n  /** AC title */\n  acTitle: string;\n  /** Whether the AC has a corresponding test.step */\n  hasCoverage: boolean;\n  /** Number of mapped steps */\n  mappedSteps: number;\n  /** Number of blocked/unmapped steps */\n  blockedSteps: number;\n  /** Coverage percentage (mapped / total) */\n  coveragePercent: number;\n  /** List of unmapped step texts */\n  unmappedSteps: string[];\n}\n\n/**\n * Overall coverage result\n */\nexport interface CoverageResult {\n  /** Whether all ACs are covered */\n  fullCoverage: boolean;\n  /** Total number of ACs */\n  totalACs: number;\n  /** Number of covered ACs */\n  coveredACs: number;\n  /** Overall coverage percentage */\n  overallCoverage: number;\n  /** Coverage details per AC */\n  perAC: ACCoverageResult[];\n  /** Validation issues */\n  issues: ValidationIssue[];\n}\n\n/**\n * Coverage validation options\n */\nexport interface CoverageOptions {\n  /** Minimum coverage percentage required */\n  minCoverage?: number;\n  /** Warn on partial coverage */\n  warnPartialCoverage?: boolean;\n  /** Maximum allowed blocked steps per AC */\n  maxBlockedSteps?: number;\n}\n\nconst DEFAULT_OPTIONS: CoverageOptions = {\n  minCoverage: 80,\n  warnPartialCoverage: true,\n  maxBlockedSteps: 2,\n};\n\n/**\n * Find test.step calls in generated code\n */\nexport function findTestSteps(code: string): Array<{ id: string; description: string }> {\n  const steps: Array<{ id: string; description: string }> = [];\n\n  // Match test.step('ID: Description', async () => { ... })\n  const stepRegex = /test\\.step\\s*\\(\\s*['\"]([^:]+):\\s*([^'\"]+)['\"]/g;\n  let match;\n\n  while ((match = stepRegex.exec(code)) !== null) {\n    steps.push({\n      id: match[1]!.trim(),\n      description: match[2]!.trim(),\n    });\n  }\n\n  return steps;\n}\n\n/**\n * Find AC IDs mentioned in code comments\n */\nexport function findACReferences(code: string): string[] {\n  const references: string[] = [];\n\n  // Match AC-### in comments\n  const acRegex = /\\/\\/\\s*(AC-\\d+)|['\"]?(AC-\\d+)['\"]?/g;\n  let match;\n\n  while ((match = acRegex.exec(code)) !== null) {\n    const acId = match[1] || match[2];\n    if (acId && !references.includes(acId)) {\n      references.push(acId);\n    }\n  }\n\n  return references;\n}\n\n/**\n * Calculate coverage for an IR step\n */\nfunction calculateStepCoverage(step: IRStep): ACCoverageResult {\n  const totalSteps = step.actions.length + step.assertions.length;\n  const blockedSteps = step.actions.filter((a) => a.type === 'blocked').length;\n  const mappedSteps = totalSteps - blockedSteps;\n\n  const unmappedSteps: string[] = [];\n  for (const action of step.actions) {\n    if (action.type === 'blocked' && action.sourceText) {\n      unmappedSteps.push(action.sourceText);\n    }\n  }\n\n  return {\n    acId: step.id,\n    acTitle: step.description,\n    hasCoverage: mappedSteps > 0,\n    mappedSteps,\n    blockedSteps,\n    coveragePercent: totalSteps > 0 ? (mappedSteps / totalSteps) * 100 : 100,\n    unmappedSteps,\n  };\n}\n\n/**\n * Validate AC coverage in IR journey\n */\nexport function validateIRCoverage(\n  journey: IRJourney,\n  options: CoverageOptions = {}\n): CoverageResult {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n  const issues: ValidationIssue[] = [];\n  const perAC: ACCoverageResult[] = [];\n\n  // Calculate coverage for each step (which corresponds to an AC)\n  for (const step of journey.steps) {\n    const coverage = calculateStepCoverage(step);\n    perAC.push(coverage);\n\n    // Check coverage issues\n    if (!coverage.hasCoverage) {\n      issues.push({\n        code: 'AC_NO_COVERAGE',\n        message: `${step.id} has no mapped test steps`,\n        severity: 'error',\n        field: step.id,\n        suggestion: 'Clarify the AC steps or add supported patterns',\n      });\n    } else if (coverage.coveragePercent < (opts.minCoverage! || 80)) {\n      if (opts.warnPartialCoverage) {\n        issues.push({\n          code: 'AC_PARTIAL_COVERAGE',\n          message: `${step.id} has only ${Math.round(coverage.coveragePercent)}% coverage (${coverage.mappedSteps}/${coverage.mappedSteps + coverage.blockedSteps} steps)`,\n          severity: 'warning',\n          field: step.id,\n          suggestion: `Unmapped steps: ${coverage.unmappedSteps.join(', ')}`,\n        });\n      }\n    }\n\n    // Check blocked step count\n    if (opts.maxBlockedSteps! && coverage.blockedSteps > opts.maxBlockedSteps!) {\n      issues.push({\n        code: 'AC_TOO_MANY_BLOCKED',\n        message: `${step.id} has ${coverage.blockedSteps} blocked steps (max: ${opts.maxBlockedSteps})`,\n        severity: 'warning',\n        field: step.id,\n        suggestion: 'Consider clarifying these steps or marking the journey as needing manual implementation',\n      });\n    }\n  }\n\n  // Calculate overall stats\n  const totalACs = perAC.length;\n  const coveredACs = perAC.filter((ac) => ac.hasCoverage).length;\n  const overallCoverage = totalACs > 0 ? (coveredACs / totalACs) * 100 : 100;\n\n  // Overall coverage check\n  if (totalACs > 0 && overallCoverage < (opts.minCoverage || 80)) {\n    issues.push({\n      code: 'JOURNEY_LOW_COVERAGE',\n      message: `Journey has only ${Math.round(overallCoverage)}% AC coverage (${coveredACs}/${totalACs} ACs)`,\n      severity: overallCoverage < 50 ? 'error' : 'warning',\n      suggestion: 'Review and clarify uncovered acceptance criteria',\n    });\n  }\n\n  return {\n    fullCoverage: coveredACs === totalACs && issues.filter((i) => i.severity === 'error').length === 0,\n    totalACs,\n    coveredACs,\n    overallCoverage,\n    perAC,\n    issues,\n  };\n}\n\n/**\n * Validate coverage in generated test code\n */\nexport function validateCodeCoverage(\n  code: string,\n  acceptanceCriteria: AcceptanceCriterion[],\n  _options: CoverageOptions = {}\n): CoverageResult {\n  // Options reserved for future use (e.g., minCoverage threshold)\n  const issues: ValidationIssue[] = [];\n  const perAC: ACCoverageResult[] = [];\n\n  // Find test steps in code\n  const testSteps = findTestSteps(code);\n  const stepIds = testSteps.map((s) => s.id);\n\n  // Check each AC\n  for (const ac of acceptanceCriteria) {\n    const hasCoverage = stepIds.includes(ac.id);\n\n    perAC.push({\n      acId: ac.id,\n      acTitle: ac.title,\n      hasCoverage,\n      mappedSteps: hasCoverage ? ac.steps.length : 0,\n      blockedSteps: hasCoverage ? 0 : ac.steps.length,\n      coveragePercent: hasCoverage ? 100 : 0,\n      unmappedSteps: hasCoverage ? [] : ac.steps,\n    });\n\n    if (!hasCoverage) {\n      issues.push({\n        code: 'AC_NOT_IN_CODE',\n        message: `${ac.id}: ${ac.title} is not covered in generated test`,\n        severity: 'error',\n        field: ac.id,\n        suggestion: 'Regenerate the test or add manual test.step',\n      });\n    }\n  }\n\n  // Check for orphan test steps (not matching any AC)\n  for (const step of testSteps) {\n    if (!acceptanceCriteria.find((ac) => ac.id === step.id)) {\n      issues.push({\n        code: 'ORPHAN_TEST_STEP',\n        message: `test.step '${step.id}' does not match any acceptance criterion`,\n        severity: 'warning',\n        suggestion: 'Remove orphan step or add corresponding AC',\n      });\n    }\n  }\n\n  // Calculate overall stats\n  const totalACs = perAC.length;\n  const coveredACs = perAC.filter((ac) => ac.hasCoverage).length;\n  const overallCoverage = totalACs > 0 ? (coveredACs / totalACs) * 100 : 100;\n\n  return {\n    fullCoverage: coveredACs === totalACs,\n    totalACs,\n    coveredACs,\n    overallCoverage,\n    perAC,\n    issues,\n  };\n}\n\n/**\n * Generate coverage report as markdown\n */\nexport function generateCoverageReport(result: CoverageResult): string {\n  const lines: string[] = [];\n\n  lines.push('# AC Coverage Report');\n  lines.push('');\n  lines.push(`**Overall Coverage**: ${Math.round(result.overallCoverage)}% (${result.coveredACs}/${result.totalACs} ACs)`);\n  lines.push('');\n\n  if (result.fullCoverage) {\n    lines.push(' All acceptance criteria are covered');\n  } else {\n    lines.push(' Some acceptance criteria are missing coverage');\n  }\n\n  lines.push('');\n  lines.push('## Per-AC Coverage');\n  lines.push('');\n  lines.push('| AC ID | Title | Coverage | Status |');\n  lines.push('|-------|-------|----------|--------|');\n\n  for (const ac of result.perAC) {\n    const status = ac.hasCoverage ? (ac.coveragePercent >= 80 ? '' : '') : '';\n    lines.push(\n      `| ${ac.acId} | ${ac.acTitle.slice(0, 30)}${ac.acTitle.length > 30 ? '...' : ''} | ${Math.round(ac.coveragePercent)}% | ${status} |`\n    );\n  }\n\n  if (result.issues.length > 0) {\n    lines.push('');\n    lines.push('## Issues');\n    lines.push('');\n    for (const issue of result.issues) {\n      const icon = issue.severity === 'error' ? '' : issue.severity === 'warning' ? '' : '';\n      lines.push(`- ${icon} **${issue.code}**: ${issue.message}`);\n      if (issue.suggestion) {\n        lines.push(`  - Suggestion: ${issue.suggestion}`);\n      }\n    }\n  }\n\n  return lines.join('\\n');\n}\n","/**\n * Code Validator - Aggregate all validation checks for generated code\n * @see T044 - Generated code validator (aggregates all checks)\n */\nimport type { ValidationIssue, ValidationSeverity, JourneyValidationResult } from './journey.js';\nimport { validateJourneyFrontmatter } from './journey.js';\nimport { scanForbiddenPatterns, scanResultsToIssues, getViolationSummary } from './patterns.js';\nimport { lintCode, type LintResult } from './lint.js';\nimport { validateTagsInCode, type TagValidationResult } from './tags.js';\nimport { validateIRCoverage, type CoverageResult } from './coverage.js';\nimport type { IRJourney } from '../ir/types.js';\nimport type { JourneyFrontmatter } from '../journey/parseJourney.js';\n\n/**\n * Full validation result for generated code\n */\nexport interface CodeValidationResult {\n  /** Overall pass/fail status */\n  valid: boolean;\n  /** Journey ID being validated */\n  journeyId: string;\n  /** All validation issues */\n  issues: ValidationIssue[];\n  /** Issue counts by severity */\n  counts: {\n    errors: number;\n    warnings: number;\n    info: number;\n  };\n  /** Individual validation results */\n  details: {\n    frontmatter?: JourneyValidationResult;\n    patterns: {\n      valid: boolean;\n      violationCount: number;\n    };\n    lint?: LintResult;\n    tags?: TagValidationResult;\n    coverage?: CoverageResult;\n  };\n  /** Validation timestamp */\n  timestamp: string;\n}\n\n/**\n * Options for code validation\n */\nexport interface CodeValidationOptions {\n  /** Whether to run ESLint */\n  runLint?: boolean;\n  /** Whether to validate tags */\n  validateTags?: boolean;\n  /** Whether to validate coverage */\n  validateCoverage?: boolean;\n  /** Whether to validate frontmatter */\n  validateFrontmatter?: boolean;\n  /** Custom forbidden patterns to check */\n  customPatterns?: RegExp[];\n  /** Minimum coverage percentage */\n  minCoverage?: number;\n  /** Allow drafts for generation */\n  allowDrafts?: boolean;\n}\n\nconst DEFAULT_OPTIONS: CodeValidationOptions = {\n  runLint: false, // ESLint requires setup, disabled by default\n  validateTags: true,\n  validateCoverage: true,\n  validateFrontmatter: true,\n  minCoverage: 80,\n  allowDrafts: false,\n};\n\n/**\n * Validate generated test code\n */\nexport async function validateCode(\n  code: string,\n  journey: IRJourney,\n  frontmatter?: JourneyFrontmatter,\n  options: CodeValidationOptions = {}\n): Promise<CodeValidationResult> {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n  const allIssues: ValidationIssue[] = [];\n  const details: CodeValidationResult['details'] = {\n    patterns: { valid: true, violationCount: 0 },\n  };\n\n  // 1. Frontmatter validation\n  if (opts.validateFrontmatter && frontmatter) {\n    const frontmatterResult = validateJourneyFrontmatter(frontmatter, {\n      allowDrafts: opts.allowDrafts,\n    });\n    details.frontmatter = frontmatterResult;\n    allIssues.push(...frontmatterResult.issues);\n  }\n\n  // 2. Forbidden pattern scan\n  const patternResults = scanForbiddenPatterns(code);\n  const patternIssues = scanResultsToIssues(patternResults);\n  allIssues.push(...patternIssues);\n\n  const patternSummary = getViolationSummary(patternResults);\n  details.patterns = {\n    valid: patternSummary.errors === 0,\n    violationCount: patternSummary.total,\n  };\n\n  // 3. ESLint (optional)\n  if (opts.runLint) {\n    const lintResult = await lintCode(code, `${journey.id.toLowerCase()}.spec.ts`);\n    details.lint = lintResult;\n    allIssues.push(...lintResult.issues);\n  }\n\n  // 4. Tag validation\n  if (opts.validateTags) {\n    const tagResult = validateTagsInCode(code, journey.id, journey.tier, journey.scope);\n    details.tags = tagResult;\n    allIssues.push(...tagResult.issues);\n  }\n\n  // 5. Coverage validation\n  if (opts.validateCoverage) {\n    const coverageResult = validateIRCoverage(journey, {\n      minCoverage: opts.minCoverage,\n      warnPartialCoverage: true,\n    });\n    details.coverage = coverageResult;\n    allIssues.push(...coverageResult.issues);\n  }\n\n  // Calculate counts\n  const counts = {\n    errors: allIssues.filter((i) => i.severity === 'error').length,\n    warnings: allIssues.filter((i) => i.severity === 'warning').length,\n    info: allIssues.filter((i) => i.severity === 'info').length,\n  };\n\n  return {\n    valid: counts.errors === 0,\n    journeyId: journey.id,\n    issues: allIssues,\n    counts,\n    details,\n    timestamp: new Date().toISOString(),\n  };\n}\n\n/**\n * Synchronous validation (without ESLint)\n */\nexport function validateCodeSync(\n  code: string,\n  journey: IRJourney,\n  frontmatter?: JourneyFrontmatter,\n  options: Omit<CodeValidationOptions, 'runLint'> = {}\n): CodeValidationResult {\n  const opts = { ...DEFAULT_OPTIONS, ...options, runLint: false };\n  const allIssues: ValidationIssue[] = [];\n  const details: CodeValidationResult['details'] = {\n    patterns: { valid: true, violationCount: 0 },\n  };\n\n  // 1. Frontmatter validation\n  if (opts.validateFrontmatter && frontmatter) {\n    const frontmatterResult = validateJourneyFrontmatter(frontmatter, {\n      allowDrafts: opts.allowDrafts,\n    });\n    details.frontmatter = frontmatterResult;\n    allIssues.push(...frontmatterResult.issues);\n  }\n\n  // 2. Forbidden pattern scan\n  const patternResults = scanForbiddenPatterns(code);\n  const patternIssues = scanResultsToIssues(patternResults);\n  allIssues.push(...patternIssues);\n\n  const patternSummary = getViolationSummary(patternResults);\n  details.patterns = {\n    valid: patternSummary.errors === 0,\n    violationCount: patternSummary.total,\n  };\n\n  // 3. Tag validation\n  if (opts.validateTags) {\n    const tagResult = validateTagsInCode(code, journey.id, journey.tier, journey.scope);\n    details.tags = tagResult;\n    allIssues.push(...tagResult.issues);\n  }\n\n  // 4. Coverage validation\n  if (opts.validateCoverage) {\n    const coverageResult = validateIRCoverage(journey, {\n      minCoverage: opts.minCoverage,\n      warnPartialCoverage: true,\n    });\n    details.coverage = coverageResult;\n    allIssues.push(...coverageResult.issues);\n  }\n\n  // Calculate counts\n  const counts = {\n    errors: allIssues.filter((i) => i.severity === 'error').length,\n    warnings: allIssues.filter((i) => i.severity === 'warning').length,\n    info: allIssues.filter((i) => i.severity === 'info').length,\n  };\n\n  return {\n    valid: counts.errors === 0,\n    journeyId: journey.id,\n    issues: allIssues,\n    counts,\n    details,\n    timestamp: new Date().toISOString(),\n  };\n}\n\n/**\n * Quick pass/fail check\n */\nexport function isCodeValid(\n  code: string,\n  journey: IRJourney,\n  frontmatter?: JourneyFrontmatter\n): boolean {\n  const result = validateCodeSync(code, journey, frontmatter);\n  return result.valid;\n}\n\n/**\n * Generate validation report as markdown\n */\nexport function generateValidationReport(result: CodeValidationResult): string {\n  const lines: string[] = [];\n\n  lines.push('# Code Validation Report');\n  lines.push('');\n  lines.push(`**Journey**: ${result.journeyId}`);\n  lines.push(`**Status**: ${result.valid ? ' PASSED' : ' FAILED'}`);\n  lines.push(`**Timestamp**: ${result.timestamp}`);\n  lines.push('');\n\n  lines.push('## Summary');\n  lines.push('');\n  lines.push(`- Errors: ${result.counts.errors}`);\n  lines.push(`- Warnings: ${result.counts.warnings}`);\n  lines.push(`- Info: ${result.counts.info}`);\n  lines.push('');\n\n  lines.push('## Validation Checks');\n  lines.push('');\n\n  // Frontmatter\n  if (result.details.frontmatter) {\n    const fm = result.details.frontmatter;\n    lines.push(`### Frontmatter: ${fm.valid ? '' : ''}`);\n    lines.push('');\n  }\n\n  // Patterns\n  const patterns = result.details.patterns;\n  lines.push(`### Forbidden Patterns: ${patterns.valid ? '' : ''}`);\n  lines.push(`- Violations found: ${patterns.violationCount}`);\n  lines.push('');\n\n  // ESLint\n  if (result.details.lint) {\n    const lint = result.details.lint;\n    lines.push(`### ESLint: ${lint.passed ? '' : ''}`);\n    lines.push(`- Errors: ${lint.errorCount}`);\n    lines.push(`- Warnings: ${lint.warningCount}`);\n    lines.push('');\n  }\n\n  // Tags\n  if (result.details.tags) {\n    const tags = result.details.tags;\n    lines.push(`### Tags: ${tags.valid ? '' : ''}`);\n    lines.push('');\n  }\n\n  // Coverage\n  if (result.details.coverage) {\n    const coverage = result.details.coverage;\n    lines.push(`### Coverage: ${coverage.fullCoverage ? '' : ''}`);\n    lines.push(`- Overall: ${Math.round(coverage.overallCoverage)}%`);\n    lines.push(`- ACs Covered: ${coverage.coveredACs}/${coverage.totalACs}`);\n    lines.push('');\n  }\n\n  // Issues\n  if (result.issues.length > 0) {\n    lines.push('## Issues');\n    lines.push('');\n\n    const groupedIssues: Record<ValidationSeverity, ValidationIssue[]> = {\n      error: [],\n      warning: [],\n      info: [],\n    };\n\n    for (const issue of result.issues) {\n      groupedIssues[issue.severity].push(issue);\n    }\n\n    if (groupedIssues.error.length > 0) {\n      lines.push('### Errors');\n      for (const issue of groupedIssues.error) {\n        lines.push(`-  **${issue.code}**: ${issue.message}`);\n        if (issue.suggestion) {\n          lines.push(`  -  ${issue.suggestion}`);\n        }\n      }\n      lines.push('');\n    }\n\n    if (groupedIssues.warning.length > 0) {\n      lines.push('### Warnings');\n      for (const issue of groupedIssues.warning) {\n        lines.push(`-  **${issue.code}**: ${issue.message}`);\n        if (issue.suggestion) {\n          lines.push(`  -  ${issue.suggestion}`);\n        }\n      }\n      lines.push('');\n    }\n\n    if (groupedIssues.info.length > 0) {\n      lines.push('### Info');\n      for (const issue of groupedIssues.info) {\n        lines.push(`-  **${issue.code}**: ${issue.message}`);\n        if (issue.suggestion) {\n          lines.push(`  -  ${issue.suggestion}`);\n        }\n      }\n      lines.push('');\n    }\n  }\n\n  return lines.join('\\n');\n}\n","/**\n * Validation module exports\n */\n\n// Journey validation\nexport {\n  type ValidationSeverity,\n  type ValidationIssue,\n  type JourneyValidationResult,\n  type JourneyValidationOptions,\n  validateJourneySchema,\n  validateJourneyStatus,\n  validateJourneyTier,\n  validateJourneyTags,\n  validateJourneyFrontmatter,\n  isJourneyReady,\n} from './journey.js';\n\n// Pattern scanning\nexport {\n  type ForbiddenPattern,\n  type PatternScanResult,\n  FORBIDDEN_PATTERNS,\n  scanForbiddenPatterns,\n  scanResultsToIssues,\n  getPatternStats,\n  hasErrorViolations,\n  filterBySeverity,\n  getViolationSummary,\n} from './patterns.js';\n\n// ESLint integration\nexport {\n  type LintResult,\n  type LintOptions,\n  PLAYWRIGHT_LINT_RULES,\n  generateESLintConfig,\n  isESLintAvailable,\n  isPlaywrightPluginAvailable,\n  parseESLintOutput,\n  lintCode,\n  lintFile,\n  hasLintErrors,\n} from './lint.js';\n\n// Tag validation\nexport {\n  TAG_PATTERNS,\n  type TagValidationOptions,\n  type TagValidationResult,\n  parseTagsFromCode,\n  parseTagsFromFrontmatter,\n  categorizeTags,\n  validateTags,\n  generateExpectedTags,\n  validateTagsInCode,\n} from './tags.js';\n\n// Coverage validation\nexport {\n  type ACCoverageResult,\n  type CoverageResult,\n  type CoverageOptions,\n  findTestSteps,\n  findACReferences,\n  validateIRCoverage,\n  validateCodeCoverage,\n  generateCoverageReport,\n} from './coverage.js';\n\n// Code validation (aggregated)\nexport {\n  type CodeValidationResult,\n  type CodeValidationOptions,\n  validateCode,\n  validateCodeSync,\n  isCodeValid,\n  generateValidationReport,\n} from './code.js';\n","/**\n * Playwright CLI Runner Wrapper - Execute tests and capture results\n * @see T050 - Implement Playwright CLI runner wrapper\n */\nimport { execSync, spawn, spawnSync, type ChildProcess } from 'node:child_process';\nimport { existsSync, mkdtempSync, rmSync, writeFileSync } from 'node:fs';\nimport { join, dirname } from 'node:path';\nimport { tmpdir } from 'node:os';\n\n/**\n * Options for running Playwright tests\n */\nexport interface RunnerOptions {\n  /** Working directory */\n  cwd?: string;\n  /** Test file or pattern to run */\n  testFile?: string;\n  /** Specific test to run (grep pattern) */\n  grep?: string;\n  /** Project to run (from playwright.config.ts) */\n  project?: string;\n  /** Number of workers */\n  workers?: number;\n  /** Retries on failure */\n  retries?: number;\n  /** Repeat each test N times (for flakiness check) */\n  repeatEach?: number;\n  /** Fail on flaky tests */\n  failOnFlaky?: boolean;\n  /** Timeout per test in ms */\n  timeout?: number;\n  /** Reporter to use */\n  reporter?: string;\n  /** Output directory for results */\n  outputDir?: string;\n  /** Environment variables */\n  env?: Record<string, string>;\n  /** Headed mode */\n  headed?: boolean;\n  /** Enable debug mode */\n  debug?: boolean;\n  /** Update snapshots */\n  updateSnapshots?: boolean;\n}\n\n/**\n * Result of running Playwright tests\n */\nexport interface RunnerResult {\n  /** Whether the run succeeded (all tests passed) */\n  success: boolean;\n  /** Exit code from Playwright */\n  exitCode: number;\n  /** Stdout output */\n  stdout: string;\n  /** Stderr output */\n  stderr: string;\n  /** Path to JSON report (if generated) */\n  reportPath?: string;\n  /** Duration in milliseconds */\n  duration: number;\n  /** Command that was executed */\n  command: string;\n}\n\n/**\n * Check if Playwright is available\n */\nexport function isPlaywrightAvailable(cwd?: string): boolean {\n  try {\n    execSync('npx playwright --version', {\n      cwd,\n      stdio: 'pipe',\n      encoding: 'utf-8',\n    });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Get Playwright version\n */\nexport function getPlaywrightVersion(cwd?: string): string | null {\n  try {\n    const result = execSync('npx playwright --version', {\n      cwd,\n      stdio: 'pipe',\n      encoding: 'utf-8',\n    });\n    return result.trim();\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Build Playwright command arguments\n */\nexport function buildPlaywrightArgs(options: RunnerOptions): string[] {\n  const args = ['test'];\n\n  if (options.testFile) {\n    args.push(options.testFile);\n  }\n\n  if (options.grep) {\n    args.push('--grep', options.grep);\n  }\n\n  if (options.project) {\n    args.push('--project', options.project);\n  }\n\n  if (options.workers !== undefined) {\n    args.push('--workers', String(options.workers));\n  }\n\n  if (options.retries !== undefined) {\n    args.push('--retries', String(options.retries));\n  }\n\n  if (options.repeatEach !== undefined) {\n    args.push('--repeat-each', String(options.repeatEach));\n  }\n\n  if (options.failOnFlaky) {\n    args.push('--fail-on-flaky-tests');\n  }\n\n  if (options.timeout !== undefined) {\n    args.push('--timeout', String(options.timeout));\n  }\n\n  if (options.reporter) {\n    args.push('--reporter', options.reporter);\n  }\n\n  if (options.outputDir) {\n    args.push('--output', options.outputDir);\n  }\n\n  if (options.headed) {\n    args.push('--headed');\n  }\n\n  if (options.debug) {\n    args.push('--debug');\n  }\n\n  if (options.updateSnapshots) {\n    args.push('--update-snapshots');\n  }\n\n  return args;\n}\n\n/**\n * Run Playwright tests synchronously\n */\nexport function runPlaywrightSync(options: RunnerOptions = {}): RunnerResult {\n  const { cwd = process.cwd(), env = {} } = options;\n\n  // Ensure Playwright is available\n  if (!isPlaywrightAvailable(cwd)) {\n    return {\n      success: false,\n      exitCode: 1,\n      stdout: '',\n      stderr: 'Playwright is not installed',\n      duration: 0,\n      command: 'npx playwright test',\n    };\n  }\n\n  // Create temp dir for JSON report (using mkdtempSync for unpredictable names)\n  const tempDir = mkdtempSync(join(tmpdir(), 'autogen-verify-'));\n  const reportPath = join(tempDir, 'results.json');\n\n  // Build command args\n  const args = buildPlaywrightArgs({\n    ...options,\n    reporter: `json,line`,\n  });\n\n  // Command string for logging only\n  const command = `npx playwright ${args.join(' ')}`;\n  const startTime = Date.now();\n\n  try {\n    // SECURITY: Use spawnSync with array args to prevent command injection\n    // This avoids shell interpretation of special characters in file paths\n    const result = spawnSync('npx', ['playwright', ...args], {\n      cwd,\n      stdio: 'pipe',\n      encoding: 'utf-8',\n      env: {\n        ...process.env,\n        ...env,\n        PLAYWRIGHT_JSON_OUTPUT_NAME: reportPath,\n      },\n      timeout: options.timeout ? options.timeout * 10 : 600000, // 10x test timeout or 10 min\n    });\n\n    const success = result.status === 0;\n    return {\n      success,\n      exitCode: result.status ?? 1,\n      stdout: result.stdout || '',\n      stderr: result.stderr || '',\n      reportPath: existsSync(reportPath) ? reportPath : undefined,\n      duration: Date.now() - startTime,\n      command,\n    };\n  } finally {\n    // Always cleanup temp directory\n    try {\n      rmSync(tempDir, { recursive: true, force: true });\n    } catch {\n      // Ignore cleanup errors\n    }\n  }\n}\n\n/**\n * Run Playwright tests asynchronously\n */\nexport function runPlaywrightAsync(\n  options: RunnerOptions = {}\n): Promise<RunnerResult> {\n  return new Promise((resolve) => {\n    const { cwd = process.cwd(), env = {} } = options;\n\n    // Create temp dir for JSON report (using mkdtempSync for unpredictable names)\n    const tempDir = mkdtempSync(join(tmpdir(), 'autogen-verify-'));\n    const reportPath = join(tempDir, 'results.json');\n\n    // Build command args\n    const args = buildPlaywrightArgs({\n      ...options,\n      reporter: 'json,line',\n    });\n\n    // Command string for logging only\n    const command = `npx playwright ${args.join(' ')}`;\n    const startTime = Date.now();\n\n    let stdout = '';\n    let stderr = '';\n\n    // Helper to cleanup and resolve\n    const cleanupAndResolve = (result: RunnerResult) => {\n      try {\n        rmSync(tempDir, { recursive: true, force: true });\n      } catch {\n        // Ignore cleanup errors\n      }\n      resolve(result);\n    };\n\n    // SECURITY: shell: false (default) prevents command injection via args\n    // Node.js v14.18+ handles .cmd/.bat files on Windows automatically\n    const child: ChildProcess = spawn('npx', ['playwright', ...args], {\n      cwd,\n      env: {\n        ...process.env,\n        ...env,\n        PLAYWRIGHT_JSON_OUTPUT_NAME: reportPath,\n      },\n    });\n\n    child.stdout?.on('data', (data: Buffer) => {\n      stdout += data.toString();\n    });\n\n    child.stderr?.on('data', (data: Buffer) => {\n      stderr += data.toString();\n    });\n\n    child.on('close', (code: number | null) => {\n      cleanupAndResolve({\n        success: code === 0,\n        exitCode: code || 1,\n        stdout,\n        stderr,\n        reportPath: existsSync(reportPath) ? reportPath : undefined,\n        duration: Date.now() - startTime,\n        command,\n      });\n    });\n\n    child.on('error', (error: Error) => {\n      cleanupAndResolve({\n        success: false,\n        exitCode: 1,\n        stdout,\n        stderr: error.message,\n        duration: Date.now() - startTime,\n        command,\n      });\n    });\n  });\n}\n\n/**\n * Run a single test file\n */\nexport function runTestFile(\n  testFilePath: string,\n  options: Omit<RunnerOptions, 'testFile'> = {}\n): RunnerResult {\n  if (!existsSync(testFilePath)) {\n    return {\n      success: false,\n      exitCode: 1,\n      stdout: '',\n      stderr: `Test file not found: ${testFilePath}`,\n      duration: 0,\n      command: '',\n    };\n  }\n\n  return runPlaywrightSync({\n    ...options,\n    testFile: testFilePath,\n    cwd: options.cwd || dirname(testFilePath),\n  });\n}\n\n/**\n * Run tests by journey ID tag\n */\nexport function runJourneyTests(\n  journeyId: string,\n  options: Omit<RunnerOptions, 'grep'> = {}\n): RunnerResult {\n  return runPlaywrightSync({\n    ...options,\n    grep: `@${journeyId}`,\n  });\n}\n\n/**\n * Check if a test file compiles (syntax check)\n */\nexport function checkTestSyntax(testFilePath: string, cwd?: string): boolean {\n  if (!existsSync(testFilePath)) {\n    return false;\n  }\n\n  // SECURITY: Use spawnSync with array args to prevent command injection\n  // This avoids shell interpretation of special characters in testFilePath\n  const result = spawnSync('npx', ['tsc', '--noEmit', testFilePath], {\n    cwd: cwd || dirname(testFilePath),\n    stdio: 'pipe',\n  });\n  return result.status === 0;\n}\n\n/**\n * Write test file and run it\n */\nexport function writeAndRunTest(\n  code: string,\n  filename: string,\n  options: RunnerOptions = {}\n): RunnerResult {\n  // Use mkdtempSync for unpredictable temp directory names\n  const tempDir = mkdtempSync(join(tmpdir(), 'autogen-test-'));\n\n  const testPath = join(tempDir, filename);\n  writeFileSync(testPath, code, 'utf-8');\n\n  try {\n    return runTestFile(testPath, options);\n  } finally {\n    // Cleanup temp directory\n    try {\n      rmSync(tempDir, { recursive: true, force: true });\n    } catch {\n      // Ignore cleanup errors\n    }\n  }\n}\n\n/**\n * Get test count from Playwright\n */\nexport function getTestCount(testFile: string, cwd?: string): number {\n  // SECURITY: Use spawnSync with array args to prevent command injection\n  // This avoids shell interpretation of special characters in testFile\n  const result = spawnSync('npx', ['playwright', 'test', '--list', testFile], {\n    cwd,\n    stdio: 'pipe',\n    encoding: 'utf-8',\n  });\n\n  if (result.status !== 0) {\n    return 0;\n  }\n\n  // Parse \"Listing X tests\" output\n  const output = result.stdout || '';\n  const match = output.match(/Listing (\\d+) tests?/);\n  return match ? parseInt(match[1]!, 10) : 0;\n}\n","/**\n * Playwright JSON Report Parser - Parse test results from JSON reporter\n * @see T051 - Implement JSON report parser for test results\n */\nimport { readFileSync, existsSync } from 'node:fs';\n\n/**\n * Test status from Playwright\n */\nexport type TestStatus = 'passed' | 'failed' | 'timedOut' | 'skipped' | 'interrupted';\n\n/**\n * Error attachment from Playwright\n */\nexport interface ErrorAttachment {\n  name: string;\n  contentType: string;\n  path?: string;\n  body?: string;\n}\n\n/**\n * Test error details\n */\nexport interface TestError {\n  message: string;\n  stack?: string;\n  location?: {\n    file: string;\n    line: number;\n    column: number;\n  };\n  snippet?: string;\n}\n\n/**\n * Test step from Playwright report\n */\nexport interface ReportStep {\n  title: string;\n  category: string;\n  duration: number;\n  error?: TestError;\n  steps?: ReportStep[];\n}\n\n/**\n * Single test result from Playwright report\n */\nexport interface TestResult {\n  /** Test title */\n  title: string;\n  /** Full title path */\n  titlePath: string[];\n  /** Test location */\n  location: {\n    file: string;\n    line: number;\n    column: number;\n  };\n  /** Test status */\n  status: TestStatus;\n  /** Test duration in ms */\n  duration: number;\n  /** Retry number (0 = first attempt) */\n  retry: number;\n  /** Errors if failed */\n  errors: TestError[];\n  /** Test steps */\n  steps: ReportStep[];\n  /** Attachments */\n  attachments: ErrorAttachment[];\n  /** Annotations */\n  annotations: Array<{ type: string; description?: string }>;\n  /** Tags */\n  tags: string[];\n}\n\n/**\n * Suite from Playwright report\n */\nexport interface TestSuite {\n  title: string;\n  file: string;\n  line: number;\n  column: number;\n  specs: TestSpec[];\n  suites: TestSuite[];\n}\n\n/**\n * Test spec from Playwright report\n */\nexport interface TestSpec {\n  title: string;\n  ok: boolean;\n  tags: string[];\n  tests: Array<{\n    expectedStatus: TestStatus;\n    status: TestStatus;\n    projectName: string;\n    results: TestResult[];\n  }>;\n}\n\n/**\n * Full Playwright JSON report\n */\nexport interface PlaywrightReport {\n  config: {\n    rootDir: string;\n    projects: Array<{\n      name: string;\n      testDir: string;\n    }>;\n  };\n  suites: TestSuite[];\n  errors: TestError[];\n  stats: {\n    startTime: string;\n    duration: number;\n    expected: number;\n    unexpected: number;\n    flaky: number;\n    skipped: number;\n  };\n}\n\n/**\n * Parsed test summary\n */\nexport interface ParsedSummary {\n  total: number;\n  passed: number;\n  failed: number;\n  skipped: number;\n  flaky: number;\n  duration: number;\n  startTime: Date;\n  files: string[];\n  failedTests: TestResult[];\n  flakyTests: TestResult[];\n}\n\n/**\n * Parse Playwright JSON report from file\n */\nexport function parseReportFile(filePath: string): PlaywrightReport | null {\n  if (!existsSync(filePath)) {\n    return null;\n  }\n\n  try {\n    const content = readFileSync(filePath, 'utf-8');\n    return JSON.parse(content) as PlaywrightReport;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Parse Playwright JSON report from string\n */\nexport function parseReportContent(content: string): PlaywrightReport | null {\n  try {\n    return JSON.parse(content) as PlaywrightReport;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Extract all test results from report\n */\nexport function extractTestResults(report: PlaywrightReport): TestResult[] {\n  const results: TestResult[] = [];\n\n  function extractFromSuite(suite: TestSuite, titlePath: string[] = []): void {\n    const currentPath = [...titlePath, suite.title].filter(Boolean);\n\n    for (const spec of suite.specs) {\n      for (const test of spec.tests) {\n        for (const result of test.results) {\n          results.push({\n            ...result,\n            titlePath: [...currentPath, spec.title],\n          });\n        }\n      }\n    }\n\n    for (const childSuite of suite.suites) {\n      extractFromSuite(childSuite, currentPath);\n    }\n  }\n\n  for (const suite of report.suites) {\n    extractFromSuite(suite);\n  }\n\n  return results;\n}\n\n/**\n * Get summary from Playwright report\n */\nexport function getSummary(report: PlaywrightReport): ParsedSummary {\n  const allResults = extractTestResults(report);\n\n  const failedTests = allResults.filter((r) => r.status === 'failed');\n  const passedTests = allResults.filter((r) => r.status === 'passed');\n  const skippedTests = allResults.filter((r) => r.status === 'skipped');\n\n  // Flaky tests: passed on retry\n  const flakyTests = allResults.filter((r) => r.status === 'passed' && r.retry > 0);\n\n  // Extract unique file paths\n  const files = [...new Set(allResults.map((r) => r.location.file))];\n\n  return {\n    total: allResults.length,\n    passed: passedTests.length,\n    failed: failedTests.length,\n    skipped: skippedTests.length,\n    flaky: flakyTests.length,\n    duration: report.stats.duration,\n    startTime: new Date(report.stats.startTime),\n    files,\n    failedTests,\n    flakyTests,\n  };\n}\n\n/**\n * Get failed test details\n */\nexport function getFailedTests(report: PlaywrightReport): TestResult[] {\n  return extractTestResults(report).filter((r) => r.status === 'failed');\n}\n\n/**\n * Get flaky test details\n */\nexport function getFlakyTests(report: PlaywrightReport): TestResult[] {\n  return extractTestResults(report).filter(\n    (r) => r.status === 'passed' && r.retry > 0\n  );\n}\n\n/**\n * Get test by title pattern\n */\nexport function findTestsByTitle(\n  report: PlaywrightReport,\n  pattern: string | RegExp\n): TestResult[] {\n  const allResults = extractTestResults(report);\n  const regex = typeof pattern === 'string' ? new RegExp(pattern, 'i') : pattern;\n\n  return allResults.filter((r) => regex.test(r.title));\n}\n\n/**\n * Get tests by tag\n */\nexport function findTestsByTag(\n  report: PlaywrightReport,\n  tag: string\n): TestResult[] {\n  const allResults = extractTestResults(report);\n  return allResults.filter((r) => r.tags.includes(tag));\n}\n\n/**\n * Extract error messages from test result\n */\nexport function extractErrorMessages(result: TestResult): string[] {\n  return result.errors.map((e) => e.message);\n}\n\n/**\n * Extract error stack from test result\n */\nexport function extractErrorStacks(result: TestResult): string[] {\n  return result.errors\n    .map((e) => e.stack)\n    .filter((s): s is string => s !== undefined);\n}\n\n/**\n * Get step that failed\n */\nexport function getFailedStep(result: TestResult): ReportStep | null {\n  function findFailedStep(steps: ReportStep[]): ReportStep | null {\n    for (const step of steps) {\n      if (step.error) {\n        return step;\n      }\n      if (step.steps) {\n        const found = findFailedStep(step.steps);\n        if (found) return found;\n      }\n    }\n    return null;\n  }\n\n  return findFailedStep(result.steps);\n}\n\n/**\n * Check if report indicates overall success\n */\nexport function isReportSuccessful(report: PlaywrightReport): boolean {\n  return report.stats.unexpected === 0;\n}\n\n/**\n * Check if report has flaky tests\n */\nexport function reportHasFlaky(report: PlaywrightReport): boolean {\n  return report.stats.flaky > 0;\n}\n\n/**\n * Format test result for display\n */\nexport function formatTestResult(result: TestResult): string {\n  const status = result.status.toUpperCase();\n  const title = result.titlePath.join(' > ');\n  const duration = `${result.duration}ms`;\n  const retry = result.retry > 0 ? ` (retry ${result.retry})` : '';\n\n  let output = `[${status}] ${title} (${duration})${retry}`;\n\n  if (result.errors.length > 0) {\n    output += '\\n  Errors:';\n    for (const error of result.errors) {\n      output += `\\n    - ${error.message}`;\n    }\n  }\n\n  return output;\n}\n\n/**\n * Generate markdown summary\n */\nexport function generateMarkdownSummary(report: PlaywrightReport): string {\n  const summary = getSummary(report);\n  const lines: string[] = [];\n\n  lines.push('# Test Results Summary');\n  lines.push('');\n  lines.push(`**Status**: ${summary.failed === 0 ? ' PASSED' : ' FAILED'}`);\n  lines.push(`**Duration**: ${Math.round(summary.duration / 1000)}s`);\n  lines.push('');\n  lines.push('## Stats');\n  lines.push('');\n  lines.push(`- Total: ${summary.total}`);\n  lines.push(`- Passed: ${summary.passed}`);\n  lines.push(`- Failed: ${summary.failed}`);\n  lines.push(`- Skipped: ${summary.skipped}`);\n  lines.push(`- Flaky: ${summary.flaky}`);\n\n  if (summary.failedTests.length > 0) {\n    lines.push('');\n    lines.push('## Failed Tests');\n    lines.push('');\n    for (const test of summary.failedTests) {\n      lines.push(`### ${test.titlePath.join(' > ')}`);\n      for (const error of test.errors) {\n        lines.push('');\n        lines.push('```');\n        lines.push(error.message);\n        lines.push('```');\n      }\n    }\n  }\n\n  if (summary.flakyTests.length > 0) {\n    lines.push('');\n    lines.push('## Flaky Tests');\n    lines.push('');\n    for (const test of summary.flakyTests) {\n      lines.push(`- ${test.titlePath.join(' > ')} (passed on retry ${test.retry})`);\n    }\n  }\n\n  return lines.join('\\n');\n}\n","/**\n * Failure Classifier - Categorize test failures for actionable remediation\n * @see T052 - Implement failure classifier (selector, timing, navigation, data, auth, env)\n */\nimport type { TestResult, TestError } from './parser.js';\n\n/**\n * Failure category\n */\nexport type FailureCategory =\n  | 'selector'    // Element not found, locator issue\n  | 'timing'      // Timeout, race condition\n  | 'navigation'  // URL mismatch, redirect issue\n  | 'data'        // Test data issue, assertion mismatch\n  | 'auth'        // Authentication failure\n  | 'env'         // Environment issue (network, config)\n  | 'script'      // Test script error (syntax, logic)\n  | 'unknown';    // Cannot classify\n\n/**\n * Failure classification result\n */\nexport interface FailureClassification {\n  /** Primary category */\n  category: FailureCategory;\n  /** Confidence level (0-1) */\n  confidence: number;\n  /** Human-readable explanation */\n  explanation: string;\n  /** Suggested fix */\n  suggestion: string;\n  /** Whether this is likely a test issue vs app issue */\n  isTestIssue: boolean;\n  /** Keywords that triggered classification */\n  matchedKeywords: string[];\n}\n\n/**\n * Classification patterns\n */\ninterface ClassificationPattern {\n  category: FailureCategory;\n  keywords: RegExp[];\n  explanation: string;\n  suggestion: string;\n  isTestIssue: boolean;\n}\n\n/**\n * Patterns for classifying failures\n */\nconst CLASSIFICATION_PATTERNS: ClassificationPattern[] = [\n  // Selector issues\n  {\n    category: 'selector',\n    keywords: [\n      /locator\\s+resolved\\s+to\\s+\\d+\\s+elements/i,\n      /locator\\.click:\\s+Error/i,\n      /waiting\\s+for\\s+locator/i,\n      /element\\s+is\\s+not\\s+visible/i,\n      /element\\s+is\\s+not\\s+attached/i,\n      /element\\s+is\\s+not\\s+enabled/i,\n      /getBy\\w+\\s*\\([^)]+\\)/i,\n      /strict\\s+mode\\s+violation/i,\n      /No\\s+element\\s+matches\\s+selector/i,\n      /Target\\s+closed/i,\n      /element\\s+is\\s+outside\\s+of\\s+the\\s+viewport/i,\n    ],\n    explanation: 'Element locator failed to find or interact with element',\n    suggestion: 'Update selector to use more stable locator strategy (role, label, testid)',\n    isTestIssue: true,\n  },\n\n  // Timing issues\n  {\n    category: 'timing',\n    keywords: [\n      /timeout\\s+\\d+ms\\s+exceeded/i,\n      /exceeded\\s+while\\s+waiting/i,\n      /timed?\\s*out/i,\n      /waiting\\s+for\\s+navigation/i,\n      /waiting\\s+for\\s+load\\s+state/i,\n      /response\\s+took\\s+too\\s+long/i,\n      /expect\\.\\w+:\\s+Timeout/i,\n      /navigation\\s+was\\s+interrupted/i,\n    ],\n    explanation: 'Operation timed out waiting for element or network',\n    suggestion: 'Increase timeout or add explicit wait for expected state',\n    isTestIssue: true,\n  },\n\n  // Navigation issues\n  {\n    category: 'navigation',\n    keywords: [\n      /expected\\s+url.*to.*match/i,\n      /expected.*toHaveURL/i,\n      /page\\s+has\\s+been\\s+closed/i,\n      /navigation\\s+failed/i,\n      /net::ERR_/i,\n      /ERR_CONNECTION/i,\n      /ERR_NAME_NOT_RESOLVED/i,\n      /redirect/i,\n      /page\\.goto:\\s+Error/i,\n      /URL\\s+is\\s+not\\s+valid/i,\n    ],\n    explanation: 'Navigation to URL failed or URL mismatch',\n    suggestion: 'Check URL configuration and network connectivity',\n    isTestIssue: false,\n  },\n\n  // Data/assertion issues\n  {\n    category: 'data',\n    keywords: [\n      /expected.*to\\s+(?:be|equal|match|contain|have)/i,\n      /received.*but\\s+expected/i,\n      /toEqual/i,\n      /toBe\\(/i,\n      /toContain/i,\n      /toHaveText/i,\n      /toHaveValue/i,\n      /assertion\\s+failed/i,\n      /expected\\s+value/i,\n      /does\\s+not\\s+match/i,\n    ],\n    explanation: 'Assertion failed due to unexpected data',\n    suggestion: 'Verify test data matches expected application state',\n    isTestIssue: false,\n  },\n\n  // Auth issues\n  {\n    category: 'auth',\n    keywords: [\n      /401\\s+Unauthorized/i,\n      /403\\s+Forbidden/i,\n      /authentication\\s+failed/i,\n      /login\\s+failed/i,\n      /session\\s+expired/i,\n      /token\\s+invalid/i,\n      /access\\s+denied/i,\n      /not\\s+authenticated/i,\n      /sign\\s*in\\s+required/i,\n      /invalid\\s+credentials/i,\n    ],\n    explanation: 'Authentication or authorization failed',\n    suggestion: 'Check authentication state and credentials',\n    isTestIssue: false,\n  },\n\n  // Environment issues\n  {\n    category: 'env',\n    keywords: [\n      /ECONNREFUSED/i,\n      /ENOTFOUND/i,\n      /ETIMEDOUT/i,\n      /connection\\s+refused/i,\n      /network\\s+error/i,\n      /502\\s+Bad\\s+Gateway/i,\n      /503\\s+Service\\s+Unavailable/i,\n      /504\\s+Gateway\\s+Timeout/i,\n      /server\\s+error/i,\n      /browser\\s+has\\s+been\\s+closed/i,\n      /browser\\s+crash/i,\n      /context\\s+closed/i,\n    ],\n    explanation: 'Environment or infrastructure issue',\n    suggestion: 'Check application availability and environment configuration',\n    isTestIssue: false,\n  },\n\n  // Script errors\n  {\n    category: 'script',\n    keywords: [\n      /SyntaxError/i,\n      /TypeError/i,\n      /ReferenceError/i,\n      /undefined\\s+is\\s+not/i,\n      /is\\s+not\\s+a\\s+function/i,\n      /Cannot\\s+read\\s+propert/i,\n      /null\\s+is\\s+not/i,\n      /is\\s+not\\s+defined/i,\n      /Unexpected\\s+token/i,\n    ],\n    explanation: 'Test script has a code error',\n    suggestion: 'Fix the JavaScript/TypeScript error in the test',\n    isTestIssue: true,\n  },\n];\n\n/**\n * Classify a single error message\n */\nexport function classifyError(error: TestError): FailureClassification {\n  const errorText = `${error.message} ${error.stack || ''}`;\n  const matchedKeywords: string[] = [];\n  let bestMatch: ClassificationPattern | null = null;\n  let maxMatches = 0;\n\n  for (const pattern of CLASSIFICATION_PATTERNS) {\n    let matches = 0;\n    const patternMatches: string[] = [];\n\n    for (const keyword of pattern.keywords) {\n      if (keyword.test(errorText)) {\n        matches++;\n        patternMatches.push(keyword.source);\n      }\n    }\n\n    if (matches > maxMatches) {\n      maxMatches = matches;\n      bestMatch = pattern;\n      matchedKeywords.length = 0;\n      matchedKeywords.push(...patternMatches);\n    }\n  }\n\n  if (bestMatch && maxMatches > 0) {\n    return {\n      category: bestMatch.category,\n      confidence: Math.min(maxMatches / 3, 1), // Normalize to 0-1\n      explanation: bestMatch.explanation,\n      suggestion: bestMatch.suggestion,\n      isTestIssue: bestMatch.isTestIssue,\n      matchedKeywords,\n    };\n  }\n\n  return {\n    category: 'unknown',\n    confidence: 0,\n    explanation: 'Unable to classify failure',\n    suggestion: 'Review error details manually',\n    isTestIssue: false,\n    matchedKeywords: [],\n  };\n}\n\n/**\n * Classify a test result\n */\nexport function classifyTestResult(result: TestResult): FailureClassification {\n  if (result.status !== 'failed' || result.errors.length === 0) {\n    return {\n      category: 'unknown',\n      confidence: 0,\n      explanation: 'Test did not fail or has no errors',\n      suggestion: 'N/A',\n      isTestIssue: false,\n      matchedKeywords: [],\n    };\n  }\n\n  // Classify each error and aggregate\n  const classifications = result.errors.map(classifyError);\n\n  // Find the most confident classification\n  const best = classifications.reduce((prev, curr) =>\n    curr.confidence > prev.confidence ? curr : prev\n  );\n\n  return best;\n}\n\n/**\n * Classify multiple test results\n */\nexport function classifyTestResults(\n  results: TestResult[]\n): Map<string, FailureClassification> {\n  const classified = new Map<string, FailureClassification>();\n\n  for (const result of results) {\n    if (result.status === 'failed') {\n      const key = result.titlePath.join(' > ');\n      classified.set(key, classifyTestResult(result));\n    }\n  }\n\n  return classified;\n}\n\n/**\n * Get failure statistics by category\n */\nexport function getFailureStats(\n  classifications: Map<string, FailureClassification>\n): Record<FailureCategory, number> {\n  const stats: Record<FailureCategory, number> = {\n    selector: 0,\n    timing: 0,\n    navigation: 0,\n    data: 0,\n    auth: 0,\n    env: 0,\n    script: 0,\n    unknown: 0,\n  };\n\n  for (const classification of classifications.values()) {\n    stats[classification.category]++;\n  }\n\n  return stats;\n}\n\n/**\n * Check if failures are likely healable\n */\nexport function isHealable(classification: FailureClassification): boolean {\n  // Selector and timing issues are typically healable\n  return (\n    classification.category === 'selector' ||\n    classification.category === 'timing'\n  );\n}\n\n/**\n * Get healable failures\n */\nexport function getHealableFailures(\n  classifications: Map<string, FailureClassification>\n): Map<string, FailureClassification> {\n  const healable = new Map<string, FailureClassification>();\n\n  for (const [key, classification] of classifications.entries()) {\n    if (isHealable(classification)) {\n      healable.set(key, classification);\n    }\n  }\n\n  return healable;\n}\n\n/**\n * Generate classification report\n */\nexport function generateClassificationReport(\n  classifications: Map<string, FailureClassification>\n): string {\n  const lines: string[] = [];\n  const stats = getFailureStats(classifications);\n\n  lines.push('# Failure Classification Report');\n  lines.push('');\n  lines.push('## Summary');\n  lines.push('');\n\n  for (const [category, count] of Object.entries(stats)) {\n    if (count > 0) {\n      lines.push(`- ${category}: ${count}`);\n    }\n  }\n\n  lines.push('');\n  lines.push('## Detailed Classifications');\n  lines.push('');\n\n  for (const [testName, classification] of classifications.entries()) {\n    lines.push(`### ${testName}`);\n    lines.push('');\n    lines.push(`- **Category**: ${classification.category}`);\n    lines.push(`- **Confidence**: ${Math.round(classification.confidence * 100)}%`);\n    lines.push(`- **Explanation**: ${classification.explanation}`);\n    lines.push(`- **Suggestion**: ${classification.suggestion}`);\n    lines.push(`- **Is Test Issue**: ${classification.isTestIssue ? 'Yes' : 'No'}`);\n    lines.push('');\n  }\n\n  return lines.join('\\n');\n}\n","/**\n * Stability Gate - Check for flaky tests with repeat execution\n * @see T053 - Implement stability gate (--repeat-each, --fail-on-flaky-tests)\n */\nimport { runPlaywrightSync, type RunnerOptions, type RunnerResult } from './runner.js';\nimport { parseReportFile, getSummary, type ParsedSummary } from './parser.js';\n\n/**\n * Stability check options\n */\nexport interface StabilityOptions extends Omit<RunnerOptions, 'repeatEach' | 'failOnFlaky'> {\n  /** Number of times to repeat each test */\n  repeatCount?: number;\n  /** Maximum allowed flaky rate (0-1) */\n  maxFlakyRate?: number;\n  /** Whether to stop on first flaky detection */\n  stopOnFlaky?: boolean;\n}\n\n/**\n * Stability check result\n */\nexport interface StabilityResult {\n  /** Whether all tests are stable */\n  stable: boolean;\n  /** Number of runs completed */\n  runsCompleted: number;\n  /** Flaky tests detected */\n  flakyTests: string[];\n  /** Flaky rate (flaky / total) */\n  flakyRate: number;\n  /** Summary of each run */\n  runSummaries: ParsedSummary[];\n  /** Runner result from final run */\n  runnerResult: RunnerResult;\n}\n\nconst DEFAULT_OPTIONS: Required<Pick<StabilityOptions, 'repeatCount' | 'maxFlakyRate' | 'stopOnFlaky'>> = {\n  repeatCount: 3,\n  maxFlakyRate: 0,\n  stopOnFlaky: false,\n};\n\n/**\n * Run stability check on tests\n */\nexport function checkStability(\n  options: StabilityOptions = {}\n): StabilityResult {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n\n  const result: StabilityResult = {\n    stable: true,\n    runsCompleted: 0,\n    flakyTests: [],\n    flakyRate: 0,\n    runSummaries: [],\n    runnerResult: {\n      success: false,\n      exitCode: 0,\n      stdout: '',\n      stderr: '',\n      duration: 0,\n      command: '',\n    },\n  };\n\n  // Run tests with repeat-each\n  const runnerResult = runPlaywrightSync({\n    ...options,\n    repeatEach: opts.repeatCount,\n    failOnFlaky: true,\n  });\n\n  result.runnerResult = runnerResult;\n  result.runsCompleted = opts.repeatCount;\n\n  // Parse report if available\n  if (runnerResult.reportPath) {\n    const report = parseReportFile(runnerResult.reportPath);\n    if (report) {\n      const summary = getSummary(report);\n      result.runSummaries.push(summary);\n\n      // Extract flaky tests\n      result.flakyTests = summary.flakyTests.map((t) => t.titlePath.join(' > '));\n\n      // Calculate flaky rate\n      result.flakyRate = summary.total > 0 ? summary.flaky / summary.total : 0;\n\n      // Check stability\n      result.stable = result.flakyRate <= opts.maxFlakyRate;\n    }\n  }\n\n  // If runner failed and no report, check stdout for flaky indication\n  if (!runnerResult.success && result.flakyTests.length === 0) {\n    if (runnerResult.stdout.includes('flaky') || runnerResult.stderr.includes('flaky')) {\n      result.stable = false;\n    }\n  }\n\n  return result;\n}\n\n/**\n * Quick stability check (2 runs)\n */\nexport function quickStabilityCheck(\n  options: Omit<StabilityOptions, 'repeatCount'> = {}\n): StabilityResult {\n  return checkStability({\n    ...options,\n    repeatCount: 2,\n  });\n}\n\n/**\n * Thorough stability check (5 runs)\n */\nexport function thoroughStabilityCheck(\n  options: Omit<StabilityOptions, 'repeatCount'> = {}\n): StabilityResult {\n  return checkStability({\n    ...options,\n    repeatCount: 5,\n  });\n}\n\n/**\n * Check if a specific test is stable\n */\nexport function isTestStable(\n  testFile: string,\n  testName: string,\n  repeatCount: number = 3,\n  options: Omit<StabilityOptions, 'repeatCount' | 'testFile' | 'grep'> = {}\n): boolean {\n  const result = checkStability({\n    ...options,\n    testFile,\n    grep: testName,\n    repeatCount,\n  });\n\n  return result.stable;\n}\n\n/**\n * Get flakiness score (0 = stable, 1 = always flaky)\n */\nexport function getFlakinessScore(result: StabilityResult): number {\n  if (result.runsCompleted === 0) return 0;\n  return result.flakyRate;\n}\n\n/**\n * Determine if test should be quarantined based on stability\n */\nexport function shouldQuarantine(\n  result: StabilityResult,\n  threshold: number = 0.3\n): boolean {\n  return result.flakyRate > threshold;\n}\n\n/**\n * Generate stability report\n */\nexport function generateStabilityReport(result: StabilityResult): string {\n  const lines: string[] = [];\n\n  lines.push('# Stability Check Report');\n  lines.push('');\n  lines.push(`**Status**: ${result.stable ? ' STABLE' : ' UNSTABLE'}`);\n  lines.push(`**Runs Completed**: ${result.runsCompleted}`);\n  lines.push(`**Flaky Rate**: ${Math.round(result.flakyRate * 100)}%`);\n  lines.push('');\n\n  if (result.flakyTests.length > 0) {\n    lines.push('## Flaky Tests Detected');\n    lines.push('');\n    for (const test of result.flakyTests) {\n      lines.push(`- ${test}`);\n    }\n    lines.push('');\n    lines.push('### Recommendations');\n    lines.push('');\n    lines.push('1. Review test steps for race conditions');\n    lines.push('2. Add explicit waits for expected states');\n    lines.push('3. Check for shared state between tests');\n    lines.push('4. Consider isolation improvements');\n  } else {\n    lines.push('## All Tests Stable');\n    lines.push('');\n    lines.push('No flakiness detected after repeated runs.');\n  }\n\n  return lines.join('\\n');\n}\n","/**\n * Evidence Capture - ARIA snapshots and screenshots for debugging\n * @see T054 - Implement ARIA snapshot capture helper\n */\nimport { existsSync, mkdirSync, writeFileSync, readFileSync } from 'node:fs';\nimport { join } from 'node:path';\n\n/**\n * ARIA snapshot for an element\n */\nexport interface ARIASnapshot {\n  /** Role of the element */\n  role: string;\n  /** Accessible name */\n  name?: string;\n  /** Current value */\n  value?: string;\n  /** Whether element is disabled */\n  disabled?: boolean;\n  /** Whether element is checked (for checkboxes/radios) */\n  checked?: boolean;\n  /** Whether element is expanded (for accordions/dropdowns) */\n  expanded?: boolean;\n  /** Whether element is pressed (for toggle buttons) */\n  pressed?: boolean;\n  /** Hierarchical level (for headings) */\n  level?: number;\n  /** Child elements */\n  children?: ARIASnapshot[];\n  /** Element's text content */\n  text?: string;\n  /** Additional ARIA attributes */\n  attributes?: Record<string, string>;\n}\n\n/**\n * Evidence collection result\n */\nexport interface Evidence {\n  /** Timestamp of collection */\n  timestamp: string;\n  /** URL where evidence was captured */\n  url: string;\n  /** Page title */\n  title: string;\n  /** ARIA snapshot of the page */\n  ariaSnapshot?: ARIASnapshot;\n  /** Path to screenshot */\n  screenshotPath?: string;\n  /** Path to trace file */\n  tracePath?: string;\n  /** Console messages */\n  consoleMessages?: string[];\n  /** Network errors */\n  networkErrors?: string[];\n  /** Custom metadata */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Evidence collection options\n */\nexport interface EvidenceOptions {\n  /** Directory to save evidence */\n  outputDir?: string;\n  /** Capture screenshot */\n  captureScreenshot?: boolean;\n  /** Capture ARIA snapshot */\n  captureAria?: boolean;\n  /** Capture console logs */\n  captureConsole?: boolean;\n  /** Capture network errors */\n  captureNetwork?: boolean;\n  /** Custom filename prefix */\n  prefix?: string;\n}\n\n/**\n * Generate Playwright code for capturing ARIA snapshot\n */\nexport function generateARIACaptureCode(): string {\n  return `\n// ARIA Snapshot Helper - Insert this in your test for debugging\nasync function captureARIASnapshot(page) {\n  return await page.evaluate(() => {\n    function getSnapshot(element) {\n      const role = element.getAttribute('role') ||\n                   element.tagName.toLowerCase();\n\n      const snapshot = { role };\n\n      // Get accessible name\n      const name = element.getAttribute('aria-label') ||\n                   element.getAttribute('aria-labelledby') ?\n                   document.getElementById(element.getAttribute('aria-labelledby'))?.textContent :\n                   element.textContent?.trim().slice(0, 100);\n      if (name) snapshot.name = name;\n\n      // Get ARIA states\n      if (element.getAttribute('aria-disabled') === 'true') {\n        snapshot.disabled = true;\n      }\n      if (element.getAttribute('aria-checked') === 'true') {\n        snapshot.checked = true;\n      }\n      if (element.getAttribute('aria-expanded') === 'true') {\n        snapshot.expanded = true;\n      }\n      if (element.getAttribute('aria-pressed') === 'true') {\n        snapshot.pressed = true;\n      }\n\n      // Get heading level\n      const levelMatch = element.tagName.match(/^H(\\\\d)$/i);\n      if (levelMatch) {\n        snapshot.level = parseInt(levelMatch[1], 10);\n      }\n\n      // Get children\n      const children = Array.from(element.children)\n        .map(child => getSnapshot(child))\n        .filter(c => c.role !== 'none' && c.role !== 'presentation');\n\n      if (children.length > 0) {\n        snapshot.children = children;\n      }\n\n      return snapshot;\n    }\n\n    return getSnapshot(document.body);\n  });\n}\n`.trim();\n}\n\n/**\n * Generate Playwright code for full evidence capture\n */\nexport function generateEvidenceCaptureCode(options: EvidenceOptions = {}): string {\n  const {\n    captureScreenshot = true,\n    captureAria = true,\n    captureConsole = true,\n  } = options;\n\n  const parts: string[] = [];\n\n  parts.push('// Evidence Capture Helper');\n  parts.push('const evidence = {');\n  parts.push('  timestamp: new Date().toISOString(),');\n  parts.push('  url: page.url(),');\n  parts.push('  title: await page.title(),');\n\n  if (captureAria) {\n    parts.push('  ariaSnapshot: await captureARIASnapshot(page),');\n  }\n\n  if (captureScreenshot) {\n    parts.push('  screenshotPath: await page.screenshot({ path: \"evidence.png\" }),');\n  }\n\n  if (captureConsole) {\n    parts.push('  consoleMessages: [], // Collect from page.on(\"console\")');\n  }\n\n  parts.push('};');\n\n  return parts.join('\\n');\n}\n\n/**\n * Create evidence directory\n */\nexport function createEvidenceDir(basePath: string, testId: string): string {\n  const evidenceDir = join(basePath, 'evidence', testId);\n  mkdirSync(evidenceDir, { recursive: true });\n  return evidenceDir;\n}\n\n/**\n * Save evidence to file\n */\nexport function saveEvidence(\n  evidence: Evidence,\n  outputDir: string,\n  testId: string\n): string {\n  const dir = createEvidenceDir(outputDir, testId);\n  const filename = `evidence-${Date.now()}.json`;\n  const filepath = join(dir, filename);\n\n  writeFileSync(filepath, JSON.stringify(evidence, null, 2), 'utf-8');\n  return filepath;\n}\n\n/**\n * Load evidence from file\n */\nexport function loadEvidence(filepath: string): Evidence | null {\n  if (!existsSync(filepath)) {\n    return null;\n  }\n\n  try {\n    const content = readFileSync(filepath, 'utf-8');\n    return JSON.parse(content) as Evidence;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Compare two ARIA snapshots\n */\nexport function compareARIASnapshots(\n  expected: ARIASnapshot,\n  actual: ARIASnapshot\n): { matches: boolean; differences: string[] } {\n  const differences: string[] = [];\n\n  function compare(\n    path: string,\n    exp: ARIASnapshot,\n    act: ARIASnapshot\n  ): void {\n    if (exp.role !== act.role) {\n      differences.push(`${path}: role mismatch (expected: ${exp.role}, actual: ${act.role})`);\n    }\n\n    if (exp.name !== act.name) {\n      differences.push(`${path}: name mismatch (expected: ${exp.name}, actual: ${act.name})`);\n    }\n\n    if (exp.disabled !== act.disabled) {\n      differences.push(`${path}: disabled state mismatch`);\n    }\n\n    if (exp.checked !== act.checked) {\n      differences.push(`${path}: checked state mismatch`);\n    }\n\n    // Compare children\n    const expChildren = exp.children || [];\n    const actChildren = act.children || [];\n\n    if (expChildren.length !== actChildren.length) {\n      differences.push(`${path}: children count mismatch (expected: ${expChildren.length}, actual: ${actChildren.length})`);\n    }\n\n    const minLen = Math.min(expChildren.length, actChildren.length);\n    for (let i = 0; i < minLen; i++) {\n      compare(`${path}/${expChildren[i]!.role}[${i}]`, expChildren[i]!, actChildren[i]!);\n    }\n  }\n\n  compare('/', expected, actual);\n\n  return {\n    matches: differences.length === 0,\n    differences,\n  };\n}\n\n/**\n * Find element in ARIA snapshot by role and name\n */\nexport function findInSnapshot(\n  snapshot: ARIASnapshot,\n  role: string,\n  name?: string\n): ARIASnapshot | null {\n  if (snapshot.role === role && (!name || snapshot.name === name)) {\n    return snapshot;\n  }\n\n  for (const child of snapshot.children || []) {\n    const found = findInSnapshot(child, role, name);\n    if (found) return found;\n  }\n\n  return null;\n}\n\n/**\n * Generate ARIA tree as text\n */\nexport function formatARIATree(\n  snapshot: ARIASnapshot,\n  indent: number = 0\n): string {\n  const prefix = '  '.repeat(indent);\n  let line = `${prefix}${snapshot.role}`;\n\n  if (snapshot.name) {\n    line += ` \"${snapshot.name}\"`;\n  }\n\n  const states: string[] = [];\n  if (snapshot.disabled) states.push('disabled');\n  if (snapshot.checked) states.push('checked');\n  if (snapshot.expanded) states.push('expanded');\n  if (snapshot.pressed) states.push('pressed');\n  if (snapshot.level) states.push(`level=${snapshot.level}`);\n\n  if (states.length > 0) {\n    line += ` [${states.join(', ')}]`;\n  }\n\n  const lines = [line];\n\n  for (const child of snapshot.children || []) {\n    lines.push(formatARIATree(child, indent + 1));\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Generate evidence report\n */\nexport function generateEvidenceReport(evidence: Evidence): string {\n  const lines: string[] = [];\n\n  lines.push('# Evidence Report');\n  lines.push('');\n  lines.push(`**Captured**: ${evidence.timestamp}`);\n  lines.push(`**URL**: ${evidence.url}`);\n  lines.push(`**Title**: ${evidence.title}`);\n  lines.push('');\n\n  if (evidence.screenshotPath) {\n    lines.push('## Screenshot');\n    lines.push('');\n    lines.push(`![Screenshot](${evidence.screenshotPath})`);\n    lines.push('');\n  }\n\n  if (evidence.ariaSnapshot) {\n    lines.push('## ARIA Snapshot');\n    lines.push('');\n    lines.push('```');\n    lines.push(formatARIATree(evidence.ariaSnapshot));\n    lines.push('```');\n    lines.push('');\n  }\n\n  if (evidence.consoleMessages && evidence.consoleMessages.length > 0) {\n    lines.push('## Console Messages');\n    lines.push('');\n    for (const msg of evidence.consoleMessages) {\n      lines.push(`- ${msg}`);\n    }\n    lines.push('');\n  }\n\n  if (evidence.networkErrors && evidence.networkErrors.length > 0) {\n    lines.push('## Network Errors');\n    lines.push('');\n    for (const err of evidence.networkErrors) {\n      lines.push(`- ${err}`);\n    }\n    lines.push('');\n  }\n\n  return lines.join('\\n');\n}\n","/**\n * Verify Summary Generator - Generate structured JSON summary of test runs\n * @see T055 - Implement verify summary JSON generator\n */\nimport { writeFileSync, mkdirSync } from 'node:fs';\nimport { dirname } from 'node:path';\nimport type { RunnerResult } from './runner.js';\nimport type { PlaywrightReport } from './parser.js';\nimport type { FailureClassification } from './classifier.js';\nimport type { StabilityResult } from './stability.js';\nimport { parseReportFile, getSummary, getFailedTests } from './parser.js';\nimport { classifyTestResults, getFailureStats } from './classifier.js';\n\n/**\n * Verification summary\n */\nexport interface VerifySummary {\n  /** Overall verification status */\n  status: 'passed' | 'failed' | 'flaky' | 'error';\n  /** Journey ID if available */\n  journeyId?: string;\n  /** Timestamp */\n  timestamp: string;\n  /** Duration in ms */\n  duration: number;\n  /** Test counts */\n  counts: {\n    total: number;\n    passed: number;\n    failed: number;\n    skipped: number;\n    flaky: number;\n  };\n  /** Failure analysis */\n  failures: {\n    tests: string[];\n    classifications: Record<string, FailureClassification>;\n    stats: Record<string, number>;\n  };\n  /** Stability information */\n  stability?: {\n    stable: boolean;\n    flakyTests: string[];\n    flakyRate: number;\n  };\n  /** Raw runner result */\n  runner: {\n    exitCode: number;\n    command: string;\n  };\n  /** Path to detailed report */\n  reportPath?: string;\n  /** Additional metadata */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Options for generating summary\n */\nexport interface SummaryOptions {\n  /** Journey ID to associate */\n  journeyId?: string;\n  /** Include stability results */\n  stabilityResult?: StabilityResult;\n  /** Additional metadata */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Generate verification summary from runner result\n */\nexport function generateVerifySummary(\n  runnerResult: RunnerResult,\n  options: SummaryOptions = {}\n): VerifySummary {\n  const summary: VerifySummary = {\n    status: 'error',\n    timestamp: new Date().toISOString(),\n    duration: runnerResult.duration,\n    counts: {\n      total: 0,\n      passed: 0,\n      failed: 0,\n      skipped: 0,\n      flaky: 0,\n    },\n    failures: {\n      tests: [],\n      classifications: {},\n      stats: {},\n    },\n    runner: {\n      exitCode: runnerResult.exitCode,\n      command: runnerResult.command,\n    },\n    reportPath: runnerResult.reportPath,\n  };\n\n  if (options.journeyId) {\n    summary.journeyId = options.journeyId;\n  }\n\n  if (options.metadata) {\n    summary.metadata = options.metadata;\n  }\n\n  // Parse report if available\n  if (runnerResult.reportPath) {\n    const report = parseReportFile(runnerResult.reportPath);\n    if (report) {\n      const parsed = getSummary(report);\n\n      // Update counts\n      summary.counts = {\n        total: parsed.total,\n        passed: parsed.passed,\n        failed: parsed.failed,\n        skipped: parsed.skipped,\n        flaky: parsed.flaky,\n      };\n\n      // Get failed tests\n      const failedTests = getFailedTests(report);\n      summary.failures.tests = failedTests.map((t) => t.titlePath.join(' > '));\n\n      // Classify failures\n      const classifications = classifyTestResults(failedTests);\n      summary.failures.classifications = Object.fromEntries(classifications);\n      summary.failures.stats = getFailureStats(classifications);\n\n      // Determine status\n      if (parsed.failed === 0) {\n        summary.status = parsed.flaky > 0 ? 'flaky' : 'passed';\n      } else {\n        summary.status = 'failed';\n      }\n    }\n  } else {\n    // No report - use runner result to determine status\n    summary.status = runnerResult.success ? 'passed' : 'failed';\n  }\n\n  // Add stability info if provided\n  if (options.stabilityResult) {\n    summary.stability = {\n      stable: options.stabilityResult.stable,\n      flakyTests: options.stabilityResult.flakyTests,\n      flakyRate: options.stabilityResult.flakyRate,\n    };\n\n    // Update status if unstable\n    if (!options.stabilityResult.stable && summary.status === 'passed') {\n      summary.status = 'flaky';\n    }\n  }\n\n  return summary;\n}\n\n/**\n * Generate summary from Playwright report directly\n */\nexport function generateSummaryFromReport(\n  report: PlaywrightReport,\n  options: SummaryOptions = {}\n): VerifySummary {\n  const parsed = getSummary(report);\n  const failedTests = getFailedTests(report);\n  const classifications = classifyTestResults(failedTests);\n\n  const summary: VerifySummary = {\n    status: parsed.failed === 0 ? (parsed.flaky > 0 ? 'flaky' : 'passed') : 'failed',\n    timestamp: parsed.startTime.toISOString(),\n    duration: parsed.duration,\n    counts: {\n      total: parsed.total,\n      passed: parsed.passed,\n      failed: parsed.failed,\n      skipped: parsed.skipped,\n      flaky: parsed.flaky,\n    },\n    failures: {\n      tests: failedTests.map((t) => t.titlePath.join(' > ')),\n      classifications: Object.fromEntries(classifications),\n      stats: getFailureStats(classifications),\n    },\n    runner: {\n      exitCode: parsed.failed > 0 ? 1 : 0,\n      command: 'N/A',\n    },\n  };\n\n  if (options.journeyId) {\n    summary.journeyId = options.journeyId;\n  }\n\n  if (options.metadata) {\n    summary.metadata = options.metadata;\n  }\n\n  return summary;\n}\n\n/**\n * Check if verification passed\n */\nexport function isVerificationPassed(summary: VerifySummary): boolean {\n  return summary.status === 'passed';\n}\n\n/**\n * Check if verification has failures\n */\nexport function hasFailures(summary: VerifySummary): boolean {\n  return summary.counts.failed > 0;\n}\n\n/**\n * Check if verification has flaky tests\n */\nexport function summaryHasFlaky(summary: VerifySummary): boolean {\n  return summary.counts.flaky > 0 || summary.stability?.flakyRate !== undefined && summary.stability.flakyRate > 0;\n}\n\n/**\n * Get actionable recommendations based on failures\n */\nexport function getRecommendations(summary: VerifySummary): string[] {\n  const recommendations: string[] = [];\n\n  if (summary.counts.failed > 0) {\n    // Analyze failure categories\n    const stats = summary.failures.stats;\n\n    if (stats.selector! > 0) {\n      recommendations.push(\n        `${stats.selector} selector issue(s): Update locators to use stable selectors (role, label, testid)`\n      );\n    }\n\n    if (stats.timing! > 0) {\n      recommendations.push(\n        `${stats.timing} timing issue(s): Add explicit waits or increase timeout`\n      );\n    }\n\n    if (stats.auth! > 0) {\n      recommendations.push(\n        `${stats.auth} auth issue(s): Check authentication state and credentials`\n      );\n    }\n\n    if (stats.env! > 0) {\n      recommendations.push(\n        `${stats.env} environment issue(s): Verify application is running and accessible`\n      );\n    }\n\n    if (stats.data! > 0) {\n      recommendations.push(\n        `${stats.data} data issue(s): Review test data and expected values`\n      );\n    }\n  }\n\n  if (summary.stability && !summary.stability.stable) {\n    recommendations.push(\n      `${summary.stability.flakyTests.length} flaky test(s) detected: Review for race conditions and add proper waits`\n    );\n  }\n\n  return recommendations;\n}\n\n/**\n * Generate human-readable summary\n */\nexport function formatVerifySummary(summary: VerifySummary): string {\n  const lines: string[] = [];\n\n  // Status header\n  const statusIcon =\n    summary.status === 'passed'\n      ? ''\n      : summary.status === 'flaky'\n      ? ''\n      : '';\n\n  lines.push(`${statusIcon} Verification ${summary.status.toUpperCase()}`);\n  lines.push('');\n\n  // Journey info\n  if (summary.journeyId) {\n    lines.push(`Journey: ${summary.journeyId}`);\n  }\n\n  lines.push(`Duration: ${Math.round(summary.duration / 1000)}s`);\n  lines.push('');\n\n  // Counts\n  lines.push('## Results');\n  lines.push(`- Total: ${summary.counts.total}`);\n  lines.push(`- Passed: ${summary.counts.passed}`);\n  lines.push(`- Failed: ${summary.counts.failed}`);\n  lines.push(`- Skipped: ${summary.counts.skipped}`);\n  lines.push(`- Flaky: ${summary.counts.flaky}`);\n  lines.push('');\n\n  // Failures\n  if (summary.failures.tests.length > 0) {\n    lines.push('## Failed Tests');\n    for (const test of summary.failures.tests) {\n      lines.push(`- ${test}`);\n    }\n    lines.push('');\n  }\n\n  // Stability\n  if (summary.stability) {\n    lines.push('## Stability');\n    lines.push(`- Stable: ${summary.stability.stable ? 'Yes' : 'No'}`);\n    lines.push(`- Flaky Rate: ${Math.round(summary.stability.flakyRate * 100)}%`);\n    lines.push('');\n  }\n\n  // Recommendations\n  const recommendations = getRecommendations(summary);\n  if (recommendations.length > 0) {\n    lines.push('## Recommendations');\n    for (const rec of recommendations) {\n      lines.push(`- ${rec}`);\n    }\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Save summary to JSON file\n */\nexport function saveSummary(summary: VerifySummary, outputPath: string): void {\n  mkdirSync(dirname(outputPath), { recursive: true });\n  writeFileSync(outputPath, JSON.stringify(summary, null, 2), 'utf-8');\n}\n","/**\n * Verification module exports\n */\n\n// Runner\nexport {\n  type RunnerOptions,\n  type RunnerResult,\n  isPlaywrightAvailable,\n  getPlaywrightVersion,\n  buildPlaywrightArgs,\n  runPlaywrightSync,\n  runPlaywrightAsync,\n  runTestFile,\n  runJourneyTests,\n  checkTestSyntax,\n  writeAndRunTest,\n  getTestCount,\n} from './runner.js';\n\n// Parser\nexport {\n  type TestStatus,\n  type ErrorAttachment,\n  type TestError,\n  type ReportStep,\n  type TestResult,\n  type TestSuite,\n  type TestSpec,\n  type PlaywrightReport,\n  type ParsedSummary,\n  parseReportFile,\n  parseReportContent,\n  extractTestResults,\n  getSummary,\n  getFailedTests,\n  getFlakyTests,\n  findTestsByTitle,\n  findTestsByTag,\n  extractErrorMessages,\n  extractErrorStacks,\n  getFailedStep,\n  isReportSuccessful,\n  reportHasFlaky,\n  formatTestResult,\n  generateMarkdownSummary,\n} from './parser.js';\n\n// Classifier\nexport {\n  type FailureCategory,\n  type FailureClassification,\n  classifyError,\n  classifyTestResult,\n  classifyTestResults,\n  getFailureStats,\n  isHealable,\n  getHealableFailures,\n  generateClassificationReport,\n} from './classifier.js';\n\n// Stability\nexport {\n  type StabilityOptions,\n  type StabilityResult,\n  checkStability,\n  quickStabilityCheck,\n  thoroughStabilityCheck,\n  isTestStable,\n  getFlakinessScore,\n  shouldQuarantine,\n  generateStabilityReport,\n} from './stability.js';\n\n// Evidence\nexport {\n  type ARIASnapshot,\n  type Evidence,\n  type EvidenceOptions,\n  generateARIACaptureCode,\n  generateEvidenceCaptureCode,\n  createEvidenceDir,\n  saveEvidence,\n  loadEvidence,\n  compareARIASnapshots,\n  findInSnapshot,\n  formatARIATree,\n  generateEvidenceReport,\n} from './evidence.js';\n\n// Summary\nexport {\n  type VerifySummary,\n  type SummaryOptions,\n  generateVerifySummary,\n  generateSummaryFromReport,\n  isVerificationPassed,\n  hasFailures,\n  summaryHasFlaky,\n  getRecommendations,\n  formatVerifySummary,\n  saveSummary,\n} from './summary.js';\n","/**\n * Healing Rules - Define allowed and forbidden healing operations\n * @see T061 - Define healing rules (allowed/forbidden fixes) per detailed spec Section 16\n */\nimport type { FailureCategory, FailureClassification } from '../verify/classifier.js';\n\n/**\n * Types of healing fixes\n */\nexport type HealFixType =\n  | 'selector-refine'      // Replace CSS with role/label/testid\n  | 'add-exact'            // Add exact: true to locator\n  | 'missing-await'        // Add missing await\n  | 'navigation-wait'      // Add waitForURL/toHaveURL\n  | 'timeout-increase'     // Increase timeout (bounded)\n  | 'web-first-assertion'; // Convert to web-first assertion\n\n/**\n * Forbidden fix types that must never be applied\n */\nexport type ForbiddenFixType =\n  | 'add-sleep'            // Never add waitForTimeout\n  | 'remove-assertion'     // Never remove assertions\n  | 'weaken-assertion'     // Never change toBe to toContain\n  | 'force-click'          // Never add force: true\n  | 'bypass-auth';         // Never skip authentication\n\n/**\n * Healing rule definition\n */\nexport interface HealingRule {\n  /** Fix type identifier */\n  fixType: HealFixType;\n  /** Categories this fix applies to */\n  appliesTo: FailureCategory[];\n  /** Priority (lower = try first) */\n  priority: number;\n  /** Human-readable description */\n  description: string;\n  /** Whether enabled by default */\n  enabledByDefault: boolean;\n}\n\n/**\n * Healing configuration\n */\nexport interface HealingConfig {\n  /** Whether healing is enabled */\n  enabled: boolean;\n  /** Maximum healing attempts */\n  maxAttempts: number;\n  /** Allowed fix types */\n  allowedFixes: HealFixType[];\n  /** Forbidden fix types (always blocked) */\n  forbiddenFixes: ForbiddenFixType[];\n  /** Timeout increase limit in ms */\n  maxTimeoutIncrease: number;\n}\n\n/**\n * Healing rule result\n */\nexport interface HealingRuleResult {\n  /** Whether healing is allowed for this failure */\n  canHeal: boolean;\n  /** Applicable fix types in priority order */\n  applicableFixes: HealFixType[];\n  /** Reason if healing not allowed */\n  reason?: string;\n}\n\n/**\n * Default healing rules\n */\nexport const DEFAULT_HEALING_RULES: HealingRule[] = [\n  {\n    fixType: 'missing-await',\n    appliesTo: ['selector', 'timing', 'script'],\n    priority: 1,\n    description: 'Add missing await to async operations',\n    enabledByDefault: true,\n  },\n  {\n    fixType: 'selector-refine',\n    appliesTo: ['selector'],\n    priority: 2,\n    description: 'Replace CSS selector with role/label/testid',\n    enabledByDefault: true,\n  },\n  {\n    fixType: 'add-exact',\n    appliesTo: ['selector'],\n    priority: 3,\n    description: 'Add exact: true to resolve ambiguous locators',\n    enabledByDefault: true,\n  },\n  {\n    fixType: 'navigation-wait',\n    appliesTo: ['navigation', 'timing'],\n    priority: 4,\n    description: 'Add waitForURL or toHaveURL assertion',\n    enabledByDefault: true,\n  },\n  {\n    fixType: 'web-first-assertion',\n    appliesTo: ['timing', 'data'],\n    priority: 5,\n    description: 'Convert to auto-retrying web-first assertion',\n    enabledByDefault: true,\n  },\n  {\n    fixType: 'timeout-increase',\n    appliesTo: ['timing'],\n    priority: 6,\n    description: 'Increase operation timeout (bounded)',\n    enabledByDefault: false, // Disabled by default as it can mask real issues\n  },\n];\n\n/**\n * Default healing configuration\n */\nexport const DEFAULT_HEALING_CONFIG: HealingConfig = {\n  enabled: true,\n  maxAttempts: 3,\n  allowedFixes: [\n    'selector-refine',\n    'add-exact',\n    'missing-await',\n    'navigation-wait',\n    'web-first-assertion',\n  ],\n  forbiddenFixes: [\n    'add-sleep',\n    'remove-assertion',\n    'weaken-assertion',\n    'force-click',\n    'bypass-auth',\n  ],\n  maxTimeoutIncrease: 30000, // Max 30 seconds\n};\n\n/**\n * Categories that cannot be healed automatically\n */\nexport const UNHEALABLE_CATEGORIES: FailureCategory[] = [\n  'auth',     // Requires credential/session fix\n  'env',      // Requires environment fix\n  'unknown',  // Cannot determine appropriate fix\n];\n\n/**\n * Check if a failure category is healable\n */\nexport function isCategoryHealable(category: FailureCategory): boolean {\n  return !UNHEALABLE_CATEGORIES.includes(category);\n}\n\n/**\n * Get applicable healing rules for a failure classification\n */\nexport function getApplicableRules(\n  classification: FailureClassification,\n  config: HealingConfig = DEFAULT_HEALING_CONFIG\n): HealingRule[] {\n  if (!config.enabled) {\n    return [];\n  }\n\n  if (!isCategoryHealable(classification.category)) {\n    return [];\n  }\n\n  return DEFAULT_HEALING_RULES\n    .filter((rule) => {\n      // Must apply to this failure category\n      if (!rule.appliesTo.includes(classification.category)) {\n        return false;\n      }\n      // Must be in allowed list\n      if (!config.allowedFixes.includes(rule.fixType)) {\n        return false;\n      }\n      return true;\n    })\n    .sort((a, b) => a.priority - b.priority);\n}\n\n/**\n * Evaluate healing possibilities for a failure\n */\nexport function evaluateHealing(\n  classification: FailureClassification,\n  config: HealingConfig = DEFAULT_HEALING_CONFIG\n): HealingRuleResult {\n  if (!config.enabled) {\n    return {\n      canHeal: false,\n      applicableFixes: [],\n      reason: 'Healing is disabled',\n    };\n  }\n\n  if (!isCategoryHealable(classification.category)) {\n    return {\n      canHeal: false,\n      applicableFixes: [],\n      reason: `Category '${classification.category}' cannot be healed automatically`,\n    };\n  }\n\n  const applicableRules = getApplicableRules(classification, config);\n\n  if (applicableRules.length === 0) {\n    return {\n      canHeal: false,\n      applicableFixes: [],\n      reason: 'No applicable healing rules for this failure',\n    };\n  }\n\n  return {\n    canHeal: true,\n    applicableFixes: applicableRules.map((r) => r.fixType),\n  };\n}\n\n/**\n * Get the next fix to try for a failure\n */\nexport function getNextFix(\n  classification: FailureClassification,\n  attemptedFixes: HealFixType[],\n  config: HealingConfig = DEFAULT_HEALING_CONFIG\n): HealFixType | null {\n  const evaluation = evaluateHealing(classification, config);\n\n  if (!evaluation.canHeal) {\n    return null;\n  }\n\n  // Find first fix that hasn't been tried\n  for (const fix of evaluation.applicableFixes) {\n    if (!attemptedFixes.includes(fix)) {\n      return fix;\n    }\n  }\n\n  return null; // All fixes exhausted\n}\n\n/**\n * Validate that a proposed fix is allowed\n */\nexport function isFixAllowed(\n  fixType: HealFixType,\n  config: HealingConfig = DEFAULT_HEALING_CONFIG\n): boolean {\n  return config.enabled && config.allowedFixes.includes(fixType);\n}\n\n/**\n * Validate that a fix is not forbidden\n */\nexport function isFixForbidden(\n  fixType: string\n): fixType is ForbiddenFixType {\n  const forbidden: string[] = [\n    'add-sleep',\n    'remove-assertion',\n    'weaken-assertion',\n    'force-click',\n    'bypass-auth',\n  ];\n  return forbidden.includes(fixType);\n}\n\n/**\n * Get healing recommendation based on failure\n */\nexport function getHealingRecommendation(\n  classification: FailureClassification\n): string {\n  switch (classification.category) {\n    case 'selector':\n      return 'Refine selector to use role, label, or testid locator strategy';\n    case 'timing':\n      return 'Add explicit wait for expected state or use web-first assertion';\n    case 'navigation':\n      return 'Add waitForURL or toHaveURL assertion after navigation';\n    case 'data':\n      return 'Verify test data and consider using expect.poll for dynamic values';\n    case 'auth':\n      return 'Check authentication state; may need to refresh session';\n    case 'env':\n      return 'Verify environment connectivity and application availability';\n    case 'script':\n      return 'Fix the JavaScript/TypeScript error in the test code';\n    default:\n      return 'Review error details manually to determine appropriate fix';\n  }\n}\n\n/**\n * Get next steps after healing exhausted\n */\nexport function getPostHealingRecommendation(\n  classification: FailureClassification,\n  attemptCount: number\n): string {\n  const baseMsg = `Healing exhausted after ${attemptCount} attempts.`;\n\n  switch (classification.category) {\n    case 'selector':\n      return `${baseMsg} Consider adding data-testid to the target element or quarantining the test.`;\n    case 'timing':\n      return `${baseMsg} The application may have a genuine performance issue. Consider quarantining.`;\n    case 'navigation':\n      return `${baseMsg} The navigation flow may have changed. Review Journey steps.`;\n    default:\n      return `${baseMsg} Consider quarantining the test and filing a bug report.`;\n  }\n}\n","/**\n * Healing Attempt Logger - Track healing attempts in heal-log.json\n * @see T066 - Implement healing attempt logger (heal-log.json)\n */\nimport { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs';\nimport { dirname, join } from 'node:path';\nimport type { HealFixType } from './rules.js';\nimport type { FailureCategory } from '../verify/classifier.js';\n\n/**\n * Single healing attempt record\n */\nexport interface HealingAttempt {\n  /** Attempt number (1-based) */\n  attempt: number;\n  /** Timestamp of the attempt */\n  timestamp: string;\n  /** Type of failure being healed */\n  failureType: FailureCategory;\n  /** Fix type applied */\n  fixType: HealFixType;\n  /** File that was modified */\n  file: string;\n  /** Diff or description of the change */\n  change: string;\n  /** Evidence files (traces, screenshots) */\n  evidence: string[];\n  /** Result of the attempt */\n  result: 'pass' | 'fail' | 'error';\n  /** Error message if failed */\n  errorMessage?: string;\n  /** Duration in ms */\n  duration: number;\n}\n\n/**\n * Complete healing log for a journey\n */\nexport interface HealingLog {\n  /** Journey ID */\n  journeyId: string;\n  /** Session start time */\n  sessionStart: string;\n  /** Session end time */\n  sessionEnd?: string;\n  /** Maximum attempts allowed */\n  maxAttempts: number;\n  /** Final status */\n  status: 'in_progress' | 'healed' | 'failed' | 'exhausted';\n  /** All healing attempts */\n  attempts: HealingAttempt[];\n  /** Summary statistics */\n  summary?: HealingSummary;\n}\n\n/**\n * Summary statistics\n */\nexport interface HealingSummary {\n  /** Total attempts made */\n  totalAttempts: number;\n  /** Successful fixes */\n  successfulFixes: number;\n  /** Failed attempts */\n  failedAttempts: number;\n  /** Total healing duration in ms */\n  totalDuration: number;\n  /** Fix types attempted */\n  fixTypesAttempted: HealFixType[];\n  /** Final recommendation if not healed */\n  recommendation?: string;\n}\n\n/**\n * Healing logger class\n */\nexport class HealingLogger {\n  private log: HealingLog;\n  private outputPath: string;\n\n  constructor(journeyId: string, outputDir: string, maxAttempts: number = 3) {\n    this.outputPath = join(outputDir, `${journeyId}.heal-log.json`);\n    this.log = {\n      journeyId,\n      sessionStart: new Date().toISOString(),\n      maxAttempts,\n      status: 'in_progress',\n      attempts: [],\n    };\n  }\n\n  /**\n   * Log a healing attempt\n   */\n  logAttempt(attempt: Omit<HealingAttempt, 'timestamp'>): void {\n    this.log.attempts.push({\n      ...attempt,\n      timestamp: new Date().toISOString(),\n    });\n    this.save();\n  }\n\n  /**\n   * Mark healing as complete (success)\n   */\n  markHealed(): void {\n    this.log.status = 'healed';\n    this.log.sessionEnd = new Date().toISOString();\n    this.calculateSummary();\n    this.save();\n  }\n\n  /**\n   * Mark healing as failed (gave up)\n   */\n  markFailed(recommendation?: string): void {\n    this.log.status = 'failed';\n    this.log.sessionEnd = new Date().toISOString();\n    this.calculateSummary();\n    if (recommendation && this.log.summary) {\n      this.log.summary.recommendation = recommendation;\n    }\n    this.save();\n  }\n\n  /**\n   * Mark healing as exhausted (all attempts used)\n   */\n  markExhausted(recommendation?: string): void {\n    this.log.status = 'exhausted';\n    this.log.sessionEnd = new Date().toISOString();\n    this.calculateSummary();\n    if (recommendation && this.log.summary) {\n      this.log.summary.recommendation = recommendation;\n    }\n    this.save();\n  }\n\n  /**\n   * Get current log\n   */\n  getLog(): HealingLog {\n    return { ...this.log };\n  }\n\n  /**\n   * Get last attempt\n   */\n  getLastAttempt(): HealingAttempt | null {\n    return this.log.attempts[this.log.attempts.length - 1] || null;\n  }\n\n  /**\n   * Get attempt count\n   */\n  getAttemptCount(): number {\n    return this.log.attempts.length;\n  }\n\n  /**\n   * Check if max attempts reached\n   */\n  isMaxAttemptsReached(): boolean {\n    return this.log.attempts.length >= this.log.maxAttempts;\n  }\n\n  /**\n   * Calculate summary statistics\n   */\n  private calculateSummary(): void {\n    const attempts = this.log.attempts;\n\n    this.log.summary = {\n      totalAttempts: attempts.length,\n      successfulFixes: attempts.filter((a) => a.result === 'pass').length,\n      failedAttempts: attempts.filter((a) => a.result === 'fail' || a.result === 'error').length,\n      totalDuration: attempts.reduce((sum, a) => sum + a.duration, 0),\n      fixTypesAttempted: [...new Set(attempts.map((a) => a.fixType))],\n    };\n  }\n\n  /**\n   * Save log to file\n   */\n  private save(): void {\n    const dir = dirname(this.outputPath);\n    if (!existsSync(dir)) {\n      mkdirSync(dir, { recursive: true });\n    }\n    writeFileSync(this.outputPath, JSON.stringify(this.log, null, 2), 'utf-8');\n  }\n\n  /**\n   * Get output path\n   */\n  getOutputPath(): string {\n    return this.outputPath;\n  }\n}\n\n/**\n * Load existing healing log\n */\nexport function loadHealingLog(filePath: string): HealingLog | null {\n  if (!existsSync(filePath)) {\n    return null;\n  }\n\n  try {\n    const content = readFileSync(filePath, 'utf-8');\n    return JSON.parse(content) as HealingLog;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Format healing log for display\n */\nexport function formatHealingLog(log: HealingLog): string {\n  const lines: string[] = [];\n\n  // Header\n  lines.push(`# Healing Log: ${log.journeyId}`);\n  lines.push('');\n  lines.push(`Status: ${log.status.toUpperCase()}`);\n  lines.push(`Started: ${log.sessionStart}`);\n  if (log.sessionEnd) {\n    lines.push(`Ended: ${log.sessionEnd}`);\n  }\n  lines.push('');\n\n  // Attempts\n  lines.push('## Attempts');\n  lines.push('');\n\n  for (const attempt of log.attempts) {\n    const icon = attempt.result === 'pass' ? '' : '';\n    lines.push(`### Attempt ${attempt.attempt} ${icon}`);\n    lines.push('');\n    lines.push(`- **Fix Type**: ${attempt.fixType}`);\n    lines.push(`- **Failure Type**: ${attempt.failureType}`);\n    lines.push(`- **File**: ${attempt.file}`);\n    lines.push(`- **Duration**: ${attempt.duration}ms`);\n    lines.push(`- **Result**: ${attempt.result}`);\n    if (attempt.errorMessage) {\n      lines.push(`- **Error**: ${attempt.errorMessage}`);\n    }\n    if (attempt.change) {\n      lines.push(`- **Change**: ${attempt.change}`);\n    }\n    if (attempt.evidence.length > 0) {\n      lines.push(`- **Evidence**: ${attempt.evidence.join(', ')}`);\n    }\n    lines.push('');\n  }\n\n  // Summary\n  if (log.summary) {\n    lines.push('## Summary');\n    lines.push('');\n    lines.push(`- Total Attempts: ${log.summary.totalAttempts}`);\n    lines.push(`- Successful Fixes: ${log.summary.successfulFixes}`);\n    lines.push(`- Failed Attempts: ${log.summary.failedAttempts}`);\n    lines.push(`- Total Duration: ${log.summary.totalDuration}ms`);\n    lines.push(`- Fix Types Tried: ${log.summary.fixTypesAttempted.join(', ')}`);\n    if (log.summary.recommendation) {\n      lines.push('');\n      lines.push(`**Recommendation**: ${log.summary.recommendation}`);\n    }\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Create healing report summary\n */\nexport function createHealingReport(log: HealingLog): {\n  success: boolean;\n  attemptCount: number;\n  fixApplied?: HealFixType;\n  recommendation?: string;\n} {\n  const lastSuccessfulAttempt = log.attempts.find((a) => a.result === 'pass');\n\n  return {\n    success: log.status === 'healed',\n    attemptCount: log.attempts.length,\n    fixApplied: lastSuccessfulAttempt?.fixType,\n    recommendation: log.summary?.recommendation,\n  };\n}\n\n/**\n * Aggregate healing logs from multiple journeys\n */\nexport function aggregateHealingLogs(logs: HealingLog[]): {\n  totalJourneys: number;\n  healed: number;\n  failed: number;\n  exhausted: number;\n  totalAttempts: number;\n  mostCommonFixes: Array<{ fix: HealFixType; count: number }>;\n  mostCommonFailures: Array<{ failure: FailureCategory; count: number }>;\n} {\n  const fixCounts = new Map<HealFixType, number>();\n  const failureCounts = new Map<FailureCategory, number>();\n  let totalAttempts = 0;\n\n  for (const log of logs) {\n    for (const attempt of log.attempts) {\n      totalAttempts++;\n      fixCounts.set(attempt.fixType, (fixCounts.get(attempt.fixType) || 0) + 1);\n      failureCounts.set(attempt.failureType, (failureCounts.get(attempt.failureType) || 0) + 1);\n    }\n  }\n\n  const mostCommonFixes = [...fixCounts.entries()]\n    .sort((a, b) => b[1] - a[1])\n    .map(([fix, count]) => ({ fix, count }));\n\n  const mostCommonFailures = [...failureCounts.entries()]\n    .sort((a, b) => b[1] - a[1])\n    .map(([failure, count]) => ({ failure, count }));\n\n  return {\n    totalJourneys: logs.length,\n    healed: logs.filter((l) => l.status === 'healed').length,\n    failed: logs.filter((l) => l.status === 'failed').length,\n    exhausted: logs.filter((l) => l.status === 'exhausted').length,\n    totalAttempts,\n    mostCommonFixes,\n    mostCommonFailures,\n  };\n}\n","/**\n * Selector Fix Strategy - Refine CSS selectors to role/label/testid\n * @see T062 - Implement selector refinement fix (CSS  role/label/testid)\n */\n\n/**\n * Selector fix context\n */\nexport interface SelectorFixContext {\n  /** Original code containing the selector */\n  code: string;\n  /** Line number where selector appears */\n  lineNumber: number;\n  /** The failing selector expression */\n  selector: string;\n  /** Error message from Playwright */\n  errorMessage: string;\n  /** Available ARIA information (if captured) */\n  ariaInfo?: ARIANodeInfo;\n}\n\n/**\n * ARIA node information for selector inference\n */\nexport interface ARIANodeInfo {\n  role?: string;\n  name?: string;\n  level?: number;\n  hasTestId?: boolean;\n  testId?: string;\n  label?: string;\n  placeholder?: string;\n}\n\n/**\n * Selector fix result\n */\nexport interface SelectorFixResult {\n  /** Whether a fix was applied */\n  applied: boolean;\n  /** The modified code */\n  code: string;\n  /** Description of the fix */\n  description: string;\n  /** The new locator expression */\n  newLocator?: string;\n  /** Confidence in the fix (0-1) */\n  confidence: number;\n}\n\n/**\n * CSS selector patterns to replace\n */\nconst CSS_SELECTOR_PATTERNS = [\n  // page.locator('.class') or page.locator('#id')\n  /page\\.locator\\s*\\(\\s*['\"`]([.#][^'\"`]+)['\"`]\\s*\\)/g,\n  // page.locator('[attribute]')\n  /page\\.locator\\s*\\(\\s*['\"`](\\[[^\\]]+\\])['\"`]\\s*\\)/g,\n  // page.locator('tag.class')\n  /page\\.locator\\s*\\(\\s*['\"`]([a-z]+[.#][^'\"`]+)['\"`]\\s*\\)/g,\n];\n\n/**\n * Map of common UI patterns to role-based selectors\n */\nconst UI_PATTERN_TO_ROLE: Record<string, { role: string; nameHint?: string }> = {\n  'button': { role: 'button' },\n  'btn': { role: 'button' },\n  'submit': { role: 'button', nameHint: 'submit' },\n  'input': { role: 'textbox' },\n  'textbox': { role: 'textbox' },\n  'checkbox': { role: 'checkbox' },\n  'radio': { role: 'radio' },\n  'select': { role: 'combobox' },\n  'dropdown': { role: 'combobox' },\n  'link': { role: 'link' },\n  'heading': { role: 'heading' },\n  'h1': { role: 'heading' },\n  'h2': { role: 'heading' },\n  'h3': { role: 'heading' },\n  'dialog': { role: 'dialog' },\n  'modal': { role: 'dialog' },\n  'alert': { role: 'alert' },\n  'tab': { role: 'tab' },\n  'menu': { role: 'menu' },\n  'menuitem': { role: 'menuitem' },\n  'table': { role: 'table' },\n  'row': { role: 'row' },\n  'cell': { role: 'cell' },\n  'grid': { role: 'grid' },\n  'list': { role: 'list' },\n  'listitem': { role: 'listitem' },\n  'img': { role: 'img' },\n  'image': { role: 'img' },\n  'nav': { role: 'navigation' },\n  'navigation': { role: 'navigation' },\n  'search': { role: 'search' },\n  'main': { role: 'main' },\n  'banner': { role: 'banner' },\n  'footer': { role: 'contentinfo' },\n};\n\n/**\n * Extract CSS selector from code\n */\nexport function extractCSSSelector(code: string): string | null {\n  for (const pattern of CSS_SELECTOR_PATTERNS) {\n    pattern.lastIndex = 0;\n    const match = pattern.exec(code);\n    if (match) {\n      return match[1] ?? null;\n    }\n  }\n  return null;\n}\n\n/**\n * Check if code contains a CSS selector\n */\nexport function containsCSSSelector(code: string): boolean {\n  return CSS_SELECTOR_PATTERNS.some((pattern) => {\n    pattern.lastIndex = 0;\n    return pattern.test(code);\n  });\n}\n\n/**\n * Infer role from CSS selector class/id names\n */\nexport function inferRoleFromSelector(selector: string): { role: string; name?: string } | null {\n  const lowerSelector = selector.toLowerCase();\n\n  for (const [pattern, roleInfo] of Object.entries(UI_PATTERN_TO_ROLE)) {\n    if (lowerSelector.includes(pattern)) {\n      return roleInfo;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Extract potential name from selector\n */\nexport function extractNameFromSelector(selector: string): string | null {\n  // Extract text between brackets for attribute selectors\n  const attrMatch = selector.match(/\\[(?:aria-label|title|alt|name)=['\"]([^'\"]+)['\"]\\]/);\n  if (attrMatch) {\n    return attrMatch[1] ?? null;\n  }\n\n  // Extract class name parts that might be descriptive\n  const classMatch = selector.match(/\\.([a-zA-Z][-a-zA-Z0-9_]*)/);\n  if (classMatch) {\n    // Convert class name to readable format\n    const className = classMatch[1]!;\n    // Convert kebab-case or snake_case to words\n    const words = className.split(/[-_]/).filter(Boolean);\n    if (words.length > 0 && words[0]!.length > 2) {\n      return words.join(' ');\n    }\n  }\n\n  return null;\n}\n\n/**\n * Generate role-based locator from inferred information\n */\nexport function generateRoleLocator(\n  role: string,\n  name?: string,\n  options?: { exact?: boolean; level?: number }\n): string {\n  const parts: string[] = [];\n\n  if (name) {\n    if (options?.exact) {\n      parts.push(`{ name: '${name}', exact: true }`);\n    } else {\n      parts.push(`{ name: '${name}' }`);\n    }\n  }\n\n  if (options?.level !== undefined && role === 'heading') {\n    if (parts.length > 0) {\n      // Merge with existing options\n      const existing = parts[0]!.slice(0, -2); // Remove ' }'\n      parts[0] = `${existing}, level: ${options.level} }`;\n    } else {\n      parts.push(`{ level: ${options.level} }`);\n    }\n  }\n\n  if (parts.length > 0) {\n    return `page.getByRole('${role}', ${parts[0]})`;\n  }\n\n  return `page.getByRole('${role}')`;\n}\n\n/**\n * Generate label-based locator\n */\nexport function generateLabelLocator(label: string, exact?: boolean): string {\n  if (exact) {\n    return `page.getByLabel('${label}', { exact: true })`;\n  }\n  return `page.getByLabel('${label}')`;\n}\n\n/**\n * Generate text-based locator\n */\nexport function generateTextLocator(text: string, exact?: boolean): string {\n  if (exact) {\n    return `page.getByText('${text}', { exact: true })`;\n  }\n  return `page.getByText('${text}')`;\n}\n\n/**\n * Generate testid-based locator\n */\nexport function generateTestIdLocator(testId: string): string {\n  return `page.getByTestId('${testId}')`;\n}\n\n/**\n * Apply selector fix to code\n */\nexport function applySelectorFix(context: SelectorFixContext): SelectorFixResult {\n  const { code, ariaInfo } = context;\n\n  // If we have ARIA info, use it\n  if (ariaInfo) {\n    return applySelectorFixWithARIA(code, ariaInfo);\n  }\n\n  // Try to infer from CSS selector\n  const cssSelector = extractCSSSelector(code);\n  if (!cssSelector) {\n    return {\n      applied: false,\n      code,\n      description: 'No CSS selector found to refine',\n      confidence: 0,\n    };\n  }\n\n  return applySelectorFixFromCSS(code, cssSelector);\n}\n\n/**\n * Apply selector fix using ARIA information\n */\nfunction applySelectorFixWithARIA(code: string, ariaInfo: ARIANodeInfo): SelectorFixResult {\n  let newLocator: string | null = null;\n  let confidence = 0;\n\n  // Priority: testid > role+name > label > text\n  if (ariaInfo.testId) {\n    newLocator = generateTestIdLocator(ariaInfo.testId);\n    confidence = 1.0;\n  } else if (ariaInfo.role && ariaInfo.name) {\n    newLocator = generateRoleLocator(ariaInfo.role, ariaInfo.name, {\n      exact: true,\n      level: ariaInfo.level,\n    });\n    confidence = 0.9;\n  } else if (ariaInfo.label) {\n    newLocator = generateLabelLocator(ariaInfo.label, true);\n    confidence = 0.85;\n  } else if (ariaInfo.role) {\n    newLocator = generateRoleLocator(ariaInfo.role);\n    confidence = 0.6;\n  }\n\n  if (!newLocator) {\n    return {\n      applied: false,\n      code,\n      description: 'Unable to generate locator from ARIA info',\n      confidence: 0,\n    };\n  }\n\n  // Replace CSS selector in code\n  let modifiedCode = code;\n  for (const pattern of CSS_SELECTOR_PATTERNS) {\n    modifiedCode = modifiedCode.replace(pattern, newLocator);\n  }\n\n  return {\n    applied: modifiedCode !== code,\n    code: modifiedCode,\n    description: `Replaced CSS selector with ${newLocator.split('(')[0]}`,\n    newLocator,\n    confidence,\n  };\n}\n\n/**\n * Apply selector fix by inferring from CSS selector\n */\nfunction applySelectorFixFromCSS(code: string, cssSelector: string): SelectorFixResult {\n  // Try to infer role from selector\n  const roleInfo = inferRoleFromSelector(cssSelector);\n  const extractedName = extractNameFromSelector(cssSelector);\n\n  let newLocator: string | null = null;\n  let confidence = 0;\n\n  if (roleInfo) {\n    const name = extractedName;\n    if (name) {\n      newLocator = generateRoleLocator(roleInfo.role, name);\n      confidence = 0.6;\n    } else {\n      newLocator = generateRoleLocator(roleInfo.role);\n      confidence = 0.4;\n    }\n  } else if (extractedName) {\n    // Fall back to text locator if we have a name but no role\n    newLocator = generateTextLocator(extractedName);\n    confidence = 0.3;\n  }\n\n  if (!newLocator) {\n    return {\n      applied: false,\n      code,\n      description: 'Unable to infer semantic locator from CSS selector',\n      confidence: 0,\n    };\n  }\n\n  // Replace CSS selector in code\n  let modifiedCode = code;\n  for (const pattern of CSS_SELECTOR_PATTERNS) {\n    modifiedCode = modifiedCode.replace(pattern, newLocator);\n  }\n\n  return {\n    applied: modifiedCode !== code,\n    code: modifiedCode,\n    description: `Inferred ${newLocator.split('(')[0]} from CSS selector pattern`,\n    newLocator,\n    confidence,\n  };\n}\n\n/**\n * Add exact: true to existing locator\n */\nexport function addExactToLocator(code: string): SelectorFixResult {\n  let modifiedCode = code;\n  let applied = false;\n\n  // Add exact: true to getByRole\n  modifiedCode = modifiedCode.replace(\n    /page\\.getByRole\\s*\\(\\s*['\"](\\w+)['\"]\\s*,\\s*\\{\\s*name:\\s*['\"]([^'\"]+)['\"]\\s*\\}\\s*\\)/g,\n    (_, role, name) => {\n      applied = true;\n      return `page.getByRole('${role}', { name: '${name}', exact: true })`;\n    }\n  );\n\n  // Add exact: true to getByLabel\n  modifiedCode = modifiedCode.replace(\n    /page\\.getByLabel\\s*\\(\\s*['\"]([^'\"]+)['\"]\\s*\\)/g,\n    (_, label) => {\n      applied = true;\n      return `page.getByLabel('${label}', { exact: true })`;\n    }\n  );\n\n  // Add exact: true to getByText\n  modifiedCode = modifiedCode.replace(\n    /page\\.getByText\\s*\\(\\s*['\"]([^'\"]+)['\"]\\s*\\)/g,\n    (_, text) => {\n      applied = true;\n      return `page.getByText('${text}', { exact: true })`;\n    }\n  );\n\n  return {\n    applied,\n    code: modifiedCode,\n    description: applied ? 'Added exact: true to locator' : 'No locator found to add exact option',\n    confidence: applied ? 0.8 : 0,\n  };\n}\n","/**\n * Navigation Wait Fix - Add waitForURL/toHaveURL assertions\n * @see T063 - Implement navigation wait fix\n */\n\n/**\n * Navigation fix context\n */\nexport interface NavigationFixContext {\n  /** Original code */\n  code: string;\n  /** Line number where navigation issue occurs */\n  lineNumber: number;\n  /** Expected URL pattern (if known) */\n  expectedUrl?: string;\n  /** Error message from Playwright */\n  errorMessage: string;\n}\n\n/**\n * Navigation fix result\n */\nexport interface NavigationFixResult {\n  /** Whether a fix was applied */\n  applied: boolean;\n  /** The modified code */\n  code: string;\n  /** Description of the fix */\n  description: string;\n  /** Confidence in the fix (0-1) */\n  confidence: number;\n}\n\n// Navigation patterns defined for reference, used in pattern matching\n\n/**\n * Patterns for existing waits (to avoid duplicates)\n */\nconst EXISTING_WAIT_PATTERNS = [\n  /await\\s+page\\.waitForURL/,\n  /await\\s+expect\\s*\\(\\s*page\\s*\\)\\.toHaveURL/,\n  /await\\s+page\\.waitForNavigation/,\n  /await\\s+page\\.waitForLoadState/,\n];\n\n/**\n * Check if code already has navigation wait\n */\nexport function hasNavigationWait(code: string): boolean {\n  return EXISTING_WAIT_PATTERNS.some((pattern) => pattern.test(code));\n}\n\n/**\n * Extract URL pattern from error message\n */\nexport function extractUrlFromError(errorMessage: string): string | null {\n  // Pattern: Expected URL to match '/pattern/'\n  const matchPattern = errorMessage.match(/Expected\\s+URL\\s+to\\s+match\\s+['\"]([^'\"]+)['\"]/i);\n  if (matchPattern) {\n    return matchPattern[1] ?? null;\n  }\n\n  // Pattern: expected \"url\" to match\n  const matchUrl = errorMessage.match(/expected\\s+['\"]([^'\"]+)['\"]\\s+to\\s+match/i);\n  if (matchUrl) {\n    return matchUrl[1] ?? null;\n  }\n\n  // Pattern: waiting for URL pattern\n  const waitingPattern = errorMessage.match(/waiting\\s+for\\s+URL\\s+['\"]([^'\"]+)['\"]/i);\n  if (waitingPattern) {\n    return waitingPattern[1] ?? null;\n  }\n\n  return null;\n}\n\n/**\n * Extract URL from goto call\n */\nexport function extractUrlFromGoto(code: string): string | null {\n  const match = code.match(/page\\.goto\\s*\\(\\s*['\"`]([^'\"`]+)['\"`]/);\n  return match ? (match[1] ?? null) : null;\n}\n\n/**\n * Infer expected URL pattern from navigation action\n */\nexport function inferUrlPattern(code: string, errorMessage: string): string | null {\n  // First try to extract from error message\n  const errorUrl = extractUrlFromError(errorMessage);\n  if (errorUrl) {\n    return errorUrl;\n  }\n\n  // Try to extract from goto call\n  const gotoUrl = extractUrlFromGoto(code);\n  if (gotoUrl) {\n    return gotoUrl;\n  }\n\n  return null;\n}\n\n/**\n * Generate waitForURL statement\n */\nexport function generateWaitForURL(urlPattern: string, options?: { timeout?: number }): string {\n  const opts = options?.timeout ? `, { timeout: ${options.timeout} }` : '';\n\n  // Determine if pattern should be regex or string\n  if (urlPattern.includes('*') || urlPattern.includes('\\\\')) {\n    return `await page.waitForURL(/${urlPattern}/${opts})`;\n  }\n\n  return `await page.waitForURL('${urlPattern}'${opts})`;\n}\n\n/**\n * Generate toHaveURL assertion\n */\nexport function generateToHaveURL(urlPattern: string): string {\n  // Determine if pattern should be regex or string\n  if (urlPattern.includes('*') || urlPattern.includes('\\\\')) {\n    return `await expect(page).toHaveURL(/${urlPattern}/)`;\n  }\n\n  return `await expect(page).toHaveURL('${urlPattern}')`;\n}\n\n/**\n * Insert navigation wait after an action\n */\nexport function insertNavigationWait(\n  code: string,\n  lineNumber: number,\n  urlPattern: string\n): NavigationFixResult {\n  const lines = code.split('\\n');\n\n  if (lineNumber < 1 || lineNumber > lines.length) {\n    return {\n      applied: false,\n      code,\n      description: 'Invalid line number',\n      confidence: 0,\n    };\n  }\n\n  // Check if there's already a wait nearby\n  const contextStart = Math.max(0, lineNumber - 2);\n  const contextEnd = Math.min(lines.length, lineNumber + 2);\n  const context = lines.slice(contextStart, contextEnd).join('\\n');\n\n  if (hasNavigationWait(context)) {\n    return {\n      applied: false,\n      code,\n      description: 'Navigation wait already exists in context',\n      confidence: 0,\n    };\n  }\n\n  // Get the line where action occurs\n  const actionLine = lines[lineNumber - 1]!;\n  const indentation = actionLine.match(/^(\\s*)/)?.[1] || '';\n\n  // Insert toHaveURL assertion after the action\n  const waitStatement = `${indentation}${generateToHaveURL(urlPattern)}`;\n  lines.splice(lineNumber, 0, waitStatement);\n\n  return {\n    applied: true,\n    code: lines.join('\\n'),\n    description: `Added toHaveURL assertion for '${urlPattern}'`,\n    confidence: 0.7,\n  };\n}\n\n/**\n * Apply navigation wait fix to code\n */\nexport function applyNavigationFix(context: NavigationFixContext): NavigationFixResult {\n  const { code, lineNumber, expectedUrl, errorMessage } = context;\n\n  // First, try to infer URL pattern\n  const urlPattern = expectedUrl || inferUrlPattern(code, errorMessage);\n\n  if (!urlPattern) {\n    // If we can't determine URL, add waitForLoadState instead\n    return applyLoadStateWait(code, lineNumber);\n  }\n\n  // Check if code already has navigation wait\n  if (hasNavigationWait(code)) {\n    return {\n      applied: false,\n      code,\n      description: 'Navigation wait already exists',\n      confidence: 0,\n    };\n  }\n\n  return insertNavigationWait(code, lineNumber, urlPattern);\n}\n\n/**\n * Apply waitForLoadState as fallback\n */\nfunction applyLoadStateWait(code: string, lineNumber: number): NavigationFixResult {\n  const lines = code.split('\\n');\n\n  if (lineNumber < 1 || lineNumber > lines.length) {\n    return {\n      applied: false,\n      code,\n      description: 'Invalid line number',\n      confidence: 0,\n    };\n  }\n\n  // Get the line where action occurs\n  const actionLine = lines[lineNumber - 1]!;\n  const indentation = actionLine.match(/^(\\s*)/)?.[1] || '';\n\n  // Insert waitForLoadState after the action\n  const waitStatement = `${indentation}await page.waitForLoadState('networkidle')`;\n  lines.splice(lineNumber, 0, waitStatement);\n\n  return {\n    applied: true,\n    code: lines.join('\\n'),\n    description: 'Added waitForLoadState as fallback',\n    confidence: 0.5,\n  };\n}\n\n/**\n * Fix missing await on goto\n */\nexport function fixMissingGotoAwait(code: string): NavigationFixResult {\n  const pattern = /(?<!\\bawait\\s+)(\\bpage\\.goto\\s*\\()/g;\n\n  if (!pattern.test(code)) {\n    return {\n      applied: false,\n      code,\n      description: 'No missing await on goto found',\n      confidence: 0,\n    };\n  }\n\n  const modifiedCode = code.replace(\n    /(?<!\\bawait\\s+)(\\bpage\\.goto\\s*\\()/g,\n    'await $1'\n  );\n\n  return {\n    applied: modifiedCode !== code,\n    code: modifiedCode,\n    description: 'Added missing await to page.goto',\n    confidence: 0.9,\n  };\n}\n\n/**\n * Add navigation wait after click that likely navigates\n */\nexport function addNavigationWaitAfterClick(\n  code: string,\n  clickLineNumber: number,\n  expectedUrl?: string\n): NavigationFixResult {\n  const urlPattern = expectedUrl || '.*';\n\n  return insertNavigationWait(code, clickLineNumber, urlPattern);\n}\n","/**\n * Timing/Async Fix - Handle timeout and async issues\n * @see T064 - Implement timing/async fix\n */\n\n/**\n * Timing fix context\n */\nexport interface TimingFixContext {\n  /** Original code */\n  code: string;\n  /** Line number where timing issue occurs */\n  lineNumber: number;\n  /** Current timeout (if known) */\n  currentTimeout?: number;\n  /** Error message from Playwright */\n  errorMessage: string;\n}\n\n/**\n * Timing fix result\n */\nexport interface TimingFixResult {\n  /** Whether a fix was applied */\n  applied: boolean;\n  /** The modified code */\n  code: string;\n  /** Description of the fix */\n  description: string;\n  /** Confidence in the fix (0-1) */\n  confidence: number;\n}\n\n/**\n * Patterns for missing await detection\n */\nconst MISSING_AWAIT_PATTERNS = [\n  // Playwright actions without await\n  /(?<!\\bawait\\s+)(page\\.(?:click|fill|type|check|uncheck|selectOption|hover|focus|press|dblclick|dragTo)\\s*\\()/g,\n  // Expectations without await\n  /(?<!\\bawait\\s+)(expect\\s*\\([^)]+\\)\\.(?:toBeVisible|toBeHidden|toHaveText|toContainText|toHaveValue|toHaveURL|toHaveTitle)\\s*\\()/g,\n  // Locator actions without await\n  /(?<!\\bawait\\s+)([a-zA-Z_$][a-zA-Z0-9_$]*\\.(?:click|fill|type|check|hover|press)\\s*\\()/g,\n];\n\n// Web-first assertion patterns used in conversion logic below\n\n/**\n * Extract timeout from error message\n */\nexport function extractTimeoutFromError(errorMessage: string): number | null {\n  const match = errorMessage.match(/timeout\\s+(\\d+)ms/i);\n  return match ? parseInt(match[1]!, 10) : null;\n}\n\n/**\n * Calculate suggested timeout increase\n */\nexport function suggestTimeoutIncrease(\n  currentTimeout: number,\n  maxTimeout: number = 30000\n): number {\n  // Increase by 50%, but cap at maxTimeout\n  const suggested = Math.min(Math.round(currentTimeout * 1.5), maxTimeout);\n  return suggested;\n}\n\n/**\n * Fix missing await statements\n */\nexport function fixMissingAwait(code: string): TimingFixResult {\n  let modifiedCode = code;\n  let fixCount = 0;\n\n  for (const pattern of MISSING_AWAIT_PATTERNS) {\n    // Reset lastIndex for global patterns\n    pattern.lastIndex = 0;\n\n    modifiedCode = modifiedCode.replace(pattern, (_match, p1) => {\n      fixCount++;\n      return `await ${p1}`;\n    });\n  }\n\n  return {\n    applied: fixCount > 0,\n    code: modifiedCode,\n    description: fixCount > 0 ? `Added ${fixCount} missing await statement(s)` : 'No missing await found',\n    confidence: fixCount > 0 ? 0.9 : 0,\n  };\n}\n\n/**\n * Convert to web-first assertion\n */\nexport function convertToWebFirstAssertion(code: string): TimingFixResult {\n  let modifiedCode = code;\n  let applied = false;\n\n  // Convert textContent extraction to toHaveText\n  modifiedCode = modifiedCode.replace(\n    /const\\s+(\\w+)\\s*=\\s*await\\s+(\\w+)\\.textContent\\s*\\(\\s*\\)\\s*;?\\s*\\n(\\s*)expect\\s*\\(\\s*\\1\\s*\\)\\.toBe\\s*\\(\\s*(['\"][^'\"]+['\"])\\s*\\)/g,\n    (_, _varName, locator, indent, expected) => {\n      applied = true;\n      return `${indent}await expect(${locator}).toHaveText(${expected})`;\n    }\n  );\n\n  // Convert innerText extraction to toHaveText\n  modifiedCode = modifiedCode.replace(\n    /const\\s+(\\w+)\\s*=\\s*await\\s+(\\w+)\\.innerText\\s*\\(\\s*\\)\\s*;?\\s*\\n(\\s*)expect\\s*\\(\\s*\\1\\s*\\)\\.toBe\\s*\\(\\s*(['\"][^'\"]+['\"])\\s*\\)/g,\n    (_, _varName, locator, indent, expected) => {\n      applied = true;\n      return `${indent}await expect(${locator}).toHaveText(${expected})`;\n    }\n  );\n\n  // Convert isVisible check to toBeVisible\n  modifiedCode = modifiedCode.replace(\n    /const\\s+(\\w+)\\s*=\\s*await\\s+(\\w+)\\.isVisible\\s*\\(\\s*\\)\\s*;?\\s*\\n(\\s*)expect\\s*\\(\\s*\\1\\s*\\)\\.toBe\\s*\\(\\s*true\\s*\\)/g,\n    (_, _varName, locator, indent) => {\n      applied = true;\n      return `${indent}await expect(${locator}).toBeVisible()`;\n    }\n  );\n\n  // Convert isHidden check to toBeHidden\n  modifiedCode = modifiedCode.replace(\n    /const\\s+(\\w+)\\s*=\\s*await\\s+(\\w+)\\.isHidden\\s*\\(\\s*\\)\\s*;?\\s*\\n(\\s*)expect\\s*\\(\\s*\\1\\s*\\)\\.toBe\\s*\\(\\s*true\\s*\\)/g,\n    (_, _varName, locator, indent) => {\n      applied = true;\n      return `${indent}await expect(${locator}).toBeHidden()`;\n    }\n  );\n\n  return {\n    applied,\n    code: modifiedCode,\n    description: applied ? 'Converted to web-first assertion' : 'No conversion needed',\n    confidence: applied ? 0.85 : 0,\n  };\n}\n\n/**\n * Add explicit timeout to action\n */\nexport function addTimeout(\n  code: string,\n  lineNumber: number,\n  timeout: number\n): TimingFixResult {\n  const lines = code.split('\\n');\n\n  if (lineNumber < 1 || lineNumber > lines.length) {\n    return {\n      applied: false,\n      code,\n      description: 'Invalid line number',\n      confidence: 0,\n    };\n  }\n\n  const line = lines[lineNumber - 1]!;\n\n  // Check if line already has timeout\n  if (/\\btimeout\\s*:/i.test(line)) {\n    return {\n      applied: false,\n      code,\n      description: 'Timeout already specified',\n      confidence: 0,\n    };\n  }\n\n  // Add timeout to action patterns\n  let modifiedLine = line;\n\n  // Pattern: .click(), .fill(), etc. with empty options\n  modifiedLine = modifiedLine.replace(\n    /\\.(click|fill|press|type|hover|focus|check|uncheck)\\s*\\(\\s*\\)/g,\n    `.$1({ timeout: ${timeout} })`\n  );\n\n  // Pattern: .click('text'), .fill('selector', 'value')\n  modifiedLine = modifiedLine.replace(\n    /\\.(click|fill|press|type|hover|focus|check|uncheck)\\s*\\(\\s*(['\"][^'\"]*['\"])\\s*\\)/g,\n    `.$1($2, { timeout: ${timeout} })`\n  );\n\n  // Pattern: .click({ options })\n  modifiedLine = modifiedLine.replace(\n    /\\.(click|fill|press|type|hover|focus|check|uncheck)\\s*\\(\\s*\\{([^}]*)\\}\\s*\\)/g,\n    (_, action, options) => {\n      if (options.includes('timeout')) {\n        return _; // Already has timeout\n      }\n      return `.${action}({ ${options.trim()}, timeout: ${timeout} })`;\n    }\n  );\n\n  // Pattern: expect().toBeVisible() etc.\n  modifiedLine = modifiedLine.replace(\n    /\\.(toBeVisible|toBeHidden|toHaveText|toContainText|toHaveValue)\\s*\\(\\s*\\)/g,\n    `.$1({ timeout: ${timeout} })`\n  );\n\n  const applied = modifiedLine !== line;\n  lines[lineNumber - 1] = modifiedLine;\n\n  return {\n    applied,\n    code: lines.join('\\n'),\n    description: applied ? `Added timeout: ${timeout}ms` : 'Unable to add timeout',\n    confidence: applied ? 0.6 : 0,\n  };\n}\n\n/**\n * Apply timing fix to code\n */\nexport function applyTimingFix(context: TimingFixContext): TimingFixResult {\n  const { code, lineNumber, currentTimeout, errorMessage } = context;\n\n  // First, try to fix missing await (most common cause)\n  const awaitFix = fixMissingAwait(code);\n  if (awaitFix.applied) {\n    return awaitFix;\n  }\n\n  // Try converting to web-first assertion\n  const webFirstFix = convertToWebFirstAssertion(code);\n  if (webFirstFix.applied) {\n    return webFirstFix;\n  }\n\n  // As last resort, increase timeout\n  const timeout = currentTimeout || extractTimeoutFromError(errorMessage) || 5000;\n  const newTimeout = suggestTimeoutIncrease(timeout);\n\n  return addTimeout(code, lineNumber, newTimeout);\n}\n\n/**\n * Wrap with expect.toPass for complex conditions\n */\nexport function wrapWithExpectToPass(\n  code: string,\n  lineStart: number,\n  lineEnd: number,\n  options?: { timeout?: number; intervals?: number[] }\n): TimingFixResult {\n  const lines = code.split('\\n');\n\n  if (lineStart < 1 || lineEnd > lines.length || lineStart > lineEnd) {\n    return {\n      applied: false,\n      code,\n      description: 'Invalid line range',\n      confidence: 0,\n    };\n  }\n\n  // Extract the code block to wrap\n  const blockLines = lines.slice(lineStart - 1, lineEnd);\n  const indentation = blockLines[0]!.match(/^(\\s*)/)?.[1] || '';\n\n  // Build options string\n  const optParts: string[] = [];\n  if (options?.timeout) {\n    optParts.push(`timeout: ${options.timeout}`);\n  }\n  if (options?.intervals) {\n    optParts.push(`intervals: [${options.intervals.join(', ')}]`);\n  }\n  const optString = optParts.length > 0 ? `, { ${optParts.join(', ')} }` : '';\n\n  // Wrap with expect.toPass\n  const wrapped = [\n    `${indentation}await expect(async () => {`,\n    ...blockLines.map((line) => `  ${line}`),\n    `${indentation}}).toPass(${optString.slice(2)})`,\n  ];\n\n  lines.splice(lineStart - 1, lineEnd - lineStart + 1, ...wrapped);\n\n  return {\n    applied: true,\n    code: lines.join('\\n'),\n    description: 'Wrapped with expect.toPass for retry behavior',\n    confidence: 0.7,\n  };\n}\n\n/**\n * Wrap with expect.poll for dynamic values\n */\nexport function wrapWithExpectPoll(\n  _code: string,\n  _lineNumber: number,\n  getter: string,\n  expected: string,\n  options?: { timeout?: number; intervals?: number[] }\n): string {\n  const optParts: string[] = [];\n  if (options?.timeout) {\n    optParts.push(`timeout: ${options.timeout}`);\n  }\n  if (options?.intervals) {\n    optParts.push(`intervals: [${options.intervals.join(', ')}]`);\n  }\n  const optString = optParts.length > 0 ? `, { ${optParts.join(', ')} }` : '';\n\n  return `await expect.poll(async () => ${getter}${optString}).toBe(${expected})`;\n}\n","/**\n * Bounded Healing Loop Controller - Orchestrate healing attempts\n * @see T067 - Implement bounded healing loop controller\n */\nimport { readFileSync, writeFileSync, existsSync } from 'node:fs';\nimport type { HealFixType, HealingConfig } from './rules.js';\nimport {\n  DEFAULT_HEALING_CONFIG,\n  evaluateHealing,\n  getNextFix,\n  getPostHealingRecommendation,\n} from './rules.js';\nimport { HealingLogger, type HealingAttempt } from './logger.js';\nimport { applySelectorFix, addExactToLocator } from './fixes/selector.js';\nimport { applyNavigationFix } from './fixes/navigation.js';\nimport { applyTimingFix, fixMissingAwait, convertToWebFirstAssertion } from './fixes/timing.js';\nimport type { FailureClassification } from '../verify/classifier.js';\nimport type { VerifySummary } from '../verify/summary.js';\n\n/**\n * Healing loop options\n */\nexport interface HealingLoopOptions {\n  /** Journey ID */\n  journeyId: string;\n  /** Path to test file */\n  testFile: string;\n  /** Output directory for logs */\n  outputDir: string;\n  /** Healing configuration */\n  config?: HealingConfig;\n  /** Function to verify the test */\n  verifyFn: () => Promise<VerifySummary>;\n  /** Optional ARIA info for selector fixes */\n  ariaInfo?: Record<string, unknown>;\n}\n\n/**\n * Healing loop result\n */\nexport interface HealingLoopResult {\n  /** Whether healing succeeded */\n  success: boolean;\n  /** Final status */\n  status: 'healed' | 'failed' | 'exhausted' | 'not_healable';\n  /** Number of attempts made */\n  attempts: number;\n  /** Fix that worked (if any) */\n  appliedFix?: HealFixType;\n  /** Path to heal log */\n  logPath: string;\n  /** Recommendation if not healed */\n  recommendation?: string;\n  /** Modified code (if any changes) */\n  modifiedCode?: string;\n}\n\n/**\n * Apply a specific fix to code\n */\nfunction applyFix(\n  code: string,\n  fixType: HealFixType,\n  context: {\n    lineNumber: number;\n    errorMessage: string;\n    classification: FailureClassification;\n    ariaInfo?: Record<string, unknown>;\n  }\n): { applied: boolean; code: string; description: string } {\n  const { lineNumber, errorMessage, ariaInfo } = context;\n\n  switch (fixType) {\n    case 'selector-refine':\n      return applySelectorFix({\n        code,\n        lineNumber,\n        selector: '', // Will be extracted from code\n        errorMessage,\n        ariaInfo: ariaInfo as never,\n      });\n\n    case 'add-exact':\n      return addExactToLocator(code);\n\n    case 'missing-await':\n      return fixMissingAwait(code);\n\n    case 'navigation-wait':\n      return applyNavigationFix({\n        code,\n        lineNumber,\n        errorMessage,\n      });\n\n    case 'web-first-assertion':\n      return convertToWebFirstAssertion(code);\n\n    case 'timeout-increase':\n      return applyTimingFix({\n        code,\n        lineNumber,\n        errorMessage,\n      });\n\n    default:\n      return {\n        applied: false,\n        code,\n        description: `Unknown fix type: ${fixType}`,\n      };\n  }\n}\n\n/**\n * Extract line number from verification summary\n */\nfunction extractLineNumber(summary: VerifySummary): number {\n  // Try to extract from first failure test name or error message\n  const firstTest = summary.failures.tests[0];\n  if (firstTest) {\n    // Try to extract line number from error message patterns like:\n    // \"at /path/to/file.ts:42:10\"\n    // \"Error: ... at line 42\"\n    const lineMatch = firstTest.match(/:(\\d+)(?::\\d+)?(?:\\)|$)/);\n    if (lineMatch) {\n      return parseInt(lineMatch[1]!, 10);\n    }\n\n    // Try \"at line N\" pattern\n    const atLineMatch = firstTest.match(/at line (\\d+)/i);\n    if (atLineMatch) {\n      return parseInt(atLineMatch[1]!, 10);\n    }\n  }\n\n  // Check classifications for error messages\n  for (const [, classification] of Object.entries(summary.failures.classifications)) {\n    if (classification && typeof classification === 'object' && 'explanation' in classification) {\n      const explanation = (classification as { explanation: string }).explanation;\n      const lineMatch = explanation.match(/:(\\d+)(?::\\d+)?/);\n      if (lineMatch) {\n        return parseInt(lineMatch[1]!, 10);\n      }\n    }\n  }\n\n  // Default to line 1 if we can't determine\n  return 1;\n}\n\n/**\n * Extract failure classification from verification summary\n */\nfunction extractClassification(summary: VerifySummary): FailureClassification | null {\n  const classifications = summary.failures.classifications;\n  const firstKey = Object.keys(classifications)[0];\n\n  if (firstKey && classifications[firstKey]) {\n    return classifications[firstKey] as FailureClassification;\n  }\n\n  return null;\n}\n\n/**\n * Run the bounded healing loop\n */\nexport async function runHealingLoop(options: HealingLoopOptions): Promise<HealingLoopResult> {\n  const {\n    journeyId,\n    testFile,\n    outputDir,\n    config = DEFAULT_HEALING_CONFIG,\n    verifyFn,\n    ariaInfo,\n  } = options;\n\n  // Initialize logger\n  const logger = new HealingLogger(journeyId, outputDir, config.maxAttempts);\n  const attemptedFixes: HealFixType[] = [];\n\n  // Read original code\n  if (!existsSync(testFile)) {\n    logger.markFailed('Test file not found');\n    return {\n      success: false,\n      status: 'failed',\n      attempts: 0,\n      logPath: logger.getOutputPath(),\n      recommendation: 'Test file not found',\n    };\n  }\n\n  let currentCode = readFileSync(testFile, 'utf-8');\n  let lastSummary: VerifySummary | null = null;\n\n  // Initial verification to get failure info\n  try {\n    lastSummary = await verifyFn();\n    if (lastSummary.status === 'passed') {\n      logger.markHealed();\n      return {\n        success: true,\n        status: 'healed',\n        attempts: 0,\n        logPath: logger.getOutputPath(),\n      };\n    }\n  } catch (error) {\n    logger.markFailed(`Initial verification failed: ${error}`);\n    return {\n      success: false,\n      status: 'failed',\n      attempts: 0,\n      logPath: logger.getOutputPath(),\n      recommendation: 'Initial verification failed',\n    };\n  }\n\n  // Get classification from initial failure\n  const classification = extractClassification(lastSummary);\n  if (!classification) {\n    logger.markFailed('Unable to classify failure');\n    return {\n      success: false,\n      status: 'failed',\n      attempts: 0,\n      logPath: logger.getOutputPath(),\n      recommendation: 'Unable to classify failure for healing',\n    };\n  }\n\n  // Check if healable\n  const evaluation = evaluateHealing(classification, config);\n  if (!evaluation.canHeal) {\n    logger.markFailed(evaluation.reason);\n    return {\n      success: false,\n      status: 'not_healable',\n      attempts: 0,\n      logPath: logger.getOutputPath(),\n      recommendation: evaluation.reason,\n    };\n  }\n\n  // Healing loop\n  while (!logger.isMaxAttemptsReached()) {\n    const attemptNumber = logger.getAttemptCount() + 1;\n    const startTime = Date.now();\n\n    // Get next fix to try\n    const nextFix = getNextFix(classification, attemptedFixes, config);\n    if (!nextFix) {\n      logger.markExhausted(getPostHealingRecommendation(classification, attemptNumber));\n      return {\n        success: false,\n        status: 'exhausted',\n        attempts: attemptNumber - 1,\n        logPath: logger.getOutputPath(),\n        recommendation: getPostHealingRecommendation(classification, attemptNumber),\n      };\n    }\n\n    attemptedFixes.push(nextFix);\n\n    // Apply the fix\n    const fixResult = applyFix(currentCode, nextFix, {\n      lineNumber: extractLineNumber(lastSummary),\n      errorMessage: lastSummary.failures.tests[0] || '',\n      classification,\n      ariaInfo,\n    });\n\n    if (!fixResult.applied) {\n      // Log skipped attempt\n      logger.logAttempt({\n        attempt: attemptNumber,\n        failureType: classification.category,\n        fixType: nextFix,\n        file: testFile,\n        change: fixResult.description,\n        evidence: [],\n        result: 'fail',\n        errorMessage: 'Fix not applied',\n        duration: Date.now() - startTime,\n      });\n      continue;\n    }\n\n    // Write fixed code\n    writeFileSync(testFile, fixResult.code, 'utf-8');\n    currentCode = fixResult.code;\n\n    // Verify the fix\n    try {\n      lastSummary = await verifyFn();\n\n      const attempt: Omit<HealingAttempt, 'timestamp'> = {\n        attempt: attemptNumber,\n        failureType: classification.category,\n        fixType: nextFix,\n        file: testFile,\n        change: fixResult.description,\n        evidence: lastSummary.reportPath ? [lastSummary.reportPath] : [],\n        result: lastSummary.status === 'passed' ? 'pass' : 'fail',\n        duration: Date.now() - startTime,\n      };\n\n      if (lastSummary.status !== 'passed') {\n        attempt.errorMessage = lastSummary.failures.tests[0] || 'Unknown error';\n\n        // Re-classify after failed attempt - failure category may have changed\n        const newClassification = extractClassification(lastSummary);\n        if (newClassification && newClassification.category !== classification.category) {\n          // Update classification for next iteration\n          Object.assign(classification, newClassification);\n        }\n      }\n\n      logger.logAttempt(attempt);\n\n      if (lastSummary.status === 'passed') {\n        logger.markHealed();\n        return {\n          success: true,\n          status: 'healed',\n          attempts: attemptNumber,\n          appliedFix: nextFix,\n          logPath: logger.getOutputPath(),\n          modifiedCode: currentCode,\n        };\n      }\n    } catch (error) {\n      logger.logAttempt({\n        attempt: attemptNumber,\n        failureType: classification.category,\n        fixType: nextFix,\n        file: testFile,\n        change: fixResult.description,\n        evidence: [],\n        result: 'error',\n        errorMessage: String(error),\n        duration: Date.now() - startTime,\n      });\n    }\n  }\n\n  // Max attempts reached\n  logger.markExhausted(getPostHealingRecommendation(classification, config.maxAttempts));\n  return {\n    success: false,\n    status: 'exhausted',\n    attempts: config.maxAttempts,\n    logPath: logger.getOutputPath(),\n    recommendation: getPostHealingRecommendation(classification, config.maxAttempts),\n  };\n}\n\n/**\n * Dry run healing to preview fixes without applying\n */\nexport function previewHealingFixes(\n  code: string,\n  classification: FailureClassification,\n  config: HealingConfig = DEFAULT_HEALING_CONFIG\n): Array<{ fixType: HealFixType; preview: string; confidence: number }> {\n  const previews: Array<{ fixType: HealFixType; preview: string; confidence: number }> = [];\n  const evaluation = evaluateHealing(classification, config);\n\n  if (!evaluation.canHeal) {\n    return previews;\n  }\n\n  for (const fixType of evaluation.applicableFixes) {\n    const result = applyFix(code, fixType, {\n      lineNumber: 1,\n      errorMessage: '',\n      classification,\n    });\n\n    if (result.applied) {\n      previews.push({\n        fixType,\n        preview: result.description,\n        confidence: 0.5, // Could be enhanced with actual confidence scores\n      });\n    }\n  }\n\n  return previews;\n}\n\n/**\n * Check if a specific fix type would apply to code\n */\nexport function wouldFixApply(\n  code: string,\n  fixType: HealFixType,\n  classification: FailureClassification\n): boolean {\n  const result = applyFix(code, fixType, {\n    lineNumber: 1,\n    errorMessage: '',\n    classification,\n  });\n  return result.applied;\n}\n","/**\n * Data Isolation Fix - Namespace test data with runId\n * @see T065 - Implement data isolation fix (runId namespace)\n */\nimport { randomBytes } from 'node:crypto';\n\n/**\n * Data fix context\n */\nexport interface DataFixContext {\n  /** Original code */\n  code: string;\n  /** Test file path */\n  testFile: string;\n  /** Journey ID */\n  journeyId: string;\n}\n\n/**\n * Data fix result\n */\nexport interface DataFixResult {\n  /** Whether a fix was applied */\n  applied: boolean;\n  /** The modified code */\n  code: string;\n  /** Description of the fix */\n  description: string;\n  /** Confidence in the fix (0-1) */\n  confidence: number;\n}\n\n/**\n * Generate unique run ID\n */\nexport function generateRunId(): string {\n  const timestamp = Date.now().toString(36);\n  const random = randomBytes(4).toString('hex');\n  return `${timestamp}-${random}`;\n}\n\n// Note: Patterns defined for reference, may be used in future enhancements\n\n/**\n * Check if code has data isolation\n */\nexport function hasDataIsolation(code: string): boolean {\n  // Check for runId pattern\n  if (/\\brunId\\b/i.test(code)) {\n    return true;\n  }\n\n  // Check for testInfo.testId usage\n  if (/testInfo\\.testId/i.test(code)) {\n    return true;\n  }\n\n  // Check for dynamic data generation\n  if (/Date\\.now\\(\\)|Math\\.random\\(\\)|crypto|uuid/i.test(code)) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Add runId variable to test\n */\nexport function addRunIdVariable(code: string): DataFixResult {\n  // Check if runId already exists\n  if (/\\bconst\\s+runId\\b/.test(code)) {\n    return {\n      applied: false,\n      code,\n      description: 'runId already defined',\n      confidence: 0,\n    };\n  }\n\n  // Find the test function start\n  const testMatch = code.match(/test\\s*\\(\\s*['\"`][^'\"`]+['\"`]\\s*,\\s*async\\s*\\(\\s*\\{[^}]*\\}\\s*\\)\\s*=>\\s*\\{/);\n  if (!testMatch) {\n    return {\n      applied: false,\n      code,\n      description: 'Unable to find test function',\n      confidence: 0,\n    };\n  }\n\n  // Insert runId after the test function opening brace\n  const insertIndex = testMatch.index! + testMatch[0].length;\n  const indentation = '    ';\n  const runIdDeclaration = `\\n${indentation}const runId = \\`\\${Date.now()}-\\${Math.random().toString(36).slice(2, 8)}\\`;`;\n\n  const modifiedCode = code.slice(0, insertIndex) + runIdDeclaration + code.slice(insertIndex);\n\n  return {\n    applied: true,\n    code: modifiedCode,\n    description: 'Added runId variable for data isolation',\n    confidence: 0.8,\n  };\n}\n\n/**\n * Namespace email with runId\n */\nexport function namespaceEmail(email: string, runId: string): string {\n  const [local, domain] = email.split('@');\n  if (!domain) return `${email}-${runId}`;\n  return `${local}+${runId}@${domain}`;\n}\n\n/**\n * Namespace name with runId\n */\nexport function namespaceName(name: string, runId: string): string {\n  return `${name} ${runId}`;\n}\n\n/**\n * Replace hardcoded email with namespaced version\n */\nexport function replaceHardcodedEmail(code: string): DataFixResult {\n  const emailPattern = /(['\"`])([\\w.+-]+@[\\w.-]+\\.[\\w]{2,})(['\"`])/g;\n\n  let applied = false;\n  const modifiedCode = code.replace(emailPattern, (match, _q1, email, _q2) => {\n    // Don't replace if already using template literals with runId\n    if (code.includes('`') && code.includes('${runId}')) {\n      return match;\n    }\n\n    // Check if this is in a fill() or similar\n    const before = code.slice(Math.max(0, code.indexOf(match) - 50), code.indexOf(match));\n    if (/\\.fill\\s*\\([^,]*$/.test(before)) {\n      applied = true;\n      const [local, domain] = email.split('@');\n      return `\\`${local}+\\${runId}@${domain}\\``;\n    }\n\n    return match;\n  });\n\n  return {\n    applied,\n    code: modifiedCode,\n    description: applied ? 'Namespaced email with runId' : 'No hardcoded email to namespace',\n    confidence: applied ? 0.7 : 0,\n  };\n}\n\n/**\n * Replace hardcoded test data with namespaced version\n */\nexport function replaceHardcodedTestData(code: string): DataFixResult {\n  let modifiedCode = code;\n  let applied = false;\n\n  // Replace test names\n  modifiedCode = modifiedCode.replace(\n    /(['\"`])(Test\\s*(?:User|Name|Account|Client|Customer))\\s*(['\"`])/gi,\n    (_match, _q1, name, _q2) => {\n      applied = true;\n      return `\\`${name} \\${runId}\\``;\n    }\n  );\n\n  // Replace test- prefixed strings in fill operations\n  modifiedCode = modifiedCode.replace(\n    /\\.fill\\s*\\([^,]+,\\s*['\"`](test[-_]?\\w+)['\"`]\\s*\\)/gi,\n    (match, value) => {\n      applied = true;\n      return match.replace(`'${value}'`, `\\`${value}-\\${runId}\\``).replace(`\"${value}\"`, `\\`${value}-\\${runId}\\``);\n    }\n  );\n\n  return {\n    applied,\n    code: modifiedCode,\n    description: applied ? 'Namespaced test data with runId' : 'No hardcoded test data found',\n    confidence: applied ? 0.6 : 0,\n  };\n}\n\n/**\n * Apply data isolation fix\n */\nexport function applyDataFix(context: DataFixContext): DataFixResult {\n  const { code } = context;\n\n  // Check if already has isolation\n  if (hasDataIsolation(code)) {\n    return {\n      applied: false,\n      code,\n      description: 'Data isolation already present',\n      confidence: 0,\n    };\n  }\n\n  // First, add runId variable\n  let result = addRunIdVariable(code);\n  if (!result.applied) {\n    return result;\n  }\n\n  let modifiedCode = result.code;\n  let fixCount = 1;\n\n  // Then namespace emails\n  const emailResult = replaceHardcodedEmail(modifiedCode);\n  if (emailResult.applied) {\n    modifiedCode = emailResult.code;\n    fixCount++;\n  }\n\n  // Then namespace test data\n  const dataResult = replaceHardcodedTestData(modifiedCode);\n  if (dataResult.applied) {\n    modifiedCode = dataResult.code;\n    fixCount++;\n  }\n\n  return {\n    applied: true,\n    code: modifiedCode,\n    description: `Applied ${fixCount} data isolation fix(es)`,\n    confidence: 0.7,\n  };\n}\n\n/**\n * Add cleanup hook for test data\n */\nexport function addCleanupHook(code: string, cleanupCode: string): DataFixResult {\n  // Check if afterEach already exists\n  if (/test\\.afterEach\\s*\\(/.test(code)) {\n    return {\n      applied: false,\n      code,\n      description: 'afterEach hook already exists',\n      confidence: 0,\n    };\n  }\n\n  // Find test.describe or test block\n  const describeMatch = code.match(/test\\.describe\\s*\\(\\s*['\"`][^'\"`]+['\"`]\\s*,\\s*\\(\\s*\\)\\s*=>\\s*\\{/);\n\n  if (describeMatch) {\n    // Add after describe opening\n    const insertIndex = describeMatch.index! + describeMatch[0].length;\n    const indentation = '  ';\n    const hookCode = `\\n${indentation}test.afterEach(async () => {\\n${indentation}  ${cleanupCode}\\n${indentation}});\\n`;\n\n    const modifiedCode = code.slice(0, insertIndex) + hookCode + code.slice(insertIndex);\n\n    return {\n      applied: true,\n      code: modifiedCode,\n      description: 'Added afterEach cleanup hook',\n      confidence: 0.7,\n    };\n  }\n\n  return {\n    applied: false,\n    code,\n    description: 'Unable to find suitable location for cleanup hook',\n    confidence: 0,\n  };\n}\n\n/**\n * Extract test data patterns from code\n */\nexport function extractTestDataPatterns(code: string): string[] {\n  const patterns: string[] = [];\n\n  // Find fill operations\n  const fillMatches = code.matchAll(/\\.fill\\s*\\([^,]+,\\s*['\"`]([^'\"`]+)['\"`]\\s*\\)/g);\n  for (const match of fillMatches) {\n    patterns.push(match[1]!);\n  }\n\n  // Find email patterns\n  const emailMatches = code.matchAll(/['\"`]([\\w.+-]+@[\\w.-]+\\.[\\w]{2,})['\"`]/g);\n  for (const match of emailMatches) {\n    patterns.push(match[1]!);\n  }\n\n  return patterns;\n}\n","/**\n * Healing Module Exports\n * @see Phase 6 - User Story 4: Developer Heals Failing Tests Safely\n */\n\n// Rules\nexport {\n  type HealFixType,\n  type ForbiddenFixType,\n  type HealingRule,\n  type HealingConfig,\n  type HealingRuleResult,\n  DEFAULT_HEALING_RULES,\n  DEFAULT_HEALING_CONFIG,\n  UNHEALABLE_CATEGORIES,\n  isCategoryHealable,\n  getApplicableRules,\n  evaluateHealing,\n  getNextFix,\n  isFixAllowed,\n  isFixForbidden,\n  getHealingRecommendation,\n  getPostHealingRecommendation,\n} from './rules.js';\n\n// Logger\nexport {\n  type HealingAttempt,\n  type HealingLog,\n  type HealingSummary,\n  HealingLogger,\n  loadHealingLog,\n  formatHealingLog,\n  createHealingReport,\n  aggregateHealingLogs,\n} from './logger.js';\n\n// Loop Controller\nexport {\n  type HealingLoopOptions,\n  type HealingLoopResult,\n  runHealingLoop,\n  previewHealingFixes,\n  wouldFixApply,\n} from './loop.js';\n\n// Fix Strategies\nexport {\n  type SelectorFixContext,\n  type SelectorFixResult,\n  type ARIANodeInfo,\n  extractCSSSelector,\n  containsCSSSelector,\n  inferRoleFromSelector,\n  extractNameFromSelector,\n  generateRoleLocator,\n  generateLabelLocator,\n  generateTextLocator,\n  generateTestIdLocator,\n  applySelectorFix,\n  addExactToLocator,\n} from './fixes/selector.js';\n\nexport {\n  type NavigationFixContext,\n  type NavigationFixResult,\n  hasNavigationWait,\n  extractUrlFromError,\n  extractUrlFromGoto,\n  inferUrlPattern,\n  generateWaitForURL,\n  generateToHaveURL,\n  insertNavigationWait,\n  applyNavigationFix,\n  fixMissingGotoAwait,\n  addNavigationWaitAfterClick,\n} from './fixes/navigation.js';\n\nexport {\n  type TimingFixContext,\n  type TimingFixResult,\n  extractTimeoutFromError,\n  suggestTimeoutIncrease,\n  fixMissingAwait,\n  convertToWebFirstAssertion,\n  addTimeout,\n  applyTimingFix,\n  wrapWithExpectToPass,\n  wrapWithExpectPoll,\n} from './fixes/timing.js';\n\nexport {\n  type DataFixContext,\n  type DataFixResult,\n  generateRunId,\n  hasDataIsolation,\n  addRunIdVariable,\n  namespaceEmail,\n  namespaceName,\n  replaceHardcodedEmail,\n  replaceHardcodedTestData,\n  applyDataFix,\n  addCleanupHook,\n  extractTestDataPatterns,\n} from './fixes/data.js';\n","import { existsSync, mkdirSync, writeFileSync } from 'node:fs';\nimport { join } from 'node:path';\nimport { stringify as stringifyYaml } from 'yaml';\n\n// Get CURRENT_CONFIG_VERSION from config schema\nconst CURRENT_CONFIG_VERSION = 1;\n\nexport interface InstallOptions {\n  /** Root directory to install into */\n  rootDir: string;\n  /** Project name (for config) */\n  projectName?: string;\n  /** Base URL for tests */\n  baseUrl?: string;\n  /** Test ID attribute */\n  testIdAttribute?: string;\n  /** Skip if already installed */\n  skipIfExists?: boolean;\n  /** Include example Journey */\n  includeExample?: boolean;\n  /** Force overwrite existing files */\n  force?: boolean;\n}\n\nexport interface InstallResult {\n  success: boolean;\n  created: string[];\n  skipped: string[];\n  errors: string[];\n}\n\n/**\n * Install ARTK autogen instance in a project\n */\nexport async function installAutogenInstance(\n  options: InstallOptions\n): Promise<InstallResult> {\n  const {\n    rootDir,\n    projectName = 'my-project',\n    baseUrl = 'http://localhost:3000',\n    testIdAttribute = 'data-testid',\n    skipIfExists = false,\n    includeExample = true,\n    force = false,\n  } = options;\n\n  const result: InstallResult = {\n    success: true,\n    created: [],\n    skipped: [],\n    errors: [],\n  };\n\n  try {\n    // 1. Create directory structure\n    const directories = [\n      'journeys',\n      'tests/journeys',\n      'tests/modules',\n      '.artk',\n    ];\n\n    for (const dir of directories) {\n      const fullPath = join(rootDir, dir);\n      if (existsSync(fullPath)) {\n        if (skipIfExists && !force) {\n          result.skipped.push(dir);\n          continue;\n        }\n      } else {\n        mkdirSync(fullPath, { recursive: true });\n        result.created.push(dir);\n      }\n    }\n\n    // 2. Create config file\n    const configPath = join(rootDir, 'autogen.config.yml');\n    if (!existsSync(configPath) || force) {\n      const config = {\n        version: CURRENT_CONFIG_VERSION,\n        project: projectName,\n        baseUrl,\n        testIdAttribute,\n        paths: {\n          journeys: 'journeys',\n          tests: 'tests/journeys',\n          modules: 'tests/modules',\n        },\n        healing: {\n          enabled: true,\n          maxAttempts: 3,\n        },\n        validation: {\n          requireClarified: true,\n          forbiddenPatterns: [\n            'page\\\\.waitForTimeout',\n            'force:\\\\s*true',\n          ],\n        },\n      };\n\n      writeFileSync(configPath, stringifyYaml(config));\n      result.created.push('autogen.config.yml');\n    } else if (skipIfExists) {\n      result.skipped.push('autogen.config.yml');\n    }\n\n    // 3. Create .artk/.gitignore\n    const gitignorePath = join(rootDir, '.artk/.gitignore');\n    if (!existsSync(gitignorePath) || force) {\n      writeFileSync(gitignorePath, [\n        '# ARTK temporary files',\n        'heal-logs/',\n        '*.heal.json',\n        'selector-catalog.local.json',\n      ].join('\\n'));\n      result.created.push('.artk/.gitignore');\n    } else if (skipIfExists) {\n      result.skipped.push('.artk/.gitignore');\n    }\n\n    // 4. Create glossary.yml\n    const glossaryPath = join(rootDir, '.artk/glossary.yml');\n    if (!existsSync(glossaryPath) || force) {\n      const glossary = {\n        terms: [],\n        aliases: {},\n      };\n      writeFileSync(glossaryPath, stringifyYaml(glossary));\n      result.created.push('.artk/glossary.yml');\n    } else if (skipIfExists) {\n      result.skipped.push('.artk/glossary.yml');\n    }\n\n    // 5. Create example Journey (optional)\n    if (includeExample) {\n      const examplePath = join(rootDir, 'journeys/EXAMPLE-001.md');\n      if (!existsSync(examplePath) || force) {\n        const exampleJourney = `---\nid: EXAMPLE-001\ntitle: Example Journey\nstatus: proposed\ntier: smoke\nscope: example\nactor: user\ntags:\n  - example\n  - smoke\ntests: []\nmodules: []\n---\n\n# Example Journey\n\n## Overview\nThis is an example Journey to demonstrate the format.\n\n## Preconditions\n- User is on the home page\n\n## Acceptance Criteria\n- [ ] AC1: User can see the welcome message\n\n## Steps\n1. Navigate to the home page\n2. Verify the welcome message is visible\n`;\n        writeFileSync(examplePath, exampleJourney);\n        result.created.push('journeys/EXAMPLE-001.md');\n      } else if (skipIfExists) {\n        result.skipped.push('journeys/EXAMPLE-001.md');\n      }\n    }\n\n    // 6. Create VS Code settings (optional)\n    const vscodePath = join(rootDir, '.vscode');\n    if (!existsSync(vscodePath)) {\n      mkdirSync(vscodePath, { recursive: true });\n    }\n\n    const settingsPath = join(vscodePath, 'settings.json');\n    if (!existsSync(settingsPath) || force) {\n      const settings = {\n        'files.associations': {\n          '*.journey.md': 'markdown',\n        },\n        'editor.quickSuggestions': {\n          strings: true,\n        },\n        'chat.promptFilesRecommendations': {\n          'artk.init-playbook': true,\n          'artk.discover-foundation': true,\n          'artk.journey-propose': true,\n          'artk.journey-define': true,\n          'artk.journey-clarify': true,\n          'artk.testid-audit': true,\n          'artk.journey-implement': true,\n          'artk.journey-validate': true,\n          'artk.journey-verify': true,\n        },\n      };\n      writeFileSync(settingsPath, JSON.stringify(settings, null, 2));\n      result.created.push('.vscode/settings.json');\n    } else if (skipIfExists) {\n      result.skipped.push('.vscode/settings.json');\n    }\n\n  } catch (error) {\n    result.success = false;\n    result.errors.push(String(error));\n  }\n\n  return result;\n}\n","import { existsSync, readFileSync, writeFileSync } from 'node:fs';\nimport { join } from 'node:path';\nimport { parse as parseYaml, stringify as stringifyYaml } from 'yaml';\n\n// Get CURRENT_CONFIG_VERSION - this should eventually come from config schema\nconst CURRENT_CONFIG_VERSION = 1;\n\nexport interface UpgradeOptions {\n  /** Root directory of ARTK instance */\n  rootDir: string;\n  /** Target version (default: current) */\n  toVersion?: number;\n  /** Create backup before upgrade */\n  backup?: boolean;\n  /** Dry run - don't write changes */\n  dryRun?: boolean;\n}\n\nexport interface UpgradeResult {\n  success: boolean;\n  fromVersion: number;\n  toVersion: number;\n  changes: UpgradeChange[];\n  backupPath?: string;\n  errors: string[];\n}\n\nexport interface UpgradeChange {\n  type: 'config' | 'file' | 'directory';\n  path: string;\n  description: string;\n}\n\ninterface VersionUpgrade {\n  type: 'config' | 'file' | 'directory';\n  path: string;\n  description: string;\n  apply: (_rootDir: string) => Promise<void>;\n}\n\n/**\n * Upgrade ARTK autogen instance to new version\n */\nexport async function upgradeAutogenInstance(\n  options: UpgradeOptions\n): Promise<UpgradeResult> {\n  const {\n    rootDir,\n    toVersion = CURRENT_CONFIG_VERSION,\n    backup = true,\n    dryRun = false,\n  } = options;\n\n  const result: UpgradeResult = {\n    success: true,\n    fromVersion: 0,\n    toVersion,\n    changes: [],\n    errors: [],\n  };\n\n  try {\n    // 1. Load current config\n    const configPath = join(rootDir, 'autogen.config.yml');\n    if (!existsSync(configPath)) {\n      throw new Error('No autogen.config.yml found. Run install first.');\n    }\n\n    const configContent = readFileSync(configPath, 'utf-8');\n    const config = parseYaml(configContent) as Record<string, unknown>;\n    result.fromVersion = (config.version as number) || 0;\n\n    // 2. Check if upgrade needed\n    if (result.fromVersion >= toVersion) {\n      result.changes.push({\n        type: 'config',\n        path: configPath,\n        description: `Already at version ${result.fromVersion}, no upgrade needed`,\n      });\n      return result;\n    }\n\n    // 3. Create backup\n    if (backup && !dryRun) {\n      const backupPath = `${configPath}.backup-v${result.fromVersion}`;\n      writeFileSync(backupPath, configContent);\n      result.backupPath = backupPath;\n      result.changes.push({\n        type: 'file',\n        path: backupPath,\n        description: 'Created config backup',\n      });\n    }\n\n    // 4. Migrate config\n    const migrationResult = migrateConfig(config, toVersion);\n\n    for (const migration of migrationResult.migrationsApplied) {\n      result.changes.push({\n        type: 'config',\n        path: configPath,\n        description: migration,\n      });\n    }\n\n    // 5. Write migrated config\n    if (!dryRun) {\n      writeFileSync(configPath, stringifyYaml(migrationResult.config));\n    }\n\n    result.changes.push({\n      type: 'config',\n      path: configPath,\n      description: `Upgraded config from v${result.fromVersion} to v${toVersion}`,\n    });\n\n    // 6. Version-specific upgrades\n    const versionUpgrades = getVersionUpgrades(result.fromVersion, toVersion);\n\n    for (const upgrade of versionUpgrades) {\n      if (!dryRun) {\n        await upgrade.apply(rootDir);\n      }\n      result.changes.push({\n        type: upgrade.type,\n        path: upgrade.path,\n        description: upgrade.description,\n      });\n    }\n\n  } catch (error) {\n    result.success = false;\n    result.errors.push(String(error));\n  }\n\n  return result;\n}\n\n/**\n * Migration interface\n */\ninterface Migration {\n  fromVersion: number;\n  toVersion: number;\n  description: string;\n  migrate: (_config: Record<string, unknown>) => Record<string, unknown>;\n}\n\n/**\n * Registry of all migrations\n */\nconst MIGRATIONS: Migration[] = [\n  // Future migrations go here\n  // {\n  //   fromVersion: 1,\n  //   toVersion: 2,\n  //   description: 'Rename selectorPolicy to locatorPolicy',\n  //   migrate: (config) => {\n  //     if (config.selectorPolicy) {\n  //       config.locatorPolicy = config.selectorPolicy;\n  //       delete config.selectorPolicy;\n  //     }\n  //     return config;\n  //   },\n  // },\n];\n\ninterface MigrationResult {\n  migrated: boolean;\n  fromVersion: number;\n  toVersion: number;\n  migrationsApplied: string[];\n  config: Record<string, unknown>;\n}\n\n/**\n * Migrate config to target version\n */\nfunction migrateConfig(\n  config: Record<string, unknown>,\n  toVersion: number = CURRENT_CONFIG_VERSION\n): MigrationResult {\n  const fromVersion = (config.version as number) || 0;\n  let currentConfig = { ...config };\n  const migrationsApplied: string[] = [];\n\n  if (fromVersion === toVersion) {\n    return {\n      migrated: false,\n      fromVersion,\n      toVersion: fromVersion,\n      migrationsApplied: [],\n      config: currentConfig,\n    };\n  }\n\n  // Apply migrations in order\n  for (const migration of MIGRATIONS) {\n    if (migration.fromVersion >= fromVersion &&\n        migration.toVersion <= toVersion) {\n      currentConfig = migration.migrate(currentConfig);\n      migrationsApplied.push(migration.description);\n    }\n  }\n\n  // Set target version\n  currentConfig.version = toVersion;\n\n  return {\n    migrated: true,\n    fromVersion,\n    toVersion,\n    migrationsApplied,\n    config: currentConfig,\n  };\n}\n\n/**\n * Get version-specific upgrade tasks\n */\nfunction getVersionUpgrades(\n  _fromVersion: number,\n  _toVersion: number\n): VersionUpgrade[] {\n  const upgrades: VersionUpgrade[] = [];\n\n  // Future version upgrades go here\n  // if (fromVersion < 2 && toVersion >= 2) {\n  //   upgrades.push({\n  //     type: 'directory',\n  //     path: 'tests/fixtures',\n  //     description: 'Create fixtures directory for v2',\n  //     apply: async (rootDir) => {\n  //       mkdirSync(join(rootDir, 'tests/fixtures'), { recursive: true });\n  //     },\n  //   });\n  // }\n\n  return upgrades;\n}\n\n/**\n * Check if config needs migration\n */\nexport function needsMigration(config: Record<string, unknown>): boolean {\n  const version = (config.version as number) || 0;\n  return version < CURRENT_CONFIG_VERSION;\n}\n\n/**\n * Validate config version is supported\n */\nexport function isVersionSupported(version: number): boolean {\n  return version >= 1 && version <= CURRENT_CONFIG_VERSION;\n}\n","/**\n * @module shared/types\n * @description Shared types used across all AutoGen enhancement strategies\n */\n\nimport { z } from 'zod';\n\n// \n// RESULT TYPE (for error handling)\n// \n\nexport type Result<T, E = Error> =\n  | { ok: true; value: T }\n  | { ok: false; error: E };\n\nexport function ok<T>(value: T): Result<T, never> {\n  return { ok: true, value };\n}\n\nexport function err<E>(error: E): Result<never, E> {\n  return { ok: false, error };\n}\n\nexport function isOk<T, E>(result: Result<T, E>): result is { ok: true; value: T } {\n  return result.ok;\n}\n\nexport function isErr<T, E>(result: Result<T, E>): result is { ok: false; error: E } {\n  return !result.ok;\n}\n\n// \n// LLM TYPES\n// \n\nexport type LLMProvider =\n  | 'openai'\n  | 'anthropic'\n  | 'azure'\n  | 'bedrock'\n  | 'ollama'\n  | 'local'\n  | 'none';\n\nexport interface LLMConfig {\n  provider: LLMProvider;\n  model: string;\n  temperature: number;\n  maxTokens: number;\n  timeoutMs: number;\n  maxRetries: number;\n  retryDelayMs: number;\n}\n\nexport interface TokenUsage {\n  promptTokens: number;\n  completionTokens: number;\n  totalTokens: number;\n  estimatedCostUsd: number;\n}\n\nexport interface LLMResponse<T> {\n  data: T;\n  tokenUsage: TokenUsage;\n  latencyMs: number;\n  retryCount: number;\n}\n\nexport interface LLMError {\n  type: 'TIMEOUT' | 'RATE_LIMIT' | 'API_ERROR' | 'INVALID_RESPONSE' | 'UNAVAILABLE';\n  message: string;\n  retryable: boolean;\n  retryAfterMs?: number;\n  originalError?: Error;\n}\n\n// \n// COST TRACKING\n// \n\nexport interface CostLimits {\n  perTestUsd: number;\n  perSessionUsd: number;\n  enabled: boolean;\n}\n\nexport interface CostTrackerState {\n  sessionCost: number;\n  testCost: number;\n  totalTokens: number;\n  sessionStartedAt: Date;\n}\n\n// \n// PIPELINE ORCHESTRATION PHASE (internal state machine)\n// NOTE: This is different from PipelineState in pipeline/state.ts which is\n// the persisted state file format for the CLI pipeline.\n// \n\nexport type OrchestrationPhase =\n  | 'IDLE'\n  | 'PARSING'\n  | 'PLANNING'\n  | 'GENERATING'\n  | 'SCORING'\n  | 'EXECUTING'\n  | 'REFINING'\n  | 'LEARNING'\n  | 'DONE'\n  | 'BLOCKED'\n  | 'DEAD_END'\n  | 'FAILED';\n\nexport interface PipelineContext {\n  journeyId: string;\n  state: OrchestrationPhase;\n  scotEnabled: boolean;\n  refinementEnabled: boolean;\n  uncertaintyEnabled: boolean;\n  generatedCode?: string;\n  error?: PipelineError;\n  startedAt: Date;\n  completedAt?: Date;\n  tokenUsage: TokenUsage;\n}\n\nexport interface StateTransition {\n  from: OrchestrationPhase;\n  to: OrchestrationPhase;\n  guard?: (_ctx: PipelineContext) => boolean;\n  action?: (_ctx: PipelineContext) => Promise<void>;\n}\n\n// \n// PIPELINE ERRORS & DEAD-END HANDLING\n// \n\nexport type PipelineErrorType =\n  | 'SCOT_FAILED'\n  | 'GENERATION_FAILED'\n  | 'UNCERTAINTY_BLOCKED'\n  | 'EXECUTION_FAILED'\n  | 'REFINEMENT_EXHAUSTED'\n  | 'LLM_UNAVAILABLE'\n  | 'COST_LIMIT_EXCEEDED'\n  | 'TIMEOUT'\n  | 'DEAD_END';\n\nexport interface PipelineError {\n  type: PipelineErrorType;\n  message: string;\n  stage: OrchestrationPhase;\n  recoverable: boolean;\n  suggestedAction: 'manual_review' | 'journey_revision' | 'retry' | 'abort';\n  diagnostics: PipelineDiagnostics;\n}\n\nexport interface PipelineDiagnostics {\n  journeyId: string;\n  scotConfidence?: number;\n  uncertaintyScore?: number;\n  refinementAttempts?: number;\n  lastError?: string;\n  tokenUsage?: TokenUsage;\n  durationMs?: number;\n}\n\nexport interface DeadEndResult {\n  status: 'dead_end';\n  error: PipelineError;\n  partialCode?: string;\n  report: DeadEndReport;\n}\n\nexport interface DeadEndReport {\n  journeyId: string;\n  blockedAt: OrchestrationPhase;\n  reasons: string[];\n  scotDiagnostics?: {\n    confidence: number;\n    warnings: string[];\n    fallbackUsed: boolean;\n  };\n  uncertaintyDiagnostics?: {\n    overallScore: number;\n    blockedDimensions: string[];\n    lowestDimension: { name: string; score: number };\n  };\n  refinementDiagnostics?: {\n    attempts: number;\n    lastError: string;\n    convergenceFailure: boolean;\n    sameErrorRepeated: boolean;\n  };\n  suggestedActions: string[];\n}\n\n// \n// LLKB ADAPTER INTERFACE\n// \n\nexport interface LLKBPattern {\n  id: string;\n  category: string;\n  pattern: string;\n  confidence: number;\n  usageCount: number;\n  lastUsed: Date;\n}\n\nexport interface LLKBLesson {\n  id: string;\n  category: string;\n  content: string;\n  confidence: number;\n  generalizability: number;\n  sourceType: 'refinement' | 'manual' | 'extraction';\n  createdAt: Date;\n}\n\nexport interface SuccessfulFix {\n  journeyId: string;\n  errorCategory: string;\n  originalCode: string;\n  fixedCode: string;\n  fixDescription: string;\n  refinementAttempts: number;\n  generalizability: number;\n}\n\nexport interface FailedAttempt {\n  journeyId: string;\n  errorCategory: string;\n  attemptedFix: string;\n  failureReason: string;\n}\n\nexport interface LLKBAdapter {\n  isAvailable(): boolean;\n  findPattern(_action: string): Promise<LLKBPattern | null>;\n  findSimilarFixes(_errorCategory: string, _context: string): Promise<LLKBPattern[]>;\n  calculatePatternCoverage(_code: string): Promise<number>;\n  recordSuccessfulFix(_fix: SuccessfulFix): Promise<void>;\n  recordFailedAttempt(_attempt: FailedAttempt): Promise<void>;\n  recordLesson(_lesson: Omit<LLKBLesson, 'id' | 'createdAt'>): Promise<string>;\n}\n\n// \n// ZOD SCHEMAS\n// \n\nexport const LLMProviderSchema = z.enum([\n  'openai',\n  'anthropic',\n  'azure',\n  'bedrock',\n  'ollama',\n  'local',\n  'none',\n]);\n\nexport const LLMConfigSchema = z.object({\n  provider: LLMProviderSchema.default('none'),\n  model: z.string().default(''),\n  temperature: z.number().min(0).max(2).default(0.2),\n  maxTokens: z.number().min(100).max(32000).default(2000),\n  timeoutMs: z.number().min(1000).max(300000).default(30000),\n  maxRetries: z.number().min(0).max(5).default(2),\n  retryDelayMs: z.number().min(100).max(10000).default(1000),\n});\n\nexport const CostLimitsSchema = z.object({\n  perTestUsd: z.number().min(0.01).max(10).default(0.10),\n  perSessionUsd: z.number().min(0.10).max(100).default(5.00),\n  enabled: z.boolean().default(true),\n});\n\nexport const TokenUsageSchema = z.object({\n  promptTokens: z.number().default(0),\n  completionTokens: z.number().default(0),\n  totalTokens: z.number().default(0),\n  estimatedCostUsd: z.number().default(0),\n});\n","/**\n * @module shared/llm-response-parser\n * @description Validated JSON parsing from LLM responses with Zod schemas\n */\n\nimport { z } from 'zod';\nimport { Result, ok, err } from './types.js';\n\n// \n// PARSE ERROR TYPES\n// \n\nexport interface ParseError {\n  type: 'INVALID_JSON' | 'SCHEMA_VALIDATION' | 'EXTRACTION_FAILED';\n  message: string;\n  rawResponse: string;\n  validationErrors?: z.ZodError;\n}\n\n// \n// JSON EXTRACTION\n// \n\n/**\n * Extract JSON from LLM response (handles markdown code blocks)\n */\nexport function extractJson(response: string): string | null {\n  // Try markdown code block first (```json ... ```)\n  const jsonBlockMatch = response.match(/```(?:json)?\\s*\\n?([\\s\\S]*?)\\n?```/);\n  if (jsonBlockMatch && jsonBlockMatch[1]) {\n    return jsonBlockMatch[1].trim();\n  }\n\n  // Try to find JSON object directly\n  const objectMatch = response.match(/\\{[\\s\\S]*\\}/);\n  if (objectMatch) {\n    // Validate it looks like complete JSON\n    try {\n      JSON.parse(objectMatch[0]);\n      return objectMatch[0];\n    } catch {\n      // Not valid JSON, continue\n    }\n  }\n\n  // Try to find JSON array directly\n  const arrayMatch = response.match(/\\[[\\s\\S]*\\]/);\n  if (arrayMatch) {\n    try {\n      JSON.parse(arrayMatch[0]);\n      return arrayMatch[0];\n    } catch {\n      // Not valid JSON\n    }\n  }\n\n  return null;\n}\n\n// \n// MAIN PARSER\n// \n\nexport interface ParseOptions {\n  maxRetries?: number;\n  onRetry?: (_attempt: number, _error: ParseError) => Promise<string>;\n}\n\n/**\n * Parse and validate LLM response against a Zod schema\n */\nexport async function parseLLMResponse<T>(\n  rawResponse: string,\n  schema: z.Schema<T>,\n  options: ParseOptions = {}\n): Promise<Result<T, ParseError>> {\n  const { maxRetries = 0, onRetry } = options;\n  let lastError: ParseError | null = null;\n  let currentResponse = rawResponse;\n\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    // Step 1: Extract JSON\n    const jsonStr = extractJson(currentResponse);\n    if (!jsonStr) {\n      lastError = {\n        type: 'EXTRACTION_FAILED',\n        message: 'Could not find JSON in LLM response',\n        rawResponse: currentResponse,\n      };\n\n      if (attempt < maxRetries && onRetry) {\n        currentResponse = await onRetry(attempt + 1, lastError);\n        continue;\n      }\n      return err(lastError);\n    }\n\n    // Step 2: Parse JSON\n    let parsed: unknown;\n    try {\n      parsed = JSON.parse(jsonStr);\n    } catch (e) {\n      lastError = {\n        type: 'INVALID_JSON',\n        message: `JSON parse error: ${e instanceof Error ? e.message : 'Unknown'}`,\n        rawResponse: currentResponse,\n      };\n\n      if (attempt < maxRetries && onRetry) {\n        currentResponse = await onRetry(attempt + 1, lastError);\n        continue;\n      }\n      return err(lastError);\n    }\n\n    // Step 3: Validate against schema\n    const result = schema.safeParse(parsed);\n    if (!result.success) {\n      lastError = {\n        type: 'SCHEMA_VALIDATION',\n        message: `Schema validation failed: ${result.error.message}`,\n        rawResponse: currentResponse,\n        validationErrors: result.error,\n      };\n\n      if (attempt < maxRetries && onRetry) {\n        currentResponse = await onRetry(attempt + 1, lastError);\n        continue;\n      }\n      return err(lastError);\n    }\n\n    return ok(result.data);\n  }\n\n  return err(lastError!);\n}\n\n// \n// SCHEMA DEFINITIONS FOR LLM RESPONSES\n// \n\n// SCoT Plan Response Schema\nexport const SCoTAtomicStepSchema = z.object({\n  action: z.string(),\n  target: z.string().optional(),\n  value: z.string().optional(),\n  assertion: z.string().optional(),\n});\n\nexport const SCoTConditionSchema = z.object({\n  element: z.string().optional(),\n  state: z.enum(['visible', 'hidden', 'enabled', 'disabled', 'exists', 'checked', 'unchecked']),\n  negate: z.boolean().optional(),\n});\n\nexport const SCoTIteratorSchema = z.object({\n  variable: z.string(),\n  collection: z.string(),\n  maxIterations: z.number().optional(),\n});\n\nexport const SCoTStructureSchema = z.object({\n  type: z.enum(['sequential', 'branch', 'loop']),\n  description: z.string(),\n  steps: z.array(SCoTAtomicStepSchema).optional(),\n  condition: SCoTConditionSchema.optional(),\n  thenBranch: z.array(SCoTAtomicStepSchema).optional(),\n  elseBranch: z.array(SCoTAtomicStepSchema).optional(),\n  iterator: SCoTIteratorSchema.optional(),\n  body: z.array(SCoTAtomicStepSchema).optional(),\n});\n\nexport const SCoTPlanResponseSchema = z.object({\n  reasoning: z.string().min(1),\n  confidence: z.number().min(0).max(1),\n  plan: z.array(SCoTStructureSchema),\n  warnings: z.array(z.string()).default([]),\n});\n\n// Error Analysis Response Schema\nexport const SuggestedApproachSchema = z.object({\n  name: z.string(),\n  description: z.string(),\n  confidence: z.number().min(0).max(1),\n  complexity: z.enum(['simple', 'moderate', 'complex']),\n  requiredChanges: z.array(z.string()),\n});\n\nexport const ErrorAnalysisResponseSchema = z.object({\n  rootCause: z.string().min(1),\n  confidence: z.number().min(0).max(1),\n  suggestedApproaches: z.array(SuggestedApproachSchema).min(1),\n});\n\n// Code Fix Response Schema\nexport const CodeChangeSchema = z.object({\n  type: z.enum(['replace', 'insert', 'delete']),\n  lineStart: z.number(),\n  lineEnd: z.number().optional(),\n  explanation: z.string(),\n});\n\nexport const CodeFixResponseSchema = z.object({\n  fixedCode: z.string().min(1),\n  changes: z.array(CodeChangeSchema),\n  explanation: z.string(),\n});\n\n// Type exports\nexport type SCoTPlanResponse = z.infer<typeof SCoTPlanResponseSchema>;\nexport type ErrorAnalysisResponse = z.infer<typeof ErrorAnalysisResponseSchema>;\nexport type CodeFixResponse = z.infer<typeof CodeFixResponseSchema>;\nexport type SuggestedApproach = z.infer<typeof SuggestedApproachSchema>;\n","/**\n * @module shared/config-validator\n * @description Config validation with LLM availability check\n */\n\nimport { z } from 'zod';\nimport { LLMProvider, LLMConfigSchema, CostLimitsSchema } from './types.js';\n\n// \n// SCOT CONFIG SCHEMA - DEFAULT DISABLED\n// \n\nexport const SCoTConfigSchema = z.object({\n  enabled: z.boolean().default(false),\n  minConfidence: z.number().min(0).max(1).default(0.7),\n  maxStructures: z.number().min(1).max(100).default(20),\n  includeReasoningComments: z.boolean().default(true),\n  llm: LLMConfigSchema.default({}),\n  fallback: z.enum(['pattern-only', 'error']).default('pattern-only'),\n}).default({});\n\n// \n// CIRCUIT BREAKER CONFIG\n// \n\nexport const CircuitBreakerConfigSchema = z.object({\n  sameErrorThreshold: z.number().min(1).max(5).default(2),\n  errorHistorySize: z.number().min(5).max(50).default(10),\n  degradationThreshold: z.number().min(0.1).max(1).default(0.5),\n  cooldownMs: z.number().min(1000).max(300000).default(60000),\n}).default({});\n\n// \n// REFINEMENT CONFIG SCHEMA - DEFAULT DISABLED\n// \n\nexport const RefinementConfigSchema = z.object({\n  enabled: z.boolean().default(false),\n  maxAttempts: z.number().min(1).max(5).default(3),\n  timeouts: z.object({\n    session: z.number().min(60000).max(600000).default(300000),\n    execution: z.number().min(10000).max(120000).default(60000),\n    delayBetweenAttempts: z.number().min(500).max(10000).default(1000),\n  }).default({}),\n  circuitBreaker: CircuitBreakerConfigSchema,\n  errorHandling: z.object({\n    categories: z.array(z.string()).default([]),\n    skip: z.array(z.string()).default(['FIXTURE', 'PAGE_ERROR']),\n  }).default({}),\n  learning: z.object({\n    enabled: z.boolean().default(true),\n    minGeneralizability: z.number().min(0).max(1).default(0.6),\n  }).default({}),\n  llm: LLMConfigSchema.default({}),\n  advanced: z.object({\n    minAutoFixConfidence: z.number().min(0).max(1).default(0.7),\n    includeScreenshots: z.boolean().default(true),\n    includeTraces: z.boolean().default(false),\n    verbose: z.boolean().default(false),\n    dryRun: z.boolean().default(false),\n  }).default({}),\n}).default({});\n\n// \n// UNCERTAINTY CONFIG SCHEMA - DEFAULT DISABLED\n// \n\nexport const UncertaintyConfigSchema = z.object({\n  enabled: z.boolean().default(false),\n  thresholds: z.object({\n    autoAccept: z.number().min(0.5).max(1).default(0.85),\n    block: z.number().min(0).max(0.8).default(0.50),\n    minimumPerDimension: z.number().min(0).max(0.8).default(0.40),\n  }).default({}),\n  weights: z.object({\n    syntax: z.number().min(0).max(1).default(0.20),\n    pattern: z.number().min(0).max(1).default(0.30),\n    selector: z.number().min(0).max(1).default(0.30),\n    agreement: z.number().min(0).max(1).default(0.20),\n  }).default({}),\n  sampling: z.object({\n    enabled: z.boolean().default(false),\n    sampleCount: z.number().min(2).max(5).default(3),\n    temperatures: z.array(z.number()).default([0.2, 0.5, 0.7]),\n  }).default({}),\n  reporting: z.object({\n    includeInTestComments: z.boolean().default(true),\n    generateMarkdownReport: z.boolean().default(false),\n  }).default({}),\n}).default({});\n\n// \n// COMBINED ENHANCEMENT CONFIG\n// \n\nexport const AutogenEnhancementConfigSchema = z.object({\n  scot: SCoTConfigSchema,\n  refinement: RefinementConfigSchema,\n  uncertainty: UncertaintyConfigSchema,\n  costLimits: CostLimitsSchema.default({}),\n});\n\nexport type SCoTConfig = z.infer<typeof SCoTConfigSchema>;\nexport type RefinementConfig = z.infer<typeof RefinementConfigSchema>;\nexport type UncertaintyConfig = z.infer<typeof UncertaintyConfigSchema>;\nexport type CircuitBreakerConfig = z.infer<typeof CircuitBreakerConfigSchema>;\nexport type AutogenEnhancementConfig = z.infer<typeof AutogenEnhancementConfigSchema>;\n\n// \n// LLM AVAILABILITY CHECK\n// \n\nexport interface LLMAvailabilityResult {\n  available: boolean;\n  provider: LLMProvider;\n  missingEnvVar?: string;\n  message: string;\n}\n\nconst PROVIDER_ENV_VARS: Record<LLMProvider, string | null> = {\n  openai: 'OPENAI_API_KEY',\n  anthropic: 'ANTHROPIC_API_KEY',\n  azure: 'AZURE_OPENAI_API_KEY',\n  bedrock: 'AWS_ACCESS_KEY_ID',\n  ollama: null,\n  local: null,\n  none: null,\n};\n\nexport function checkLLMAvailability(provider: LLMProvider): LLMAvailabilityResult {\n  if (provider === 'none') {\n    return { available: true, provider, message: 'LLM disabled' };\n  }\n\n  if (provider === 'local' || provider === 'ollama') {\n    return { available: true, provider, message: 'Local LLM, no API key required' };\n  }\n\n  const envVar = PROVIDER_ENV_VARS[provider];\n  if (!envVar) {\n    return { available: false, provider, message: `Unknown provider: ${provider}` };\n  }\n\n  if (!process.env[envVar]) {\n    return {\n      available: false,\n      provider,\n      missingEnvVar: envVar,\n      message: `${provider} requires ${envVar} environment variable`,\n    };\n  }\n\n  return { available: true, provider, message: `${provider} configured` };\n}\n\n// \n// CONFIG VALIDATION\n// \n\nexport interface ConfigValidationResult {\n  valid: boolean;\n  config?: AutogenEnhancementConfig;\n  errors: ConfigValidationError[];\n  warnings: string[];\n}\n\nexport interface ConfigValidationError {\n  path: string;\n  message: string;\n  severity: 'error' | 'warning';\n}\n\nexport function validateEnhancementConfig(rawConfig: unknown): ConfigValidationResult {\n  const errors: ConfigValidationError[] = [];\n  const warnings: string[] = [];\n\n  // Parse with Zod\n  const result = AutogenEnhancementConfigSchema.safeParse(rawConfig ?? {});\n  if (!result.success) {\n    for (const issue of result.error.issues) {\n      errors.push({\n        path: issue.path.join('.'),\n        message: issue.message,\n        severity: 'error',\n      });\n    }\n    return { valid: false, errors, warnings };\n  }\n\n  const config = result.data;\n\n  // Check LLM availability for enabled features\n  if (config.scot.enabled) {\n    const llmCheck = checkLLMAvailability(config.scot.llm.provider);\n    if (!llmCheck.available) {\n      errors.push({\n        path: 'scot.llm.provider',\n        message: `SCoT is enabled but LLM is not available: ${llmCheck.message}. ` +\n                 `Set ${llmCheck.missingEnvVar} or set scot.enabled: false`,\n        severity: 'error',\n      });\n    }\n  }\n\n  if (config.refinement.enabled) {\n    const llmCheck = checkLLMAvailability(config.refinement.llm.provider);\n    if (!llmCheck.available) {\n      errors.push({\n        path: 'refinement.llm.provider',\n        message: `Self-Refinement is enabled but LLM is not available: ${llmCheck.message}. ` +\n                 `Set ${llmCheck.missingEnvVar} or set refinement.enabled: false`,\n        severity: 'error',\n      });\n    }\n  }\n\n  // Warn if weights don't sum to 1.0\n  const weightSum = config.uncertainty.weights.syntax +\n                    config.uncertainty.weights.pattern +\n                    config.uncertainty.weights.selector +\n                    config.uncertainty.weights.agreement;\n  if (Math.abs(weightSum - 1.0) > 0.001) {\n    warnings.push(`Uncertainty weights sum to ${weightSum.toFixed(2)}, not 1.0. Scores may be unexpected.`);\n  }\n\n  // Warn if thresholds are inverted\n  if (config.uncertainty.thresholds.block >= config.uncertainty.thresholds.autoAccept) {\n    warnings.push(`Uncertainty block threshold (${config.uncertainty.thresholds.block}) >= ` +\n                  `autoAccept (${config.uncertainty.thresholds.autoAccept}). This may cause unexpected blocking.`);\n  }\n\n  return {\n    valid: errors.length === 0,\n    config: errors.length === 0 ? config : undefined,\n    errors,\n    warnings,\n  };\n}\n","/**\n * @module shared/cost-tracker\n * @description LLM cost tracking with limits to prevent cost explosion\n */\n\nimport { TokenUsage, CostLimits, CostTrackerState } from './types.js';\n\n// \n// COST ESTIMATION\n// \n\n// Pricing per 1M tokens (as of 2026)\nconst MODEL_PRICING: Record<string, { input: number; output: number }> = {\n  // OpenAI\n  'gpt-4o': { input: 2.50, output: 10.00 },\n  'gpt-4o-mini': { input: 0.15, output: 0.60 },\n  'gpt-4-turbo': { input: 10.00, output: 30.00 },\n  'gpt-3.5-turbo': { input: 0.50, output: 1.50 },\n  // Anthropic\n  'claude-opus-4-20250514': { input: 15.00, output: 75.00 },\n  'claude-sonnet-4-20250514': { input: 3.00, output: 15.00 },\n  'claude-3-5-sonnet-20241022': { input: 3.00, output: 15.00 },\n  'claude-3-haiku-20240307': { input: 0.25, output: 1.25 },\n  // Default for unknown models\n  'default': { input: 1.00, output: 3.00 },\n};\n\nexport function estimateCost(usage: TokenUsage, model: string): number {\n  const pricing = MODEL_PRICING[model] ?? MODEL_PRICING['default'];\n  if (!pricing) {\n    throw new Error('Default pricing not found in MODEL_PRICING');\n  }\n  const inputCost = (usage.promptTokens / 1_000_000) * pricing.input;\n  const outputCost = (usage.completionTokens / 1_000_000) * pricing.output;\n  return inputCost + outputCost;\n}\n\nexport function estimateTokensFromText(text: string): number {\n  // Rough estimation: ~4 characters per token for English\n  return Math.ceil(text.length / 4);\n}\n\n// \n// COST TRACKER\n// \n\nexport class CostTracker {\n  private state: CostTrackerState;\n  private limits: CostLimits;\n  private model: string;\n\n  constructor(limits: CostLimits, model: string = 'default') {\n    this.limits = limits;\n    this.model = model;\n    this.state = {\n      sessionCost: 0,\n      testCost: 0,\n      totalTokens: 0,\n      sessionStartedAt: new Date(),\n    };\n  }\n\n  /**\n   * Track token usage and update costs\n   */\n  trackUsage(usage: TokenUsage): void {\n    const cost = usage.estimatedCostUsd > 0\n      ? usage.estimatedCostUsd\n      : estimateCost(usage, this.model);\n\n    this.state.sessionCost += cost;\n    this.state.testCost += cost;\n    this.state.totalTokens += usage.totalTokens;\n  }\n\n  /**\n   * Get current session cost\n   */\n  getSessionCost(): number {\n    return this.state.sessionCost;\n  }\n\n  /**\n   * Get current test cost\n   */\n  getTestCost(): number {\n    return this.state.testCost;\n  }\n\n  /**\n   * Get total tokens used\n   */\n  getTotalTokens(): number {\n    return this.state.totalTokens;\n  }\n\n  /**\n   * Reset test cost (call between tests)\n   */\n  resetTestCost(): void {\n    this.state.testCost = 0;\n  }\n\n  /**\n   * Check if we are still under budget (have not exceeded limit)\n   * @returns true if cost is UNDER the limit (can continue), false if limit exceeded\n   */\n  isUnderBudget(type: 'test' | 'session'): boolean {\n    if (!this.limits.enabled) return true;  // No limits = always under budget\n\n    if (type === 'test') {\n      return this.state.testCost < this.limits.perTestUsd;\n    } else {\n      return this.state.sessionCost < this.limits.perSessionUsd;\n    }\n  }\n\n  /**\n   * @deprecated Use isUnderBudget() instead - clearer naming\n   */\n  checkLimit(type: 'test' | 'session'): boolean {\n    return this.isUnderBudget(type);\n  }\n\n  /**\n   * Check if adding estimated tokens would exceed limit\n   */\n  wouldExceedLimit(estimatedTokens: number, type: 'test' | 'session' = 'test'): boolean {\n    if (!this.limits.enabled) return false;\n\n    const estimatedUsage: TokenUsage = {\n      promptTokens: estimatedTokens,\n      completionTokens: Math.ceil(estimatedTokens * 0.5), // Assume 50% output ratio\n      totalTokens: Math.ceil(estimatedTokens * 1.5),\n      estimatedCostUsd: 0,\n    };\n    const estimatedCost = estimateCost(estimatedUsage, this.model);\n\n    if (type === 'test') {\n      return (this.state.testCost + estimatedCost) >= this.limits.perTestUsd;\n    } else {\n      return (this.state.sessionCost + estimatedCost) >= this.limits.perSessionUsd;\n    }\n  }\n\n  /**\n   * Get remaining budget\n   */\n  getRemainingBudget(type: 'test' | 'session'): number {\n    if (!this.limits.enabled) return Infinity;\n\n    if (type === 'test') {\n      return Math.max(0, this.limits.perTestUsd - this.state.testCost);\n    } else {\n      return Math.max(0, this.limits.perSessionUsd - this.state.sessionCost);\n    }\n  }\n\n  /**\n   * Get state snapshot\n   */\n  getState(): CostTrackerState {\n    return { ...this.state };\n  }\n\n  /**\n   * Create summary report\n   */\n  getSummary(): CostTrackerSummary {\n    return {\n      sessionCost: this.state.sessionCost,\n      testCost: this.state.testCost,\n      totalTokens: this.state.totalTokens,\n      sessionDurationMs: Date.now() - this.state.sessionStartedAt.getTime(),\n      testBudgetRemaining: this.getRemainingBudget('test'),\n      sessionBudgetRemaining: this.getRemainingBudget('session'),\n      limitsEnabled: this.limits.enabled,\n    };\n  }\n}\n\nexport interface CostTrackerSummary {\n  sessionCost: number;\n  testCost: number;\n  totalTokens: number;\n  sessionDurationMs: number;\n  testBudgetRemaining: number;\n  sessionBudgetRemaining: number;\n  limitsEnabled: boolean;\n}\n\n/**\n * Create a cost tracker with default limits\n */\nexport function createCostTracker(\n  limits?: Partial<CostLimits>,\n  model?: string\n): CostTracker {\n  const defaultLimits: CostLimits = {\n    perTestUsd: 0.10,\n    perSessionUsd: 5.00,\n    enabled: true,\n    ...limits,\n  };\n  return new CostTracker(defaultLimits, model);\n}\n","/**\n * @module shared/telemetry\n * @description Pipeline telemetry for tracking performance, costs, and errors\n *\n * Persists data to .artk/autogen/telemetry.json for analysis and debugging.\n */\n\nimport { readFileSync, writeFileSync, existsSync } from 'node:fs';\nimport { TokenUsage } from './types.js';\nimport { getAutogenArtifact, ensureAutogenDir } from '../utils/paths.js';\nimport { estimateCost } from './cost-tracker.js';\n\n// \n// TYPES\n// \n\nexport interface TelemetryEvent {\n  /** Event timestamp (ISO 8601) */\n  timestamp: string;\n  /** Event type */\n  type: 'command_start' | 'command_end' | 'llm_call' | 'error' | 'pipeline_transition';\n  /** Command that generated the event */\n  command: string;\n  /** Additional event data */\n  data: Record<string, unknown>;\n}\n\nexport interface CommandStats {\n  /** Total executions */\n  count: number;\n  /** Total successful executions */\n  successCount: number;\n  /** Total failed executions */\n  errorCount: number;\n  /** Average duration in milliseconds */\n  avgDurationMs: number;\n  /** Total duration in milliseconds */\n  totalDurationMs: number;\n  /** Last execution timestamp */\n  lastRun: string | null;\n}\n\nexport interface TelemetryData {\n  /** Version of telemetry schema */\n  version: number;\n  /** Session ID */\n  sessionId: string;\n  /** When this telemetry file was created */\n  createdAt: string;\n  /** Last update time */\n  updatedAt: string;\n  /** Total tokens used across all commands */\n  totalTokens: number;\n  /** Total estimated cost in USD */\n  totalCostUsd: number;\n  /** Command-level stats */\n  commandStats: Record<string, CommandStats>;\n  /** Recent events (last 100) */\n  recentEvents: TelemetryEvent[];\n  /** Error counts by type */\n  errorCounts: Record<string, number>;\n}\n\nexport interface TelemetryConfig {\n  /** Whether telemetry is enabled */\n  enabled: boolean;\n  /** Maximum number of events to keep */\n  maxEvents: number;\n  /** Default model for cost estimation */\n  defaultModel: string;\n}\n\n// \n// DEFAULTS\n// \n\nconst DEFAULT_CONFIG: TelemetryConfig = {\n  enabled: true,\n  maxEvents: 100,\n  defaultModel: 'gpt-4o-mini',\n};\n\nfunction createEmptyTelemetryData(sessionId: string): TelemetryData {\n  const now = new Date().toISOString();\n  return {\n    version: 1,\n    sessionId,\n    createdAt: now,\n    updatedAt: now,\n    totalTokens: 0,\n    totalCostUsd: 0,\n    commandStats: {},\n    recentEvents: [],\n    errorCounts: {},\n  };\n}\n\n// \n// TELEMETRY CLASS\n// \n\nexport class Telemetry {\n  private data: TelemetryData;\n  private config: TelemetryConfig;\n  private sessionId: string;\n  private pendingCommands: Map<string, { startTime: number; command: string }>;\n\n  constructor(config: Partial<TelemetryConfig> = {}) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.sessionId = this.generateSessionId();\n    this.data = createEmptyTelemetryData(this.sessionId);\n    this.pendingCommands = new Map();\n  }\n\n  private generateSessionId(): string {\n    return `session-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;\n  }\n\n  /**\n   * Load existing telemetry data or create new\n   */\n  async load(baseDir?: string): Promise<void> {\n    if (!this.config.enabled) return;\n\n    try {\n      const telemetryPath = getAutogenArtifact('telemetry', baseDir);\n      if (existsSync(telemetryPath)) {\n        const content = readFileSync(telemetryPath, 'utf-8');\n        const loaded = JSON.parse(content) as TelemetryData;\n\n        // Preserve historical data, update session\n        this.data = {\n          ...loaded,\n          sessionId: this.sessionId,\n          updatedAt: new Date().toISOString(),\n        };\n      }\n    } catch {\n      // If loading fails, start fresh\n      this.data = createEmptyTelemetryData(this.sessionId);\n    }\n  }\n\n  /**\n   * Save telemetry data to disk\n   */\n  async save(baseDir?: string): Promise<void> {\n    if (!this.config.enabled) return;\n\n    try {\n      await ensureAutogenDir(baseDir);\n      const telemetryPath = getAutogenArtifact('telemetry', baseDir);\n      this.data.updatedAt = new Date().toISOString();\n      writeFileSync(telemetryPath, JSON.stringify(this.data, null, 2), 'utf-8');\n    } catch {\n      // Silently fail - telemetry should never block operations\n    }\n  }\n\n  /**\n   * Track command start\n   */\n  trackCommandStart(command: string): string {\n    if (!this.config.enabled) return '';\n\n    const eventId = `${command}-${Date.now()}`;\n    this.pendingCommands.set(eventId, {\n      startTime: Date.now(),\n      command,\n    });\n\n    this.addEvent({\n      timestamp: new Date().toISOString(),\n      type: 'command_start',\n      command,\n      data: { eventId },\n    });\n\n    return eventId;\n  }\n\n  /**\n   * Track command end\n   */\n  trackCommandEnd(eventId: string, success: boolean, data: Record<string, unknown> = {}): void {\n    if (!this.config.enabled) return;\n\n    const pending = this.pendingCommands.get(eventId);\n    if (!pending) return;\n\n    const durationMs = Date.now() - pending.startTime;\n    const { command } = pending;\n\n    // Update command stats\n    if (!this.data.commandStats[command]) {\n      this.data.commandStats[command] = {\n        count: 0,\n        successCount: 0,\n        errorCount: 0,\n        avgDurationMs: 0,\n        totalDurationMs: 0,\n        lastRun: null,\n      };\n    }\n\n    const stats = this.data.commandStats[command];\n    stats.count++;\n    if (success) {\n      stats.successCount++;\n    } else {\n      stats.errorCount++;\n    }\n    stats.totalDurationMs += durationMs;\n    stats.avgDurationMs = stats.totalDurationMs / stats.count;\n    stats.lastRun = new Date().toISOString();\n\n    this.addEvent({\n      timestamp: new Date().toISOString(),\n      type: 'command_end',\n      command,\n      data: { eventId, success, durationMs, ...data },\n    });\n\n    this.pendingCommands.delete(eventId);\n  }\n\n  /**\n   * Track LLM usage\n   */\n  trackLLMUsage(\n    command: string,\n    usage: TokenUsage,\n    model: string = this.config.defaultModel\n  ): void {\n    if (!this.config.enabled) return;\n\n    const cost = usage.estimatedCostUsd > 0\n      ? usage.estimatedCostUsd\n      : estimateCost(usage, model);\n\n    this.data.totalTokens += usage.totalTokens;\n    this.data.totalCostUsd += cost;\n\n    this.addEvent({\n      timestamp: new Date().toISOString(),\n      type: 'llm_call',\n      command,\n      data: {\n        model,\n        promptTokens: usage.promptTokens,\n        completionTokens: usage.completionTokens,\n        totalTokens: usage.totalTokens,\n        costUsd: cost,\n      },\n    });\n  }\n\n  /**\n   * Track error\n   */\n  trackError(command: string, errorType: string, message: string): void {\n    if (!this.config.enabled) return;\n\n    this.data.errorCounts[errorType] = (this.data.errorCounts[errorType] || 0) + 1;\n\n    this.addEvent({\n      timestamp: new Date().toISOString(),\n      type: 'error',\n      command,\n      data: { errorType, message },\n    });\n  }\n\n  /**\n   * Track pipeline state transition\n   */\n  trackPipelineTransition(\n    command: string,\n    fromStage: string,\n    toStage: string,\n    data: Record<string, unknown> = {}\n  ): void {\n    if (!this.config.enabled) return;\n\n    this.addEvent({\n      timestamp: new Date().toISOString(),\n      type: 'pipeline_transition',\n      command,\n      data: { fromStage, toStage, ...data },\n    });\n  }\n\n  private addEvent(event: TelemetryEvent): void {\n    this.data.recentEvents.push(event);\n\n    // Trim to max events\n    if (this.data.recentEvents.length > this.config.maxEvents) {\n      this.data.recentEvents = this.data.recentEvents.slice(-this.config.maxEvents);\n    }\n  }\n\n  /**\n   * Get telemetry summary\n   */\n  getSummary(): TelemetrySummary {\n    return {\n      sessionId: this.sessionId,\n      totalTokens: this.data.totalTokens,\n      totalCostUsd: this.data.totalCostUsd,\n      commandStats: { ...this.data.commandStats },\n      topErrors: Object.entries(this.data.errorCounts)\n        .sort(([, a], [, b]) => b - a)\n        .slice(0, 5)\n        .map(([type, count]) => ({ type, count })),\n      eventCount: this.data.recentEvents.length,\n    };\n  }\n\n  /**\n   * Get raw data (for debugging)\n   */\n  getData(): TelemetryData {\n    return { ...this.data };\n  }\n\n  /**\n   * Reset telemetry (for testing)\n   */\n  reset(): void {\n    this.sessionId = this.generateSessionId();\n    this.data = createEmptyTelemetryData(this.sessionId);\n    this.pendingCommands.clear();\n  }\n}\n\nexport interface TelemetrySummary {\n  sessionId: string;\n  totalTokens: number;\n  totalCostUsd: number;\n  commandStats: Record<string, CommandStats>;\n  topErrors: Array<{ type: string; count: number }>;\n  eventCount: number;\n}\n\n// \n// SINGLETON INSTANCE\n// \n\nlet globalTelemetry: Telemetry | null = null;\n\n/**\n * Get the global telemetry instance\n */\nexport function getTelemetry(config?: Partial<TelemetryConfig>): Telemetry {\n  if (!globalTelemetry) {\n    globalTelemetry = new Telemetry(config);\n  }\n  return globalTelemetry;\n}\n\n/**\n * Create a new telemetry instance (for testing)\n */\nexport function createTelemetry(config?: Partial<TelemetryConfig>): Telemetry {\n  return new Telemetry(config);\n}\n\n/**\n * Reset global telemetry (for testing)\n */\nexport function resetGlobalTelemetry(): void {\n  globalTelemetry = null;\n}\n","/**\n * @module shared\n * @description Shared infrastructure for AutoGen enhancement strategies\n */\n\n// Types\nexport * from './types.js';\n\n// LLM Response Parser\nexport {\n  parseLLMResponse,\n  extractJson,\n  type ParseError,\n  type ParseOptions,\n  // Schemas\n  SCoTPlanResponseSchema,\n  ErrorAnalysisResponseSchema,\n  CodeFixResponseSchema,\n  SCoTAtomicStepSchema,\n  SCoTConditionSchema,\n  SCoTIteratorSchema,\n  SCoTStructureSchema,\n  SuggestedApproachSchema,\n  CodeChangeSchema,\n  // Types\n  type SCoTPlanResponse,\n  type ErrorAnalysisResponse,\n  type CodeFixResponse,\n  type SuggestedApproach,\n} from './llm-response-parser.js';\n\n// Config Validator\nexport {\n  validateEnhancementConfig,\n  checkLLMAvailability,\n  // Schemas\n  SCoTConfigSchema,\n  RefinementConfigSchema,\n  UncertaintyConfigSchema,\n  CircuitBreakerConfigSchema,\n  AutogenEnhancementConfigSchema,\n  // Types\n  type SCoTConfig,\n  type RefinementConfig,\n  type UncertaintyConfig,\n  type CircuitBreakerConfig,\n  type AutogenEnhancementConfig,\n  type LLMAvailabilityResult,\n  type ConfigValidationResult,\n  type ConfigValidationError,\n} from './config-validator.js';\n\n// Cost Tracker\nexport {\n  CostTracker,\n  createCostTracker,\n  estimateCost,\n  estimateTokensFromText,\n  type CostTrackerSummary,\n} from './cost-tracker.js';\n\n// Telemetry\nexport {\n  Telemetry,\n  getTelemetry,\n  createTelemetry,\n  resetGlobalTelemetry,\n  type TelemetryEvent,\n  type TelemetryData,\n  type TelemetryConfig,\n  type TelemetrySummary,\n  type CommandStats,\n} from './telemetry.js';\n","/**\n * @module scot/types\n * @description Type definitions for Structured Chain-of-Thought (SCoT) planning\n */\n\nimport { TokenUsage, LLMConfig } from '../shared/types.js';\n\n// \n// ATOMIC STEP\n// \n\nexport interface SCoTAtomicStep {\n  /** The action to perform (e.g., 'click', 'fill', 'navigate', 'assert') */\n  action: string;\n  /** The target element or URL */\n  target?: string;\n  /** The value to input (for fill actions) */\n  value?: string;\n  /** An assertion to verify after the action */\n  assertion?: string;\n  /** Optional timeout override in milliseconds */\n  timeoutMs?: number;\n  /** Whether this step is optional (won't fail the test if it fails) */\n  optional?: boolean;\n}\n\n// \n// CONDITION\n// \n\nexport type ConditionState = 'visible' | 'hidden' | 'enabled' | 'disabled' | 'exists' | 'checked' | 'unchecked';\n\nexport interface SCoTCondition {\n  /** The element to check (selector or description) */\n  element?: string;\n  /** The state to check for */\n  state: ConditionState;\n  /** Whether to negate the condition (NOT visible, etc.) */\n  negate?: boolean;\n  /** Alternative: a custom JavaScript expression to evaluate */\n  expression?: string;\n  /** Timeout for waiting on the condition */\n  timeoutMs?: number;\n}\n\n// \n// ITERATOR\n// \n\nexport interface SCoTIterator {\n  /** The variable name for each iteration */\n  variable: string;\n  /** The collection to iterate over (selector or data source) */\n  collection: string;\n  /** Maximum iterations to prevent infinite loops */\n  maxIterations?: number;\n  /** Whether to continue on error (vs fail fast) */\n  continueOnError?: boolean;\n}\n\n// \n// STRUCTURE TYPES\n// \n\nexport type SCoTStructureType = 'sequential' | 'branch' | 'loop';\n\nexport interface SCoTSequential {\n  type: 'sequential';\n  description: string;\n  steps: SCoTAtomicStep[];\n}\n\nexport interface SCoTBranch {\n  type: 'branch';\n  description: string;\n  condition: SCoTCondition;\n  thenBranch: SCoTAtomicStep[];\n  elseBranch?: SCoTAtomicStep[];\n}\n\nexport interface SCoTLoop {\n  type: 'loop';\n  description: string;\n  iterator: SCoTIterator;\n  body: SCoTAtomicStep[];\n  maxIterations?: number;\n}\n\n/** Union type for all structure types */\nexport type SCoTStructure = SCoTSequential | SCoTBranch | SCoTLoop;\n\n// \n// PLAN\n// \n\nexport interface SCoTPlan {\n  journeyId: string;\n  structures: SCoTStructure[];\n  reasoning: string;\n  confidence: number;\n  warnings: string[];\n  metadata: SCoTPlanMetadata;\n}\n\nexport interface SCoTPlanMetadata {\n  generatedAt: Date;\n  llmModel: string;\n  tokenUsage: TokenUsage;\n  parseAttempts: number;\n  parsingMethod: 'json' | 'text';\n}\n\n// \n// CONFIG\n// \n\nexport interface SCoTConfig {\n  enabled: boolean;\n  minConfidence: number;\n  maxStructures: number;\n  includeReasoningComments: boolean;\n  llm: LLMConfig;\n  fallback: 'pattern-only' | 'error';\n}\n\n// \n// RESULT TYPES\n// \n\nexport type SCoTPlanResult =\n  | { success: true; plan: SCoTPlan }\n  | { success: false; error: SCoTPlanError; fallbackUsed: boolean };\n\nexport type SCoTPlanErrorType =\n  | 'LLM_ERROR'\n  | 'PARSE_ERROR'\n  | 'VALIDATION_ERROR'\n  | 'LOW_CONFIDENCE'\n  | 'TIMEOUT'\n  | 'COST_LIMIT';\n\nexport interface SCoTPlanError {\n  type: SCoTPlanErrorType;\n  message: string;\n  details?: unknown;\n  tokenUsage?: TokenUsage;\n}\n\n// \n// VALIDATION\n// \n\nexport interface SCoTValidationResult {\n  valid: boolean;\n  errors: SCoTValidationError[];\n  warnings: string[];\n}\n\nexport interface SCoTValidationError {\n  path: string;\n  message: string;\n  severity: 'error' | 'warning';\n}\n\n// \n// TYPE GUARDS\n// \n\nexport function isSequential(structure: SCoTStructure): structure is SCoTSequential {\n  return structure.type === 'sequential';\n}\n\nexport function isBranch(structure: SCoTStructure): structure is SCoTBranch {\n  return structure.type === 'branch';\n}\n\nexport function isLoop(structure: SCoTStructure): structure is SCoTLoop {\n  return structure.type === 'loop';\n}\n","/**\n * @module scot/parser\n * @description Parse LLM output to structured SCoT plan\n */\n\nimport { z } from 'zod';\nimport { Result, ok, err } from '../shared/types.js';\nimport { parseLLMResponse, SCoTPlanResponseSchema } from '../shared/llm-response-parser.js';\nimport {\n  SCoTPlan,\n  SCoTStructure,\n  SCoTSequential,\n  SCoTBranch,\n  SCoTLoop,\n  SCoTAtomicStep,\n  SCoTPlanMetadata,\n} from './types.js';\n\n// \n// PARSE ERROR\n// \n\nexport interface SCoTParseError {\n  type: 'EXTRACTION_FAILED' | 'INVALID_JSON' | 'SCHEMA_VALIDATION' | 'STRUCTURE_ERROR';\n  message: string;\n  line?: number;\n  rawContent?: string;\n}\n\n// \n// REGEX PATTERNS FOR TEXT PARSING\n// \n\nconst PATTERNS = {\n  SEQUENTIAL: /^SEQUENTIAL:\\s*(.+)$/im,\n  BRANCH: /^BRANCH:\\s*(.+)$/im,\n  LOOP: /^LOOP:\\s*(.+)$/im,\n  IF: /^IF\\s+(.+)\\s+THEN$/im,\n  ELSE: /^ELSE$/im,\n  ENDIF: /^ENDIF$/im,\n  FOR_EACH: /^FOR\\s+EACH\\s+(\\w+)\\s+IN\\s+(.+)$/im,\n  ENDFOR: /^ENDFOR$/im,\n  STEP: /^\\s*(\\d+[a-z]?)\\.\\s*(.+)$/m,\n  REASONING: /REASONING:\\s*([\\s\\S]*?)(?=CONFIDENCE:|PLAN:|$)/i,\n  CONFIDENCE: /CONFIDENCE:\\s*([\\d.]+)/i,\n  WARNINGS: /WARNINGS:\\s*([\\s\\S]*?)$/i,\n  ACTION_STEP: /^-\\s*(.+)$/m,\n};\n\n// \n// MAIN PARSER\n// \n\nexport interface ParseOptions {\n  journeyId: string;\n  llmModel?: string;\n  maxRetries?: number;\n}\n\n/**\n * Parse SCoT plan from LLM response\n * Tries JSON first, falls back to text parsing\n */\nexport async function parseSCoTPlan(\n  llmResponse: string,\n  options: ParseOptions\n): Promise<Result<SCoTPlan, SCoTParseError>> {\n  const { journeyId, llmModel = 'unknown', maxRetries = 1 } = options;\n\n  // Try JSON parsing first (preferred)\n  const jsonResult = await parseLLMResponse(llmResponse, SCoTPlanResponseSchema, {\n    maxRetries,\n  });\n\n  if (jsonResult.ok) {\n    // Normalize the response (ensure warnings is always an array)\n    const normalized = {\n      ...jsonResult.value,\n      warnings: jsonResult.value.warnings ?? [],\n    };\n    const plan = convertResponseToPlan(normalized, journeyId, llmModel, 'json');\n    return ok(plan);\n  }\n\n  // Fall back to text parsing\n  const textResult = parseTextFormat(llmResponse, journeyId, llmModel);\n  return textResult;\n}\n\n// \n// JSON RESPONSE CONVERTER\n// \n\ntype SCoTPlanResponse = z.infer<typeof SCoTPlanResponseSchema>;\n\nfunction convertResponseToPlan(\n  response: SCoTPlanResponse,\n  journeyId: string,\n  llmModel: string,\n  method: 'json' | 'text'\n): SCoTPlan {\n  const structures: SCoTStructure[] = response.plan.map(item => {\n    if (item.type === 'sequential') {\n      return {\n        type: 'sequential',\n        description: item.description,\n        steps: (item.steps ?? []).map(convertStep),\n      } as SCoTSequential;\n    } else if (item.type === 'branch') {\n      return {\n        type: 'branch',\n        description: item.description,\n        condition: item.condition ?? { state: 'visible' },\n        thenBranch: (item.thenBranch ?? []).map(convertStep),\n        elseBranch: item.elseBranch?.map(convertStep),\n      } as SCoTBranch;\n    } else {\n      return {\n        type: 'loop',\n        description: item.description,\n        iterator: item.iterator ?? { variable: 'item', collection: 'items' },\n        body: (item.body ?? []).map(convertStep),\n        maxIterations: item.iterator?.maxIterations,\n      } as SCoTLoop;\n    }\n  });\n\n  const metadata: SCoTPlanMetadata = {\n    generatedAt: new Date(),\n    llmModel,\n    tokenUsage: { promptTokens: 0, completionTokens: 0, totalTokens: 0, estimatedCostUsd: 0 },\n    parseAttempts: 1,\n    parsingMethod: method,\n  };\n\n  return {\n    journeyId,\n    structures,\n    reasoning: response.reasoning,\n    confidence: response.confidence,\n    warnings: response.warnings ?? [],\n    metadata,\n  };\n}\n\nfunction convertStep(step: { action: string; target?: string; value?: string; assertion?: string }): SCoTAtomicStep {\n  return {\n    action: step.action,\n    target: step.target,\n    value: step.value,\n    assertion: step.assertion,\n  };\n}\n\n// \n// TEXT FORMAT PARSER\n// \n\nfunction parseTextFormat(\n  text: string,\n  journeyId: string,\n  llmModel: string\n): Result<SCoTPlan, SCoTParseError> {\n  try {\n    const reasoning = extractReasoning(text);\n    const confidence = extractConfidence(text);\n    const warnings = extractWarnings(text);\n    const structures = extractStructures(text);\n\n    if (structures.length === 0) {\n      return err({\n        type: 'STRUCTURE_ERROR',\n        message: 'No SEQUENTIAL, BRANCH, or LOOP structures found in response',\n        rawContent: text.substring(0, 500),\n      });\n    }\n\n    const metadata: SCoTPlanMetadata = {\n      generatedAt: new Date(),\n      llmModel,\n      tokenUsage: { promptTokens: 0, completionTokens: 0, totalTokens: 0, estimatedCostUsd: 0 },\n      parseAttempts: 1,\n      parsingMethod: 'text',\n    };\n\n    return ok({\n      journeyId,\n      structures,\n      reasoning,\n      confidence,\n      warnings,\n      metadata,\n    });\n  } catch (e) {\n    return err({\n      type: 'STRUCTURE_ERROR',\n      message: e instanceof Error ? e.message : 'Unknown parsing error',\n      rawContent: text.substring(0, 500),\n    });\n  }\n}\n\nfunction extractReasoning(text: string): string {\n  const match = text.match(PATTERNS.REASONING);\n  return (match && match[1]) ? match[1].trim() : '';\n}\n\nfunction extractConfidence(text: string): number {\n  const match = text.match(PATTERNS.CONFIDENCE);\n  if (match && match[1]) {\n    const value = parseFloat(match[1]);\n    if (!isNaN(value) && value >= 0 && value <= 1) {\n      return value;\n    }\n  }\n  return 0.5; // Default confidence\n}\n\nfunction extractWarnings(text: string): string[] {\n  const match = text.match(PATTERNS.WARNINGS);\n  if (!match || !match[1] || match[1].trim().toLowerCase() === 'none') {\n    return [];\n  }\n  return match[1]\n    .trim()\n    .split('\\n')\n    .map(w => w.trim())\n    .filter(Boolean);\n}\n\nfunction extractStructures(text: string): SCoTStructure[] {\n  const structures: SCoTStructure[] = [];\n  const lines = text.split('\\n');\n\n  let i = 0;\n  while (i < lines.length) {\n    const currentLine = lines[i];\n    if (!currentLine) {\n      i++;\n      continue;\n    }\n    const line = currentLine.trim();\n\n    // Check for SEQUENTIAL\n    const seqMatch = line.match(PATTERNS.SEQUENTIAL);\n    if (seqMatch && seqMatch[1]) {\n      const { structure, endIndex } = parseSequentialBlock(lines, i, seqMatch[1]);\n      structures.push(structure);\n      i = endIndex + 1;\n      continue;\n    }\n\n    // Check for BRANCH\n    const branchMatch = line.match(PATTERNS.BRANCH);\n    if (branchMatch && branchMatch[1]) {\n      const { structure, endIndex } = parseBranchBlock(lines, i, branchMatch[1]);\n      structures.push(structure);\n      i = endIndex + 1;\n      continue;\n    }\n\n    // Check for LOOP\n    const loopMatch = line.match(PATTERNS.LOOP);\n    if (loopMatch && loopMatch[1]) {\n      const { structure, endIndex } = parseLoopBlock(lines, i, loopMatch[1]);\n      structures.push(structure);\n      i = endIndex + 1;\n      continue;\n    }\n\n    i++;\n  }\n\n  return structures;\n}\n\nfunction parseSequentialBlock(\n  lines: string[],\n  startIndex: number,\n  description: string\n): { structure: SCoTSequential; endIndex: number } {\n  const steps: SCoTAtomicStep[] = [];\n  let i = startIndex + 1;\n\n  while (i < lines.length) {\n    const currentLine = lines[i];\n    if (!currentLine) {\n      i++;\n      continue;\n    }\n    const line = currentLine.trim();\n\n    // Check for end of block (next structure or empty lines followed by structure)\n    if (PATTERNS.SEQUENTIAL.test(line) || PATTERNS.BRANCH.test(line) || PATTERNS.LOOP.test(line)) {\n      break;\n    }\n\n    // Parse numbered step\n    const stepMatch = line.match(PATTERNS.STEP);\n    if (stepMatch && stepMatch[2]) {\n      steps.push(parseStepText(stepMatch[2]));\n    }\n\n    // Parse bullet point step\n    const bulletMatch = line.match(PATTERNS.ACTION_STEP);\n    if (bulletMatch && bulletMatch[1]) {\n      steps.push(parseStepText(bulletMatch[1]));\n    }\n\n    i++;\n  }\n\n  return {\n    structure: { type: 'sequential', description, steps },\n    endIndex: i - 1,\n  };\n}\n\nfunction parseBranchBlock(\n  lines: string[],\n  startIndex: number,\n  description: string\n): { structure: SCoTBranch; endIndex: number } {\n  const thenBranch: SCoTAtomicStep[] = [];\n  const elseBranch: SCoTAtomicStep[] = [];\n  let condition: { element?: string; state: 'visible' | 'hidden' | 'enabled' | 'disabled' | 'exists' | 'checked' | 'unchecked' } = { state: 'visible' };\n  let inElse = false;\n  let i = startIndex + 1;\n\n  while (i < lines.length) {\n    const currentLine = lines[i];\n    if (!currentLine) {\n      i++;\n      continue;\n    }\n    const line = currentLine.trim();\n\n    // Check for IF condition\n    const ifMatch = line.match(PATTERNS.IF);\n    if (ifMatch && ifMatch[1]) {\n      condition = parseConditionText(ifMatch[1]);\n      i++;\n      continue;\n    }\n\n    // Check for ELSE\n    if (PATTERNS.ELSE.test(line)) {\n      inElse = true;\n      i++;\n      continue;\n    }\n\n    // Check for ENDIF\n    if (PATTERNS.ENDIF.test(line)) {\n      break;\n    }\n\n    // Check for end of block\n    if (PATTERNS.SEQUENTIAL.test(line) || PATTERNS.BRANCH.test(line) || PATTERNS.LOOP.test(line)) {\n      break;\n    }\n\n    // Parse step\n    const bulletMatch = line.match(PATTERNS.ACTION_STEP);\n    if (bulletMatch && bulletMatch[1]) {\n      const step = parseStepText(bulletMatch[1]);\n      if (inElse) {\n        elseBranch.push(step);\n      } else {\n        thenBranch.push(step);\n      }\n    }\n\n    i++;\n  }\n\n  return {\n    structure: {\n      type: 'branch',\n      description,\n      condition,\n      thenBranch,\n      elseBranch: elseBranch.length > 0 ? elseBranch : undefined,\n    },\n    endIndex: i,\n  };\n}\n\nfunction parseLoopBlock(\n  lines: string[],\n  startIndex: number,\n  description: string\n): { structure: SCoTLoop; endIndex: number } {\n  const body: SCoTAtomicStep[] = [];\n  let iterator = { variable: 'item', collection: 'items' };\n  let i = startIndex + 1;\n\n  while (i < lines.length) {\n    const currentLine = lines[i];\n    if (!currentLine) {\n      i++;\n      continue;\n    }\n    const line = currentLine.trim();\n\n    // Check for FOR EACH\n    const forMatch = line.match(PATTERNS.FOR_EACH);\n    if (forMatch && forMatch[1] && forMatch[2]) {\n      iterator = { variable: forMatch[1], collection: forMatch[2] };\n      i++;\n      continue;\n    }\n\n    // Check for ENDFOR\n    if (PATTERNS.ENDFOR.test(line)) {\n      break;\n    }\n\n    // Check for end of block\n    if (PATTERNS.SEQUENTIAL.test(line) || PATTERNS.BRANCH.test(line) || PATTERNS.LOOP.test(line)) {\n      break;\n    }\n\n    // Parse step\n    const bulletMatch = line.match(PATTERNS.ACTION_STEP);\n    if (bulletMatch && bulletMatch[1]) {\n      body.push(parseStepText(bulletMatch[1]));\n    }\n\n    i++;\n  }\n\n  return {\n    structure: { type: 'loop', description, iterator, body },\n    endIndex: i,\n  };\n}\n\n// \n// STEP TEXT PARSING\n// \n\nfunction parseStepText(stepText: string): SCoTAtomicStep {\n  const lowerText = stepText.toLowerCase();\n\n  // Navigation actions\n  if (lowerText.includes('navigate') || lowerText.includes('go to') || lowerText.includes('open')) {\n    return { action: 'navigate', target: stepText };\n  }\n\n  // Click actions\n  if (lowerText.includes('click') || lowerText.includes('press') || lowerText.includes('tap')) {\n    return { action: 'click', target: stepText };\n  }\n\n  // Fill/input actions\n  if (lowerText.includes('fill') || lowerText.includes('enter') || lowerText.includes('type') || lowerText.includes('input')) {\n    return { action: 'fill', target: stepText };\n  }\n\n  // Select actions\n  if (lowerText.includes('select') || lowerText.includes('choose')) {\n    return { action: 'select', target: stepText };\n  }\n\n  // Check/uncheck actions\n  if (lowerText.includes('check') || lowerText.includes('toggle')) {\n    return { action: 'check', target: stepText };\n  }\n\n  // Wait actions\n  if (lowerText.includes('wait')) {\n    return { action: 'wait', target: stepText };\n  }\n\n  // Assertion actions\n  if (lowerText.includes('verify') || lowerText.includes('assert') || lowerText.includes('expect') || lowerText.includes('confirm') || lowerText.includes('should')) {\n    return { action: 'assert', assertion: stepText };\n  }\n\n  // Default to generic action\n  return { action: 'action', target: stepText };\n}\n\nfunction parseConditionText(conditionText: string): { element?: string; state: 'visible' | 'hidden' | 'enabled' | 'disabled' | 'exists' | 'checked' | 'unchecked' } {\n  const lowerText = conditionText.toLowerCase();\n\n  let state: 'visible' | 'hidden' | 'enabled' | 'disabled' | 'exists' | 'checked' | 'unchecked' = 'visible';\n\n  if (lowerText.includes('hidden') || lowerText.includes('not visible')) {\n    state = 'hidden';\n  } else if (lowerText.includes('disabled')) {\n    state = 'disabled';\n  } else if (lowerText.includes('enabled')) {\n    state = 'enabled';\n  } else if (lowerText.includes('exists') || lowerText.includes('present')) {\n    state = 'exists';\n  } else if (lowerText.includes('checked') || lowerText.includes('selected')) {\n    state = 'checked';\n  } else if (lowerText.includes('unchecked') || lowerText.includes('not selected')) {\n    state = 'unchecked';\n  }\n\n  return { element: conditionText, state };\n}\n","/**\n * @module scot/validator\n * @description Validate SCoT plans for correctness and completeness\n */\n\nimport {\n  SCoTPlan,\n  SCoTStructure,\n  SCoTAtomicStep,\n  SCoTValidationResult,\n  SCoTValidationError,\n  SCoTConfig,\n  isSequential,\n  isBranch,\n  isLoop,\n} from './types.js';\n\n// \n// MAIN VALIDATOR\n// \n\nexport function validateSCoTPlan(plan: SCoTPlan, config: SCoTConfig): SCoTValidationResult {\n  const errors: SCoTValidationError[] = [];\n  const warnings: string[] = [];\n\n  // Check basic plan structure\n  if (!plan.journeyId) {\n    errors.push({\n      path: 'journeyId',\n      message: 'Plan must have a journeyId',\n      severity: 'error',\n    });\n  }\n\n  if (!plan.structures || plan.structures.length === 0) {\n    errors.push({\n      path: 'structures',\n      message: 'Plan must have at least one structure',\n      severity: 'error',\n    });\n  }\n\n  // Check structure count limit\n  if (plan.structures.length > config.maxStructures) {\n    errors.push({\n      path: 'structures',\n      message: `Plan has ${plan.structures.length} structures, exceeds maximum of ${config.maxStructures}`,\n      severity: 'error',\n    });\n  }\n\n  // Check confidence threshold\n  if (plan.confidence < config.minConfidence) {\n    errors.push({\n      path: 'confidence',\n      message: `Plan confidence ${plan.confidence.toFixed(2)} is below minimum ${config.minConfidence}`,\n      severity: 'error',\n    });\n  }\n\n  // Validate each structure\n  plan.structures.forEach((structure, index) => {\n    const structureErrors = validateStructure(structure, `structures[${index}]`);\n    errors.push(...structureErrors);\n  });\n\n  // Check for empty reasoning (warning only)\n  if (!plan.reasoning || plan.reasoning.trim().length < 10) {\n    warnings.push('Plan reasoning is missing or too short');\n  }\n\n  // Check for warnings in the plan\n  if (plan.warnings && plan.warnings.length > 0) {\n    warnings.push(...plan.warnings.map(w => `LLM warning: ${w}`));\n  }\n\n  // Check for potential infinite loops\n  const loopWarnings = checkForInfiniteLoops(plan.structures);\n  warnings.push(...loopWarnings);\n\n  // Check for unreachable code\n  const unreachableWarnings = checkForUnreachableCode(plan.structures);\n  warnings.push(...unreachableWarnings);\n\n  return {\n    valid: errors.filter(e => e.severity === 'error').length === 0,\n    errors,\n    warnings,\n  };\n}\n\n// \n// STRUCTURE VALIDATION\n// \n\nfunction validateStructure(structure: SCoTStructure, path: string): SCoTValidationError[] {\n  const errors: SCoTValidationError[] = [];\n\n  // Check description\n  if (!structure.description || structure.description.trim().length === 0) {\n    errors.push({\n      path: `${path}.description`,\n      message: 'Structure must have a description',\n      severity: 'warning',\n    });\n  }\n\n  if (isSequential(structure)) {\n    errors.push(...validateSequential(structure, path));\n  } else if (isBranch(structure)) {\n    errors.push(...validateBranch(structure, path));\n  } else if (isLoop(structure)) {\n    errors.push(...validateLoop(structure, path));\n  }\n\n  return errors;\n}\n\nfunction validateSequential(structure: { steps: SCoTAtomicStep[] }, path: string): SCoTValidationError[] {\n  const errors: SCoTValidationError[] = [];\n\n  if (!structure.steps || structure.steps.length === 0) {\n    errors.push({\n      path: `${path}.steps`,\n      message: 'Sequential structure must have at least one step',\n      severity: 'error',\n    });\n    return errors;\n  }\n\n  structure.steps.forEach((step, index) => {\n    errors.push(...validateStep(step, `${path}.steps[${index}]`));\n  });\n\n  return errors;\n}\n\nfunction validateBranch(\n  structure: { condition: unknown; thenBranch: SCoTAtomicStep[]; elseBranch?: SCoTAtomicStep[] },\n  path: string\n): SCoTValidationError[] {\n  const errors: SCoTValidationError[] = [];\n\n  // Check condition\n  if (!structure.condition) {\n    errors.push({\n      path: `${path}.condition`,\n      message: 'Branch structure must have a condition',\n      severity: 'error',\n    });\n  }\n\n  // Check thenBranch\n  if (!structure.thenBranch || structure.thenBranch.length === 0) {\n    errors.push({\n      path: `${path}.thenBranch`,\n      message: 'Branch structure must have at least one step in thenBranch',\n      severity: 'error',\n    });\n  } else {\n    structure.thenBranch.forEach((step, index) => {\n      errors.push(...validateStep(step, `${path}.thenBranch[${index}]`));\n    });\n  }\n\n  // Validate elseBranch if present\n  if (structure.elseBranch) {\n    structure.elseBranch.forEach((step, index) => {\n      errors.push(...validateStep(step, `${path}.elseBranch[${index}]`));\n    });\n  }\n\n  return errors;\n}\n\nfunction validateLoop(\n  structure: { iterator: unknown; body: SCoTAtomicStep[]; maxIterations?: number },\n  path: string\n): SCoTValidationError[] {\n  const errors: SCoTValidationError[] = [];\n\n  // Check iterator\n  if (!structure.iterator) {\n    errors.push({\n      path: `${path}.iterator`,\n      message: 'Loop structure must have an iterator',\n      severity: 'error',\n    });\n  }\n\n  // Check body\n  if (!structure.body || structure.body.length === 0) {\n    errors.push({\n      path: `${path}.body`,\n      message: 'Loop structure must have at least one step in body',\n      severity: 'error',\n    });\n  } else {\n    structure.body.forEach((step, index) => {\n      errors.push(...validateStep(step, `${path}.body[${index}]`));\n    });\n  }\n\n  // Check maxIterations\n  if (structure.maxIterations !== undefined && structure.maxIterations <= 0) {\n    errors.push({\n      path: `${path}.maxIterations`,\n      message: 'Loop maxIterations must be positive',\n      severity: 'error',\n    });\n  }\n\n  return errors;\n}\n\n// \n// STEP VALIDATION\n// \n\nfunction validateStep(step: SCoTAtomicStep, path: string): SCoTValidationError[] {\n  const errors: SCoTValidationError[] = [];\n\n  if (!step.action || step.action.trim().length === 0) {\n    errors.push({\n      path: `${path}.action`,\n      message: 'Step must have an action',\n      severity: 'error',\n    });\n  }\n\n  // Validate action-specific requirements\n  const action = step.action.toLowerCase();\n\n  if (['click', 'fill', 'select', 'check', 'uncheck', 'hover', 'focus'].includes(action)) {\n    if (!step.target) {\n      errors.push({\n        path: `${path}.target`,\n        message: `${action} action requires a target`,\n        severity: 'warning',\n      });\n    }\n  }\n\n  if (['fill', 'type', 'input'].includes(action)) {\n    if (!step.value && !step.target?.includes('=')) {\n      errors.push({\n        path: `${path}.value`,\n        message: `${action} action should have a value`,\n        severity: 'warning',\n      });\n    }\n  }\n\n  if (['assert', 'expect', 'verify'].includes(action)) {\n    if (!step.assertion && !step.target) {\n      errors.push({\n        path: `${path}.assertion`,\n        message: `${action} action should have an assertion or target`,\n        severity: 'warning',\n      });\n    }\n  }\n\n  return errors;\n}\n\n// \n// ADVANCED CHECKS\n// \n\nfunction checkForInfiniteLoops(structures: SCoTStructure[]): string[] {\n  const warnings: string[] = [];\n\n  structures.forEach((structure, index) => {\n    if (isLoop(structure)) {\n      // Check if loop has no max iterations and no clear exit condition\n      if (!structure.maxIterations) {\n        warnings.push(\n          `Loop at index ${index} has no maxIterations limit - could potentially loop indefinitely`\n        );\n      }\n\n      // Check if loop body has any assertions or conditions that could break\n      const hasBreakCondition = structure.body.some(\n        step => ['assert', 'expect', 'verify', 'break'].includes(step.action.toLowerCase())\n      );\n      if (!hasBreakCondition && !structure.maxIterations) {\n        warnings.push(\n          `Loop at index ${index} has no break condition or iteration limit`\n        );\n      }\n    }\n  });\n\n  return warnings;\n}\n\nfunction checkForUnreachableCode(structures: SCoTStructure[]): string[] {\n  const warnings: string[] = [];\n\n  structures.forEach((structure, index) => {\n    if (isBranch(structure)) {\n      // Check for always-true or always-false conditions\n      const condition = structure.condition;\n      if (condition.expression) {\n        const expr = condition.expression.toLowerCase();\n        if (expr === 'true' || expr === '1' || expr === 'always') {\n          warnings.push(\n            `Branch at index ${index} has always-true condition - elseBranch may be unreachable`\n          );\n        }\n        if (expr === 'false' || expr === '0' || expr === 'never') {\n          warnings.push(\n            `Branch at index ${index} has always-false condition - thenBranch may be unreachable`\n          );\n        }\n      }\n    }\n  });\n\n  return warnings;\n}\n\n// \n// QUICK VALIDATION (for confidence check only)\n// \n\nexport function quickValidateConfidence(plan: SCoTPlan, minConfidence: number): boolean {\n  return plan.confidence >= minConfidence;\n}\n\nexport function getValidationSummary(result: SCoTValidationResult): string {\n  const errorCount = result.errors.filter(e => e.severity === 'error').length;\n  const warningCount = result.errors.filter(e => e.severity === 'warning').length + result.warnings.length;\n\n  if (result.valid) {\n    if (warningCount > 0) {\n      return `Valid with ${warningCount} warning(s)`;\n    }\n    return 'Valid';\n  }\n\n  return `Invalid: ${errorCount} error(s), ${warningCount} warning(s)`;\n}\n","/**\n * @module scot/prompts\n * @description LLM prompt templates for SCoT planning\n */\n\nimport { JourneyInput } from './planner.js';\n\n// \n// SYSTEM PROMPT\n// \n\nexport const SCOT_SYSTEM_PROMPT = `You are an expert test automation architect specializing in Playwright E2E tests.\n\nYour task is to analyze a Journey specification and create a Structured Chain-of-Thought (SCoT) plan using these programming structures:\n\n## SEQUENTIAL Structure\nFor linear, step-by-step actions that must happen in order:\n\\`\\`\\`\nSEQUENTIAL: <description>\n1. <action>\n2. <action>\n3. <action>\n\\`\\`\\`\n\n## BRANCH Structure\nFor conditional logic where different paths may be taken:\n\\`\\`\\`\nBRANCH: <condition description>\nIF <condition> THEN\n  - <action if true>\n  - <another action if true>\nELSE\n  - <action if false>\nENDIF\n\\`\\`\\`\n\n## LOOP Structure\nFor repeated actions over a collection or until a condition:\n\\`\\`\\`\nLOOP: <iteration description>\nFOR EACH <variable> IN <collection>\n  - <action with variable>\nENDFOR\n\\`\\`\\`\n\n## Guidelines\n1. Use SEQUENTIAL for straightforward test flows\n2. Use BRANCH when the test may take different paths (e.g., MFA prompt, error handling)\n3. Use LOOP when iterating over table rows, list items, or form fields\n4. Each step should be atomic and testable\n5. Include assertions as steps (e.g., \"Verify redirect to dashboard\")\n6. Consider edge cases and potential failure points\n\n## Output Format\nYour response MUST be valid JSON:\n\\`\\`\\`json\n{\n  \"reasoning\": \"Brief explanation of your understanding of the test flow\",\n  \"confidence\": 0.85,\n  \"plan\": [\n    {\n      \"type\": \"sequential\",\n      \"description\": \"Login flow\",\n      \"steps\": [\n        {\"action\": \"navigate\", \"target\": \"/login\"},\n        {\"action\": \"fill\", \"target\": \"username field\", \"value\": \"test user\"},\n        {\"action\": \"fill\", \"target\": \"password field\", \"value\": \"password\"},\n        {\"action\": \"click\", \"target\": \"submit button\"},\n        {\"action\": \"assert\", \"assertion\": \"redirect to dashboard\"}\n      ]\n    },\n    {\n      \"type\": \"branch\",\n      \"description\": \"Handle optional MFA\",\n      \"condition\": {\"element\": \"MFA prompt\", \"state\": \"visible\"},\n      \"thenBranch\": [\n        {\"action\": \"fill\", \"target\": \"TOTP code field\", \"value\": \"generated code\"},\n        {\"action\": \"click\", \"target\": \"verify button\"}\n      ]\n    }\n  ],\n  \"warnings\": [\"MFA handling may need specific TOTP generator setup\"]\n}\n\\`\\`\\`\n\n## Confidence Scoring\n- 0.9-1.0: Clear, unambiguous journey with well-defined steps\n- 0.7-0.9: Minor ambiguities but overall clear intent\n- 0.5-0.7: Several ambiguities or missing details\n- Below 0.5: Too vague to create reliable test\n\nBe precise, thorough, and focus on creating a plan that maps directly to Playwright actions.`;\n\n// \n// USER PROMPT BUILDER\n// \n\nexport function createUserPrompt(journey: JourneyInput): string {\n  const parts: string[] = [];\n\n  // Header\n  parts.push(`# Journey: ${journey.id}`);\n  parts.push(`## ${journey.title}`);\n  parts.push('');\n\n  // Description\n  if (journey.description) {\n    parts.push(`### Description`);\n    parts.push(journey.description);\n    parts.push('');\n  }\n\n  // Tier\n  if (journey.tier) {\n    parts.push(`**Tier:** ${journey.tier}`);\n    parts.push('');\n  }\n\n  // Steps\n  parts.push(`### Steps`);\n  for (const step of journey.steps) {\n    parts.push(`${step.number}. ${step.text}`);\n    if (step.substeps && step.substeps.length > 0) {\n      for (const substep of step.substeps) {\n        parts.push(`   - ${substep}`);\n      }\n    }\n  }\n  parts.push('');\n\n  // Acceptance Criteria\n  if (journey.acceptanceCriteria && journey.acceptanceCriteria.length > 0) {\n    parts.push(`### Acceptance Criteria`);\n    for (const criterion of journey.acceptanceCriteria) {\n      parts.push(`- ${criterion}`);\n    }\n    parts.push('');\n  }\n\n  // Raw markdown if available (for additional context)\n  if (journey.rawMarkdown) {\n    parts.push(`### Additional Context (Raw Markdown)`);\n    parts.push('```markdown');\n    parts.push(journey.rawMarkdown);\n    parts.push('```');\n    parts.push('');\n  }\n\n  // Instructions\n  parts.push(`---`);\n  parts.push(`Create a SCoT plan for this journey. Output your response as valid JSON.`);\n\n  return parts.join('\\n');\n}\n\n// \n// ERROR CORRECTION PROMPT\n// \n\nexport function createErrorCorrectionPrompt(\n  originalResponse: string,\n  error: string\n): string {\n  return `Your previous response had a parsing error:\n\n**Error:** ${error}\n\n**Your response:**\n\\`\\`\\`\n${originalResponse.substring(0, 1000)}${originalResponse.length > 1000 ? '...' : ''}\n\\`\\`\\`\n\nPlease fix the JSON and respond with ONLY valid JSON (no markdown code blocks, no explanation).\nThe JSON must match this structure:\n{\n  \"reasoning\": \"string\",\n  \"confidence\": number (0-1),\n  \"plan\": [...],\n  \"warnings\": [...]\n}`;\n}\n\n// \n// FEW-SHOT EXAMPLES\n// \n\nexport const FEW_SHOT_EXAMPLES = {\n  simpleLogin: {\n    input: `# Journey: J-AUTH-001\n## User Login\n### Steps\n1. Navigate to login page\n2. Enter username\n3. Enter password\n4. Click login button\n5. Verify dashboard is displayed`,\n    output: {\n      reasoning: \"Simple login flow with standard username/password authentication\",\n      confidence: 0.95,\n      plan: [\n        {\n          type: \"sequential\",\n          description: \"Standard login flow\",\n          steps: [\n            { action: \"navigate\", target: \"/login\" },\n            { action: \"fill\", target: \"username field\", value: \"test_user\" },\n            { action: \"fill\", target: \"password field\", value: \"password\" },\n            { action: \"click\", target: \"login button\" },\n            { action: \"assert\", assertion: \"dashboard is visible\" }\n          ]\n        }\n      ],\n      warnings: []\n    }\n  },\n  loginWithMFA: {\n    input: `# Journey: J-AUTH-002\n## Login with Optional MFA\n### Steps\n1. Navigate to login page\n2. Enter credentials\n3. Submit login form\n4. If MFA prompt appears, enter TOTP code\n5. Verify successful login`,\n    output: {\n      reasoning: \"Login with conditional MFA handling - need to check if MFA prompt appears\",\n      confidence: 0.85,\n      plan: [\n        {\n          type: \"sequential\",\n          description: \"Initial login\",\n          steps: [\n            { action: \"navigate\", target: \"/login\" },\n            { action: \"fill\", target: \"username\", value: \"test_user\" },\n            { action: \"fill\", target: \"password\", value: \"password\" },\n            { action: \"click\", target: \"submit button\" }\n          ]\n        },\n        {\n          type: \"branch\",\n          description: \"Handle MFA if prompted\",\n          condition: { element: \"MFA prompt\", state: \"visible\" },\n          thenBranch: [\n            { action: \"fill\", target: \"TOTP code field\", value: \"generated_totp\" },\n            { action: \"click\", target: \"verify button\" }\n          ]\n        },\n        {\n          type: \"sequential\",\n          description: \"Verify login success\",\n          steps: [\n            { action: \"assert\", assertion: \"user is logged in\" }\n          ]\n        }\n      ],\n      warnings: [\"TOTP code generation requires proper test setup\"]\n    }\n  },\n  tableIteration: {\n    input: `# Journey: J-DATA-001\n## Verify All Table Rows\n### Steps\n1. Navigate to data table page\n2. For each row in the table, verify the status column shows \"Active\"\n3. Verify total row count matches expected`,\n    output: {\n      reasoning: \"Table iteration test - need to loop through rows and verify status\",\n      confidence: 0.80,\n      plan: [\n        {\n          type: \"sequential\",\n          description: \"Navigate to table\",\n          steps: [\n            { action: \"navigate\", target: \"/data-table\" },\n            { action: \"wait\", target: \"table is loaded\" }\n          ]\n        },\n        {\n          type: \"loop\",\n          description: \"Verify each row status\",\n          iterator: { variable: \"row\", collection: \"table rows\", maxIterations: 100 },\n          body: [\n            { action: \"assert\", assertion: \"row status is Active\" }\n          ]\n        },\n        {\n          type: \"sequential\",\n          description: \"Verify total\",\n          steps: [\n            { action: \"assert\", assertion: \"row count matches expected\" }\n          ]\n        }\n      ],\n      warnings: [\"Large tables may require pagination handling\"]\n    }\n  }\n};\n","/**\n * @module scot/planner\n * @description Main SCoT planning module - generates structured plans from journeys\n */\n\nimport { TokenUsage } from '../shared/types.js';\nimport { CostTracker } from '../shared/cost-tracker.js';\nimport { SCoTConfig } from '../shared/config-validator.js';\nimport {\n  SCoTPlan,\n  SCoTPlanResult,\n  \n} from './types.js';\nimport { parseSCoTPlan } from './parser.js';\nimport { validateSCoTPlan } from './validator.js';\nimport { SCOT_SYSTEM_PROMPT, createUserPrompt } from './prompts.js';\n\n// \n// LLM CLIENT INTERFACE\n// \n\nexport interface LLMClient {\n  generate(_prompt: string, _systemPrompt: string, _options: LLMGenerateOptions): Promise<LLMGenerateResult>;\n}\n\nexport interface LLMGenerateOptions {\n  temperature: number;\n  maxTokens: number;\n  timeoutMs: number;\n}\n\nexport interface LLMGenerateResult {\n  content: string;\n  tokenUsage: TokenUsage;\n  model: string;\n}\n\n// \n// JOURNEY INPUT\n// \n\nexport interface JourneyInput {\n  id: string;\n  title: string;\n  description?: string;\n  steps: JourneyStep[];\n  acceptanceCriteria?: string[];\n  tier?: 'smoke' | 'release' | 'regression';\n  rawMarkdown?: string;\n}\n\nexport interface JourneyStep {\n  number: number;\n  text: string;\n  substeps?: string[];\n}\n\n// \n// PLANNER OPTIONS\n// \n\nexport type PlannerMode = 'direct' | 'orchestrator';\n\nexport interface PlannerOptions {\n  config: SCoTConfig;\n  /** LLM client - required for 'direct' mode, optional for 'orchestrator' mode */\n  llmClient?: LLMClient;\n  costTracker?: CostTracker;\n  /** Planning mode: 'direct' calls LLM API, 'orchestrator' outputs prompts for external LLM */\n  mode?: PlannerMode;\n}\n\n/**\n * Output for orchestrator mode - the LLM prompt to send to the orchestrating LLM\n */\nexport interface OrchestratorPromptOutput {\n  /** System prompt for the LLM */\n  systemPrompt: string;\n  /** User prompt with journey context */\n  userPrompt: string;\n  /** Expected response format description */\n  expectedFormat: string;\n  /** Journey ID for tracking */\n  journeyId: string;\n  /** Function to parse the LLM response */\n  parseResponse: (_response: string) => Promise<SCoTPlanResult>;\n}\n\n// \n// MAIN PLANNER\n// \n\n/**\n * Generate a SCoT plan from a journey\n *\n * Supports two modes:\n * - 'direct': Calls LLM API directly (requires llmClient)\n * - 'orchestrator': Returns prompts for the orchestrating LLM (hybrid agentic pattern)\n */\nexport async function generateSCoTPlan(\n  journey: JourneyInput,\n  options: PlannerOptions\n): Promise<SCoTPlanResult> {\n  const { config, llmClient, costTracker, mode = 'direct' } = options;\n\n  // Check if SCoT is enabled\n  if (!config.enabled) {\n    return {\n      success: false,\n      error: {\n        type: 'LLM_ERROR',\n        message: 'SCoT is disabled in configuration',\n      },\n      fallbackUsed: true,\n    };\n  }\n\n  // For orchestrator mode, we generate prompts instead of calling LLM\n  if (mode === 'orchestrator') {\n    // Return a partial result that indicates prompts are needed\n    return {\n      success: false,\n      error: {\n        type: 'LLM_ERROR',\n        message: 'Orchestrator mode requires using generateSCoTPrompts() instead',\n      },\n      fallbackUsed: false,\n    };\n  }\n\n  // Direct mode requires LLM client\n  if (!llmClient) {\n    return {\n      success: false,\n      error: {\n        type: 'LLM_ERROR',\n        message: 'LLM client is required for direct mode',\n      },\n      fallbackUsed: config.fallback === 'pattern-only',\n    };\n  }\n\n  // Check cost limits\n  if (costTracker?.wouldExceedLimit(2000)) {\n    return {\n      success: false,\n      error: {\n        type: 'COST_LIMIT',\n        message: 'Cost limit would be exceeded',\n      },\n      fallbackUsed: config.fallback === 'pattern-only',\n    };\n  }\n\n  try {\n    // Generate the user prompt\n    const userPrompt = createUserPrompt(journey);\n\n    // Call LLM\n    const llmResult = await llmClient.generate(userPrompt, SCOT_SYSTEM_PROMPT, {\n      temperature: config.llm.temperature,\n      maxTokens: config.llm.maxTokens,\n      timeoutMs: config.llm.timeoutMs,\n    });\n\n    // Track cost\n    if (costTracker) {\n      costTracker.trackUsage(llmResult.tokenUsage);\n    }\n\n    // Parse the response\n    const parseResult = await parseSCoTPlan(llmResult.content, {\n      journeyId: journey.id,\n      llmModel: llmResult.model,\n      maxRetries: config.llm.maxRetries,\n    });\n\n    if (!parseResult.ok) {\n      return {\n        success: false,\n        error: {\n          type: 'PARSE_ERROR',\n          message: parseResult.error.message,\n          details: parseResult.error,\n          tokenUsage: llmResult.tokenUsage,\n        },\n        fallbackUsed: config.fallback === 'pattern-only',\n      };\n    }\n\n    const plan = parseResult.value;\n\n    // Update token usage in metadata\n    plan.metadata.tokenUsage = llmResult.tokenUsage;\n    plan.metadata.llmModel = llmResult.model;\n\n    // Validate the plan\n    const validationResult = validateSCoTPlan(plan, config);\n\n    if (!validationResult.valid) {\n      const criticalErrors = validationResult.errors.filter(e => e.severity === 'error');\n      return {\n        success: false,\n        error: {\n          type: 'VALIDATION_ERROR',\n          message: criticalErrors.map(e => e.message).join('; '),\n          details: validationResult,\n          tokenUsage: llmResult.tokenUsage,\n        },\n        fallbackUsed: config.fallback === 'pattern-only',\n      };\n    }\n\n    // Check confidence threshold\n    if (plan.confidence < config.minConfidence) {\n      return {\n        success: false,\n        error: {\n          type: 'LOW_CONFIDENCE',\n          message: `Plan confidence ${plan.confidence.toFixed(2)} is below threshold ${config.minConfidence}`,\n          tokenUsage: llmResult.tokenUsage,\n        },\n        fallbackUsed: config.fallback === 'pattern-only',\n      };\n    }\n\n    return {\n      success: true,\n      plan,\n    };\n\n  } catch (error) {\n    const message = error instanceof Error ? error.message : 'Unknown error';\n    const isTimeout = message.toLowerCase().includes('timeout');\n\n    return {\n      success: false,\n      error: {\n        type: isTimeout ? 'TIMEOUT' : 'LLM_ERROR',\n        message,\n        details: error,\n      },\n      fallbackUsed: config.fallback === 'pattern-only',\n    };\n  }\n}\n\n// \n// PLAN TO CODE CONTEXT\n// \n\nexport interface CodeContext {\n  reasoning: string;\n  structureComments: string[];\n  hasConditionals: boolean;\n  hasLoops: boolean;\n  estimatedSteps: number;\n}\n\nexport function extractCodeContext(plan: SCoTPlan, includeReasoning: boolean): CodeContext {\n  const structureComments: string[] = [];\n  let hasConditionals = false;\n  let hasLoops = false;\n  let estimatedSteps = 0;\n\n  for (const structure of plan.structures) {\n    if (structure.type === 'sequential') {\n      structureComments.push(`// SEQUENTIAL: ${structure.description}`);\n      estimatedSteps += structure.steps.length;\n    } else if (structure.type === 'branch') {\n      structureComments.push(`// BRANCH: ${structure.description}`);\n      hasConditionals = true;\n      estimatedSteps += structure.thenBranch.length;\n      if (structure.elseBranch) {\n        estimatedSteps += structure.elseBranch.length;\n      }\n    } else if (structure.type === 'loop') {\n      structureComments.push(`// LOOP: ${structure.description}`);\n      hasLoops = true;\n      estimatedSteps += structure.body.length * (structure.maxIterations ?? 3);\n    }\n  }\n\n  return {\n    reasoning: includeReasoning ? plan.reasoning : '',\n    structureComments,\n    hasConditionals,\n    hasLoops,\n    estimatedSteps,\n  };\n}\n\n// \n// ORCHESTRATOR MODE (Hybrid Agentic Architecture)\n// \n\nconst SCOT_EXPECTED_FORMAT = `\nThe response should be a JSON object with:\n- reasoning: string explaining the test structure approach\n- structures: array of test structures (sequential, branch, loop)\n- stepMappings: array mapping journey steps to test actions\n- confidence: number 0.0-1.0 for overall plan confidence\n- metadata: object with journeyId, generatedAt\n\nEach structure has:\n- type: \"sequential\" | \"branch\" | \"loop\"\n- description: string explaining the structure\n- steps/thenBranch/elseBranch/body: arrays of step references\n- condition (for branch/loop): string describing the condition\n`;\n\n/**\n * Generate prompts for the orchestrating LLM (Hybrid Agentic Pattern)\n *\n * Instead of calling an LLM directly, this returns the prompts that the\n * orchestrating LLM (Copilot/Claude Code) should use to generate the plan.\n *\n * @example\n * ```typescript\n * const prompts = generateSCoTPrompts(journey, { config });\n *\n * // The orchestrating LLM generates a response\n * const llmResponse = await orchestratorLLM.generate(prompts.userPrompt);\n *\n * // Parse the response\n * const result = await prompts.parseResponse(llmResponse);\n * ```\n */\nexport function generateSCoTPrompts(\n  journey: JourneyInput,\n  config: SCoTConfig\n): OrchestratorPromptOutput {\n  const userPrompt = createUserPrompt(journey);\n\n  return {\n    systemPrompt: SCOT_SYSTEM_PROMPT,\n    userPrompt,\n    expectedFormat: SCOT_EXPECTED_FORMAT,\n    journeyId: journey.id,\n    parseResponse: async (response: string): Promise<SCoTPlanResult> => {\n      try {\n        // Parse the response\n        const parseResult = await parseSCoTPlan(response, {\n          journeyId: journey.id,\n          llmModel: 'orchestrator',\n          maxRetries: config.llm.maxRetries,\n        });\n\n        if (!parseResult.ok) {\n          return {\n            success: false,\n            error: {\n              type: 'PARSE_ERROR',\n              message: parseResult.error.message,\n              details: parseResult.error,\n            },\n            fallbackUsed: config.fallback === 'pattern-only',\n          };\n        }\n\n        const plan = parseResult.value;\n\n        // Validate the plan\n        const validationResult = validateSCoTPlan(plan, config);\n\n        if (!validationResult.valid) {\n          const criticalErrors = validationResult.errors.filter(e => e.severity === 'error');\n          return {\n            success: false,\n            error: {\n              type: 'VALIDATION_ERROR',\n              message: criticalErrors.map(e => e.message).join('; '),\n              details: validationResult,\n            },\n            fallbackUsed: config.fallback === 'pattern-only',\n          };\n        }\n\n        // Check confidence threshold\n        if (plan.confidence < config.minConfidence) {\n          return {\n            success: false,\n            error: {\n              type: 'LOW_CONFIDENCE',\n              message: `Plan confidence ${plan.confidence.toFixed(2)} is below threshold ${config.minConfidence}`,\n            },\n            fallbackUsed: config.fallback === 'pattern-only',\n          };\n        }\n\n        return {\n          success: true,\n          plan,\n        };\n\n      } catch (error) {\n        const message = error instanceof Error ? error.message : 'Unknown error';\n        return {\n          success: false,\n          error: {\n            type: 'PARSE_ERROR',\n            message,\n            details: error,\n          },\n          fallbackUsed: config.fallback === 'pattern-only',\n        };\n      }\n    },\n  };\n}\n\n/**\n * Process a plan from orchestrator-provided JSON\n *\n * For cases where the orchestrating LLM has already generated a plan\n * and we just need to parse and validate it.\n */\nexport async function processSCoTPlanFromJSON(\n  planJson: string,\n  journeyId: string,\n  config: SCoTConfig\n): Promise<SCoTPlanResult> {\n  const prompts = generateSCoTPrompts({ id: journeyId, title: journeyId, steps: [] }, config);\n  return prompts.parseResponse(planJson);\n}\n","/**\n * @module scot\n * @description Structured Chain-of-Thought (SCoT) planning for Playwright test generation\n */\n\n// Types\nexport * from './types.js';\n\n// Parser\nexport { parseSCoTPlan, type SCoTParseError } from './parser.js';\n\n// Validator\nexport {\n  validateSCoTPlan,\n  quickValidateConfidence,\n  getValidationSummary,\n} from './validator.js';\n\n// Planner\nexport {\n  generateSCoTPlan,\n  extractCodeContext,\n  // Orchestrator mode (Hybrid Agentic Architecture)\n  generateSCoTPrompts,\n  processSCoTPlanFromJSON,\n  type LLMClient,\n  type LLMGenerateOptions,\n  type LLMGenerateResult,\n  type JourneyInput,\n  type JourneyStep,\n  type PlannerOptions,\n  type PlannerMode,\n  type OrchestratorPromptOutput,\n  type CodeContext,\n} from './planner.js';\n\n// Prompts\nexport {\n  SCOT_SYSTEM_PROMPT,\n  createUserPrompt,\n  createErrorCorrectionPrompt,\n  FEW_SHOT_EXAMPLES,\n} from './prompts.js';\n","/**\n * @module refinement/types\n * @description Type definitions for Self-Refinement strategy\n */\n\nimport { TokenUsage } from '../shared/types.js';\n\n// \n// ERROR CATEGORIES\n// \n\nexport type ErrorCategory =\n  | 'SELECTOR_NOT_FOUND'\n  | 'TIMEOUT'\n  | 'ASSERTION_FAILED'\n  | 'NAVIGATION_ERROR'\n  | 'TYPE_ERROR'\n  | 'RUNTIME_ERROR'\n  | 'NETWORK_ERROR'\n  | 'AUTHENTICATION_ERROR'\n  | 'PERMISSION_ERROR'\n  | 'SYNTAX_ERROR'\n  | 'UNKNOWN';\n\nexport type ErrorSeverity = 'critical' | 'major' | 'minor' | 'warning';\n\n// \n// ERROR ANALYSIS\n// \n\nexport interface ErrorLocation {\n  file: string;\n  line: number;\n  column?: number;\n  testName?: string;\n  stepDescription?: string;\n}\n\nexport interface ErrorAnalysis {\n  category: ErrorCategory;\n  severity: ErrorSeverity;\n  message: string;\n  originalError: string;\n  location?: ErrorLocation;\n  selector?: string;\n  expectedValue?: string;\n  actualValue?: string;\n  stackTrace?: string;\n  timestamp: Date;\n\n  // Fingerprint for detecting same errors\n  fingerprint: string;\n}\n\n// \n// CODE FIX\n// \n\nexport type FixType =\n  | 'SELECTOR_CHANGE'\n  | 'WAIT_ADDED'\n  | 'ASSERTION_MODIFIED'\n  | 'FLOW_REORDERED'\n  | 'ERROR_HANDLING_ADDED'\n  | 'TIMEOUT_INCREASED'\n  | 'RETRY_ADDED'\n  | 'LOCATOR_STRATEGY_CHANGED'\n  | 'FRAME_CONTEXT_ADDED'\n  | 'OTHER';\n\nexport interface CodeFix {\n  type: FixType;\n  description: string;\n  originalCode: string;\n  fixedCode: string;\n  location: ErrorLocation;\n  confidence: number;\n  reasoning?: string;\n}\n\nexport interface FixAttempt {\n  attemptNumber: number;\n  timestamp: Date;\n  error: ErrorAnalysis;\n  proposedFixes: CodeFix[];\n  appliedFix?: CodeFix;\n  outcome: 'success' | 'failure' | 'partial' | 'skipped';\n  newErrors?: ErrorAnalysis[];\n  tokenUsage?: TokenUsage;\n}\n\n// \n// PLAYWRIGHT TEST RESULT\n// \n\nexport type TestStatus = 'passed' | 'failed' | 'timedOut' | 'skipped' | 'interrupted';\n\nexport interface PlaywrightTestResult {\n  testId: string;\n  testName: string;\n  testFile: string;\n  status: TestStatus;\n  duration: number;\n  errors: ErrorAnalysis[];\n  retries: number;\n  stdout?: string;\n  stderr?: string;\n  attachments?: TestAttachment[];\n}\n\nexport interface TestAttachment {\n  name: string;\n  contentType: string;\n  path?: string;\n  body?: Buffer;\n}\n\n// \n// CIRCUIT BREAKER\n// \n\nexport interface CircuitBreakerConfig {\n  /** Maximum refinement attempts before giving up */\n  maxAttempts: number;\n\n  /** Stop if same error fingerprint repeats this many times */\n  sameErrorThreshold: number;\n\n  /** Detect oscillation: ABA error pattern */\n  oscillationDetection: boolean;\n\n  /** Window size for oscillation detection */\n  oscillationWindowSize: number;\n\n  /** Maximum time for all refinement attempts (ms) */\n  totalTimeoutMs: number;\n\n  /** Time between refinement attempts (ms) - for rate limiting */\n  cooldownMs: number;\n\n  /** Maximum token budget for refinement */\n  maxTokenBudget: number;\n}\n\nexport interface CircuitBreakerState {\n  isOpen: boolean;\n  openReason?: 'MAX_ATTEMPTS' | 'SAME_ERROR' | 'OSCILLATION' | 'TIMEOUT' | 'BUDGET_EXCEEDED';\n  attemptCount: number;\n  errorHistory: string[];\n  startTime?: Date;\n  tokensUsed: number;\n  /** Max attempts config (for state restoration) */\n  maxAttempts?: number;\n}\n\n// \n// CONVERGENCE\n// \n\nexport interface ConvergenceInfo {\n  converged: boolean;\n  attempts: number;\n  errorCountHistory: number[];\n  uniqueErrorsHistory: Set<string>[];\n  lastImprovement?: number;\n  stagnationCount: number;\n  trend: 'improving' | 'stagnating' | 'degrading' | 'oscillating';\n}\n\n// \n// REFINEMENT SESSION\n// \n\nexport interface RefinementSession {\n  sessionId: string;\n  journeyId: string;\n  testFile: string;\n  startTime: Date;\n  endTime?: Date;\n\n  originalCode: string;\n  currentCode: string;\n\n  attempts: FixAttempt[];\n  circuitBreakerState: CircuitBreakerState;\n  convergenceInfo: ConvergenceInfo;\n\n  finalStatus: RefinementStatus;\n  totalTokenUsage: TokenUsage;\n}\n\nexport type RefinementStatus =\n  | 'SUCCESS'\n  | 'PARTIAL_SUCCESS'\n  | 'MAX_ATTEMPTS_REACHED'\n  | 'SAME_ERROR_LOOP'\n  | 'OSCILLATION_DETECTED'\n  | 'TIMEOUT'\n  | 'BUDGET_EXCEEDED'\n  | 'CANNOT_FIX'\n  | 'ABORTED';\n\n// \n// REFINEMENT RESULT\n// \n\nexport interface RefinementResult {\n  success: boolean;\n  session: RefinementSession;\n  fixedCode?: string;\n  remainingErrors: ErrorAnalysis[];\n  appliedFixes: CodeFix[];\n\n  /** Lessons learned for LLKB */\n  lessonsLearned: LessonLearned[];\n\n  /** Diagnostics for dead-end reporting */\n  diagnostics: RefinementDiagnostics;\n}\n\nexport interface RefinementDiagnostics {\n  attempts: number;\n  lastError: string;\n  convergenceFailure: boolean;\n  sameErrorRepeated: boolean;\n  oscillationDetected: boolean;\n  budgetExhausted: boolean;\n  timedOut: boolean;\n}\n\n// \n// LLKB LEARNING\n// \n\nexport interface LessonLearned {\n  id: string;\n  type: 'selector_pattern' | 'error_fix' | 'wait_strategy' | 'flow_pattern';\n  context: {\n    journeyId: string;\n    errorCategory: ErrorCategory;\n    originalSelector?: string;\n    element?: string;\n  };\n  solution: {\n    pattern: string;\n    code: string;\n    explanation: string;\n  };\n  confidence: number;\n  createdAt: Date;\n  verified: boolean;\n}\n\n// \n// REFINEMENT CONFIG (imported from shared, re-exported for convenience)\n// \n\nexport type { RefinementConfig } from '../shared/config-validator.js';\n","/**\n * @module refinement/error-parser\n * @description Parse and categorize Playwright test errors\n */\n\nimport crypto from 'crypto';\nimport {\n  ErrorAnalysis,\n  ErrorCategory,\n  ErrorSeverity,\n  ErrorLocation,\n  PlaywrightTestResult,\n  TestStatus,\n} from './types.js';\n\n// \n// ERROR PATTERNS\n// \n\ninterface ErrorPattern {\n  category: ErrorCategory;\n  patterns: RegExp[];\n  severity: ErrorSeverity;\n  selectorExtractor?: RegExp;\n  valueExtractor?: RegExp;\n}\n\nconst ERROR_PATTERNS: ErrorPattern[] = [\n  // Selector not found\n  {\n    category: 'SELECTOR_NOT_FOUND',\n    patterns: [\n      /locator\\..*: Timeout \\d+ms exceeded/i,\n      /waiting for (locator|selector)/i,\n      /No element matches selector/i,\n      /Element is not attached to the DOM/i,\n      /Element is outside of the viewport/i,\n      /page\\.\\$\\(.*\\) resolved to (null|undefined)/i,\n      /getByRole.*resolved to \\d+ element/i,\n      /getByTestId.*resolved to \\d+ element/i,\n      /getByText.*resolved to \\d+ element/i,\n      /locator resolved to \\d+ elements/i,\n    ],\n    severity: 'major',\n    selectorExtractor: /locator\\(['\"]([^'\"]+)['\"]\\)|getBy\\w+\\(['\"]([^'\"]+)['\"]\\)/,\n  },\n\n  // Timeout\n  {\n    category: 'TIMEOUT',\n    patterns: [\n      /Timeout \\d+ms exceeded/i,\n      /page\\.waitFor.*exceeded/i,\n      /Test timeout of \\d+ms exceeded/i,\n      /Navigation timeout of \\d+ms exceeded/i,\n      /exceeded .*timeout/i,\n    ],\n    severity: 'major',\n  },\n\n  // Assertion failed\n  {\n    category: 'ASSERTION_FAILED',\n    patterns: [\n      /expect\\(.*\\)\\.to/i,\n      /Expected.*to (be|have|contain|match|equal)/i,\n      /AssertionError/i,\n      /Received.*Expected/i,\n      /toBeVisible.*but.*hidden/i,\n      /toHaveText.*but.*received/i,\n      /toHaveValue.*but.*received/i,\n      /toBeChecked.*but.*unchecked/i,\n    ],\n    severity: 'major',\n    valueExtractor: /Expected:?\\s*(.+?)\\s*(?:Received|Actual|but|$)/i,\n  },\n\n  // Navigation error\n  {\n    category: 'NAVIGATION_ERROR',\n    patterns: [\n      /net::ERR_/i,\n      /Navigation failed/i,\n      /page\\.goto.*failed/i,\n      /Frame was detached/i,\n      /Target page.*closed/i,\n      /browser has disconnected/i,\n      /Protocol error.*Target closed/i,\n    ],\n    severity: 'critical',\n  },\n\n  // Network error\n  {\n    category: 'NETWORK_ERROR',\n    patterns: [\n      /ECONNREFUSED/i,\n      /ENOTFOUND/i,\n      /ETIMEDOUT/i,\n      /fetch failed/i,\n      /Request failed/i,\n      /Status code: [45]\\d{2}/i,\n    ],\n    severity: 'major',\n  },\n\n  // Authentication error\n  {\n    category: 'AUTHENTICATION_ERROR',\n    patterns: [\n      /401 Unauthorized/i,\n      /403 Forbidden/i,\n      /Authentication failed/i,\n      /Login failed/i,\n      /Invalid credentials/i,\n      /Session expired/i,\n      /Token expired/i,\n    ],\n    severity: 'critical',\n  },\n\n  // Permission error\n  {\n    category: 'PERMISSION_ERROR',\n    patterns: [\n      /Permission denied/i,\n      /Access denied/i,\n      /not authorized/i,\n      /insufficient permissions/i,\n    ],\n    severity: 'critical',\n  },\n\n  // Type error\n  {\n    category: 'TYPE_ERROR',\n    patterns: [\n      /TypeError:/i,\n      /Cannot read propert/i,\n      /is not a function/i,\n      /is not defined/i,\n      /undefined is not/i,\n      /null is not/i,\n    ],\n    severity: 'major',\n  },\n\n  // Syntax error\n  {\n    category: 'SYNTAX_ERROR',\n    patterns: [\n      /SyntaxError:/i,\n      /Unexpected token/i,\n      /Unexpected identifier/i,\n      /Invalid or unexpected token/i,\n    ],\n    severity: 'critical',\n  },\n\n  // Runtime error\n  {\n    category: 'RUNTIME_ERROR',\n    patterns: [\n      /ReferenceError:/i,\n      /RangeError:/i,\n      /Error:/i,\n    ],\n    severity: 'major',\n  },\n];\n\n// \n// LOCATION EXTRACTION\n// \n\nconst LOCATION_PATTERNS = [\n  // Standard stack trace format\n  /at\\s+.*\\s+\\(([^:]+):(\\d+):(\\d+)\\)/,\n  // Playwright error format\n  /([^:\\s]+\\.ts):(\\d+):(\\d+)/,\n  // Simple file:line format\n  /([^:\\s]+\\.(ts|js)):(\\d+)/,\n];\n\nfunction extractLocation(errorText: string, stackTrace?: string): ErrorLocation | undefined {\n  const textToSearch = stackTrace || errorText;\n\n  for (const pattern of LOCATION_PATTERNS) {\n    const match = textToSearch.match(pattern);\n    if (match && match[1] && match[2]) {\n      return {\n        file: match[1],\n        line: parseInt(match[2], 10),\n        column: match[3] ? parseInt(match[3], 10) : undefined,\n      };\n    }\n  }\n\n  return undefined;\n}\n\n// \n// ERROR FINGERPRINTING\n// \n\nfunction generateFingerprint(\n  category: ErrorCategory,\n  message: string,\n  selector?: string,\n  location?: ErrorLocation\n): string {\n  // Normalize message by removing dynamic values\n  const normalizedMessage = message\n    .replace(/\\d+ms/g, 'Xms')\n    .replace(/\\d+ element/g, 'X element')\n    .replace(/timeout of \\d+/gi, 'timeout of X')\n    .replace(/'[^']+'/g, \"'X'\")\n    .replace(/\"[^\"]+\"/g, '\"X\"')\n    .toLowerCase()\n    .trim();\n\n  const components = [\n    category,\n    normalizedMessage.substring(0, 100),\n    selector || '',\n    location?.file || '',\n    location?.line?.toString() || '',\n  ];\n\n  const hash = crypto.createHash('md5');\n  hash.update(components.join('|'));\n  return hash.digest('hex').substring(0, 12);\n}\n\n// \n// MAIN PARSER\n// \n\nexport interface ParseErrorOptions {\n  testFile?: string;\n  testName?: string;\n  includeStackTrace?: boolean;\n}\n\n/**\n * Parse a raw error string into structured ErrorAnalysis\n */\nexport function parseError(\n  errorText: string,\n  options: ParseErrorOptions = {}\n): ErrorAnalysis {\n  const { testFile, testName, includeStackTrace = true } = options;\n\n  // Find matching category\n  let matchedPattern: ErrorPattern | undefined;\n  for (const pattern of ERROR_PATTERNS) {\n    for (const regex of pattern.patterns) {\n      if (regex.test(errorText)) {\n        matchedPattern = pattern;\n        break;\n      }\n    }\n    if (matchedPattern) break;\n  }\n\n  const category = matchedPattern?.category || 'UNKNOWN';\n  const severity = matchedPattern?.severity || 'major';\n\n  // Extract selector if applicable\n  let selector: string | undefined;\n  if (matchedPattern?.selectorExtractor) {\n    const selectorMatch = errorText.match(matchedPattern.selectorExtractor);\n    if (selectorMatch && (selectorMatch[1] || selectorMatch[2])) {\n      selector = selectorMatch[1] || selectorMatch[2];\n    }\n  }\n\n  // Extract expected/actual values for assertions\n  let expectedValue: string | undefined;\n  let actualValue: string | undefined;\n  if (category === 'ASSERTION_FAILED') {\n    const expectedMatch = errorText.match(/Expected:?\\s*(.+?)(?:\\n|$)/i);\n    const actualMatch = errorText.match(/Received:?\\s*(.+?)(?:\\n|$)/i);\n    expectedValue = expectedMatch?.[1]?.trim();\n    actualValue = actualMatch?.[1]?.trim();\n  }\n\n  // Extract stack trace\n  const stackTraceMatch = errorText.match(/(\\s+at\\s+.+(?:\\n\\s+at\\s+.+)*)/);\n  const stackTrace = includeStackTrace ? stackTraceMatch?.[1]?.trim() : undefined;\n\n  // Extract location\n  const location = extractLocation(errorText, stackTrace);\n  if (location && testFile) {\n    location.file = testFile;\n  }\n  if (location && testName) {\n    location.testName = testName;\n  }\n\n  // Extract message (first line or most relevant part)\n  const firstLine = errorText.split('\\n')[0]?.trim() || '';\n  const message = firstLine.length > 200 ? firstLine.substring(0, 200) + '...' : firstLine;\n\n  // Generate fingerprint\n  const fingerprint = generateFingerprint(category, message, selector, location);\n\n  return {\n    category,\n    severity,\n    message,\n    originalError: errorText,\n    location,\n    selector,\n    expectedValue,\n    actualValue,\n    stackTrace,\n    timestamp: new Date(),\n    fingerprint,\n  };\n}\n\n/**\n * Parse multiple errors from test output\n */\nexport function parseErrors(\n  testOutput: string,\n  options: ParseErrorOptions = {}\n): ErrorAnalysis[] {\n  const errors: ErrorAnalysis[] = [];\n\n  // Split by common error boundaries\n  const errorBlocks = testOutput.split(/(?=Error:|AssertionError:|TypeError:|TimeoutError:)/i);\n\n  for (const block of errorBlocks) {\n    const trimmed = block.trim();\n    if (trimmed.length > 10 && /error|failed|timeout|assert/i.test(trimmed)) {\n      errors.push(parseError(trimmed, options));\n    }\n  }\n\n  // Deduplicate by fingerprint\n  const seen = new Set<string>();\n  return errors.filter(e => {\n    if (seen.has(e.fingerprint)) return false;\n    seen.add(e.fingerprint);\n    return true;\n  });\n}\n\n// \n// PLAYWRIGHT RESULT PARSER\n// \n\nexport interface PlaywrightJsonReport {\n  suites?: PlaywrightSuite[];\n  stats?: {\n    total?: number;\n    passed?: number;\n    failed?: number;\n    skipped?: number;\n    duration?: number;\n  };\n}\n\ninterface PlaywrightSuite {\n  title: string;\n  file?: string;\n  specs?: PlaywrightSpec[];\n  suites?: PlaywrightSuite[];\n}\n\ninterface PlaywrightSpec {\n  title: string;\n  tests?: PlaywrightTest[];\n}\n\ninterface PlaywrightTest {\n  title: string;\n  status: string;\n  duration: number;\n  results?: PlaywrightTestRun[];\n}\n\ninterface PlaywrightTestRun {\n  status: string;\n  duration: number;\n  error?: {\n    message?: string;\n    stack?: string;\n  };\n  stdout?: string[];\n  stderr?: string[];\n  attachments?: Array<{\n    name: string;\n    contentType: string;\n    path?: string;\n  }>;\n}\n\n/**\n * Parse Playwright JSON report into structured test results\n */\nexport function parsePlaywrightReport(\n  report: PlaywrightJsonReport\n): PlaywrightTestResult[] {\n  const results: PlaywrightTestResult[] = [];\n\n  function processSuite(suite: PlaywrightSuite, filePath?: string): void {\n    const file = suite.file || filePath;\n\n    // Process specs in this suite\n    if (suite.specs) {\n      for (const spec of suite.specs) {\n        if (spec.tests) {\n          for (const test of spec.tests) {\n            const lastRun = test.results?.[test.results.length - 1];\n            const errors: ErrorAnalysis[] = [];\n\n            // Parse error if present\n            if (lastRun?.error) {\n              const errorText = [lastRun.error.message, lastRun.error.stack]\n                .filter(Boolean)\n                .join('\\n');\n\n              if (errorText) {\n                errors.push(parseError(errorText, {\n                  testFile: file,\n                  testName: `${suite.title} > ${spec.title} > ${test.title}`,\n                }));\n              }\n            }\n\n            // Parse stderr for additional errors\n            if (lastRun?.stderr?.length) {\n              const stderrErrors = parseErrors(lastRun.stderr.join('\\n'), {\n                testFile: file,\n                testName: `${suite.title} > ${spec.title} > ${test.title}`,\n              });\n              errors.push(...stderrErrors);\n            }\n\n            results.push({\n              testId: `${file}:${spec.title}:${test.title}`,\n              testName: `${suite.title} > ${spec.title} > ${test.title}`,\n              testFile: file || 'unknown',\n              status: mapStatus(test.status),\n              duration: test.duration,\n              errors: deduplicateErrors(errors),\n              retries: (test.results?.length || 1) - 1,\n              stdout: lastRun?.stdout?.join('\\n'),\n              stderr: lastRun?.stderr?.join('\\n'),\n              attachments: lastRun?.attachments?.map(a => ({\n                name: a.name,\n                contentType: a.contentType,\n                path: a.path,\n              })),\n            });\n          }\n        }\n      }\n    }\n\n    // Process nested suites\n    if (suite.suites) {\n      for (const nestedSuite of suite.suites) {\n        processSuite(nestedSuite, file);\n      }\n    }\n  }\n\n  // Process all top-level suites\n  if (report.suites) {\n    for (const suite of report.suites) {\n      processSuite(suite);\n    }\n  }\n\n  return results;\n}\n\nfunction mapStatus(status: string): TestStatus {\n  switch (status.toLowerCase()) {\n    case 'passed':\n      return 'passed';\n    case 'failed':\n      return 'failed';\n    case 'timedout':\n      return 'timedOut';\n    case 'skipped':\n    case 'pending':\n      return 'skipped';\n    case 'interrupted':\n      return 'interrupted';\n    default:\n      return 'failed';\n  }\n}\n\nfunction deduplicateErrors(errors: ErrorAnalysis[]): ErrorAnalysis[] {\n  const seen = new Set<string>();\n  return errors.filter(e => {\n    if (seen.has(e.fingerprint)) return false;\n    seen.add(e.fingerprint);\n    return true;\n  });\n}\n\n// \n// ERROR CATEGORIZATION HELPERS\n// \n\n/**\n * Check if error is likely fixable by selector change\n */\nexport function isSelectorRelated(error: ErrorAnalysis): boolean {\n  return error.category === 'SELECTOR_NOT_FOUND' && !!error.selector;\n}\n\n/**\n * Check if error is likely fixable by adding waits\n */\nexport function isTimingRelated(error: ErrorAnalysis): boolean {\n  return error.category === 'TIMEOUT' ||\n    (error.category === 'SELECTOR_NOT_FOUND' && error.message.includes('Timeout'));\n}\n\n/**\n * Check if error is likely an environmental issue (not code-fixable)\n */\nexport function isEnvironmentalError(error: ErrorAnalysis): boolean {\n  return [\n    'NETWORK_ERROR',\n    'AUTHENTICATION_ERROR',\n    'PERMISSION_ERROR',\n  ].includes(error.category);\n}\n\n/**\n * Check if error is a syntax/type error requiring code fix\n */\nexport function isCodeError(error: ErrorAnalysis): boolean {\n  return [\n    'SYNTAX_ERROR',\n    'TYPE_ERROR',\n    'RUNTIME_ERROR',\n  ].includes(error.category);\n}\n\n/**\n * Get suggested fix types for an error category\n */\nexport function getSuggestedFixTypes(category: ErrorCategory): string[] {\n  switch (category) {\n    case 'SELECTOR_NOT_FOUND':\n      return ['SELECTOR_CHANGE', 'LOCATOR_STRATEGY_CHANGED', 'FRAME_CONTEXT_ADDED'];\n    case 'TIMEOUT':\n      return ['WAIT_ADDED', 'TIMEOUT_INCREASED', 'RETRY_ADDED'];\n    case 'ASSERTION_FAILED':\n      return ['ASSERTION_MODIFIED', 'WAIT_ADDED'];\n    case 'NAVIGATION_ERROR':\n      return ['ERROR_HANDLING_ADDED', 'RETRY_ADDED'];\n    case 'TYPE_ERROR':\n    case 'RUNTIME_ERROR':\n      return ['OTHER'];\n    case 'SYNTAX_ERROR':\n      return ['OTHER'];\n    default:\n      return ['OTHER'];\n  }\n}\n","/**\n * @module refinement/convergence-detector\n * @description Circuit breaker and convergence detection for refinement loops\n */\n\nimport {\n  CircuitBreakerConfig,\n  CircuitBreakerState,\n  ConvergenceInfo,\n  ErrorAnalysis,\n  FixAttempt,\n} from './types.js';\nimport { TokenUsage } from '../shared/types.js';\n\n// \n// DEFAULT CONFIGURATION\n// \n\nexport const DEFAULT_CIRCUIT_BREAKER_CONFIG: CircuitBreakerConfig = {\n  maxAttempts: 3,\n  sameErrorThreshold: 2,\n  oscillationDetection: true,\n  oscillationWindowSize: 4,\n  totalTimeoutMs: 300000, // 5 minutes\n  cooldownMs: 1000,\n  maxTokenBudget: 50000,\n};\n\n// \n// CIRCUIT BREAKER\n// \n\nexport interface CircuitBreakerOptions extends Partial<CircuitBreakerConfig> {\n  /** Optional initial state for restoration from saved state */\n  initialState?: CircuitBreakerState;\n}\n\nexport class CircuitBreaker {\n  private config: CircuitBreakerConfig;\n  private state: CircuitBreakerState;\n\n  constructor(options: CircuitBreakerOptions = {}) {\n    const { initialState, ...config } = options;\n    this.config = { ...DEFAULT_CIRCUIT_BREAKER_CONFIG, ...config };\n\n    // Restore from saved state if provided, otherwise create fresh state\n    if (initialState) {\n      this.state = this.restoreState(initialState);\n    } else {\n      this.state = this.createInitialState();\n    }\n  }\n\n  private createInitialState(): CircuitBreakerState {\n    return {\n      isOpen: false,\n      attemptCount: 0,\n      errorHistory: [],\n      startTime: new Date(),\n      tokensUsed: 0,\n      maxAttempts: this.config.maxAttempts,\n    };\n  }\n\n  /**\n   * Restore state from a saved CircuitBreakerState\n   * This allows the circuit breaker to continue from a previous session\n   * without double-counting attempts\n   */\n  private restoreState(saved: CircuitBreakerState): CircuitBreakerState {\n    return {\n      isOpen: saved.isOpen,\n      openReason: saved.openReason,\n      attemptCount: saved.attemptCount,\n      errorHistory: [...(saved.errorHistory || [])],\n      // Restore startTime or use now if not saved\n      startTime: saved.startTime ? new Date(saved.startTime) : new Date(),\n      tokensUsed: saved.tokensUsed || 0,\n      maxAttempts: this.config.maxAttempts,\n    };\n  }\n\n  /**\n   * Reset the circuit breaker to initial state\n   */\n  reset(): void {\n    this.state = this.createInitialState();\n  }\n\n  /**\n   * Get current state\n   */\n  getState(): CircuitBreakerState {\n    return { ...this.state };\n  }\n\n  /**\n   * Record an attempt and check if circuit should open\n   */\n  recordAttempt(errors: ErrorAnalysis[], tokenUsage?: TokenUsage): CircuitBreakerState {\n    if (this.state.isOpen) {\n      return this.state;\n    }\n\n    this.state.attemptCount++;\n\n    // Add error fingerprints to history\n    const fingerprints = errors.map(e => e.fingerprint);\n    this.state.errorHistory.push(...fingerprints);\n\n    // Track tokens\n    if (tokenUsage) {\n      this.state.tokensUsed += tokenUsage.totalTokens;\n    }\n\n    // Check all conditions\n    this.checkMaxAttempts();\n    this.checkSameError();\n    this.checkOscillation();\n    this.checkTimeout();\n    this.checkBudget();\n\n    return this.state;\n  }\n\n  /**\n   * Check if we can make another attempt\n   */\n  canAttempt(): boolean {\n    if (this.state.isOpen) {\n      return false;\n    }\n\n    // Re-check timeout in case time passed\n    this.checkTimeout();\n\n    return !this.state.isOpen;\n  }\n\n  /**\n   * Get remaining attempts\n   */\n  remainingAttempts(): number {\n    if (this.state.isOpen) return 0;\n    return Math.max(0, this.config.maxAttempts - this.state.attemptCount);\n  }\n\n  /**\n   * Get remaining token budget\n   */\n  remainingTokenBudget(): number {\n    return Math.max(0, this.config.maxTokenBudget - this.state.tokensUsed);\n  }\n\n  /**\n   * Estimate if operation would exceed budget\n   */\n  wouldExceedBudget(estimatedTokens: number): boolean {\n    return (this.state.tokensUsed + estimatedTokens) > this.config.maxTokenBudget;\n  }\n\n  // \n  // PRIVATE CHECKS\n  // \n\n  private checkMaxAttempts(): void {\n    if (this.state.attemptCount >= this.config.maxAttempts) {\n      this.openCircuit('MAX_ATTEMPTS');\n    }\n  }\n\n  private checkSameError(): void {\n    if (this.state.errorHistory.length < this.config.sameErrorThreshold) {\n      return;\n    }\n\n    // Count occurrences of each fingerprint\n    const counts = new Map<string, number>();\n    for (const fp of this.state.errorHistory) {\n      counts.set(fp, (counts.get(fp) || 0) + 1);\n    }\n\n    // Check if any error repeated too many times\n    for (const count of counts.values()) {\n      if (count >= this.config.sameErrorThreshold) {\n        this.openCircuit('SAME_ERROR');\n        return;\n      }\n    }\n  }\n\n  private checkOscillation(): void {\n    if (!this.config.oscillationDetection) {\n      return;\n    }\n\n    const history = this.state.errorHistory;\n    const windowSize = this.config.oscillationWindowSize;\n\n    if (history.length < windowSize) {\n      return;\n    }\n\n    // Check for A-B-A-B pattern in recent history\n    const recentHistory = history.slice(-windowSize);\n\n    // Simple oscillation: alternating between two states\n    const unique = new Set(recentHistory);\n    if (unique.size === 2) {\n      // Check if it's actually alternating\n      let isAlternating = true;\n      for (let i = 2; i < recentHistory.length; i++) {\n        const currentItem = recentHistory[i];\n        const previousItem = recentHistory[i - 2];\n        if (currentItem !== undefined && previousItem !== undefined && currentItem !== previousItem) {\n          isAlternating = false;\n          break;\n        }\n      }\n      if (isAlternating) {\n        this.openCircuit('OSCILLATION');\n      }\n    }\n  }\n\n  private checkTimeout(): void {\n    if (!this.state.startTime) return;\n    const elapsed = Date.now() - this.state.startTime.getTime();\n    if (elapsed >= this.config.totalTimeoutMs) {\n      this.openCircuit('TIMEOUT');\n    }\n  }\n\n  private checkBudget(): void {\n    if (this.state.tokensUsed >= this.config.maxTokenBudget) {\n      this.openCircuit('BUDGET_EXCEEDED');\n    }\n  }\n\n  private openCircuit(reason: CircuitBreakerState['openReason']): void {\n    this.state.isOpen = true;\n    this.state.openReason = reason;\n  }\n}\n\n// \n// CONVERGENCE DETECTOR\n// \n\nexport class ConvergenceDetector {\n  private errorCountHistory: number[] = [];\n  private uniqueErrorsHistory: Set<string>[] = [];\n  private lastImprovement: number | undefined;\n  private stagnationCount = 0;\n\n  /**\n   * Record errors from an attempt\n   */\n  recordAttempt(errors: ErrorAnalysis[]): void {\n    const count = errors.length;\n    const uniqueFingerprints = new Set(errors.map(e => e.fingerprint));\n\n    this.errorCountHistory.push(count);\n    this.uniqueErrorsHistory.push(uniqueFingerprints);\n\n    // Check for improvement\n    if (this.errorCountHistory.length >= 2) {\n      const prev = this.errorCountHistory[this.errorCountHistory.length - 2] ?? 0;\n      const curr = this.errorCountHistory[this.errorCountHistory.length - 1] ?? 0;\n\n      if (curr < prev) {\n        this.lastImprovement = this.errorCountHistory.length - 1;\n        this.stagnationCount = 0;\n      } else {\n        this.stagnationCount++;\n      }\n    }\n  }\n\n  /**\n   * Get convergence information\n   */\n  getInfo(): ConvergenceInfo {\n    const converged = this.isConverged();\n    const trend = this.detectTrend();\n\n    return {\n      converged,\n      attempts: this.errorCountHistory.length,\n      errorCountHistory: [...this.errorCountHistory],\n      uniqueErrorsHistory: this.uniqueErrorsHistory.map(s => new Set(s)),\n      lastImprovement: this.lastImprovement,\n      stagnationCount: this.stagnationCount,\n      trend,\n    };\n  }\n\n  /**\n   * Check if we've converged (no errors)\n   */\n  isConverged(): boolean {\n    if (this.errorCountHistory.length === 0) return false;\n    return this.errorCountHistory[this.errorCountHistory.length - 1] === 0;\n  }\n\n  /**\n   * Detect the trend in error counts\n   */\n  detectTrend(): ConvergenceInfo['trend'] {\n    if (this.errorCountHistory.length < 2) {\n      return 'stagnating';\n    }\n\n    const recent = this.errorCountHistory.slice(-3);\n\n    // Check for oscillation first\n    if (this.isOscillating()) {\n      return 'oscillating';\n    }\n\n    // Check trend\n    const decreasing = recent.every((val, i, arr) =>\n      i === 0 || val <= (arr[i - 1] ?? val)\n    );\n\n    const increasing = recent.every((val, i, arr) =>\n      i === 0 || val >= (arr[i - 1] ?? val)\n    );\n\n    const allSame = recent.every((val, _, arr) => val === arr[0]);\n\n    if (allSame || this.stagnationCount >= 2) {\n      return 'stagnating';\n    }\n\n    if (decreasing) {\n      return 'improving';\n    }\n\n    if (increasing) {\n      return 'degrading';\n    }\n\n    return 'stagnating';\n  }\n\n  /**\n   * Check if error counts are oscillating\n   */\n  private isOscillating(): boolean {\n    if (this.errorCountHistory.length < 4) {\n      return false;\n    }\n\n    const recent = this.errorCountHistory.slice(-4);\n    // A-B-A-B pattern in counts (allow some tolerance)\n    const diff01 = (recent[1] || 0) - (recent[0] || 0);\n    const diff12 = (recent[2] || 0) - (recent[1] || 0);\n    const diff23 = (recent[3] || 0) - (recent[2] || 0);\n\n    // Signs alternate: +, -, +, - or -, +, -, +\n    const signsAlternate =\n      Math.sign(diff01) !== 0 &&\n      Math.sign(diff01) === -Math.sign(diff12) &&\n      Math.sign(diff12) === -Math.sign(diff23);\n\n    return signsAlternate;\n  }\n\n  /**\n   * Calculate improvement percentage\n   */\n  getImprovementPercentage(): number {\n    if (this.errorCountHistory.length < 2) {\n      return 0;\n    }\n\n    const first = this.errorCountHistory[0] || 0;\n    const last = this.errorCountHistory[this.errorCountHistory.length - 1] || 0;\n\n    if (first === 0) {\n      return last === 0 ? 100 : 0;\n    }\n\n    return Math.round(((first - last) / first) * 100);\n  }\n\n  /**\n   * Get new errors introduced in last attempt (not in previous)\n   */\n  getNewErrors(): Set<string> {\n    if (this.uniqueErrorsHistory.length < 2) {\n      const firstEntry = this.uniqueErrorsHistory[0];\n      return firstEntry ? firstEntry : new Set();\n    }\n\n    const prev = this.uniqueErrorsHistory[this.uniqueErrorsHistory.length - 2];\n    const curr = this.uniqueErrorsHistory[this.uniqueErrorsHistory.length - 1];\n\n    if (!prev || !curr) {\n      return new Set();\n    }\n\n    const newErrors = new Set<string>();\n    for (const fp of curr) {\n      if (!prev.has(fp)) {\n        newErrors.add(fp);\n      }\n    }\n\n    return newErrors;\n  }\n\n  /**\n   * Get errors fixed in last attempt (in previous but not current)\n   */\n  getFixedErrors(): Set<string> {\n    if (this.uniqueErrorsHistory.length < 2) {\n      return new Set();\n    }\n\n    const prev = this.uniqueErrorsHistory[this.uniqueErrorsHistory.length - 2];\n    const curr = this.uniqueErrorsHistory[this.uniqueErrorsHistory.length - 1];\n\n    if (!prev || !curr) {\n      return new Set();\n    }\n\n    const fixedErrors = new Set<string>();\n    for (const fp of prev) {\n      if (!curr.has(fp)) {\n        fixedErrors.add(fp);\n      }\n    }\n\n    return fixedErrors;\n  }\n\n  /**\n   * Reset the detector\n   */\n  reset(): void {\n    this.errorCountHistory = [];\n    this.uniqueErrorsHistory = [];\n    this.lastImprovement = undefined;\n    this.stagnationCount = 0;\n  }\n\n  /**\n   * Restore detector state from saved error count history\n   * This allows the detector to continue from a previous session\n   * without losing context about convergence trends\n   */\n  restoreFromHistory(savedErrorCounts: number[]): void {\n    if (!savedErrorCounts || savedErrorCounts.length === 0) {\n      return;\n    }\n\n    this.errorCountHistory = [...savedErrorCounts];\n    // We can't restore uniqueErrorsHistory without fingerprints,\n    // but we can still detect trends from error counts\n    this.uniqueErrorsHistory = savedErrorCounts.map(() => new Set<string>());\n\n    // Recalculate lastImprovement and stagnationCount\n    this.lastImprovement = undefined;\n    this.stagnationCount = 0;\n\n    for (let i = 1; i < savedErrorCounts.length; i++) {\n      const prev = savedErrorCounts[i - 1];\n      const curr = savedErrorCounts[i];\n\n      if (prev !== undefined && curr !== undefined && curr < prev) {\n        this.lastImprovement = i;\n        this.stagnationCount = 0;\n      } else {\n        this.stagnationCount++;\n      }\n    }\n  }\n\n  /**\n   * Get the error count history for serialization\n   */\n  getErrorCountHistory(): number[] {\n    return [...this.errorCountHistory];\n  }\n}\n\n// \n// COMBINED ANALYZER\n// \n\nexport interface RefinementAnalysis {\n  shouldContinue: boolean;\n  reason: string;\n  circuitBreaker: CircuitBreakerState;\n  convergence: ConvergenceInfo;\n  recommendation: 'continue' | 'stop' | 'escalate';\n}\n\n/**\n * Analyze refinement progress and decide whether to continue\n */\nexport function analyzeRefinementProgress(\n  _attempts: FixAttempt[],\n  circuitBreaker: CircuitBreaker,\n  convergenceDetector: ConvergenceDetector\n): RefinementAnalysis {\n  const cbState = circuitBreaker.getState();\n  const convergenceInfo = convergenceDetector.getInfo();\n\n  // Check circuit breaker first\n  if (cbState.isOpen) {\n    return {\n      shouldContinue: false,\n      reason: `Circuit breaker open: ${cbState.openReason}`,\n      circuitBreaker: cbState,\n      convergence: convergenceInfo,\n      recommendation: 'stop',\n    };\n  }\n\n  // Check convergence\n  if (convergenceInfo.converged) {\n    return {\n      shouldContinue: false,\n      reason: 'All errors resolved',\n      circuitBreaker: cbState,\n      convergence: convergenceInfo,\n      recommendation: 'stop',\n    };\n  }\n\n  // Check trend\n  if (convergenceInfo.trend === 'degrading') {\n    return {\n      shouldContinue: false,\n      reason: 'Error count increasing - fixes are making things worse',\n      circuitBreaker: cbState,\n      convergence: convergenceInfo,\n      recommendation: 'escalate',\n    };\n  }\n\n  if (convergenceInfo.trend === 'oscillating') {\n    return {\n      shouldContinue: false,\n      reason: 'Error counts oscillating - cannot converge',\n      circuitBreaker: cbState,\n      convergence: convergenceInfo,\n      recommendation: 'escalate',\n    };\n  }\n\n  // Check stagnation\n  if (convergenceInfo.stagnationCount >= 2) {\n    return {\n      shouldContinue: false,\n      reason: 'No improvement in last 2 attempts - stagnating',\n      circuitBreaker: cbState,\n      convergence: convergenceInfo,\n      recommendation: 'escalate',\n    };\n  }\n\n  // Can continue\n  return {\n    shouldContinue: true,\n    reason: 'Progress being made',\n    circuitBreaker: cbState,\n    convergence: convergenceInfo,\n    recommendation: 'continue',\n  };\n}\n","/**\n * @module refinement/refinement-loop\n * @description Main orchestrator for self-refinement of generated tests\n */\n\nimport { Result, ok, err, TokenUsage } from '../shared/types.js';\nimport { CostTracker } from '../shared/cost-tracker.js';\nimport { RefinementConfig } from '../shared/config-validator.js';\nimport {\n  ErrorAnalysis,\n  CodeFix,\n  FixAttempt,\n  PlaywrightTestResult,\n  RefinementSession,\n  RefinementResult,\n  RefinementStatus,\n  RefinementDiagnostics,\n  LessonLearned,\n  CircuitBreakerConfig,\n} from './types.js';\nimport { parseError } from './error-parser.js';\nimport {\n  CircuitBreaker,\n  ConvergenceDetector,\n  analyzeRefinementProgress,\n  DEFAULT_CIRCUIT_BREAKER_CONFIG,\n} from './convergence-detector.js';\n\n// \n// LLM CLIENT INTERFACE\n// \n\nexport interface RefinementLLMClient {\n  generateFix(\n    _code: string,\n    _errors: ErrorAnalysis[],\n    _previousAttempts: FixAttempt[],\n    _options: FixGenerationOptions\n  ): Promise<FixGenerationResult>;\n}\n\nexport interface FixGenerationOptions {\n  maxTokens: number;\n  temperature: number;\n  systemPrompt: string;\n}\n\nexport interface FixGenerationResult {\n  fixes: CodeFix[];\n  tokenUsage: TokenUsage;\n  reasoning?: string;\n}\n\n// \n// TEST RUNNER INTERFACE\n// \n\nexport interface TestRunner {\n  runTest(_testFile: string, _testCode: string): Promise<PlaywrightTestResult>;\n}\n\n// \n// REFINEMENT OPTIONS\n// \n\nexport interface RefinementOptions {\n  config: RefinementConfig;\n  llmClient: RefinementLLMClient;\n  testRunner: TestRunner;\n  costTracker?: CostTracker;\n  circuitBreakerConfig?: Partial<CircuitBreakerConfig>;\n  onAttemptComplete?: (_attempt: FixAttempt) => void;\n  onProgressUpdate?: (_progress: RefinementProgress) => void;\n}\n\nexport interface RefinementProgress {\n  attemptNumber: number;\n  maxAttempts: number;\n  currentErrorCount: number;\n  originalErrorCount: number;\n  trend: string;\n  status: 'running' | 'success' | 'failed';\n}\n\n// \n// SYSTEM PROMPT\n// \n\nconst REFINEMENT_SYSTEM_PROMPT = `You are an expert Playwright test debugger. Your task is to fix failing E2E tests.\n\n## Context\nYou will receive:\n1. The current test code (TypeScript/Playwright)\n2. A list of errors with detailed analysis\n3. Previous fix attempts (if any)\n\n## Your Task\nAnalyze the errors and provide fixes. For each error:\n1. Understand the root cause\n2. Propose a minimal, targeted fix\n3. Explain your reasoning\n\n## Fix Guidelines\n- Prefer more robust selectors (testId > role > text > css)\n- Add appropriate waits for async operations\n- Don't over-engineer - fix only what's broken\n- Preserve the original test intent\n- Avoid changing test assertions unless they're incorrect\n\n## Response Format\nRespond with JSON:\n{\n  \"reasoning\": \"Brief explanation of root cause\",\n  \"fixes\": [\n    {\n      \"type\": \"SELECTOR_CHANGE\" | \"WAIT_ADDED\" | \"ASSERTION_MODIFIED\" | \"OTHER\",\n      \"description\": \"What this fix does\",\n      \"originalCode\": \"exact code being replaced\",\n      \"fixedCode\": \"replacement code\",\n      \"location\": { \"file\": \"test.spec.ts\", \"line\": 42 },\n      \"confidence\": 0.85,\n      \"reasoning\": \"Why this fix should work\"\n    }\n  ]\n}\n\n## Important\n- fixes[].originalCode must be an EXACT substring of the current code\n- Each fix should target one specific issue\n- Order fixes by confidence (highest first)\n- If you cannot determine a fix, set confidence < 0.5`;\n\n// \n// MAIN REFINEMENT LOOP\n// \n\nexport async function runRefinementLoop(\n  journeyId: string,\n  testFile: string,\n  originalCode: string,\n  initialErrors: ErrorAnalysis[],\n  options: RefinementOptions\n): Promise<RefinementResult> {\n  const {\n    config,\n    llmClient,\n    testRunner,\n    costTracker,\n    circuitBreakerConfig,\n    onAttemptComplete,\n    onProgressUpdate,\n  } = options;\n\n  // Initialize session\n  const sessionId = `refine-${journeyId}-${Date.now()}`;\n  const circuitBreaker = new CircuitBreaker({\n    ...DEFAULT_CIRCUIT_BREAKER_CONFIG,\n    maxAttempts: config.maxAttempts,\n    ...circuitBreakerConfig,\n  });\n  const convergenceDetector = new ConvergenceDetector();\n\n  // Track initial errors\n  convergenceDetector.recordAttempt(initialErrors);\n\n  const session: RefinementSession = {\n    sessionId,\n    journeyId,\n    testFile,\n    startTime: new Date(),\n    originalCode,\n    currentCode: originalCode,\n    attempts: [],\n    circuitBreakerState: circuitBreaker.getState(),\n    convergenceInfo: convergenceDetector.getInfo(),\n    finalStatus: 'SUCCESS', // Will be updated\n    totalTokenUsage: { promptTokens: 0, completionTokens: 0, totalTokens: 0, estimatedCostUsd: 0 },\n  };\n\n  let currentCode = originalCode;\n  let currentErrors = initialErrors;\n  const appliedFixes: CodeFix[] = [];\n  const lessonsLearned: LessonLearned[] = [];\n  let consecutiveSkips = 0;  // Track consecutive low-confidence fix attempts\n  const MAX_CONSECUTIVE_SKIPS = 3;  // Escalate after this many skips\n\n  // Main loop\n  while (true) {\n    // Check if we can continue\n    const analysis = analyzeRefinementProgress(\n      session.attempts,\n      circuitBreaker,\n      convergenceDetector\n    );\n\n    if (!analysis.shouldContinue) {\n      session.finalStatus = mapAnalysisToStatus(analysis.reason, currentErrors.length === 0);\n      break;\n    }\n\n    // Check cost limits\n    if (costTracker?.wouldExceedLimit(5000)) {\n      session.finalStatus = 'BUDGET_EXCEEDED';\n      break;\n    }\n\n    // Report progress\n    if (onProgressUpdate) {\n      onProgressUpdate({\n        attemptNumber: session.attempts.length + 1,\n        maxAttempts: config.maxAttempts,\n        currentErrorCount: currentErrors.length,\n        originalErrorCount: initialErrors.length,\n        trend: convergenceDetector.getInfo().trend,\n        status: 'running',\n      });\n    }\n\n    // Generate fixes\n    let fixResult: FixGenerationResult;\n    try {\n      fixResult = await llmClient.generateFix(\n        currentCode,\n        currentErrors,\n        session.attempts,\n        {\n          maxTokens: config.llm.maxTokens,\n          temperature: config.llm.temperature,\n          systemPrompt: REFINEMENT_SYSTEM_PROMPT,\n        }\n      );\n    } catch (error) {\n      // CRITICAL FIX: LLM exceptions must be tracked by circuit breaker\n      // to prevent infinite retry loops when LLM is unavailable\n      const llmError = parseError(error instanceof Error ? error.message : 'LLM error');\n\n      const primaryError = currentErrors[0];\n      if (!primaryError) {\n        // No errors to fix but LLM failed - still track the failure\n        circuitBreaker.recordAttempt([llmError]);\n        session.finalStatus = 'CANNOT_FIX';\n        break;\n      }\n      const attempt: FixAttempt = {\n        attemptNumber: session.attempts.length + 1,\n        timestamp: new Date(),\n        error: primaryError,\n        proposedFixes: [],\n        outcome: 'failure',\n        newErrors: [llmError],\n      };\n      session.attempts.push(attempt);\n\n      // Track LLM failure in circuit breaker (was missing before - caused skip escalation loophole)\n      circuitBreaker.recordAttempt([...currentErrors, llmError]);\n      convergenceDetector.recordAttempt([...currentErrors, llmError]);\n\n      if (onAttemptComplete) {\n        onAttemptComplete(attempt);\n      }\n\n      session.finalStatus = 'CANNOT_FIX';\n      break;\n    }\n\n    // Track token usage\n    session.totalTokenUsage = addTokenUsage(session.totalTokenUsage, fixResult.tokenUsage);\n    if (costTracker) {\n      costTracker.trackUsage(fixResult.tokenUsage);\n    }\n\n    // Filter to high-confidence fixes\n    const viableFixes = fixResult.fixes.filter(f => f.confidence >= 0.5);\n\n    const primaryError = currentErrors[0];\n    if (!primaryError) {\n      // No errors - we're done\n      session.finalStatus = 'SUCCESS';\n      break;\n    }\n\n    if (viableFixes.length === 0) {\n      consecutiveSkips++;\n\n      const attempt: FixAttempt = {\n        attemptNumber: session.attempts.length + 1,\n        timestamp: new Date(),\n        error: primaryError,\n        proposedFixes: fixResult.fixes,\n        outcome: 'skipped',\n        tokenUsage: fixResult.tokenUsage,\n      };\n      session.attempts.push(attempt);\n      circuitBreaker.recordAttempt(currentErrors, fixResult.tokenUsage);\n\n      if (onAttemptComplete) {\n        onAttemptComplete(attempt);\n      }\n\n      // Escalate after too many consecutive skips (LLM can't generate high-confidence fixes)\n      if (consecutiveSkips >= MAX_CONSECUTIVE_SKIPS) {\n        session.finalStatus = 'CANNOT_FIX';\n        break;\n      }\n      continue;\n    }\n\n    // Reset skip counter on successful fix generation\n    consecutiveSkips = 0;\n\n    // Apply the highest confidence fix\n    const fixToApply = viableFixes[0]!;\n    const applyResult = applyFix(currentCode, fixToApply);\n\n    if (!applyResult.ok) {\n      const attempt: FixAttempt = {\n        attemptNumber: session.attempts.length + 1,\n        timestamp: new Date(),\n        error: primaryError,\n        proposedFixes: fixResult.fixes,\n        outcome: 'failure',\n        tokenUsage: fixResult.tokenUsage,\n      };\n      session.attempts.push(attempt);\n      circuitBreaker.recordAttempt(currentErrors, fixResult.tokenUsage);\n\n      if (onAttemptComplete) {\n        onAttemptComplete(attempt);\n      }\n      continue;\n    }\n\n    const fixedCode = applyResult.value;\n\n    // Run test with fixed code\n    let testResult: PlaywrightTestResult;\n    try {\n      testResult = await testRunner.runTest(testFile, fixedCode);\n    } catch (error) {\n      const attempt: FixAttempt = {\n        attemptNumber: session.attempts.length + 1,\n        timestamp: new Date(),\n        error: primaryError,\n        proposedFixes: fixResult.fixes,\n        appliedFix: fixToApply,\n        outcome: 'failure',\n        newErrors: [parseError(error instanceof Error ? error.message : 'Test run error')],\n        tokenUsage: fixResult.tokenUsage,\n      };\n      session.attempts.push(attempt);\n      circuitBreaker.recordAttempt(currentErrors, fixResult.tokenUsage);\n\n      if (onAttemptComplete) {\n        onAttemptComplete(attempt);\n      }\n      continue;\n    }\n\n    // Determine outcome\n    const newErrors = testResult.errors;\n    const outcome = determineOutcome(currentErrors, newErrors);\n\n    const attempt: FixAttempt = {\n      attemptNumber: session.attempts.length + 1,\n      timestamp: new Date(),\n      error: primaryError,\n      proposedFixes: fixResult.fixes,\n      appliedFix: fixToApply,\n      outcome,\n      newErrors: newErrors.length > 0 ? newErrors : undefined,\n      tokenUsage: fixResult.tokenUsage,\n    };\n\n    session.attempts.push(attempt);\n\n    // Update state\n    if (outcome === 'success' || outcome === 'partial') {\n      currentCode = fixedCode;\n      session.currentCode = currentCode;\n      appliedFixes.push(fixToApply);\n\n      // Learn from successful fix\n      const lesson = createLesson(journeyId, fixToApply, primaryError);\n      if (lesson) {\n        lessonsLearned.push(lesson);\n      }\n    }\n\n    currentErrors = newErrors;\n    convergenceDetector.recordAttempt(newErrors);\n    circuitBreaker.recordAttempt(newErrors, fixResult.tokenUsage);\n\n    // Update session state\n    session.circuitBreakerState = circuitBreaker.getState();\n    session.convergenceInfo = convergenceDetector.getInfo();\n\n    if (onAttemptComplete) {\n      onAttemptComplete(attempt);\n    }\n\n    // Add cooldown between attempts\n    if (config.timeouts.delayBetweenAttempts > 0) {\n      await sleep(config.timeouts.delayBetweenAttempts);\n    }\n  }\n\n  // Finalize session\n  session.endTime = new Date();\n  session.circuitBreakerState = circuitBreaker.getState();\n  session.convergenceInfo = convergenceDetector.getInfo();\n\n  // Report final progress\n  if (onProgressUpdate) {\n    onProgressUpdate({\n      attemptNumber: session.attempts.length,\n      maxAttempts: config.maxAttempts,\n      currentErrorCount: currentErrors.length,\n      originalErrorCount: initialErrors.length,\n      trend: convergenceDetector.getInfo().trend,\n      status: currentErrors.length === 0 ? 'success' : 'failed',\n    });\n  }\n\n  return {\n    success: currentErrors.length === 0,\n    session,\n    fixedCode: currentErrors.length === 0 ? currentCode : undefined,\n    remainingErrors: currentErrors,\n    appliedFixes,\n    lessonsLearned,\n    diagnostics: createDiagnostics(session),\n  };\n}\n\n// \n// HELPER FUNCTIONS\n// \n\nfunction applyFix(code: string, fix: CodeFix): Result<string, string> {\n  if (!code.includes(fix.originalCode)) {\n    return err(`Original code not found: \"${fix.originalCode.substring(0, 50)}...\"`);\n  }\n\n  const fixedCode = code.replace(fix.originalCode, fix.fixedCode);\n  return ok(fixedCode);\n}\n\nfunction determineOutcome(\n  previousErrors: ErrorAnalysis[],\n  newErrors: ErrorAnalysis[]\n): 'success' | 'failure' | 'partial' {\n  if (newErrors.length === 0) {\n    return 'success';\n  }\n\n  if (newErrors.length < previousErrors.length) {\n    return 'partial';\n  }\n\n  // Check if we fixed some errors but introduced new ones\n  const previousFingerprints = new Set(previousErrors.map(e => e.fingerprint));\n  const newFingerprints = new Set(newErrors.map(e => e.fingerprint));\n\n  let fixedCount = 0;\n  for (const fp of previousFingerprints) {\n    if (!newFingerprints.has(fp)) {\n      fixedCount++;\n    }\n  }\n\n  if (fixedCount > 0) {\n    return 'partial';\n  }\n\n  return 'failure';\n}\n\nfunction mapAnalysisToStatus(reason: string, noErrors: boolean): RefinementStatus {\n  if (noErrors) {\n    return 'SUCCESS';\n  }\n\n  if (reason.includes('Circuit breaker')) {\n    if (reason.includes('MAX_ATTEMPTS')) return 'MAX_ATTEMPTS_REACHED';\n    if (reason.includes('SAME_ERROR')) return 'SAME_ERROR_LOOP';\n    if (reason.includes('OSCILLATION')) return 'OSCILLATION_DETECTED';\n    if (reason.includes('TIMEOUT')) return 'TIMEOUT';\n    if (reason.includes('BUDGET')) return 'BUDGET_EXCEEDED';\n  }\n\n  if (reason.includes('stagnating')) return 'CANNOT_FIX';\n  if (reason.includes('degrading')) return 'CANNOT_FIX';\n  if (reason.includes('oscillating')) return 'OSCILLATION_DETECTED';\n\n  return 'PARTIAL_SUCCESS';\n}\n\nfunction createDiagnostics(session: RefinementSession): RefinementDiagnostics {\n  const lastAttempt = session.attempts.length > 0 ? session.attempts[session.attempts.length - 1] : undefined;\n  const lastError = lastAttempt?.error?.message || '';\n\n  return {\n    attempts: session.attempts.length,\n    lastError,\n    convergenceFailure: session.convergenceInfo.trend === 'stagnating' ||\n      session.convergenceInfo.trend === 'oscillating',\n    sameErrorRepeated: session.circuitBreakerState.openReason === 'SAME_ERROR',\n    oscillationDetected: session.circuitBreakerState.openReason === 'OSCILLATION' ||\n      session.convergenceInfo.trend === 'oscillating',\n    budgetExhausted: session.circuitBreakerState.openReason === 'BUDGET_EXCEEDED',\n    timedOut: session.circuitBreakerState.openReason === 'TIMEOUT',\n  };\n}\n\nfunction createLesson(\n  journeyId: string,\n  fix: CodeFix,\n  error: ErrorAnalysis\n): LessonLearned | undefined {\n  // Only create lessons for high-confidence fixes\n  if (fix.confidence < 0.7) {\n    return undefined;\n  }\n\n  const lessonType = mapFixTypeToLessonType(fix.type);\n  if (!lessonType) {\n    return undefined;\n  }\n\n  return {\n    id: `lesson-${journeyId}-${Date.now()}`,\n    type: lessonType,\n    context: {\n      journeyId,\n      errorCategory: error.category,\n      originalSelector: error.selector,\n      element: fix.location.stepDescription || '',\n    },\n    solution: {\n      pattern: fix.type,\n      code: fix.fixedCode,\n      explanation: fix.reasoning || fix.description,\n    },\n    confidence: fix.confidence,\n    createdAt: new Date(),\n    verified: true, // It worked!\n  };\n}\n\nfunction mapFixTypeToLessonType(\n  fixType: string\n): LessonLearned['type'] | undefined {\n  switch (fixType) {\n    case 'SELECTOR_CHANGE':\n    case 'LOCATOR_STRATEGY_CHANGED':\n      return 'selector_pattern';\n    case 'WAIT_ADDED':\n    case 'TIMEOUT_INCREASED':\n      return 'wait_strategy';\n    case 'FLOW_REORDERED':\n      return 'flow_pattern';\n    default:\n      return 'error_fix';\n  }\n}\n\nfunction addTokenUsage(a: TokenUsage, b: TokenUsage): TokenUsage {\n  return {\n    promptTokens: a.promptTokens + b.promptTokens,\n    completionTokens: a.completionTokens + b.completionTokens,\n    totalTokens: a.totalTokens + b.totalTokens,\n    estimatedCostUsd: a.estimatedCostUsd + b.estimatedCostUsd,\n  };\n}\n\nfunction sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// \n// SINGLE ATTEMPT HELPER\n// \n\n/**\n * Run a single refinement attempt (for testing or manual control)\n */\nexport async function runSingleRefinementAttempt(\n  code: string,\n  errors: ErrorAnalysis[],\n  llmClient: RefinementLLMClient,\n  options: {\n    maxTokens?: number;\n    temperature?: number;\n  } = {}\n): Promise<Result<{ fixes: CodeFix[]; reasoning?: string }, string>> {\n  try {\n    const result = await llmClient.generateFix(code, errors, [], {\n      maxTokens: options.maxTokens || 4096,\n      temperature: options.temperature || 0.2,\n      systemPrompt: REFINEMENT_SYSTEM_PROMPT,\n    });\n\n    return ok({\n      fixes: result.fixes,\n      reasoning: result.reasoning,\n    });\n  } catch (error) {\n    return err(error instanceof Error ? error.message : 'Unknown error');\n  }\n}\n","/**\n * @module refinement/llkb-learning\n * @description Record successful fixes to LLKB for future learning\n */\n\nimport {\n  LessonLearned,\n  CodeFix,\n  ErrorAnalysis,\n  RefinementSession,\n  ErrorCategory,\n} from './types.js';\n\n// \n// LLKB STORAGE INTERFACE\n// \n\nexport interface LLKBStorage {\n  saveLessons(_lessons: LessonLearned[]): Promise<void>;\n  getLessons(_filter: LessonFilter): Promise<LessonLearned[]>;\n  updateLessonConfidence(_lessonId: string, _newConfidence: number): Promise<void>;\n  markLessonAsVerified(_lessonId: string, _verified: boolean): Promise<void>;\n}\n\nexport interface LessonFilter {\n  journeyId?: string;\n  errorCategory?: ErrorCategory;\n  type?: LessonLearned['type'];\n  minConfidence?: number;\n  verified?: boolean;\n}\n\n// \n// LESSON EXTRACTION\n// \n\nexport interface LessonExtractionOptions {\n  minConfidence: number;\n  includeUnverified: boolean;\n  maxLessonsPerSession: number;\n}\n\nconst DEFAULT_EXTRACTION_OPTIONS: LessonExtractionOptions = {\n  minConfidence: 0.7,\n  includeUnverified: false,\n  maxLessonsPerSession: 10,\n};\n\n/**\n * Extract lessons from a completed refinement session\n */\nexport function extractLessonsFromSession(\n  session: RefinementSession,\n  options: Partial<LessonExtractionOptions> = {}\n): LessonLearned[] {\n  const opts = { ...DEFAULT_EXTRACTION_OPTIONS, ...options };\n  const lessons: LessonLearned[] = [];\n\n  for (const attempt of session.attempts) {\n    // Only learn from successful or partial success attempts\n    if (attempt.outcome !== 'success' && attempt.outcome !== 'partial') {\n      continue;\n    }\n\n    // Only learn from attempts with applied fixes\n    if (!attempt.appliedFix) {\n      continue;\n    }\n\n    const fix = attempt.appliedFix;\n\n    // Check confidence threshold\n    if (fix.confidence < opts.minConfidence) {\n      continue;\n    }\n\n    // Create lesson\n    const lesson = createLessonFromFix(\n      session.journeyId,\n      fix,\n      attempt.error,\n      attempt.outcome === 'success' // verified only if full success\n    );\n\n    if (lesson && (lesson.verified || opts.includeUnverified)) {\n      lessons.push(lesson);\n    }\n\n    // Respect max lessons limit\n    if (lessons.length >= opts.maxLessonsPerSession) {\n      break;\n    }\n  }\n\n  return lessons;\n}\n\n/**\n * Create a lesson from a successful fix\n */\nfunction createLessonFromFix(\n  journeyId: string,\n  fix: CodeFix,\n  error: ErrorAnalysis,\n  verified: boolean\n): LessonLearned | undefined {\n  const type = mapFixTypeToLessonType(fix.type);\n  if (!type) {\n    return undefined;\n  }\n\n  return {\n    id: generateLessonId(journeyId, fix, error),\n    type,\n    context: {\n      journeyId,\n      errorCategory: error.category,\n      originalSelector: error.selector,\n      element: extractElementDescription(fix, error),\n    },\n    solution: {\n      pattern: extractPattern(fix),\n      code: fix.fixedCode,\n      explanation: fix.reasoning || fix.description,\n    },\n    confidence: fix.confidence,\n    createdAt: new Date(),\n    verified,\n  };\n}\n\nfunction mapFixTypeToLessonType(fixType: string): LessonLearned['type'] | undefined {\n  switch (fixType) {\n    case 'SELECTOR_CHANGE':\n    case 'LOCATOR_STRATEGY_CHANGED':\n    case 'FRAME_CONTEXT_ADDED':\n      return 'selector_pattern';\n    case 'WAIT_ADDED':\n    case 'TIMEOUT_INCREASED':\n    case 'RETRY_ADDED':\n      return 'wait_strategy';\n    case 'FLOW_REORDERED':\n      return 'flow_pattern';\n    case 'ASSERTION_MODIFIED':\n    case 'ERROR_HANDLING_ADDED':\n    case 'OTHER':\n      return 'error_fix';\n    default:\n      return undefined;\n  }\n}\n\nfunction generateLessonId(journeyId: string, fix: CodeFix, error: ErrorAnalysis): string {\n  const timestamp = Date.now();\n  const fixHash = hashString(fix.fixedCode.substring(0, 50));\n  return `lesson-${journeyId}-${error.category}-${fixHash}-${timestamp}`;\n}\n\nfunction hashString(str: string): string {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash; // Convert to 32-bit integer\n  }\n  return Math.abs(hash).toString(36);\n}\n\nfunction extractElementDescription(fix: CodeFix, error: ErrorAnalysis): string {\n  // Try to extract element description from various sources\n  if (fix.location.stepDescription) {\n    return fix.location.stepDescription;\n  }\n\n  if (error.selector) {\n    return extractElementFromSelector(error.selector);\n  }\n\n  // Try to extract from fixed code\n  const locatorMatch = fix.fixedCode.match(/getBy\\w+\\(['\"]([^'\"]+)['\"]\\)/);\n  if (locatorMatch && locatorMatch[1]) {\n    return locatorMatch[1];\n  }\n\n  return 'unknown element';\n}\n\nfunction extractElementFromSelector(selector: string): string {\n  // Extract meaningful element description from selector\n  const testIdMatch = selector.match(/data-testid[=~*^$]*[\"']?([^\"'\\]]+)/);\n  if (testIdMatch && testIdMatch[1]) {\n    return testIdMatch[1];\n  }\n\n  const roleMatch = selector.match(/role=[\"']?([^\"'\\]]+)/);\n  if (roleMatch && roleMatch[1]) {\n    return roleMatch[1];\n  }\n\n  const classMatch = selector.match(/\\.([a-zA-Z0-9_-]+)/);\n  if (classMatch && classMatch[1]) {\n    return classMatch[1];\n  }\n\n  return selector.substring(0, 30);\n}\n\nfunction extractPattern(fix: CodeFix): string {\n  // Extract a generalizable pattern from the fix\n  switch (fix.type) {\n    case 'SELECTOR_CHANGE':\n      return extractSelectorPattern(fix.fixedCode);\n    case 'WAIT_ADDED':\n      return extractWaitPattern(fix.fixedCode);\n    case 'ASSERTION_MODIFIED':\n      return extractAssertionPattern(fix.fixedCode);\n    default:\n      return fix.type;\n  }\n}\n\nfunction extractSelectorPattern(code: string): string {\n  // Identify the selector strategy used\n  if (code.includes('getByTestId')) return 'testid';\n  if (code.includes('getByRole')) return 'role';\n  if (code.includes('getByText')) return 'text';\n  if (code.includes('getByLabel')) return 'label';\n  if (code.includes('getByPlaceholder')) return 'placeholder';\n  if (code.includes('locator')) return 'css';\n  return 'unknown';\n}\n\nfunction extractWaitPattern(code: string): string {\n  if (code.includes('waitForSelector')) return 'waitForSelector';\n  if (code.includes('waitForLoadState')) return 'waitForLoadState';\n  if (code.includes('waitForResponse')) return 'waitForResponse';\n  if (code.includes('waitForTimeout')) return 'waitForTimeout';\n  if (code.includes('toBeVisible')) return 'expectVisible';\n  return 'unknown';\n}\n\nfunction extractAssertionPattern(code: string): string {\n  if (code.includes('toHaveText')) return 'toHaveText';\n  if (code.includes('toHaveValue')) return 'toHaveValue';\n  if (code.includes('toBeVisible')) return 'toBeVisible';\n  if (code.includes('toBeEnabled')) return 'toBeEnabled';\n  if (code.includes('toHaveCount')) return 'toHaveCount';\n  return 'unknown';\n}\n\n// \n// LESSON AGGREGATION\n// \n\nexport interface AggregatedPattern {\n  pattern: string;\n  occurrences: number;\n  averageConfidence: number;\n  contexts: string[];\n  representativeCode: string;\n}\n\n/**\n * Aggregate similar lessons into patterns\n */\nexport function aggregateLessons(lessons: LessonLearned[]): AggregatedPattern[] {\n  const patterns = new Map<string, {\n    occurrences: number;\n    totalConfidence: number;\n    contexts: Set<string>;\n    codes: string[];\n  }>();\n\n  for (const lesson of lessons) {\n    const key = `${lesson.type}:${lesson.solution.pattern}`;\n    const existing = patterns.get(key);\n\n    if (existing) {\n      existing.occurrences++;\n      existing.totalConfidence += lesson.confidence;\n      existing.contexts.add(lesson.context.errorCategory);\n      existing.codes.push(lesson.solution.code);\n    } else {\n      patterns.set(key, {\n        occurrences: 1,\n        totalConfidence: lesson.confidence,\n        contexts: new Set([lesson.context.errorCategory]),\n        codes: [lesson.solution.code],\n      });\n    }\n  }\n\n  return Array.from(patterns.entries())\n    .map(([key, data]) => ({\n      pattern: key,\n      occurrences: data.occurrences,\n      averageConfidence: data.totalConfidence / data.occurrences,\n      contexts: Array.from(data.contexts),\n      representativeCode: data.codes[0] || '', // Use first occurrence as representative\n    }))\n    .sort((a, b) => b.occurrences - a.occurrences);\n}\n\n// \n// CONFIDENCE ADJUSTMENT\n// \n\nexport interface ConfidenceAdjustment {\n  lessonId: string;\n  oldConfidence: number;\n  newConfidence: number;\n  reason: 'success' | 'failure' | 'decay';\n}\n\n/**\n * Calculate confidence adjustment based on outcome\n */\nexport function calculateConfidenceAdjustment(\n  lesson: LessonLearned,\n  outcome: 'success' | 'failure',\n  currentUsageCount: number\n): ConfidenceAdjustment {\n  const oldConfidence = lesson.confidence;\n  let newConfidence: number;\n  let reason: ConfidenceAdjustment['reason'];\n\n  if (outcome === 'success') {\n    // Increase confidence, with diminishing returns\n    const increment = 0.05 * Math.pow(0.9, currentUsageCount);\n    newConfidence = Math.min(1.0, oldConfidence + increment);\n    reason = 'success';\n  } else {\n    // Decrease confidence more aggressively\n    const decrement = 0.1 * Math.pow(1.1, currentUsageCount);\n    newConfidence = Math.max(0.0, oldConfidence - decrement);\n    reason = 'failure';\n  }\n\n  return {\n    lessonId: lesson.id,\n    oldConfidence,\n    newConfidence,\n    reason,\n  };\n}\n\n/**\n * Apply time-based decay to confidence scores\n */\nexport function applyConfidenceDecay(\n  lessons: LessonLearned[],\n  decayRate: number = 0.01,\n  referenceDate: Date = new Date()\n): ConfidenceAdjustment[] {\n  const adjustments: ConfidenceAdjustment[] = [];\n\n  for (const lesson of lessons) {\n    const ageInDays = (referenceDate.getTime() - lesson.createdAt.getTime()) / (1000 * 60 * 60 * 24);\n\n    if (ageInDays > 30) { // Only decay lessons older than 30 days\n      const decayFactor = Math.pow(1 - decayRate, Math.floor(ageInDays / 30));\n      const newConfidence = lesson.confidence * decayFactor;\n\n      if (newConfidence !== lesson.confidence) {\n        adjustments.push({\n          lessonId: lesson.id,\n          oldConfidence: lesson.confidence,\n          newConfidence,\n          reason: 'decay',\n        });\n      }\n    }\n  }\n\n  return adjustments;\n}\n\n// \n// LESSON RECOMMENDATIONS\n// \n\nexport interface LessonRecommendation {\n  lesson: LessonLearned;\n  relevanceScore: number;\n  applicabilityReason: string;\n}\n\n/**\n * Recommend lessons that might help fix given errors\n */\nexport function recommendLessons(\n  errors: ErrorAnalysis[],\n  availableLessons: LessonLearned[],\n  maxRecommendations: number = 5\n): LessonRecommendation[] {\n  const recommendations: LessonRecommendation[] = [];\n\n  for (const lesson of availableLessons) {\n    // Skip low-confidence or unverified lessons\n    if (lesson.confidence < 0.6 || !lesson.verified) {\n      continue;\n    }\n\n    for (const error of errors) {\n      const relevance = calculateRelevance(lesson, error);\n      if (relevance > 0) {\n        recommendations.push({\n          lesson,\n          relevanceScore: relevance * lesson.confidence,\n          applicabilityReason: explainRelevance(lesson, error),\n        });\n        break; // One recommendation per lesson\n      }\n    }\n  }\n\n  return recommendations\n    .sort((a, b) => b.relevanceScore - a.relevanceScore)\n    .slice(0, maxRecommendations);\n}\n\nfunction calculateRelevance(lesson: LessonLearned, error: ErrorAnalysis): number {\n  let score = 0;\n\n  // Same error category is highly relevant\n  if (lesson.context.errorCategory === error.category) {\n    score += 0.5;\n  }\n\n  // Similar selector patterns\n  if (lesson.context.originalSelector && error.selector) {\n    const similarity = calculateSelectorSimilarity(\n      lesson.context.originalSelector,\n      error.selector\n    );\n    score += similarity * 0.3;\n  }\n\n  // Lesson type matches suggested fix types\n  const suggestedFixes = getSuggestedFixTypesForLesson(error.category);\n  if (suggestedFixes.includes(lessonTypeToFixType(lesson.type))) {\n    score += 0.2;\n  }\n\n  return score;\n}\n\nfunction calculateSelectorSimilarity(selector1: string, selector2: string): number {\n  // Simple similarity based on common strategies\n  const strategy1 = extractSelectorStrategy(selector1);\n  const strategy2 = extractSelectorStrategy(selector2);\n\n  if (strategy1 === strategy2) {\n    return 0.8;\n  }\n\n  // Both are attribute-based\n  if (['testid', 'role', 'label'].includes(strategy1) &&\n      ['testid', 'role', 'label'].includes(strategy2)) {\n    return 0.5;\n  }\n\n  return 0.2;\n}\n\nfunction extractSelectorStrategy(selector: string): string {\n  if (selector.includes('data-testid')) return 'testid';\n  if (selector.includes('role=')) return 'role';\n  if (selector.includes('aria-label')) return 'label';\n  if (selector.match(/^[.#]/)) return 'css';\n  return 'other';\n}\n\nfunction explainRelevance(lesson: LessonLearned, error: ErrorAnalysis): string {\n  const reasons: string[] = [];\n\n  if (lesson.context.errorCategory === error.category) {\n    reasons.push(`Same error type: ${error.category}`);\n  }\n\n  if (lesson.context.originalSelector && error.selector) {\n    reasons.push('Similar selector pattern');\n  }\n\n  reasons.push(`Solution: ${lesson.solution.pattern}`);\n\n  return reasons.join('; ');\n}\n\nfunction getSuggestedFixTypesForLesson(category: ErrorCategory): string[] {\n  switch (category) {\n    case 'SELECTOR_NOT_FOUND':\n      return ['SELECTOR_CHANGE', 'LOCATOR_STRATEGY_CHANGED'];\n    case 'TIMEOUT':\n      return ['WAIT_ADDED', 'TIMEOUT_INCREASED'];\n    case 'ASSERTION_FAILED':\n      return ['ASSERTION_MODIFIED'];\n    default:\n      return ['OTHER'];\n  }\n}\n\nfunction lessonTypeToFixType(lessonType: LessonLearned['type']): string {\n  switch (lessonType) {\n    case 'selector_pattern':\n      return 'SELECTOR_CHANGE';\n    case 'wait_strategy':\n      return 'WAIT_ADDED';\n    case 'flow_pattern':\n      return 'FLOW_REORDERED';\n    case 'error_fix':\n      return 'OTHER';\n  }\n}\n","/**\n * @module refinement/llkb-storage\n * @description LLKB (Living Learned Knowledge Base) storage for refinement lessons\n *\n * Persists lessons learned during test generation and refinement cycles\n * so they can be reused in future generation runs.\n *\n * @see research/2026-02-02_autogen-enhancement-implementation-plan.md\n */\nimport { readFileSync, writeFileSync, existsSync, mkdirSync } from 'node:fs';\nimport { join, dirname } from 'node:path';\nimport { getLlkbRoot } from '../utils/paths.js';\n\n// \n// TYPES\n// \n\nexport interface LlkbLesson {\n  id: string;\n  type: LessonType;\n  pattern: string;\n  context: LessonContext;\n  fix: LessonFix;\n  confidence: number;\n  successCount: number;\n  failureCount: number;\n  createdAt: string;\n  lastUsedAt?: string;\n  lastSuccessAt?: string;\n}\n\nexport type LessonType =\n  | 'selector'      // Selector strategy lesson\n  | 'timing'        // Wait/timeout adjustment\n  | 'assertion'     // Assertion pattern\n  | 'navigation'    // Navigation pattern\n  | 'form'          // Form interaction pattern\n  | 'error-fix';    // Error  fix mapping\n\nexport interface LessonContext {\n  errorType?: string;\n  errorMessage?: string;\n  stepType?: string;\n  pageContext?: string;\n  componentType?: string;\n}\n\nexport interface LessonFix {\n  type: 'replace' | 'insert' | 'wrap' | 'config';\n  pattern: string;\n  replacement: string;\n  explanation: string;\n}\n\nexport interface LlkbStore {\n  version: '1.0';\n  lessons: LlkbLesson[];\n  stats: LlkbStats;\n  lastUpdated: string;\n}\n\nexport interface LlkbStats {\n  totalLessons: number;\n  lessonsByType: Record<LessonType, number>;\n  avgConfidence: number;\n  totalApplications: number;\n  successRate: number;\n}\n\n// \n// STORAGE\n// \n\nconst LLKB_REFINEMENT_FILE = 'refinement-lessons.json';\n\n/**\n * Get the path to the LLKB refinement lessons file\n */\nexport function getLlkbRefinementPath(): string {\n  return join(getLlkbRoot(), LLKB_REFINEMENT_FILE);\n}\n\n/**\n * Create an empty LLKB store\n */\nfunction createEmptyStore(): LlkbStore {\n  return {\n    version: '1.0',\n    lessons: [],\n    stats: {\n      totalLessons: 0,\n      lessonsByType: {\n        'selector': 0,\n        'timing': 0,\n        'assertion': 0,\n        'navigation': 0,\n        'form': 0,\n        'error-fix': 0,\n      },\n      avgConfidence: 0,\n      totalApplications: 0,\n      successRate: 0,\n    },\n    lastUpdated: new Date().toISOString(),\n  };\n}\n\n/**\n * Load the LLKB store from disk\n */\nexport function loadLlkbStore(): LlkbStore {\n  const path = getLlkbRefinementPath();\n\n  if (!existsSync(path)) {\n    return createEmptyStore();\n  }\n\n  try {\n    const content = readFileSync(path, 'utf-8');\n    return JSON.parse(content) as LlkbStore;\n  } catch {\n    // Return empty store on parse error\n    return createEmptyStore();\n  }\n}\n\n/**\n * Save the LLKB store to disk\n */\nexport function saveLlkbStore(store: LlkbStore): void {\n  const path = getLlkbRefinementPath();\n  const dir = dirname(path);\n\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n\n  store.lastUpdated = new Date().toISOString();\n  updateStats(store);\n\n  writeFileSync(path, JSON.stringify(store, null, 2), 'utf-8');\n}\n\n/**\n * Update store statistics\n */\nfunction updateStats(store: LlkbStore): void {\n  const stats = store.stats;\n  stats.totalLessons = store.lessons.length;\n\n  // Reset type counts\n  for (const type of Object.keys(stats.lessonsByType) as LessonType[]) {\n    stats.lessonsByType[type] = 0;\n  }\n\n  // Count lessons by type and calculate averages\n  let totalConfidence = 0;\n  let totalApplications = 0;\n  let totalSuccesses = 0;\n\n  for (const lesson of store.lessons) {\n    stats.lessonsByType[lesson.type]++;\n    totalConfidence += lesson.confidence;\n    totalApplications += lesson.successCount + lesson.failureCount;\n    totalSuccesses += lesson.successCount;\n  }\n\n  stats.avgConfidence = store.lessons.length > 0\n    ? totalConfidence / store.lessons.length\n    : 0;\n\n  stats.totalApplications = totalApplications;\n  stats.successRate = totalApplications > 0\n    ? totalSuccesses / totalApplications\n    : 0;\n}\n\n// \n// LESSON MANAGEMENT\n// \n\n/**\n * Generate a unique lesson ID\n */\nfunction generateLessonId(type: LessonType, pattern: string): string {\n  const hash = pattern.split('').reduce((a, b) => {\n    a = ((a << 5) - a) + b.charCodeAt(0);\n    return a & a;\n  }, 0);\n  return `${type}-${Math.abs(hash).toString(36)}`;\n}\n\n/**\n * Find an existing lesson by type and pattern\n */\nexport function findLesson(\n  store: LlkbStore,\n  type: LessonType,\n  pattern: string\n): LlkbLesson | undefined {\n  return store.lessons.find(l =>\n    l.type === type && l.pattern === pattern\n  );\n}\n\n/**\n * Find lessons matching a context\n */\nexport function findLessonsForContext(\n  store: LlkbStore,\n  context: Partial<LessonContext>,\n  minConfidence = 0.5\n): LlkbLesson[] {\n  return store.lessons.filter(lesson => {\n    // Must meet minimum confidence\n    if (lesson.confidence < minConfidence) {\n      return false;\n    }\n\n    // Match context fields\n    const lc = lesson.context;\n\n    if (context.errorType && lc.errorType !== context.errorType) {\n      return false;\n    }\n\n    if (context.stepType && lc.stepType !== context.stepType) {\n      return false;\n    }\n\n    if (context.componentType && lc.componentType !== context.componentType) {\n      return false;\n    }\n\n    // Partial match on error message\n    if (context.errorMessage && lc.errorMessage) {\n      const contextWords = context.errorMessage.toLowerCase().split(/\\s+/);\n      const lessonWords = lc.errorMessage.toLowerCase().split(/\\s+/);\n      const overlap = contextWords.filter(w => lessonWords.includes(w));\n      if (overlap.length < Math.min(3, contextWords.length * 0.5)) {\n        return false;\n      }\n    }\n\n    return true;\n  }).sort((a, b) => b.confidence - a.confidence);\n}\n\n/**\n * Add or update a lesson\n */\nexport function addLesson(\n  store: LlkbStore,\n  type: LessonType,\n  pattern: string,\n  context: LessonContext,\n  fix: LessonFix,\n  initialConfidence = 0.5\n): LlkbLesson {\n  const existing = findLesson(store, type, pattern);\n\n  if (existing) {\n    // Update existing lesson\n    existing.context = { ...existing.context, ...context };\n    existing.fix = fix;\n    existing.lastUsedAt = new Date().toISOString();\n    return existing;\n  }\n\n  // Create new lesson\n  const lesson: LlkbLesson = {\n    id: generateLessonId(type, pattern),\n    type,\n    pattern,\n    context,\n    fix,\n    confidence: initialConfidence,\n    successCount: 0,\n    failureCount: 0,\n    createdAt: new Date().toISOString(),\n  };\n\n  store.lessons.push(lesson);\n  return lesson;\n}\n\n/**\n * Record a successful application of a lesson\n */\nexport function recordSuccess(store: LlkbStore, lessonId: string): void {\n  const lesson = store.lessons.find(l => l.id === lessonId);\n  if (lesson) {\n    lesson.successCount++;\n    lesson.lastSuccessAt = new Date().toISOString();\n    lesson.lastUsedAt = new Date().toISOString();\n\n    // Increase confidence (capped at 0.95)\n    lesson.confidence = Math.min(0.95, lesson.confidence + 0.05);\n  }\n}\n\n/**\n * Record a failed application of a lesson\n */\nexport function recordFailure(store: LlkbStore, lessonId: string): void {\n  const lesson = store.lessons.find(l => l.id === lessonId);\n  if (lesson) {\n    lesson.failureCount++;\n    lesson.lastUsedAt = new Date().toISOString();\n\n    // Decrease confidence (floored at 0.1)\n    lesson.confidence = Math.max(0.1, lesson.confidence - 0.1);\n  }\n}\n\n/**\n * Remove low-confidence lessons\n */\nexport function pruneLessons(\n  store: LlkbStore,\n  minConfidence = 0.2,\n  minApplications = 3\n): number {\n  const before = store.lessons.length;\n\n  store.lessons = store.lessons.filter(lesson => {\n    const applications = lesson.successCount + lesson.failureCount;\n    // Keep if not enough applications yet OR confidence is good\n    return applications < minApplications || lesson.confidence >= minConfidence;\n  });\n\n  return before - store.lessons.length;\n}\n\n// \n// REFINEMENT INTEGRATION\n// \n\n/**\n * Learn from a successful refinement\n */\nexport function learnFromRefinement(\n  errorType: string,\n  errorMessage: string,\n  originalCode: string,\n  fixedCode: string,\n  stepType?: string\n): LlkbLesson {\n  const store = loadLlkbStore();\n\n  // Create pattern from error\n  const pattern = `${errorType}:${errorMessage.substring(0, 50)}`;\n\n  // Determine fix type\n  let fixType: LessonFix['type'] = 'replace';\n  if (fixedCode.length > originalCode.length * 1.5) {\n    fixType = 'wrap';\n  } else if (!originalCode.trim()) {\n    fixType = 'insert';\n  }\n\n  const lesson = addLesson(\n    store,\n    'error-fix',\n    pattern,\n    {\n      errorType,\n      errorMessage: errorMessage.substring(0, 200),\n      stepType,\n    },\n    {\n      type: fixType,\n      pattern: originalCode,\n      replacement: fixedCode,\n      explanation: `Fix for ${errorType} error`,\n    },\n    0.6 // Start with higher confidence since it worked\n  );\n\n  recordSuccess(store, lesson.id);\n  saveLlkbStore(store);\n\n  return lesson;\n}\n\n/**\n * Get suggested fixes for an error\n */\nexport function getSuggestedFixes(\n  errorType: string,\n  errorMessage: string,\n  stepType?: string\n): LlkbLesson[] {\n  const store = loadLlkbStore();\n\n  return findLessonsForContext(store, {\n    errorType,\n    errorMessage,\n    stepType,\n  });\n}\n\n/**\n * Apply a learned fix and record result\n */\nexport function applyLearnedFix(\n  lessonId: string,\n  success: boolean\n): void {\n  const store = loadLlkbStore();\n\n  if (success) {\n    recordSuccess(store, lessonId);\n  } else {\n    recordFailure(store, lessonId);\n  }\n\n  saveLlkbStore(store);\n}\n\n// \n// EXPORT FOR ORCHESTRATOR\n// \n\n/**\n * Export lessons as JSON for the orchestrating LLM\n */\nexport function exportLessonsForOrchestrator(): {\n  lessons: LlkbLesson[];\n  stats: LlkbStats;\n  exportedAt: string;\n} {\n  const store = loadLlkbStore();\n\n  // Only export high-confidence lessons\n  const exportLessons = store.lessons\n    .filter(l => l.confidence >= 0.5)\n    .sort((a, b) => b.confidence - a.confidence)\n    .slice(0, 100); // Limit to top 100\n\n  return {\n    lessons: exportLessons,\n    stats: store.stats,\n    exportedAt: new Date().toISOString(),\n  };\n}\n","/**\n * @module refinement/playwright-runner\n * @description Playwright test runner for refinement and verification\n *\n * Provides a reusable interface for running Playwright tests and\n * capturing structured results for the orchestrating LLM.\n *\n * @see research/2026-02-02_autogen-enhancement-implementation-plan.md\n */\nimport { spawn, type SpawnOptions } from 'node:child_process';\nimport { existsSync, readFileSync, mkdirSync, unlinkSync } from 'node:fs';\nimport { join } from 'node:path';\nimport { randomUUID } from 'node:crypto';\nimport { getHarnessRoot } from '../utils/paths.js';\n\n// \n// TYPES\n// \n\nexport interface PlaywrightRunOptions {\n  /** Test file(s) to run */\n  testFiles: string[];\n  /** Working directory (default: harness root) */\n  cwd?: string;\n  /** Timeout per test in ms (default: 30000) */\n  timeout?: number;\n  /** Number of retries (default: 0) */\n  retries?: number;\n  /** Run in headed mode */\n  headed?: boolean;\n  /** Run in debug mode (pause on failure) */\n  debug?: boolean;\n  /** Custom reporter (default: list) */\n  reporter?: string;\n  /** Additional Playwright args */\n  extraArgs?: string[];\n  /** Environment variables */\n  env?: Record<string, string>;\n  /** Grep filter for test names */\n  grep?: string;\n  /** Project to run */\n  project?: string;\n  /** Number of workers (default: 1 for sequential) */\n  workers?: number;\n}\n\nexport interface PlaywrightRunResult {\n  /** Overall status */\n  status: 'passed' | 'failed' | 'timeout' | 'error';\n  /** Exit code from Playwright */\n  exitCode: number;\n  /** Total duration in ms */\n  duration: number;\n  /** Test counts */\n  counts: {\n    total: number;\n    passed: number;\n    failed: number;\n    skipped: number;\n    flaky: number;\n  };\n  /** Parsed test failures */\n  failures: TestFailure[];\n  /** Raw stdout */\n  stdout: string;\n  /** Raw stderr */\n  stderr: string;\n  /** Path to generated report (if any) */\n  reportPath?: string;\n  /** Path to trace file (if any) */\n  tracePath?: string;\n}\n\nexport interface TestFailure {\n  /** Test title */\n  title: string;\n  /** Full test path */\n  fullTitle: string;\n  /** File path */\n  file: string;\n  /** Line number */\n  line?: number;\n  /** Error message */\n  error: string;\n  /** Error type classification */\n  errorType: ErrorType;\n  /** Stack trace excerpt */\n  stack?: string;\n  /** Duration of failed test */\n  duration?: number;\n  /** Retry count when failed */\n  retryCount?: number;\n}\n\nexport type ErrorType =\n  | 'selector'\n  | 'timeout'\n  | 'assertion'\n  | 'navigation'\n  | 'typescript'\n  | 'network'\n  | 'unknown';\n\n// \n// ERROR CLASSIFICATION\n// \n\nconst ERROR_PATTERNS: Array<{ type: ErrorType; patterns: RegExp[] }> = [\n  {\n    type: 'selector',\n    patterns: [\n      /locator.*not found/i,\n      /element.*not found/i,\n      /strict mode violation/i,\n      /resolved to \\d+ elements/i,\n      /waiting for locator/i,\n    ],\n  },\n  {\n    type: 'timeout',\n    patterns: [\n      /timeout.*exceeded/i,\n      /test.*timeout/i,\n      /exceeded.*timeout/i,\n      /timed out/i,\n    ],\n  },\n  {\n    type: 'assertion',\n    patterns: [\n      /expect.*received/i,\n      /assertion.*failed/i,\n      /toequal.*failed/i,\n      /tobehave.*failed/i,\n      /expected.*but got/i,\n    ],\n  },\n  {\n    type: 'navigation',\n    patterns: [\n      /page\\.goto/i,\n      /navigation.*failed/i,\n      /net::ERR/i,\n      /NS_ERROR/i,\n      /navigating to/i,\n    ],\n  },\n  {\n    type: 'typescript',\n    patterns: [\n      /syntaxerror/i,\n      /typeerror/i,\n      /referenceerror/i,\n      /ts\\(\\d+\\)/i,\n      /cannot find module/i,\n    ],\n  },\n  {\n    type: 'network',\n    patterns: [\n      /ECONNREFUSED/i,\n      /ENOTFOUND/i,\n      /network.*error/i,\n      /fetch.*failed/i,\n    ],\n  },\n];\n\nfunction classifyError(message: string): ErrorType {\n  for (const { type, patterns } of ERROR_PATTERNS) {\n    if (patterns.some(p => p.test(message))) {\n      return type;\n    }\n  }\n  return 'unknown';\n}\n\n// \n// JSON REPORTER TYPES (Playwright native format)\n// \n\ninterface PlaywrightJsonReport {\n  config: unknown;\n  suites: PlaywrightSuite[];\n  errors: PlaywrightError[];\n  stats: {\n    startTime: string;\n    duration: number;\n    expected: number;\n    unexpected: number;\n    skipped: number;\n    flaky: number;\n  };\n}\n\ninterface PlaywrightSuite {\n  title: string;\n  file: string;\n  line: number;\n  column: number;\n  specs: PlaywrightSpec[];\n  suites?: PlaywrightSuite[];\n}\n\ninterface PlaywrightSpec {\n  title: string;\n  ok: boolean;\n  tests: PlaywrightTest[];\n}\n\ninterface PlaywrightTest {\n  timeout: number;\n  annotations: unknown[];\n  expectedStatus: string;\n  projectId: string;\n  projectName: string;\n  results: PlaywrightTestResult[];\n  status: 'expected' | 'unexpected' | 'flaky' | 'skipped';\n}\n\ninterface PlaywrightTestResult {\n  workerIndex: number;\n  status: 'passed' | 'failed' | 'timedOut' | 'skipped' | 'interrupted';\n  duration: number;\n  error?: {\n    message?: string;\n    stack?: string;\n    location?: {\n      file: string;\n      line: number;\n      column: number;\n    };\n  };\n  stdout?: Array<{ text?: string; buffer?: string }>;\n  stderr?: Array<{ text?: string; buffer?: string }>;\n  retry: number;\n  attachments: unknown[];\n}\n\ninterface PlaywrightError {\n  message: string;\n  location?: {\n    file: string;\n    line: number;\n    column: number;\n  };\n}\n\n// \n// JSON REPORT PARSING (Primary - more reliable)\n// \n\nfunction parseJsonReport(jsonPath: string): { counts: PlaywrightRunResult['counts']; failures: TestFailure[] } | null {\n  try {\n    if (!existsSync(jsonPath)) {\n      return null;\n    }\n    const content = readFileSync(jsonPath, 'utf-8');\n    const report: PlaywrightJsonReport = JSON.parse(content);\n\n    // Parse counts from stats\n    const counts: PlaywrightRunResult['counts'] = {\n      total: (report.stats.expected ?? 0) + (report.stats.unexpected ?? 0) + (report.stats.skipped ?? 0) + (report.stats.flaky ?? 0),\n      passed: report.stats.expected ?? 0,\n      failed: report.stats.unexpected ?? 0,\n      skipped: report.stats.skipped ?? 0,\n      flaky: report.stats.flaky ?? 0,\n    };\n\n    // Parse failures from suites\n    const failures: TestFailure[] = [];\n    parseFailuresFromSuites(report.suites, failures);\n\n    // Also add global errors\n    for (const error of report.errors ?? []) {\n      failures.push({\n        title: 'Global Error',\n        fullTitle: 'Global Error',\n        file: error.location?.file ?? '',\n        line: error.location?.line,\n        error: error.message.substring(0, 500),\n        errorType: classifyError(error.message),\n      });\n    }\n\n    return { counts, failures };\n  } catch (err) {\n    // JSON parsing failed, will fallback to regex parsing\n    console.warn(`[playwright-runner] Failed to parse JSON report: ${err instanceof Error ? err.message : 'unknown'}`);\n    return null;\n  }\n}\n\nfunction parseFailuresFromSuites(suites: PlaywrightSuite[], failures: TestFailure[]): void {\n  for (const suite of suites) {\n    for (const spec of suite.specs ?? []) {\n      for (const test of spec.tests ?? []) {\n        if (test.status === 'unexpected' || test.status === 'flaky') {\n          // Get the last result (after retries)\n          const lastResult = test.results[test.results.length - 1];\n          if (lastResult?.error) {\n            failures.push({\n              title: spec.title,\n              fullTitle: `${suite.title} > ${spec.title}`,\n              file: suite.file,\n              line: suite.line,\n              error: (lastResult.error.message ?? 'Unknown error').substring(0, 500),\n              errorType: classifyError(lastResult.error.message ?? ''),\n              stack: lastResult.error.stack?.split('\\n').slice(0, 5).join('\\n'),\n              duration: lastResult.duration,\n              retryCount: lastResult.retry,\n            });\n          }\n        }\n      }\n    }\n\n    // Recurse into nested suites\n    if (suite.suites) {\n      parseFailuresFromSuites(suite.suites, failures);\n    }\n  }\n}\n\n// \n// STDOUT/STDERR PARSING (Fallback - less reliable)\n// \n\nfunction parseTestCounts(output: string): PlaywrightRunResult['counts'] {\n  const counts = {\n    total: 0,\n    passed: 0,\n    failed: 0,\n    skipped: 0,\n    flaky: 0,\n  };\n\n  // Try to parse Playwright summary line\n  // Format: \"X passed, Y failed, Z skipped\"\n  const summaryMatch = output.match(/(\\d+)\\s+passed.*?(\\d+)\\s+failed.*?(\\d+)\\s+skipped/i);\n  if (summaryMatch && summaryMatch[1] && summaryMatch[2] && summaryMatch[3]) {\n    counts.passed = parseInt(summaryMatch[1], 10);\n    counts.failed = parseInt(summaryMatch[2], 10);\n    counts.skipped = parseInt(summaryMatch[3], 10);\n    counts.total = counts.passed + counts.failed + counts.skipped;\n    return counts;\n  }\n\n  // Alternative: count individual test results\n  const passedMatches = output.match(/||passed/gi);\n  const failedMatches = output.match(/||failed/gi);\n  const skippedMatches = output.match(/|skipped/gi);\n\n  counts.passed = passedMatches?.length || 0;\n  counts.failed = failedMatches?.length || 0;\n  counts.skipped = skippedMatches?.length || 0;\n  counts.total = counts.passed + counts.failed + counts.skipped;\n\n  // Check for flaky tests\n  const flakyMatch = output.match(/(\\d+)\\s+flaky/i);\n  if (flakyMatch && flakyMatch[1]) {\n    counts.flaky = parseInt(flakyMatch[1], 10);\n  }\n\n  return counts;\n}\n\nfunction parseFailures(stdout: string, stderr: string): TestFailure[] {\n  const failures: TestFailure[] = [];\n  const combined = `${stdout}\\n${stderr}`;\n\n  // Split by error markers\n  const errorBlocks = combined.split(/(?=\\d+\\)\\s+\\[|Error:|\\s+\\d+\\s+)/);\n\n  for (const block of errorBlocks) {\n    if (!block.trim() || block.length < 30) continue;\n\n    // Skip non-error blocks\n    if (!block.includes('Error') && !block.includes('') && !block.includes('failed')) {\n      continue;\n    }\n\n    // Extract test title\n    const titleMatch = block.match(/(?:||\\d+\\))\\s+(?:\\[.*?\\])?\\s*(.+?)(?:\\(|at\\s|Error)/);\n    const title = (titleMatch && titleMatch[1]) ? titleMatch[1].trim() : 'Unknown test';\n\n    // Extract file location\n    const fileMatch = block.match(/([^\\s:]+\\.(?:ts|js)):(\\d+)/);\n    const file = (fileMatch && fileMatch[1]) ? fileMatch[1] : '';\n    const line = (fileMatch && fileMatch[2]) ? parseInt(fileMatch[2], 10) : undefined;\n\n    // Extract error message\n    const errorMatch = block.match(/Error:\\s*([^\\n]+)/);\n    const error = (errorMatch && errorMatch[1]) ? errorMatch[1].trim() : (block.split('\\n')[0]?.trim() || 'Unknown error');\n\n    // Extract stack trace (first few lines)\n    const stackLines = block.split('\\n')\n      .filter(l => l.trim().startsWith('at '))\n      .slice(0, 5);\n    const stack = stackLines.length > 0 ? stackLines.join('\\n') : undefined;\n\n    // Extract duration if available\n    const durationMatch = block.match(/(\\d+(?:\\.\\d+)?)\\s*(?:ms|s)/);\n    const duration = (durationMatch && durationMatch[1])\n      ? parseFloat(durationMatch[1]) * (durationMatch[0].includes('s') && !durationMatch[0].includes('ms') ? 1000 : 1)\n      : undefined;\n\n    failures.push({\n      title,\n      fullTitle: title,\n      file,\n      line,\n      error: error.substring(0, 500),\n      errorType: classifyError(error),\n      stack,\n      duration,\n    });\n  }\n\n  return failures;\n}\n\n// \n// RUNNER\n// \n\n/**\n * Run Playwright tests and return structured results\n *\n * Uses JSON reporter for reliable parsing, with stdout/stderr regex as fallback.\n */\nexport async function runPlaywright(options: PlaywrightRunOptions): Promise<PlaywrightRunResult> {\n  const {\n    testFiles,\n    cwd = getHarnessRoot(),\n    timeout = 30000,\n    retries = 0,\n    headed = false,\n    debug = false,\n    reporter = 'list',\n    extraArgs = [],\n    env = {},\n    grep,\n    project,\n    workers = 1,\n  } = options;\n\n  const startTime = Date.now();\n\n  // Generate unique JSON report path in temp directory\n  const jsonReportDir = join(cwd, '.artk', 'autogen', 'temp');\n  const jsonReportPath = join(jsonReportDir, `playwright-report-${randomUUID()}.json`);\n\n  // Ensure temp directory exists\n  mkdirSync(jsonReportDir, { recursive: true });\n\n  // Build command args - use both JSON reporter (for parsing) and user's reporter (for display)\n  const args = [\n    'playwright', 'test',\n    ...testFiles,\n    `--timeout=${timeout}`,\n    `--retries=${retries}`,\n    // Use multiple reporters: JSON for parsing + user's choice for display\n    `--reporter=json,${reporter}`,\n    `--workers=${workers}`,\n  ];\n\n  if (headed) args.push('--headed');\n  if (debug) args.push('--debug');\n  if (grep) args.push(`--grep=${grep}`);\n  if (project) args.push(`--project=${project}`);\n  args.push(...extraArgs);\n\n  return new Promise((resolve) => {\n    let stdout = '';\n    let stderr = '';\n\n    // SECURITY: shell: false (default) prevents command injection via grep/extraArgs\n    // This is critical because `grep` parameter comes from user input\n    // Node.js v14.18+ handles .cmd/.bat files on Windows automatically\n    const spawnOptions: SpawnOptions = {\n      cwd,\n      env: {\n        ...process.env,\n        ...env,\n        FORCE_COLOR: '1', // Force colored output for display reporter\n        PLAYWRIGHT_JSON_OUTPUT_NAME: jsonReportPath, // Direct JSON output to our file\n      },\n    };\n\n    const proc = spawn('npx', args, spawnOptions);\n\n    proc.stdout?.on('data', (data) => {\n      stdout += data.toString();\n    });\n\n    proc.stderr?.on('data', (data) => {\n      stderr += data.toString();\n    });\n\n    proc.on('close', (code) => {\n      const duration = Date.now() - startTime;\n      const exitCode = code ?? 1;\n\n      // PRIMARY: Try to parse from JSON report (more reliable)\n      let counts: PlaywrightRunResult['counts'];\n      let failures: TestFailure[];\n\n      const jsonResult = parseJsonReport(jsonReportPath);\n      if (jsonResult) {\n        counts = jsonResult.counts;\n        failures = jsonResult.failures;\n      } else {\n        // FALLBACK: Parse from stdout/stderr (less reliable)\n        console.warn('[playwright-runner] JSON report not available, falling back to stdout parsing');\n        counts = parseTestCounts(stdout);\n        failures = parseFailures(stdout, stderr);\n      }\n\n      // Clean up temp JSON file\n      try {\n        if (existsSync(jsonReportPath)) {\n          unlinkSync(jsonReportPath);\n        }\n      } catch {\n        // Ignore cleanup errors\n      }\n\n      // Determine overall status\n      let status: PlaywrightRunResult['status'] = 'passed';\n      if (exitCode !== 0) {\n        if (stdout.includes('timeout') || stderr.includes('timeout') || failures.some(f => f.errorType === 'timeout')) {\n          status = 'timeout';\n        } else if (failures.length > 0 || counts.failed > 0) {\n          status = 'failed';\n        } else {\n          status = 'error';\n        }\n      }\n\n      // Find report/trace paths\n      let reportPath: string | undefined;\n      let tracePath: string | undefined;\n\n      const reportDir = join(cwd, 'playwright-report');\n      if (existsSync(join(reportDir, 'index.html'))) {\n        reportPath = join(reportDir, 'index.html');\n      }\n\n      const testResultsDir = join(cwd, 'test-results');\n      if (existsSync(testResultsDir)) {\n        // Look for trace files\n        const traceFile = join(testResultsDir, 'trace.zip');\n        if (existsSync(traceFile)) {\n          tracePath = traceFile;\n        }\n      }\n\n      resolve({\n        status,\n        exitCode,\n        duration,\n        counts,\n        failures,\n        stdout: stdout.substring(0, 50000), // Limit size\n        stderr: stderr.substring(0, 50000),\n        reportPath,\n        tracePath,\n      });\n    });\n\n    proc.on('error', (err) => {\n      // Clean up temp JSON file on error\n      try {\n        if (existsSync(jsonReportPath)) {\n          unlinkSync(jsonReportPath);\n        }\n      } catch {\n        // Ignore cleanup errors\n      }\n\n      resolve({\n        status: 'error',\n        exitCode: 1,\n        duration: Date.now() - startTime,\n        counts: { total: 0, passed: 0, failed: 0, skipped: 0, flaky: 0 },\n        failures: [{\n          title: 'Runner Error',\n          fullTitle: 'Runner Error',\n          file: '',\n          error: `Failed to spawn Playwright: ${err.message}`,\n          errorType: 'unknown',\n        }],\n        stdout: '',\n        stderr: err.message,\n      });\n    });\n  });\n}\n\n/**\n * Run a single test file and return results\n */\nexport async function runSingleTest(\n  testFile: string,\n  options: Omit<PlaywrightRunOptions, 'testFiles'> = {}\n): Promise<PlaywrightRunResult> {\n  return runPlaywright({\n    ...options,\n    testFiles: [testFile],\n  });\n}\n\n/**\n * Quick check if a test passes (minimal output)\n */\nexport async function quickCheck(testFile: string, cwd?: string): Promise<boolean> {\n  const result = await runSingleTest(testFile, {\n    cwd,\n    timeout: 60000,\n    retries: 0,\n    workers: 1,\n  });\n  return result.status === 'passed';\n}\n\n// \n// UTILITIES\n// \n\n/**\n * Check if Playwright is installed and accessible\n */\nexport async function checkPlaywrightInstalled(cwd?: string): Promise<{\n  installed: boolean;\n  version?: string;\n  error?: string;\n}> {\n  return new Promise((resolve) => {\n    // SECURITY: shell: false (default) is safer\n    // Node.js v14.18+ handles .cmd/.bat files on Windows automatically\n    const proc = spawn('npx', ['playwright', '--version'], {\n      cwd: cwd || getHarnessRoot(),\n      env: process.env,\n    });\n\n    let stdout = '';\n    let stderr = '';\n\n    proc.stdout?.on('data', (data) => {\n      stdout += data.toString();\n    });\n\n    proc.stderr?.on('data', (data) => {\n      stderr += data.toString();\n    });\n\n    proc.on('close', (code) => {\n      if (code === 0) {\n        // Extract version from output (format: \"Version X.Y.Z\")\n        const versionMatch = stdout.match(/(\\d+\\.\\d+\\.\\d+)/);\n        resolve({\n          installed: true,\n          version: (versionMatch && versionMatch[1]) ? versionMatch[1] : undefined,\n        });\n      } else {\n        resolve({\n          installed: false,\n          error: stderr || 'Playwright not found. Run: npx playwright install',\n        });\n      }\n    });\n\n    proc.on('error', (err) => {\n      resolve({\n        installed: false,\n        error: `Failed to check Playwright: ${err.message}`,\n      });\n    });\n\n    // Timeout after 10 seconds\n    setTimeout(() => {\n      proc.kill();\n      resolve({\n        installed: false,\n        error: 'Playwright check timed out',\n      });\n    }, 10000);\n  });\n}\n\n/**\n * Format failures for display\n */\nexport function formatFailures(failures: TestFailure[]): string {\n  return failures.map((f, i) => {\n    const lines = [\n      `${i + 1}) ${f.title}`,\n      `   File: ${f.file}${f.line ? `:${f.line}` : ''}`,\n      `   Error [${f.errorType}]: ${f.error}`,\n    ];\n    if (f.stack) {\n      lines.push(`   Stack:\\n${f.stack.split('\\n').map(l => `      ${l}`).join('\\n')}`);\n    }\n    return lines.join('\\n');\n  }).join('\\n\\n');\n}\n\n/**\n * Get summary string\n */\nexport function formatSummary(result: PlaywrightRunResult): string {\n  const { counts, duration, status } = result;\n  const durationSec = (duration / 1000).toFixed(1);\n\n  let summary = `Status: ${status.toUpperCase()}\\n`;\n  summary += `Duration: ${durationSec}s\\n`;\n  summary += `Tests: ${counts.passed}/${counts.total} passed`;\n\n  if (counts.failed > 0) {\n    summary += `, ${counts.failed} failed`;\n  }\n  if (counts.skipped > 0) {\n    summary += `, ${counts.skipped} skipped`;\n  }\n  if (counts.flaky > 0) {\n    summary += `, ${counts.flaky} flaky`;\n  }\n\n  return summary;\n}\n","/**\n * @module refinement\n * @description Self-Refinement strategy for iterative test fixing\n */\n\n// Types\nexport * from './types.js';\n\n// Error Parser\nexport {\n  parseError,\n  parseErrors,\n  parsePlaywrightReport,\n  isSelectorRelated,\n  isTimingRelated,\n  isEnvironmentalError,\n  isCodeError,\n  getSuggestedFixTypes,\n  type ParseErrorOptions,\n  type PlaywrightJsonReport,\n} from './error-parser.js';\n\n// Convergence Detection\nexport {\n  CircuitBreaker,\n  ConvergenceDetector,\n  analyzeRefinementProgress,\n  DEFAULT_CIRCUIT_BREAKER_CONFIG,\n  type RefinementAnalysis,\n} from './convergence-detector.js';\n\n// Refinement Loop\nexport {\n  runRefinementLoop,\n  runSingleRefinementAttempt,\n  type RefinementLLMClient,\n  type FixGenerationOptions,\n  type FixGenerationResult,\n  type TestRunner,\n  type RefinementOptions,\n  type RefinementProgress,\n} from './refinement-loop.js';\n\n// LLKB Learning\nexport {\n  extractLessonsFromSession,\n  aggregateLessons,\n  calculateConfidenceAdjustment,\n  applyConfidenceDecay,\n  recommendLessons,\n  type LLKBStorage,\n  type LessonFilter,\n  type LessonExtractionOptions,\n  type AggregatedPattern,\n  type ConfidenceAdjustment,\n  type LessonRecommendation,\n} from './llkb-learning.js';\n\n// LLKB Storage (Refinement-specific persistence)\nexport {\n  loadLlkbStore,\n  saveLlkbStore,\n  findLesson,\n  findLessonsForContext,\n  addLesson,\n  recordSuccess,\n  recordFailure,\n  pruneLessons,\n  learnFromRefinement,\n  getSuggestedFixes,\n  applyLearnedFix,\n  exportLessonsForOrchestrator,\n  getLlkbRefinementPath,\n  type LlkbLesson,\n  type LessonType,\n  type LessonContext,\n  type LessonFix,\n  type LlkbStore,\n  type LlkbStats,\n} from './llkb-storage.js';\n\n// Playwright Runner (Hybrid Agentic Architecture)\nexport {\n  runPlaywright,\n  runSingleTest,\n  quickCheck,\n  formatFailures,\n  formatSummary,\n  type PlaywrightRunOptions,\n  type PlaywrightRunResult,\n  type TestFailure,\n  type ErrorType,\n} from './playwright-runner.js';\n","/**\n * @module uncertainty/types\n * @description Type definitions for Uncertainty Quantification strategy\n */\n\nimport { TokenUsage } from '../shared/types.js';\n\n// \n// CONFIDENCE DIMENSIONS\n// \n\nexport type ConfidenceDimension = 'syntax' | 'pattern' | 'selector' | 'agreement';\n\nexport interface DimensionScore {\n  dimension: ConfidenceDimension;\n  score: number; // 0.0 - 1.0\n  weight: number;\n  reasoning: string;\n  subScores?: SubScore[];\n}\n\nexport interface SubScore {\n  name: string;\n  score: number;\n  details?: string;\n}\n\n// \n// SYNTAX VALIDATION\n// \n\nexport interface SyntaxValidationResult {\n  valid: boolean;\n  score: number;\n  errors: SyntaxError[];\n  warnings: SyntaxWarning[];\n  typescript: TypeScriptValidation;\n  playwright: PlaywrightValidation;\n}\n\nexport interface SyntaxError {\n  line: number;\n  column: number;\n  message: string;\n  code: string;\n  severity: 'error' | 'warning';\n}\n\nexport interface SyntaxWarning {\n  line: number;\n  message: string;\n  suggestion?: string;\n}\n\nexport interface TypeScriptValidation {\n  compiles: boolean;\n  errors: SyntaxError[];\n  typeInferenceScore: number;\n}\n\nexport interface PlaywrightValidation {\n  hasValidImports: boolean;\n  usesTestFixtures: boolean;\n  hasValidTestBlocks: boolean;\n  apiUsageScore: number;\n  deprecatedAPIs: string[];\n}\n\n// \n// PATTERN MATCHING\n// \n\nexport interface PatternMatchResult {\n  score: number;\n  matchedPatterns: MatchedPattern[];\n  unmatchedElements: UnmatchedElement[];\n  noveltyScore: number;\n  consistencyScore: number;\n}\n\nexport interface MatchedPattern {\n  patternId: string;\n  patternName: string;\n  confidence: number;\n  codeLocation: {\n    startLine: number;\n    endLine: number;\n  };\n  source: 'glossary' | 'llkb' | 'builtin' | 'inferred';\n}\n\nexport interface UnmatchedElement {\n  element: string;\n  reason: string;\n  suggestedPatterns: string[];\n  riskLevel: 'low' | 'medium' | 'high';\n}\n\n// \n// SELECTOR ANALYSIS\n// \n\nexport type SelectorStrategy =\n  | 'testId'\n  | 'role'\n  | 'text'\n  | 'label'\n  | 'placeholder'\n  | 'title'\n  | 'altText'\n  | 'css'\n  | 'xpath'\n  | 'nth'\n  | 'chain';\n\nexport interface SelectorAnalysisResult {\n  score: number;\n  selectors: SelectorInfo[];\n  strategyDistribution: Record<SelectorStrategy, number>;\n  stabilityScore: number;\n  accessibilityScore: number;\n  recommendations: SelectorRecommendation[];\n}\n\nexport interface SelectorInfo {\n  selector: string;\n  strategy: SelectorStrategy;\n  stabilityScore: number;\n  specificity: number;\n  hasTestId: boolean;\n  usesRole: boolean;\n  isFragile: boolean;\n  fragilityReasons: string[];\n  line: number;\n}\n\nexport interface SelectorRecommendation {\n  selector: string;\n  currentStrategy: SelectorStrategy;\n  suggestedStrategy: SelectorStrategy;\n  reason: string;\n  priority: 'low' | 'medium' | 'high';\n}\n\n// \n// MULTI-SAMPLE AGREEMENT\n// \n\nexport interface AgreementAnalysisResult {\n  score: number;\n  sampleCount: number;\n  structuralAgreement: number;\n  selectorAgreement: number;\n  flowAgreement: number;\n  assertionAgreement: number;\n  consensusCode?: string;\n  disagreementAreas: DisagreementArea[];\n}\n\nexport interface DisagreementArea {\n  area: string;\n  variants: string[];\n  voteCounts: Record<string, number>;\n  selectedVariant?: string;\n  confidence: number;\n}\n\nexport interface CodeSample {\n  id: string;\n  code: string;\n  temperature: number;\n  tokenUsage?: TokenUsage;\n}\n\n// \n// OVERALL CONFIDENCE\n// \n\nexport interface ConfidenceScore {\n  overall: number;\n  dimensions: DimensionScore[];\n  threshold: ConfidenceThreshold;\n  verdict: ConfidenceVerdict;\n  blockedDimensions: ConfidenceDimension[];\n  diagnostics: ConfidenceDiagnostics;\n}\n\nexport type ConfidenceVerdict = 'ACCEPT' | 'REVIEW' | 'REJECT';\n\nexport interface ConfidenceThreshold {\n  overall: number;\n  perDimension: Record<ConfidenceDimension, number>;\n  blockOnAnyBelow: number;\n}\n\nexport interface ConfidenceDiagnostics {\n  lowestDimension: {\n    name: ConfidenceDimension;\n    score: number;\n  };\n  highestDimension: {\n    name: ConfidenceDimension;\n    score: number;\n  };\n  improvementSuggestions: string[];\n  riskAreas: string[];\n}\n\n// \n// SCORING OPTIONS\n// \n\nexport interface ScoringOptions {\n  weights: DimensionWeights;\n  thresholds: ConfidenceThreshold;\n  enableMultiSampling: boolean;\n  sampleCount: number;\n  sampleTemperatures: number[];\n}\n\nexport interface DimensionWeights {\n  syntax: number;\n  pattern: number;\n  selector: number;\n  agreement: number;\n}\n\nexport const DEFAULT_DIMENSION_WEIGHTS: DimensionWeights = {\n  syntax: 0.25,\n  pattern: 0.25,\n  selector: 0.30,\n  agreement: 0.20,\n};\n\nexport const DEFAULT_THRESHOLDS: ConfidenceThreshold = {\n  overall: 0.7,\n  perDimension: {\n    syntax: 0.9,      // Syntax must be very high\n    pattern: 0.6,\n    selector: 0.7,\n    agreement: 0.5,   // Agreement can be lower if single sample\n  },\n  blockOnAnyBelow: 0.4,\n};\n\n// \n// UNCERTAINTY CONFIG (imported from shared, re-exported for convenience)\n// \n\nexport type { UncertaintyConfig } from '../shared/config-validator.js';\n","/**\n * @module uncertainty/syntax-validator\n * @description Validate TypeScript and Playwright syntax\n */\n\nimport {\n  SyntaxValidationResult,\n  SyntaxError,\n  SyntaxWarning,\n  TypeScriptValidation,\n  PlaywrightValidation,\n  DimensionScore,\n} from './types.js';\n\n// \n// VALIDATION PATTERNS\n// \n\nconst PLAYWRIGHT_IMPORTS = [\n  '@playwright/test',\n  'playwright',\n];\n\nconst PLAYWRIGHT_TEST_PATTERNS = [\n  /test\\s*\\(\\s*['\"`]/,\n  /test\\.describe\\s*\\(\\s*['\"`]/,\n  /test\\.beforeEach\\s*\\(/,\n  /test\\.afterEach\\s*\\(/,\n  /test\\.beforeAll\\s*\\(/,\n  /test\\.afterAll\\s*\\(/,\n];\n\nconst PLAYWRIGHT_FIXTURE_PATTERNS = [\n  /\\{\\s*page\\s*\\}/,\n  /\\{\\s*page\\s*,/,\n  /,\\s*page\\s*\\}/,\n  /\\{\\s*browser\\s*\\}/,\n  /\\{\\s*context\\s*\\}/,\n  /\\{\\s*request\\s*\\}/,\n];\n\nconst DEPRECATED_APIS = [\n  { pattern: /page\\.waitForTimeout\\s*\\(\\s*\\d+\\s*\\)/g, api: 'waitForTimeout with fixed delay', suggestion: 'Use waitForSelector or expect assertions' },\n  { pattern: /page\\.\\$\\(/g, api: 'page.$()', suggestion: 'Use page.locator()' },\n  { pattern: /page\\.\\$\\$\\(/g, api: 'page.$$()', suggestion: 'Use page.locator().all()' },\n  { pattern: /page\\.waitForSelector\\(/g, api: 'waitForSelector', suggestion: 'Use locator.waitFor() or expect assertions' },\n  { pattern: /elementHandle\\./g, api: 'ElementHandle', suggestion: 'Use Locator API instead' },\n  { pattern: /page\\.click\\(/g, api: 'page.click()', suggestion: 'Use locator.click()' },\n  { pattern: /page\\.fill\\(/g, api: 'page.fill()', suggestion: 'Use locator.fill()' },\n  { pattern: /page\\.type\\(/g, api: 'page.type()', suggestion: 'Use locator.fill() or locator.pressSequentially()' },\n];\n\nconst SYNTAX_ERROR_PATTERNS = [\n  { pattern: /await\\s+await\\s+/g, message: 'Duplicate await', severity: 'error' as const },\n  { pattern: /\\}\\s*\\)\\s*;?\\s*\\)\\s*;/g, message: 'Unbalanced parentheses/braces', severity: 'error' as const },\n  { pattern: /\\(\\s*\\)\\s*=>\\s*\\{[^}]*$/m, message: 'Unclosed arrow function', severity: 'error' as const },\n  { pattern: /expect\\([^)]*\\)\\s*\\.\\s*$/m, message: 'Incomplete expect chain', severity: 'error' as const },\n  { pattern: /const\\s+\\w+\\s*=\\s*$/m, message: 'Incomplete variable declaration', severity: 'error' as const },\n];\n\nconst SYNTAX_WARNING_PATTERNS = [\n  { pattern: /\\/\\/\\s*TODO/gi, message: 'TODO comment found - incomplete implementation', suggestion: 'Complete the TODO items' },\n  { pattern: /console\\.log\\(/g, message: 'Console.log in test code', suggestion: 'Remove debug statements' },\n  { pattern: /\\.only\\s*\\(/g, message: '.only() will skip other tests', suggestion: 'Remove .only() before committing' },\n  { pattern: /\\.skip\\s*\\(/g, message: '.skip() found - test will not run', suggestion: 'Remove .skip() or add explanation' },\n  { pattern: /any\\s*[,)]/g, message: 'Use of \"any\" type', suggestion: 'Add proper type annotations' },\n  { pattern: /as\\s+any/g, message: 'Type assertion to any', suggestion: 'Use proper type instead' },\n];\n\n// \n// MAIN VALIDATOR\n// \n\n/**\n * Validate syntax of generated Playwright test code\n */\nexport function validateSyntax(code: string): SyntaxValidationResult {\n  const errors: SyntaxError[] = [];\n  const warnings: SyntaxWarning[] = [];\n\n  // Run all validations\n  const bracketErrors = validateBrackets(code);\n  errors.push(...bracketErrors);\n\n  const patternErrors = validatePatterns(code);\n  errors.push(...patternErrors);\n\n  const patternWarnings = checkWarningPatterns(code);\n  warnings.push(...patternWarnings);\n\n  const typescript = validateTypeScript(code);\n  errors.push(...typescript.errors);\n\n  const playwright = validatePlaywright(code);\n\n  // Calculate overall score\n  const score = calculateSyntaxScore(errors, warnings, typescript, playwright);\n\n  return {\n    valid: errors.filter(e => e.severity === 'error').length === 0,\n    score,\n    errors,\n    warnings,\n    typescript,\n    playwright,\n  };\n}\n\n/**\n * Create a dimension score from syntax validation\n */\nexport function createSyntaxDimensionScore(result: SyntaxValidationResult): DimensionScore {\n  const subScores = [\n    {\n      name: 'TypeScript Compilation',\n      score: result.typescript.compiles ? 1.0 : 0.0,\n      details: result.typescript.compiles ? 'Code compiles' : 'Compilation errors found',\n    },\n    {\n      name: 'Type Inference',\n      score: result.typescript.typeInferenceScore,\n      details: `Type coverage: ${Math.round(result.typescript.typeInferenceScore * 100)}%`,\n    },\n    {\n      name: 'Playwright API Usage',\n      score: result.playwright.apiUsageScore,\n      details: `API correctness: ${Math.round(result.playwright.apiUsageScore * 100)}%`,\n    },\n    {\n      name: 'Test Structure',\n      score: result.playwright.hasValidTestBlocks ? 1.0 : 0.3,\n      details: result.playwright.hasValidTestBlocks ? 'Valid test blocks' : 'Missing test blocks',\n    },\n  ];\n\n  const reasoning = generateSyntaxReasoning(result);\n\n  return {\n    dimension: 'syntax',\n    score: result.score,\n    weight: 0.25,\n    reasoning,\n    subScores,\n  };\n}\n\n// \n// BRACKET VALIDATION\n// \n\nfunction validateBrackets(code: string): SyntaxError[] {\n  const errors: SyntaxError[] = [];\n  const stack: Array<{ char: string; line: number; column: number }> = [];\n  const pairs: Record<string, string> = { '(': ')', '[': ']', '{': '}' };\n  const closers: Record<string, string> = { ')': '(', ']': '[', '}': '{' };\n\n  const lines = code.split('\\n');\n  let inString = false;\n  let stringChar = '';\n  let inMultilineComment = false;\n\n  for (let lineNum = 0; lineNum < lines.length; lineNum++) {\n    const line = lines[lineNum] || '';\n\n    for (let col = 0; col < line.length; col++) {\n      const char = line[col] || '';\n      const prevChar = col > 0 ? line[col - 1] || '' : '';\n      const nextChar = col < line.length - 1 ? line[col + 1] || '' : '';\n\n      // Handle comments\n      if (!inString) {\n        if (char === '/' && nextChar === '/' && !inMultilineComment) {\n          break; // Rest of line is comment\n        }\n        if (char === '/' && nextChar === '*') {\n          inMultilineComment = true;\n          continue;\n        }\n        if (char === '*' && nextChar === '/' && inMultilineComment) {\n          inMultilineComment = false;\n          col++; // Skip the /\n          continue;\n        }\n        if (inMultilineComment) continue;\n      }\n\n      // Handle strings\n      if ((char === '\"' || char === \"'\" || char === '`') && prevChar !== '\\\\') {\n        if (!inString) {\n          inString = true;\n          stringChar = char;\n        } else if (char === stringChar) {\n          inString = false;\n        }\n        continue;\n      }\n\n      if (inString) continue;\n\n      // Track brackets\n      if (pairs[char]) {\n        stack.push({ char, line: lineNum + 1, column: col + 1 });\n      } else if (closers[char]) {\n        const last = stack.pop();\n        if (!last) {\n          errors.push({\n            line: lineNum + 1,\n            column: col + 1,\n            message: `Unexpected closing '${char}'`,\n            code: 'BRACKET_MISMATCH',\n            severity: 'error',\n          });\n        } else {\n          const expectedCloser = pairs[last.char];\n          if (expectedCloser && last.char !== closers[char]) {\n            errors.push({\n              line: lineNum + 1,\n              column: col + 1,\n              message: `Mismatched brackets: expected '${expectedCloser}' but found '${char}'`,\n              code: 'BRACKET_MISMATCH',\n              severity: 'error',\n            });\n          }\n        }\n      }\n    }\n  }\n\n  // Check for unclosed brackets\n  for (const unclosed of stack) {\n    errors.push({\n      line: unclosed.line,\n      column: unclosed.column,\n      message: `Unclosed '${unclosed.char}'`,\n      code: 'BRACKET_UNCLOSED',\n      severity: 'error',\n    });\n  }\n\n  // Check for unterminated string\n  if (inString) {\n    errors.push({\n      line: lines.length,\n      column: 1,\n      message: `Unterminated string literal`,\n      code: 'STRING_UNTERMINATED',\n      severity: 'error',\n    });\n  }\n\n  return errors;\n}\n\n// \n// PATTERN VALIDATION\n// \n\nfunction validatePatterns(code: string): SyntaxError[] {\n  const errors: SyntaxError[] = [];\n\n  for (const errorPattern of SYNTAX_ERROR_PATTERNS) {\n    let match: RegExpExecArray | null;\n    const regex = new RegExp(errorPattern.pattern.source, errorPattern.pattern.flags);\n\n    while ((match = regex.exec(code)) !== null) {\n      const lineNum = code.substring(0, match.index).split('\\n').length;\n      const lineStart = code.lastIndexOf('\\n', match.index) + 1;\n\n      errors.push({\n        line: lineNum,\n        column: match.index - lineStart + 1,\n        message: errorPattern.message,\n        code: 'PATTERN_ERROR',\n        severity: errorPattern.severity,\n      });\n    }\n  }\n\n  return errors;\n}\n\nfunction checkWarningPatterns(code: string): SyntaxWarning[] {\n  const warnings: SyntaxWarning[] = [];\n\n  for (const warningPattern of SYNTAX_WARNING_PATTERNS) {\n    let match: RegExpExecArray | null;\n    const regex = new RegExp(warningPattern.pattern.source, warningPattern.pattern.flags);\n\n    while ((match = regex.exec(code)) !== null) {\n      const lineNum = code.substring(0, match.index).split('\\n').length;\n\n      warnings.push({\n        line: lineNum,\n        message: warningPattern.message,\n        suggestion: warningPattern.suggestion,\n      });\n    }\n  }\n\n  return warnings;\n}\n\n// \n// TYPESCRIPT VALIDATION\n// \n\nfunction validateTypeScript(code: string): TypeScriptValidation {\n  const errors: SyntaxError[] = [];\n\n  // Check for basic TypeScript validity\n  // (Note: Full TypeScript compilation would require ts.transpile, but for static analysis we check patterns)\n\n  // Check for incomplete statements\n  const incompleteStatements = code.match(/(?:const|let|var|function|class)\\s+\\w+\\s*(?::|=)?\\s*$/gm);\n  if (incompleteStatements) {\n    for (const stmt of incompleteStatements) {\n      const lineNum = code.substring(0, code.indexOf(stmt)).split('\\n').length;\n      errors.push({\n        line: lineNum,\n        column: 1,\n        message: 'Incomplete statement',\n        code: 'TS_INCOMPLETE',\n        severity: 'error',\n      });\n    }\n  }\n\n  // Check for syntax errors in arrow functions\n  const badArrows = code.match(/=>\\s*\\{[^}]*(?!\\})/gm);\n  if (badArrows) {\n    errors.push({\n      line: 1,\n      column: 1,\n      message: 'Unclosed arrow function body',\n      code: 'TS_ARROW_ERROR',\n      severity: 'error',\n    });\n  }\n\n  // Calculate type inference score\n  const typeInferenceScore = calculateTypeInferenceScore(code);\n\n  return {\n    compiles: errors.length === 0,\n    errors,\n    typeInferenceScore,\n  };\n}\n\nfunction calculateTypeInferenceScore(code: string): number {\n  let score = 1.0;\n\n  // Penalize for 'any' usage\n  const anyCount = (code.match(/:\\s*any\\b/g) || []).length;\n  score -= anyCount * 0.1;\n\n  // Penalize for missing type annotations on function parameters\n  const untypedParams = (code.match(/\\(\\s*\\w+\\s*[,)]/g) || []).length;\n  const typedParams = (code.match(/\\(\\s*\\w+\\s*:/g) || []).length;\n  if (untypedParams + typedParams > 0) {\n    score -= (untypedParams / (untypedParams + typedParams)) * 0.2;\n  }\n\n  // Bonus for explicit return types\n  const hasReturnTypes = /\\)\\s*:\\s*\\w+/.test(code);\n  if (hasReturnTypes) {\n    score += 0.1;\n  }\n\n  return Math.max(0, Math.min(1, score));\n}\n\n// \n// PLAYWRIGHT VALIDATION\n// \n\nfunction validatePlaywright(code: string): PlaywrightValidation {\n  // Check imports\n  const hasValidImports = PLAYWRIGHT_IMPORTS.some(imp =>\n    code.includes(`from '${imp}'`) || code.includes(`from \"${imp}\"`)\n  );\n\n  // Check test fixtures\n  const usesTestFixtures = PLAYWRIGHT_FIXTURE_PATTERNS.some(pattern => pattern.test(code));\n\n  // Check test blocks\n  const hasValidTestBlocks = PLAYWRIGHT_TEST_PATTERNS.some(pattern => pattern.test(code));\n\n  // Check for deprecated APIs\n  const deprecatedAPIs: string[] = [];\n  for (const deprecated of DEPRECATED_APIS) {\n    if (deprecated.pattern.test(code)) {\n      deprecatedAPIs.push(deprecated.api);\n    }\n  }\n\n  // Calculate API usage score\n  const apiUsageScore = calculatePlaywrightAPIScore(code, deprecatedAPIs);\n\n  return {\n    hasValidImports,\n    usesTestFixtures,\n    hasValidTestBlocks,\n    apiUsageScore,\n    deprecatedAPIs,\n  };\n}\n\nfunction calculatePlaywrightAPIScore(code: string, deprecatedAPIs: string[]): number {\n  let score = 1.0;\n\n  // Penalize for deprecated APIs\n  score -= deprecatedAPIs.length * 0.15;\n\n  // Bonus for using modern locator API\n  if (code.includes('.locator(') || code.includes('getBy')) {\n    score += 0.1;\n  }\n\n  // Bonus for using expect assertions\n  if (code.includes('expect(') && code.includes(').to')) {\n    score += 0.1;\n  }\n\n  // Bonus for using test.step\n  if (code.includes('test.step(')) {\n    score += 0.05;\n  }\n\n  // Penalize for hard waits\n  const hardWaits = (code.match(/waitForTimeout\\s*\\(\\s*\\d{4,}/g) || []).length;\n  score -= hardWaits * 0.2;\n\n  return Math.max(0, Math.min(1, score));\n}\n\n// \n// SCORE CALCULATION\n// \n\nfunction calculateSyntaxScore(\n  errors: SyntaxError[],\n  warnings: SyntaxWarning[],\n  typescript: TypeScriptValidation,\n  playwright: PlaywrightValidation\n): number {\n  // Start with base score\n  let score = 1.0;\n\n  // Critical errors eliminate most of the score\n  const criticalErrors = errors.filter(e => e.severity === 'error').length;\n  score -= criticalErrors * 0.3;\n\n  // Warnings have smaller impact\n  score -= warnings.length * 0.05;\n\n  // Factor in TypeScript validation\n  if (!typescript.compiles) {\n    score -= 0.4;\n  }\n  score *= (0.7 + 0.3 * typescript.typeInferenceScore);\n\n  // Factor in Playwright validation\n  if (!playwright.hasValidImports) score -= 0.2;\n  if (!playwright.hasValidTestBlocks) score -= 0.3;\n  if (!playwright.usesTestFixtures) score -= 0.1;\n  score *= (0.7 + 0.3 * playwright.apiUsageScore);\n\n  return Math.max(0, Math.min(1, score));\n}\n\nfunction generateSyntaxReasoning(result: SyntaxValidationResult): string {\n  const reasons: string[] = [];\n\n  if (result.errors.length > 0) {\n    reasons.push(`${result.errors.length} syntax error(s) found`);\n  }\n\n  if (result.warnings.length > 0) {\n    reasons.push(`${result.warnings.length} warning(s)`);\n  }\n\n  if (!result.typescript.compiles) {\n    reasons.push('TypeScript compilation failed');\n  }\n\n  if (!result.playwright.hasValidImports) {\n    reasons.push('Missing Playwright imports');\n  }\n\n  if (!result.playwright.hasValidTestBlocks) {\n    reasons.push('No valid test blocks found');\n  }\n\n  if (result.playwright.deprecatedAPIs.length > 0) {\n    reasons.push(`${result.playwright.deprecatedAPIs.length} deprecated API(s) used`);\n  }\n\n  if (reasons.length === 0) {\n    reasons.push('Syntax is valid');\n  }\n\n  return reasons.join('; ');\n}\n\n// \n// EXPORTS FOR QUICK CHECKS\n// \n\n/**\n * Quick check if code has valid structure (no full validation)\n */\nexport function quickSyntaxCheck(code: string): boolean {\n  // Check for basic structure\n  if (!code.includes('test(') && !code.includes('test.describe(')) {\n    return false;\n  }\n\n  // Check bracket balance\n  const brackets = validateBrackets(code);\n  if (brackets.length > 0) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Get list of deprecated APIs used\n */\nexport function getDeprecatedAPIs(code: string): Array<{ api: string; suggestion: string }> {\n  const found: Array<{ api: string; suggestion: string }> = [];\n\n  for (const deprecated of DEPRECATED_APIS) {\n    if (deprecated.pattern.test(code)) {\n      found.push({\n        api: deprecated.api,\n        suggestion: deprecated.suggestion,\n      });\n    }\n  }\n\n  return found;\n}\n","/**\n * @module uncertainty/pattern-matcher\n * @description Match generated code against known patterns from LLKB/glossary\n */\n\nimport {\n  PatternMatchResult,\n  MatchedPattern,\n  UnmatchedElement,\n  DimensionScore,\n} from './types.js';\n\n// \n// PATTERN DEFINITIONS\n// \n\nexport interface PatternDefinition {\n  id: string;\n  name: string;\n  category: PatternCategory;\n  patterns: RegExp[];\n  confidence: number;\n  source: 'glossary' | 'llkb' | 'builtin';\n}\n\nexport type PatternCategory =\n  | 'navigation'\n  | 'interaction'\n  | 'assertion'\n  | 'wait'\n  | 'form'\n  | 'authentication'\n  | 'data'\n  | 'utility';\n\n// Built-in patterns for common Playwright operations\nconst BUILTIN_PATTERNS: PatternDefinition[] = [\n  // Navigation patterns\n  {\n    id: 'nav-goto',\n    name: 'Page Navigation',\n    category: 'navigation',\n    patterns: [/page\\.goto\\s*\\(/],\n    confidence: 0.95,\n    source: 'builtin',\n  },\n  {\n    id: 'nav-reload',\n    name: 'Page Reload',\n    category: 'navigation',\n    patterns: [/page\\.reload\\s*\\(/],\n    confidence: 0.95,\n    source: 'builtin',\n  },\n  {\n    id: 'nav-back',\n    name: 'Navigate Back',\n    category: 'navigation',\n    patterns: [/page\\.goBack\\s*\\(/, /page\\.goForward\\s*\\(/],\n    confidence: 0.95,\n    source: 'builtin',\n  },\n\n  // Interaction patterns\n  {\n    id: 'click-locator',\n    name: 'Locator Click',\n    category: 'interaction',\n    patterns: [/\\.click\\s*\\(\\s*\\)/, /locator\\([^)]+\\)\\.click/],\n    confidence: 0.9,\n    source: 'builtin',\n  },\n  {\n    id: 'fill-locator',\n    name: 'Locator Fill',\n    category: 'interaction',\n    patterns: [/\\.fill\\s*\\([^)]+\\)/, /locator\\([^)]+\\)\\.fill/],\n    confidence: 0.9,\n    source: 'builtin',\n  },\n  {\n    id: 'type-locator',\n    name: 'Locator Type',\n    category: 'interaction',\n    patterns: [/\\.pressSequentially\\s*\\(/, /\\.type\\s*\\(/],\n    confidence: 0.85,\n    source: 'builtin',\n  },\n  {\n    id: 'select-option',\n    name: 'Select Option',\n    category: 'interaction',\n    patterns: [/\\.selectOption\\s*\\(/],\n    confidence: 0.9,\n    source: 'builtin',\n  },\n  {\n    id: 'check-uncheck',\n    name: 'Checkbox Toggle',\n    category: 'interaction',\n    patterns: [/\\.check\\s*\\(\\s*\\)/, /\\.uncheck\\s*\\(\\s*\\)/, /\\.setChecked\\s*\\(/],\n    confidence: 0.9,\n    source: 'builtin',\n  },\n  {\n    id: 'hover',\n    name: 'Hover Action',\n    category: 'interaction',\n    patterns: [/\\.hover\\s*\\(\\s*\\)/],\n    confidence: 0.9,\n    source: 'builtin',\n  },\n  {\n    id: 'focus',\n    name: 'Focus Element',\n    category: 'interaction',\n    patterns: [/\\.focus\\s*\\(\\s*\\)/],\n    confidence: 0.9,\n    source: 'builtin',\n  },\n  {\n    id: 'keyboard',\n    name: 'Keyboard Action',\n    category: 'interaction',\n    patterns: [/\\.press\\s*\\(['\"]/, /keyboard\\.press\\s*\\(/],\n    confidence: 0.85,\n    source: 'builtin',\n  },\n\n  // Assertion patterns\n  {\n    id: 'expect-visible',\n    name: 'Visibility Assertion',\n    category: 'assertion',\n    patterns: [/expect\\([^)]+\\)\\.toBeVisible/, /expect\\([^)]+\\)\\.toBeHidden/],\n    confidence: 0.95,\n    source: 'builtin',\n  },\n  {\n    id: 'expect-text',\n    name: 'Text Assertion',\n    category: 'assertion',\n    patterns: [/expect\\([^)]+\\)\\.toHaveText/, /expect\\([^)]+\\)\\.toContainText/],\n    confidence: 0.9,\n    source: 'builtin',\n  },\n  {\n    id: 'expect-value',\n    name: 'Value Assertion',\n    category: 'assertion',\n    patterns: [/expect\\([^)]+\\)\\.toHaveValue/],\n    confidence: 0.9,\n    source: 'builtin',\n  },\n  {\n    id: 'expect-url',\n    name: 'URL Assertion',\n    category: 'assertion',\n    patterns: [/expect\\(page\\)\\.toHaveURL/],\n    confidence: 0.95,\n    source: 'builtin',\n  },\n  {\n    id: 'expect-title',\n    name: 'Title Assertion',\n    category: 'assertion',\n    patterns: [/expect\\(page\\)\\.toHaveTitle/],\n    confidence: 0.95,\n    source: 'builtin',\n  },\n  {\n    id: 'expect-count',\n    name: 'Count Assertion',\n    category: 'assertion',\n    patterns: [/expect\\([^)]+\\)\\.toHaveCount/],\n    confidence: 0.9,\n    source: 'builtin',\n  },\n  {\n    id: 'expect-enabled',\n    name: 'Enabled State Assertion',\n    category: 'assertion',\n    patterns: [/expect\\([^)]+\\)\\.toBeEnabled/, /expect\\([^)]+\\)\\.toBeDisabled/],\n    confidence: 0.9,\n    source: 'builtin',\n  },\n  {\n    id: 'expect-checked',\n    name: 'Checked State Assertion',\n    category: 'assertion',\n    patterns: [/expect\\([^)]+\\)\\.toBeChecked/],\n    confidence: 0.9,\n    source: 'builtin',\n  },\n\n  // Wait patterns\n  {\n    id: 'wait-selector',\n    name: 'Wait for Selector',\n    category: 'wait',\n    patterns: [/\\.waitFor\\s*\\(\\s*\\{/, /locator\\.waitFor/],\n    confidence: 0.85,\n    source: 'builtin',\n  },\n  {\n    id: 'wait-load-state',\n    name: 'Wait for Load State',\n    category: 'wait',\n    patterns: [/page\\.waitForLoadState\\s*\\(/],\n    confidence: 0.9,\n    source: 'builtin',\n  },\n  {\n    id: 'wait-response',\n    name: 'Wait for Response',\n    category: 'wait',\n    patterns: [/page\\.waitForResponse\\s*\\(/],\n    confidence: 0.9,\n    source: 'builtin',\n  },\n  {\n    id: 'wait-request',\n    name: 'Wait for Request',\n    category: 'wait',\n    patterns: [/page\\.waitForRequest\\s*\\(/],\n    confidence: 0.9,\n    source: 'builtin',\n  },\n\n  // Form patterns\n  {\n    id: 'form-submit',\n    name: 'Form Submit',\n    category: 'form',\n    patterns: [/getByRole\\(['\"]button['\"].*submit/i, /type=['\"]submit['\"]/],\n    confidence: 0.85,\n    source: 'builtin',\n  },\n\n  // Data patterns\n  {\n    id: 'table-row',\n    name: 'Table Row Access',\n    category: 'data',\n    patterns: [/getByRole\\(['\"]row['\"]/, /locator\\(['\"]tr['\"]\\)/],\n    confidence: 0.85,\n    source: 'builtin',\n  },\n  {\n    id: 'table-cell',\n    name: 'Table Cell Access',\n    category: 'data',\n    patterns: [/getByRole\\(['\"]cell['\"]/, /locator\\(['\"]td['\"]\\)/],\n    confidence: 0.85,\n    source: 'builtin',\n  },\n\n  // Utility patterns\n  {\n    id: 'screenshot',\n    name: 'Screenshot',\n    category: 'utility',\n    patterns: [/page\\.screenshot\\s*\\(/],\n    confidence: 0.95,\n    source: 'builtin',\n  },\n  {\n    id: 'test-step',\n    name: 'Test Step',\n    category: 'utility',\n    patterns: [/test\\.step\\s*\\(/],\n    confidence: 0.95,\n    source: 'builtin',\n  },\n];\n\n// \n// PATTERN MATCHER\n// \n\nexport interface PatternMatcherOptions {\n  customPatterns?: PatternDefinition[];\n  llkbPatterns?: PatternDefinition[];\n  includeBuiltins?: boolean;\n  minConfidence?: number;\n}\n\n/**\n * Match code against known patterns\n */\nexport function matchPatterns(\n  code: string,\n  options: PatternMatcherOptions = {}\n): PatternMatchResult {\n  const {\n    customPatterns = [],\n    llkbPatterns = [],\n    includeBuiltins = true,\n    minConfidence = 0.5,\n  } = options;\n\n  // Combine all patterns\n  const allPatterns = [\n    ...(includeBuiltins ? BUILTIN_PATTERNS : []),\n    ...customPatterns,\n    ...llkbPatterns,\n  ];\n\n  const matchedPatterns: MatchedPattern[] = [];\n  const matchedLineRanges = new Set<string>();\n\n  // Find matches for each pattern\n  for (const pattern of allPatterns) {\n    for (const regex of pattern.patterns) {\n      const globalRegex = new RegExp(regex.source, 'gm');\n      let match: RegExpExecArray | null;\n\n      while ((match = globalRegex.exec(code)) !== null) {\n        const startLine = code.substring(0, match.index).split('\\n').length;\n        const endLine = startLine; // Most patterns are single-line\n\n        const lineRange = `${startLine}-${endLine}`;\n        if (!matchedLineRanges.has(`${pattern.id}:${lineRange}`)) {\n          matchedLineRanges.add(`${pattern.id}:${lineRange}`);\n\n          matchedPatterns.push({\n            patternId: pattern.id,\n            patternName: pattern.name,\n            confidence: pattern.confidence,\n            codeLocation: { startLine, endLine },\n            source: pattern.source,\n          });\n        }\n      }\n    }\n  }\n\n  // Find unmatched elements (potential issues)\n  const unmatchedElements = findUnmatchedElements(code, matchedPatterns, allPatterns);\n\n  // Calculate scores\n  const noveltyScore = calculateNoveltyScore(matchedPatterns, allPatterns);\n  const consistencyScore = calculateConsistencyScore(matchedPatterns);\n  const overallScore = calculatePatternScore(\n    matchedPatterns,\n    unmatchedElements,\n    noveltyScore,\n    consistencyScore,\n    minConfidence\n  );\n\n  return {\n    score: overallScore,\n    matchedPatterns,\n    unmatchedElements,\n    noveltyScore,\n    consistencyScore,\n  };\n}\n\n/**\n * Create a dimension score from pattern matching\n */\nexport function createPatternDimensionScore(result: PatternMatchResult): DimensionScore {\n  const subScores = [\n    {\n      name: 'Pattern Coverage',\n      score: Math.min(1, result.matchedPatterns.length / 10),\n      details: `${result.matchedPatterns.length} patterns matched`,\n    },\n    {\n      name: 'Novelty',\n      score: result.noveltyScore,\n      details: `Novelty score: ${Math.round(result.noveltyScore * 100)}%`,\n    },\n    {\n      name: 'Consistency',\n      score: result.consistencyScore,\n      details: `Consistency score: ${Math.round(result.consistencyScore * 100)}%`,\n    },\n    {\n      name: 'Unmatched Risk',\n      score: Math.max(0, 1 - result.unmatchedElements.length * 0.2),\n      details: `${result.unmatchedElements.length} unmatched elements`,\n    },\n  ];\n\n  const reasoning = generatePatternReasoning(result);\n\n  return {\n    dimension: 'pattern',\n    score: result.score,\n    weight: 0.25,\n    reasoning,\n    subScores,\n  };\n}\n\n// \n// UNMATCHED ELEMENT DETECTION\n// \n\nfunction findUnmatchedElements(\n  code: string,\n  matchedPatterns: MatchedPattern[],\n  allPatterns: PatternDefinition[]\n): UnmatchedElement[] {\n  const unmatched: UnmatchedElement[] = [];\n\n  // Look for potential action calls that weren't matched\n  const actionPatterns = [\n    { regex: /page\\.(\\w+)\\s*\\(/g, type: 'page method' },\n    { regex: /locator\\([^)]+\\)\\.(\\w+)\\s*\\(/g, type: 'locator method' },\n    { regex: /getBy\\w+\\([^)]+\\)\\.(\\w+)\\s*\\(/g, type: 'locator method' },\n    { regex: /expect\\([^)]+\\)\\.(\\w+)/g, type: 'assertion' },\n  ];\n\n  for (const actionPattern of actionPatterns) {\n    let match: RegExpExecArray | null;\n    const regex = new RegExp(actionPattern.regex.source, 'g');\n\n    while ((match = regex.exec(code)) !== null) {\n      const methodName = match[1] || '';\n      const lineNum = code.substring(0, match.index).split('\\n').length;\n\n      // Check if this is covered by any matched pattern\n      const isCovered = matchedPatterns.some(p =>\n        p.codeLocation.startLine <= lineNum && p.codeLocation.endLine >= lineNum\n      );\n\n      if (!isCovered && methodName) {\n        // Find suggested patterns\n        const suggestions = findSuggestedPatterns(methodName, allPatterns);\n\n        unmatched.push({\n          element: `${actionPattern.type}: ${methodName}`,\n          reason: 'No matching pattern found',\n          suggestedPatterns: suggestions,\n          riskLevel: determineRiskLevel(methodName),\n        });\n      }\n    }\n  }\n\n  // Deduplicate by element name\n  const seen = new Set<string>();\n  return unmatched.filter(u => {\n    if (seen.has(u.element)) return false;\n    seen.add(u.element);\n    return true;\n  });\n}\n\nfunction findSuggestedPatterns(methodName: string, patterns: PatternDefinition[]): string[] {\n  const suggestions: string[] = [];\n\n  // Find patterns that might be similar\n  for (const pattern of patterns) {\n    const patternText = pattern.patterns.map(p => p.source).join(' ');\n    if (patternText.toLowerCase().includes(methodName.toLowerCase())) {\n      suggestions.push(pattern.name);\n    }\n  }\n\n  return suggestions.slice(0, 3);\n}\n\nfunction determineRiskLevel(methodName: string): 'low' | 'medium' | 'high' {\n  const highRiskMethods = ['evaluate', 'evaluateHandle', 'addScriptTag', 'setContent'];\n  const mediumRiskMethods = ['waitForTimeout', 'waitForFunction', 'route', 'unroute'];\n\n  if (highRiskMethods.includes(methodName)) return 'high';\n  if (mediumRiskMethods.includes(methodName)) return 'medium';\n  return 'low';\n}\n\n// \n// SCORE CALCULATION\n// \n\nfunction calculateNoveltyScore(\n  matchedPatterns: MatchedPattern[],\n  _allPatterns: PatternDefinition[]\n): number {\n  if (matchedPatterns.length === 0) return 0.5; // Neutral if no patterns\n\n  // Higher novelty = more LLKB patterns used (shows learning)\n  const llkbCount = matchedPatterns.filter(p => p.source === 'llkb').length;\n  const glossaryCount = matchedPatterns.filter(p => p.source === 'glossary').length;\n  // builtinCount not used in scoring formula - LLKB/glossary patterns rewarded\n\n  // Reward using learned patterns while not penalizing builtins\n  const total = matchedPatterns.length;\n  const learnedRatio = (llkbCount + glossaryCount) / total;\n\n  // Score: base 0.5 + up to 0.5 for learned patterns\n  return 0.5 + learnedRatio * 0.5;\n}\n\nfunction calculateConsistencyScore(matchedPatterns: MatchedPattern[]): number {\n  if (matchedPatterns.length < 2) return 1.0; // Single pattern is consistent\n\n  // Check for consistent selector strategies\n  const categories = matchedPatterns.map(p => {\n    const pattern = BUILTIN_PATTERNS.find(bp => bp.id === p.patternId);\n    return pattern?.category || 'unknown';\n  });\n\n  // Count category transitions (inconsistency indicator)\n  let transitions = 0;\n  for (let i = 1; i < categories.length; i++) {\n    const currCategory = categories[i];\n    const prevCategory = categories[i - 1];\n    if (currCategory && prevCategory && currCategory !== prevCategory) {\n      transitions++;\n    }\n  }\n\n  // More transitions = potentially less consistent (but not always bad)\n  const transitionRatio = categories.length > 1 ? transitions / (categories.length - 1) : 0;\n\n  // Score: 1.0 for few transitions, down to 0.6 for many\n  return Math.max(0.6, 1 - transitionRatio * 0.4);\n}\n\nfunction calculatePatternScore(\n  matchedPatterns: MatchedPattern[],\n  unmatchedElements: UnmatchedElement[],\n  noveltyScore: number,\n  consistencyScore: number,\n  _minConfidence: number // Reserved for future confidence filtering\n): number {\n  // Base score from pattern matches\n  const avgConfidence = matchedPatterns.length > 0\n    ? matchedPatterns.reduce((sum, p) => sum + p.confidence, 0) / matchedPatterns.length\n    : 0.5;\n\n  // Penalty for unmatched high-risk elements\n  const highRiskCount = unmatchedElements.filter(u => u.riskLevel === 'high').length;\n  const mediumRiskCount = unmatchedElements.filter(u => u.riskLevel === 'medium').length;\n  const riskPenalty = highRiskCount * 0.15 + mediumRiskCount * 0.05;\n\n  // Combine scores\n  let score = (\n    avgConfidence * 0.4 +\n    noveltyScore * 0.2 +\n    consistencyScore * 0.2 +\n    (1 - riskPenalty) * 0.2\n  );\n\n  // Ensure minimum coverage\n  if (matchedPatterns.length < 3) {\n    score *= 0.8; // Penalty for too few patterns\n  }\n\n  return Math.max(0, Math.min(1, score));\n}\n\nfunction generatePatternReasoning(result: PatternMatchResult): string {\n  const reasons: string[] = [];\n\n  const patternCount = result.matchedPatterns.length;\n  if (patternCount === 0) {\n    reasons.push('No recognized patterns found');\n  } else if (patternCount < 5) {\n    reasons.push(`${patternCount} patterns matched (low coverage)`);\n  } else {\n    reasons.push(`${patternCount} patterns matched`);\n  }\n\n  // Count by source\n  const llkbCount = result.matchedPatterns.filter(p => p.source === 'llkb').length;\n  if (llkbCount > 0) {\n    reasons.push(`${llkbCount} LLKB patterns used`);\n  }\n\n  // Unmatched warnings\n  const highRisk = result.unmatchedElements.filter(u => u.riskLevel === 'high');\n  if (highRisk.length > 0) {\n    reasons.push(`${highRisk.length} high-risk unmatched elements`);\n  }\n\n  // Consistency\n  if (result.consistencyScore < 0.7) {\n    reasons.push('Pattern usage inconsistent');\n  }\n\n  return reasons.join('; ');\n}\n\n// \n// PATTERN ANALYSIS HELPERS\n// \n\n/**\n * Get pattern categories used in code\n */\nexport function getPatternCategories(\n  matchedPatterns: MatchedPattern[]\n): Record<PatternCategory, number> {\n  const categories: Record<PatternCategory, number> = {\n    navigation: 0,\n    interaction: 0,\n    assertion: 0,\n    wait: 0,\n    form: 0,\n    authentication: 0,\n    data: 0,\n    utility: 0,\n  };\n\n  for (const matched of matchedPatterns) {\n    const pattern = BUILTIN_PATTERNS.find(p => p.id === matched.patternId);\n    if (pattern) {\n      categories[pattern.category]++;\n    }\n  }\n\n  return categories;\n}\n\n/**\n * Check if code has minimum required patterns\n */\nexport function hasMinimumPatterns(\n  matchedPatterns: MatchedPattern[],\n  requirements: Partial<Record<PatternCategory, number>>\n): boolean {\n  const categories = getPatternCategories(matchedPatterns);\n\n  for (const [category, minCount] of Object.entries(requirements)) {\n    if (categories[category as PatternCategory] < minCount) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Get all built-in patterns (for external use)\n */\nexport function getBuiltinPatterns(): PatternDefinition[] {\n  return [...BUILTIN_PATTERNS];\n}\n","/**\n * @module uncertainty/selector-analyzer\n * @description Analyze selector quality and stability\n */\n\nimport {\n  SelectorAnalysisResult,\n  SelectorInfo,\n  SelectorStrategy,\n  SelectorRecommendation,\n  DimensionScore,\n} from './types.js';\n\n// \n// SELECTOR PATTERNS\n// \n\ninterface SelectorPattern {\n  strategy: SelectorStrategy;\n  pattern: RegExp;\n  stabilityScore: number;\n  accessibilityBonus: number;\n}\n\nconst SELECTOR_PATTERNS: SelectorPattern[] = [\n  // Test ID selectors (most stable)\n  {\n    strategy: 'testId',\n    pattern: /getByTestId\\s*\\(\\s*['\"]([^'\"]+)['\"]\\s*\\)/g,\n    stabilityScore: 1.0,\n    accessibilityBonus: 0,\n  },\n  {\n    strategy: 'testId',\n    pattern: /locator\\s*\\(\\s*['\"]\\[data-testid=['\"]?([^'\"\\]]+)['\"]?\\]['\"]\\s*\\)/g,\n    stabilityScore: 0.95,\n    accessibilityBonus: 0,\n  },\n\n  // Role selectors (stable + accessible)\n  {\n    strategy: 'role',\n    pattern: /getByRole\\s*\\(\\s*['\"]([^'\"]+)['\"](?:\\s*,\\s*\\{[^}]*\\})?\\s*\\)/g,\n    stabilityScore: 0.9,\n    accessibilityBonus: 0.2,\n  },\n\n  // Label selectors (stable + accessible)\n  {\n    strategy: 'label',\n    pattern: /getByLabel\\s*\\(\\s*['\"]([^'\"]+)['\"]\\s*\\)/g,\n    stabilityScore: 0.85,\n    accessibilityBonus: 0.15,\n  },\n  {\n    strategy: 'label',\n    pattern: /getByLabelText\\s*\\(\\s*['\"]([^'\"]+)['\"]\\s*\\)/g,\n    stabilityScore: 0.85,\n    accessibilityBonus: 0.15,\n  },\n\n  // Placeholder selectors (moderately stable)\n  {\n    strategy: 'placeholder',\n    pattern: /getByPlaceholder\\s*\\(\\s*['\"]([^'\"]+)['\"]\\s*\\)/g,\n    stabilityScore: 0.75,\n    accessibilityBonus: 0,\n  },\n\n  // Text selectors (less stable due to content changes)\n  {\n    strategy: 'text',\n    pattern: /getByText\\s*\\(\\s*['\"]([^'\"]+)['\"]\\s*\\)/g,\n    stabilityScore: 0.65,\n    accessibilityBonus: 0.05,\n  },\n  {\n    strategy: 'text',\n    pattern: /getByText\\s*\\(\\s*\\/([^/]+)\\/[a-z]*\\s*\\)/g,\n    stabilityScore: 0.6, // Regex text is slightly less stable\n    accessibilityBonus: 0.05,\n  },\n\n  // Title selectors\n  {\n    strategy: 'title',\n    pattern: /getByTitle\\s*\\(\\s*['\"]([^'\"]+)['\"]\\s*\\)/g,\n    stabilityScore: 0.7,\n    accessibilityBonus: 0.1,\n  },\n\n  // Alt text selectors\n  {\n    strategy: 'altText',\n    pattern: /getByAltText\\s*\\(\\s*['\"]([^'\"]+)['\"]\\s*\\)/g,\n    stabilityScore: 0.75,\n    accessibilityBonus: 0.15,\n  },\n\n  // CSS selectors (fragile)\n  {\n    strategy: 'css',\n    pattern: /locator\\s*\\(\\s*['\"]([^'\"]+)['\"]\\s*\\)/g,\n    stabilityScore: 0.5,\n    accessibilityBonus: 0,\n  },\n\n  // XPath selectors (most fragile)\n  {\n    strategy: 'xpath',\n    pattern: /locator\\s*\\(\\s*['\"]xpath=([^'\"]+)['\"]\\s*\\)/g,\n    stabilityScore: 0.3,\n    accessibilityBonus: 0,\n  },\n  {\n    strategy: 'xpath',\n    pattern: /locator\\s*\\(\\s*['\"]\\/\\/([^'\"]+)['\"]\\s*\\)/g,\n    stabilityScore: 0.3,\n    accessibilityBonus: 0,\n  },\n\n  // nth selectors (order-dependent, fragile)\n  {\n    strategy: 'nth',\n    pattern: /\\.nth\\s*\\(\\s*(\\d+)\\s*\\)/g,\n    stabilityScore: 0.4,\n    accessibilityBonus: 0,\n  },\n  {\n    strategy: 'nth',\n    pattern: /\\.first\\s*\\(\\s*\\)/g,\n    stabilityScore: 0.45,\n    accessibilityBonus: 0,\n  },\n  {\n    strategy: 'nth',\n    pattern: /\\.last\\s*\\(\\s*\\)/g,\n    stabilityScore: 0.45,\n    accessibilityBonus: 0,\n  },\n\n  // Chained selectors\n  {\n    strategy: 'chain',\n    pattern: /locator\\([^)]+\\)\\s*\\.\\s*locator\\s*\\(/g,\n    stabilityScore: 0.55,\n    accessibilityBonus: 0,\n  },\n];\n\n// Fragility indicators\nconst FRAGILITY_INDICATORS = [\n  { pattern: /\\[class[*^$~|]?=['\"][^'\"]*['\"]\\]/i, reason: 'Class-based selector (may change)' },\n  { pattern: /\\[id[*^$~|]?=['\"][^'\"]*['\"]\\]/i, reason: 'ID-based selector (may be dynamic)' },\n  { pattern: /:nth-child\\(\\d+\\)/i, reason: 'Position-based selector' },\n  { pattern: /:nth-of-type\\(\\d+\\)/i, reason: 'Position-based selector' },\n  { pattern: /\\s>\\s/g, reason: 'Direct child combinator (structure-sensitive)' },\n  { pattern: /\\s+\\s/g, reason: 'Descendant combinator (structure-sensitive)' },\n  { pattern: /\\[style[*^$~|]?=/i, reason: 'Style-based selector (highly volatile)' },\n  { pattern: /\\.btn-[a-z]+/i, reason: 'Framework-specific class (may change)' },\n  { pattern: /\\.col-[a-z0-9-]+/i, reason: 'Grid class (layout-dependent)' },\n  { pattern: /auto-generated|generated-id|uuid|guid/i, reason: 'Contains generated ID pattern' },\n];\n\n// \n// MAIN ANALYZER\n// \n\n/**\n * Analyze selectors in generated code\n */\nexport function analyzeSelectors(code: string): SelectorAnalysisResult {\n  const selectors: SelectorInfo[] = [];\n  const strategyDistribution: Record<SelectorStrategy, number> = {\n    testId: 0,\n    role: 0,\n    text: 0,\n    label: 0,\n    placeholder: 0,\n    title: 0,\n    altText: 0,\n    css: 0,\n    xpath: 0,\n    nth: 0,\n    chain: 0,\n  };\n\n  // Extract all selectors\n  for (const selectorPattern of SELECTOR_PATTERNS) {\n    const regex = new RegExp(selectorPattern.pattern.source, 'g');\n    let match: RegExpExecArray | null;\n\n    while ((match = regex.exec(code)) !== null) {\n      const selector = match[0];\n      const lineNum = code.substring(0, match.index).split('\\n').length;\n\n      // Analyze fragility\n      const fragilityReasons = analyzeSelectorFragility(selector);\n      const isFragile = fragilityReasons.length > 0;\n\n      // Calculate specificity\n      const specificity = calculateSpecificity(selector, selectorPattern.strategy);\n\n      // Adjust stability for fragility\n      let stabilityScore = selectorPattern.stabilityScore;\n      if (isFragile) {\n        stabilityScore *= (1 - fragilityReasons.length * 0.1);\n      }\n\n      selectors.push({\n        selector,\n        strategy: selectorPattern.strategy,\n        stabilityScore: Math.max(0, stabilityScore),\n        specificity,\n        hasTestId: selectorPattern.strategy === 'testId',\n        usesRole: selectorPattern.strategy === 'role',\n        isFragile,\n        fragilityReasons,\n        line: lineNum,\n      });\n\n      strategyDistribution[selectorPattern.strategy]++;\n    }\n  }\n\n  // Calculate scores\n  const stabilityScore = calculateOverallStability(selectors);\n  const accessibilityScore = calculateAccessibilityScore(selectors);\n\n  // Generate recommendations\n  const recommendations = generateRecommendations(selectors);\n\n  // Calculate overall score\n  const overallScore = calculateSelectorScore(\n    selectors,\n    stabilityScore,\n    accessibilityScore,\n    strategyDistribution\n  );\n\n  return {\n    score: overallScore,\n    selectors,\n    strategyDistribution,\n    stabilityScore,\n    accessibilityScore,\n    recommendations,\n  };\n}\n\n/**\n * Create a dimension score from selector analysis\n */\nexport function createSelectorDimensionScore(result: SelectorAnalysisResult): DimensionScore {\n  const subScores = [\n    {\n      name: 'Stability',\n      score: result.stabilityScore,\n      details: `Stability: ${Math.round(result.stabilityScore * 100)}%`,\n    },\n    {\n      name: 'Accessibility',\n      score: result.accessibilityScore,\n      details: `A11y: ${Math.round(result.accessibilityScore * 100)}%`,\n    },\n    {\n      name: 'TestId Usage',\n      score: calculateTestIdRatio(result.strategyDistribution),\n      details: `TestId: ${result.strategyDistribution.testId} selectors`,\n    },\n    {\n      name: 'Fragility',\n      score: calculateFragilityScore(result.selectors),\n      details: `${result.selectors.filter(s => s.isFragile).length} fragile selectors`,\n    },\n  ];\n\n  const reasoning = generateSelectorReasoning(result);\n\n  return {\n    dimension: 'selector',\n    score: result.score,\n    weight: 0.30,\n    reasoning,\n    subScores,\n  };\n}\n\n// \n// FRAGILITY ANALYSIS\n// \n\nfunction analyzeSelectorFragility(selector: string): string[] {\n  const reasons: string[] = [];\n\n  for (const indicator of FRAGILITY_INDICATORS) {\n    if (indicator.pattern.test(selector)) {\n      reasons.push(indicator.reason);\n    }\n  }\n\n  // Check for very long selectors (usually fragile)\n  if (selector.length > 100) {\n    reasons.push('Very long selector (likely over-specified)');\n  }\n\n  // Check for multiple combinators\n  const combinatorCount = (selector.match(/[>\\s+~]/g) || []).length;\n  if (combinatorCount > 3) {\n    reasons.push('Too many combinators (deep nesting)');\n  }\n\n  return reasons;\n}\n\nfunction calculateSpecificity(selector: string, strategy: SelectorStrategy): number {\n  // Simplified specificity calculation\n  switch (strategy) {\n    case 'testId':\n      return 1.0; // Most specific and intentional\n    case 'role':\n      return 0.9; // Very specific\n    case 'label':\n    case 'altText':\n      return 0.85;\n    case 'placeholder':\n    case 'title':\n      return 0.8;\n    case 'text':\n      return 0.7;\n    case 'css':\n      // CSS specificity varies\n      const idCount = (selector.match(/#/g) || []).length;\n      const classCount = (selector.match(/\\./g) || []).length;\n      return Math.min(1, 0.3 + idCount * 0.3 + classCount * 0.1);\n    case 'xpath':\n      return 0.4; // XPath is usually less specific\n    case 'nth':\n      return 0.3; // Position-based is not semantic\n    case 'chain':\n      return 0.5; // Depends on the chain\n    default:\n      return 0.5;\n  }\n}\n\n// \n// SCORE CALCULATIONS\n// \n\nfunction calculateOverallStability(selectors: SelectorInfo[]): number {\n  if (selectors.length === 0) return 0.5;\n\n  const totalStability = selectors.reduce((sum, s) => sum + s.stabilityScore, 0);\n  return totalStability / selectors.length;\n}\n\nfunction calculateAccessibilityScore(selectors: SelectorInfo[]): number {\n  if (selectors.length === 0) return 0.5;\n\n  // Strategies that use accessibility attributes\n  const accessibleStrategies: SelectorStrategy[] = ['role', 'label', 'altText', 'title'];\n\n  const accessibleCount = selectors.filter(s =>\n    accessibleStrategies.includes(s.strategy)\n  ).length;\n\n  return accessibleCount / selectors.length;\n}\n\nfunction calculateTestIdRatio(distribution: Record<SelectorStrategy, number>): number {\n  const total = Object.values(distribution).reduce((sum, count) => sum + count, 0);\n  if (total === 0) return 0;\n  return distribution.testId / total;\n}\n\nfunction calculateFragilityScore(selectors: SelectorInfo[]): number {\n  if (selectors.length === 0) return 1.0;\n\n  const fragileCount = selectors.filter(s => s.isFragile).length;\n  return 1 - (fragileCount / selectors.length);\n}\n\nfunction calculateSelectorScore(\n  selectors: SelectorInfo[],\n  stabilityScore: number,\n  accessibilityScore: number,\n  distribution: Record<SelectorStrategy, number>\n): number {\n  if (selectors.length === 0) return 0.5; // Neutral if no selectors\n\n  // Weight factors\n  const weights = {\n    stability: 0.4,\n    accessibility: 0.2,\n    testIdUsage: 0.25,\n    fragility: 0.15,\n  };\n\n  const testIdRatio = calculateTestIdRatio(distribution);\n  const fragilityScore = calculateFragilityScore(selectors);\n\n  let score =\n    stabilityScore * weights.stability +\n    accessibilityScore * weights.accessibility +\n    testIdRatio * weights.testIdUsage +\n    fragilityScore * weights.fragility;\n\n  // Penalize for overuse of fragile strategies\n  const fragileStrategyCount = distribution.css + distribution.xpath + distribution.nth;\n  const total = Object.values(distribution).reduce((sum, c) => sum + c, 0);\n  if (total > 0 && fragileStrategyCount / total > 0.5) {\n    score *= 0.8; // 20% penalty for >50% fragile selectors\n  }\n\n  return Math.max(0, Math.min(1, score));\n}\n\n// \n// RECOMMENDATIONS\n// \n\nfunction generateRecommendations(selectors: SelectorInfo[]): SelectorRecommendation[] {\n  const recommendations: SelectorRecommendation[] = [];\n\n  for (const selector of selectors) {\n    // Recommend upgrading CSS/XPath to better strategies\n    if (selector.strategy === 'css' || selector.strategy === 'xpath') {\n      recommendations.push({\n        selector: selector.selector,\n        currentStrategy: selector.strategy,\n        suggestedStrategy: 'testId',\n        reason: 'CSS/XPath selectors are fragile. Add data-testid to element.',\n        priority: 'high',\n      });\n    }\n\n    // Recommend upgrading nth selectors\n    if (selector.strategy === 'nth') {\n      recommendations.push({\n        selector: selector.selector,\n        currentStrategy: selector.strategy,\n        suggestedStrategy: 'role',\n        reason: 'Position-based selectors break when order changes. Use role with name.',\n        priority: 'medium',\n      });\n    }\n\n    // Recommend adding testId to fragile selectors\n    if (selector.isFragile && selector.strategy !== 'testId') {\n      recommendations.push({\n        selector: selector.selector,\n        currentStrategy: selector.strategy,\n        suggestedStrategy: 'testId',\n        reason: `Fragile selector: ${selector.fragilityReasons.join(', ')}`,\n        priority: 'high',\n      });\n    }\n\n    // Suggest role for better accessibility\n    if (selector.strategy === 'text' && !selector.usesRole) {\n      recommendations.push({\n        selector: selector.selector,\n        currentStrategy: selector.strategy,\n        suggestedStrategy: 'role',\n        reason: 'Text selectors break on content changes. Use role for stability.',\n        priority: 'low',\n      });\n    }\n  }\n\n  // Sort by priority\n  const priorityOrder = { high: 0, medium: 1, low: 2 };\n  recommendations.sort((a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]);\n\n  return recommendations.slice(0, 10); // Limit to top 10\n}\n\nfunction generateSelectorReasoning(result: SelectorAnalysisResult): string {\n  const reasons: string[] = [];\n\n  if (result.selectors.length === 0) {\n    return 'No selectors found in code';\n  }\n\n  // Strategy distribution\n  const totalSelectors = result.selectors.length;\n  const testIdCount = result.strategyDistribution.testId;\n  const roleCount = result.strategyDistribution.role;\n  const fragileCount = result.strategyDistribution.css +\n    result.strategyDistribution.xpath +\n    result.strategyDistribution.nth;\n\n  if (testIdCount > totalSelectors * 0.5) {\n    reasons.push('Good test-id coverage');\n  } else if (testIdCount < totalSelectors * 0.2) {\n    reasons.push('Low test-id usage');\n  }\n\n  if (roleCount > 0) {\n    reasons.push(`${roleCount} role-based selectors (accessible)`);\n  }\n\n  if (fragileCount > totalSelectors * 0.3) {\n    reasons.push(`${fragileCount} fragile selectors (CSS/XPath/nth)`);\n  }\n\n  // Fragility issues\n  const fragileSelectors = result.selectors.filter(s => s.isFragile);\n  if (fragileSelectors.length > 0) {\n    reasons.push(`${fragileSelectors.length} selectors with fragility issues`);\n  }\n\n  // Overall assessment\n  if (result.stabilityScore > 0.8) {\n    reasons.push('High stability');\n  } else if (result.stabilityScore < 0.5) {\n    reasons.push('Low stability');\n  }\n\n  return reasons.join('; ');\n}\n\n// \n// UTILITY EXPORTS\n// \n\n/**\n * Quick check if code uses recommended selector strategies\n */\nexport function usesRecommendedSelectors(code: string): boolean {\n  const hasTestId = /getByTestId|data-testid/.test(code);\n  const hasRole = /getByRole/.test(code);\n\n  return hasTestId || hasRole;\n}\n\n/**\n * Get selector strategy from code snippet\n */\nexport function identifyStrategy(selectorCode: string): SelectorStrategy {\n  for (const pattern of SELECTOR_PATTERNS) {\n    if (new RegExp(pattern.pattern.source).test(selectorCode)) {\n      return pattern.strategy;\n    }\n  }\n  return 'css'; // Default fallback\n}\n\n/**\n * Check if selector is likely fragile\n */\nexport function isSelectorFragile(selector: string): boolean {\n  return analyzeSelectorFragility(selector).length > 0;\n}\n","/**\n * @module uncertainty/confidence-scorer\n * @description Multi-dimensional confidence scoring for generated code\n */\n\nimport { TokenUsage } from '../shared/types.js';\nimport { CostTracker } from '../shared/cost-tracker.js';\nimport { UncertaintyConfig } from '../shared/config-validator.js';\nimport {\n  ConfidenceScore,\n  ConfidenceDimension,\n  ConfidenceVerdict,\n  ConfidenceThreshold,\n  ConfidenceDiagnostics,\n  DimensionScore,\n  DimensionWeights,\n  CodeSample,\n  AgreementAnalysisResult,\n  DisagreementArea,\n  DEFAULT_DIMENSION_WEIGHTS,\n  DEFAULT_THRESHOLDS,\n} from './types.js';\nimport { validateSyntax, createSyntaxDimensionScore } from './syntax-validator.js';\nimport { matchPatterns, createPatternDimensionScore, PatternDefinition } from './pattern-matcher.js';\nimport { analyzeSelectors, createSelectorDimensionScore } from './selector-analyzer.js';\n\n// \n// LLM CLIENT INTERFACE (for multi-sampling)\n// \n\nexport interface UncertaintyLLMClient {\n  generateSample(\n    _prompt: string,\n    _systemPrompt: string,\n    _temperature: number,\n    _maxTokens: number\n  ): Promise<{ code: string; tokenUsage: TokenUsage }>;\n}\n\n// \n// MAIN CONFIDENCE SCORER\n// \n\nexport interface ScorerOptions {\n  config: UncertaintyConfig;\n  llmClient?: UncertaintyLLMClient;\n  costTracker?: CostTracker;\n  customPatterns?: PatternDefinition[];\n  llkbPatterns?: PatternDefinition[];\n}\n\n/**\n * Calculate confidence score for generated code\n */\nexport async function calculateConfidence(\n  code: string,\n  options: ScorerOptions\n): Promise<ConfidenceScore> {\n  const {\n    config,\n    // Note: llmClient and costTracker are available in options for future multi-sample LLM calls\n    customPatterns,\n    llkbPatterns,\n  } = options;\n\n  const weights: DimensionWeights = config.weights ? {\n    syntax: config.weights.syntax,\n    pattern: config.weights.pattern,\n    selector: config.weights.selector,\n    agreement: config.weights.agreement,\n  } : DEFAULT_DIMENSION_WEIGHTS;\n\n  // Convert config thresholds to internal format\n  const thresholds: ConfidenceThreshold = config.thresholds ? {\n    overall: config.thresholds.autoAccept,\n    perDimension: {\n      syntax: config.thresholds.minimumPerDimension,\n      pattern: config.thresholds.minimumPerDimension,\n      selector: config.thresholds.minimumPerDimension,\n      agreement: config.thresholds.minimumPerDimension,\n    },\n    blockOnAnyBelow: config.thresholds.block,\n  } : DEFAULT_THRESHOLDS;\n\n  // Calculate each dimension\n  const dimensions: DimensionScore[] = [];\n\n  // 1. Syntax validation\n  const syntaxResult = validateSyntax(code);\n  const syntaxScore = createSyntaxDimensionScore(syntaxResult);\n  syntaxScore.weight = weights.syntax;\n  dimensions.push(syntaxScore);\n\n  // 2. Pattern matching\n  const patternResult = matchPatterns(code, {\n    customPatterns,\n    llkbPatterns,\n    includeBuiltins: true,\n  });\n  const patternScore = createPatternDimensionScore(patternResult);\n  patternScore.weight = weights.pattern;\n  dimensions.push(patternScore);\n\n  // 3. Selector analysis\n  const selectorResult = analyzeSelectors(code);\n  const selectorScore = createSelectorDimensionScore(selectorResult);\n  selectorScore.weight = weights.selector;\n  dimensions.push(selectorScore);\n\n  // 4. Multi-sample agreement\n  // NOTE: Multi-sample agreement scoring requires multiple code samples.\n  // For single-code confidence scoring, use calculateConfidenceWithSamples() instead\n  // which properly analyzes agreement between pre-generated samples.\n  //\n  // IMPORTANT: We do NOT add a fake agreement score here. Instead:\n  // - If multi-sampling is enabled but single code passed: throw error (misconfiguration)\n  // - If multi-sampling is disabled: exclude agreement dimension entirely\n  if (config.sampling?.enabled && config.sampling.sampleCount > 1) {\n    // Multi-sampling enabled but wrong function called - this is a programming error\n    throw new Error(\n      '[confidence-scorer] Multi-sampling is enabled (sampleCount=' + config.sampling.sampleCount + ') ' +\n      'but calculateConfidence() only accepts single code. ' +\n      'Use calculateConfidenceWithSamples() with pre-generated samples for agreement scoring.'\n    );\n  }\n  // Single-code mode: Agreement dimension is excluded from scoring.\n  // The overall score will be calculated from syntax, pattern, and selector dimensions only.\n  // This prevents artificial bias from a fake \"neutral\" agreement score.\n\n  // Calculate overall score\n  const overall = calculateOverallScore(dimensions);\n\n  // Determine verdict\n  const { verdict, blockedDimensions } = determineVerdict(dimensions, thresholds);\n\n  // Create diagnostics\n  const diagnostics = createDiagnostics(dimensions);\n\n  return {\n    overall,\n    dimensions,\n    threshold: thresholds,\n    verdict,\n    blockedDimensions,\n    diagnostics,\n  };\n}\n\n/**\n * Calculate confidence with multiple samples\n */\nexport async function calculateConfidenceWithSamples(\n  samples: CodeSample[],\n  options: ScorerOptions\n): Promise<ConfidenceScore> {\n  if (samples.length === 0) {\n    throw new Error('At least one sample is required');\n  }\n\n  if (samples.length === 1) {\n    // Single sample - just calculate normally\n    const sample = samples[0]!;\n    return calculateConfidence(sample.code, options);\n  }\n\n  const { config, customPatterns, llkbPatterns } = options;\n  const weights: DimensionWeights = config.weights ? {\n    syntax: config.weights.syntax,\n    pattern: config.weights.pattern,\n    selector: config.weights.selector,\n    agreement: config.weights.agreement,\n  } : DEFAULT_DIMENSION_WEIGHTS;\n\n  // Convert config thresholds to internal format\n  const thresholds: ConfidenceThreshold = config.thresholds ? {\n    overall: config.thresholds.autoAccept,\n    perDimension: {\n      syntax: config.thresholds.minimumPerDimension,\n      pattern: config.thresholds.minimumPerDimension,\n      selector: config.thresholds.minimumPerDimension,\n      agreement: config.thresholds.minimumPerDimension,\n    },\n    blockOnAnyBelow: config.thresholds.block,\n  } : DEFAULT_THRESHOLDS;\n\n  // Calculate scores for each sample\n  const sampleScores = samples.map(sample => ({\n    sample,\n    syntax: validateSyntax(sample.code),\n    patterns: matchPatterns(sample.code, { customPatterns, llkbPatterns }),\n    selectors: analyzeSelectors(sample.code),\n  }));\n\n  // Use median scores for syntax, pattern, selector\n  const syntaxScores = sampleScores.map(s => s.syntax.score).sort((a, b) => a - b);\n  const patternScores = sampleScores.map(s => s.patterns.score).sort((a, b) => a - b);\n  const selectorScores = sampleScores.map(s => s.selectors.score).sort((a, b) => a - b);\n\n  const medianIndex = Math.floor(samples.length / 2);\n\n  // Create dimension scores with median values\n  const dimensions: DimensionScore[] = [\n    {\n      dimension: 'syntax',\n      score: syntaxScores[medianIndex] ?? 0,\n      weight: weights.syntax,\n      reasoning: `Median of ${samples.length} samples`,\n      subScores: [],\n    },\n    {\n      dimension: 'pattern',\n      score: patternScores[medianIndex] ?? 0,\n      weight: weights.pattern,\n      reasoning: `Median of ${samples.length} samples`,\n      subScores: [],\n    },\n    {\n      dimension: 'selector',\n      score: selectorScores[medianIndex] ?? 0,\n      weight: weights.selector,\n      reasoning: `Median of ${samples.length} samples`,\n      subScores: [],\n    },\n  ];\n\n  // Calculate agreement score\n  const agreementResult = analyzeAgreement(samples.map(s => s.code));\n  const agreementScore: DimensionScore = {\n    dimension: 'agreement',\n    score: agreementResult.score,\n    weight: weights.agreement,\n    reasoning: `Agreement across ${samples.length} samples`,\n    subScores: [\n      { name: 'Structural', score: agreementResult.structuralAgreement },\n      { name: 'Selector', score: agreementResult.selectorAgreement },\n      { name: 'Flow', score: agreementResult.flowAgreement },\n      { name: 'Assertion', score: agreementResult.assertionAgreement },\n    ],\n  };\n  dimensions.push(agreementScore);\n\n  // Calculate overall and verdict\n  const overall = calculateOverallScore(dimensions);\n  const { verdict, blockedDimensions } = determineVerdict(dimensions, thresholds);\n  const diagnostics = createDiagnostics(dimensions);\n\n  return {\n    overall,\n    dimensions,\n    threshold: thresholds,\n    verdict,\n    blockedDimensions,\n    diagnostics,\n  };\n}\n\n// \n// AGREEMENT ANALYSIS\n// \n\nfunction analyzeAgreement(codes: string[]): AgreementAnalysisResult {\n  if (codes.length < 2) {\n    return {\n      score: 1.0,\n      sampleCount: codes.length,\n      structuralAgreement: 1.0,\n      selectorAgreement: 1.0,\n      flowAgreement: 1.0,\n      assertionAgreement: 1.0,\n      disagreementAreas: [],\n    };\n  }\n\n  // Extract comparable features from each sample\n  const features = codes.map(code => extractCodeFeatures(code));\n\n  // Calculate agreement for each aspect\n  const structuralAgreement = calculateStructuralAgreement(features);\n  const selectorAgreement = calculateSelectorAgreement(features);\n  const flowAgreement = calculateFlowAgreement(features);\n  const assertionAgreement = calculateAssertionAgreement(features);\n\n  // Find disagreement areas\n  const disagreementAreas = findDisagreementAreas(features);\n\n  // Overall agreement score\n  const score = (\n    structuralAgreement * 0.3 +\n    selectorAgreement * 0.3 +\n    flowAgreement * 0.2 +\n    assertionAgreement * 0.2\n  );\n\n  // Select consensus code (most common structure)\n  const consensusCode = selectConsensusCode(codes, features);\n\n  return {\n    score,\n    sampleCount: codes.length,\n    structuralAgreement,\n    selectorAgreement,\n    flowAgreement,\n    assertionAgreement,\n    consensusCode,\n    disagreementAreas,\n  };\n}\n\ninterface CodeFeatures {\n  testCount: number;\n  stepCount: number;\n  selectorStrategies: string[];\n  assertions: string[];\n  flowStructure: string;\n}\n\nfunction extractCodeFeatures(code: string): CodeFeatures {\n  return {\n    testCount: (code.match(/test\\s*\\(/g) || []).length,\n    stepCount: (code.match(/test\\.step\\s*\\(/g) || []).length,\n    selectorStrategies: extractSelectorStrategies(code),\n    assertions: extractAssertions(code),\n    flowStructure: extractFlowStructure(code),\n  };\n}\n\nfunction extractSelectorStrategies(code: string): string[] {\n  const strategies: string[] = [];\n  if (/getByTestId/.test(code)) strategies.push('testId');\n  if (/getByRole/.test(code)) strategies.push('role');\n  if (/getByText/.test(code)) strategies.push('text');\n  if (/getByLabel/.test(code)) strategies.push('label');\n  if (/locator\\(/.test(code)) strategies.push('css');\n  return strategies;\n}\n\nfunction extractAssertions(code: string): string[] {\n  const assertions: string[] = [];\n  const assertionMatches = code.match(/expect\\([^)]+\\)\\.\\w+/g) || [];\n  for (const match of assertionMatches) {\n    const method = match.match(/\\.(\\w+)$/)?.[1] || '';\n    if (method) assertions.push(method);\n  }\n  return assertions;\n}\n\nfunction extractFlowStructure(code: string): string {\n  // Create a simplified flow representation\n  const actions: string[] = [];\n\n  // Navigation\n  if (/page\\.goto/.test(code)) actions.push('navigate');\n\n  // Interactions\n  if (/\\.click/.test(code)) actions.push('click');\n  if (/\\.fill/.test(code)) actions.push('fill');\n  if (/\\.selectOption/.test(code)) actions.push('select');\n\n  // Waits\n  if (/waitFor/.test(code)) actions.push('wait');\n\n  // Assertions\n  if (/expect\\(/.test(code)) actions.push('assert');\n\n  return actions.join('->');\n}\n\nfunction calculateStructuralAgreement(features: CodeFeatures[]): number {\n  if (features.length < 2) return 1.0;\n\n  // Compare test counts\n  const testCounts = features.map(f => f.testCount);\n  const testCountAgreement = calculateValueAgreement(testCounts);\n\n  // Compare step counts\n  const stepCounts = features.map(f => f.stepCount);\n  const stepCountAgreement = calculateValueAgreement(stepCounts);\n\n  return (testCountAgreement + stepCountAgreement) / 2;\n}\n\nfunction calculateSelectorAgreement(features: CodeFeatures[]): number {\n  if (features.length < 2) return 1.0;\n\n  // Calculate Jaccard similarity\n  let totalSimilarity = 0;\n  let comparisons = 0;\n\n  for (let i = 0; i < features.length; i++) {\n    for (let j = i + 1; j < features.length; j++) {\n      const featureI = features[i];\n      const featureJ = features[j];\n      if (featureI && featureJ) {\n        const set1 = new Set(featureI.selectorStrategies);\n        const set2 = new Set(featureJ.selectorStrategies);\n        totalSimilarity += jaccardSimilarity(set1, set2);\n        comparisons++;\n      }\n    }\n  }\n\n  return comparisons > 0 ? totalSimilarity / comparisons : 1.0;\n}\n\nfunction calculateFlowAgreement(features: CodeFeatures[]): number {\n  if (features.length < 2) return 1.0;\n\n  // Compare flow structures\n  const flows = features.map(f => f.flowStructure);\n  const uniqueFlows = new Set(flows);\n\n  // If all flows are the same, perfect agreement\n  if (uniqueFlows.size === 1) return 1.0;\n\n  // Calculate based on majority\n  const flowCounts = new Map<string, number>();\n  for (const flow of flows) {\n    flowCounts.set(flow, (flowCounts.get(flow) || 0) + 1);\n  }\n\n  const maxCount = Math.max(...flowCounts.values());\n  return maxCount / flows.length;\n}\n\nfunction calculateAssertionAgreement(features: CodeFeatures[]): number {\n  if (features.length < 2) return 1.0;\n\n  // Compare assertions\n  let totalSimilarity = 0;\n  let comparisons = 0;\n\n  for (let i = 0; i < features.length; i++) {\n    for (let j = i + 1; j < features.length; j++) {\n      const featureI = features[i];\n      const featureJ = features[j];\n      if (featureI && featureJ) {\n        const set1 = new Set(featureI.assertions);\n        const set2 = new Set(featureJ.assertions);\n        totalSimilarity += jaccardSimilarity(set1, set2);\n        comparisons++;\n      }\n    }\n  }\n\n  return comparisons > 0 ? totalSimilarity / comparisons : 1.0;\n}\n\nfunction calculateValueAgreement(values: number[]): number {\n  if (values.length < 2) return 1.0;\n\n  const min = Math.min(...values);\n  const max = Math.max(...values);\n\n  if (max === 0) return 1.0;\n  return min / max; // Higher when values are similar\n}\n\nfunction jaccardSimilarity(set1: Set<string>, set2: Set<string>): number {\n  if (set1.size === 0 && set2.size === 0) return 1.0;\n\n  const intersection = new Set([...set1].filter(x => set2.has(x)));\n  const union = new Set([...set1, ...set2]);\n\n  return intersection.size / union.size;\n}\n\nfunction findDisagreementAreas(features: CodeFeatures[]): DisagreementArea[] {\n  const areas: DisagreementArea[] = [];\n\n  // Check selector strategy disagreement\n  const allStrategies = features.map(f => f.selectorStrategies.join(','));\n  if (new Set(allStrategies).size > 1) {\n    const voteCounts: Record<string, number> = {};\n    for (const s of allStrategies) {\n      voteCounts[s] = (voteCounts[s] || 0) + 1;\n    }\n    const voteValues = Object.values(voteCounts);\n    areas.push({\n      area: 'Selector Strategies',\n      variants: [...new Set(allStrategies)],\n      voteCounts,\n      confidence: voteValues.length > 0 ? Math.max(...voteValues) / features.length : 0,\n    });\n  }\n\n  // Check flow disagreement\n  const flows = features.map(f => f.flowStructure);\n  if (new Set(flows).size > 1) {\n    const voteCounts: Record<string, number> = {};\n    for (const f of flows) {\n      voteCounts[f] = (voteCounts[f] || 0) + 1;\n    }\n    const voteValues = Object.values(voteCounts);\n    areas.push({\n      area: 'Test Flow',\n      variants: [...new Set(flows)],\n      voteCounts,\n      confidence: voteValues.length > 0 ? Math.max(...voteValues) / features.length : 0,\n    });\n  }\n\n  return areas;\n}\n\nfunction selectConsensusCode(codes: string[], features: CodeFeatures[]): string {\n  // Select the code with the most common structure\n  const structures = features.map(f => JSON.stringify({\n    testCount: f.testCount,\n    stepCount: f.stepCount,\n    flow: f.flowStructure,\n  }));\n\n  const structureCounts = new Map<string, number>();\n  for (const s of structures) {\n    structureCounts.set(s, (structureCounts.get(s) || 0) + 1);\n  }\n\n  let maxCount = 0;\n  let consensusStructure = structures[0] || '';\n  for (const [structure, count] of structureCounts) {\n    if (count > maxCount) {\n      maxCount = count;\n      consensusStructure = structure;\n    }\n  }\n\n  // Return the first code with the consensus structure\n  const index = structures.indexOf(consensusStructure);\n  return codes[index] || codes[0] || '';\n}\n\n// \n// SCORE CALCULATIONS\n// \n\nfunction calculateOverallScore(dimensions: DimensionScore[]): number {\n  let weightedSum = 0;\n  let totalWeight = 0;\n\n  for (const dim of dimensions) {\n    weightedSum += dim.score * dim.weight;\n    totalWeight += dim.weight;\n  }\n\n  return totalWeight > 0 ? weightedSum / totalWeight : 0;\n}\n\nfunction determineVerdict(\n  dimensions: DimensionScore[],\n  thresholds: ConfidenceThreshold\n): { verdict: ConfidenceVerdict; blockedDimensions: ConfidenceDimension[] } {\n  const blockedDimensions: ConfidenceDimension[] = [];\n\n  // Check each dimension against its threshold\n  for (const dim of dimensions) {\n    const dimThreshold = thresholds.perDimension[dim.dimension];\n    // Block if below the absolute minimum OR below the per-dimension threshold\n    if (dim.score < thresholds.blockOnAnyBelow || dim.score < dimThreshold) {\n      blockedDimensions.push(dim.dimension);\n    }\n  }\n\n  // Determine verdict\n  if (blockedDimensions.length > 0) {\n    return { verdict: 'REJECT', blockedDimensions };\n  }\n\n  const overall = calculateOverallScore(dimensions);\n  if (overall >= thresholds.overall) {\n    return { verdict: 'ACCEPT', blockedDimensions: [] };\n  }\n\n  return { verdict: 'REVIEW', blockedDimensions: [] };\n}\n\nfunction createDiagnostics(dimensions: DimensionScore[]): ConfidenceDiagnostics {\n  // Find lowest and highest dimensions\n  const sorted = [...dimensions].sort((a, b) => a.score - b.score);\n  const lowest = sorted[0];\n  const highest = sorted[sorted.length - 1];\n\n  // Generate improvement suggestions\n  const suggestions: string[] = [];\n  for (const dim of dimensions) {\n    if (dim.score < 0.7) {\n      suggestions.push(...generateSuggestions(dim));\n    }\n  }\n\n  // Identify risk areas\n  const riskAreas: string[] = [];\n  for (const dim of dimensions) {\n    if (dim.score < 0.5) {\n      riskAreas.push(`Low ${dim.dimension} score (${Math.round(dim.score * 100)}%)`);\n    }\n  }\n\n  return {\n    lowestDimension: lowest ? {\n      name: lowest.dimension,\n      score: lowest.score,\n    } : { name: 'syntax' as const, score: 0 },\n    highestDimension: highest ? {\n      name: highest.dimension,\n      score: highest.score,\n    } : { name: 'syntax' as const, score: 0 },\n    improvementSuggestions: suggestions.slice(0, 5),\n    riskAreas,\n  };\n}\n\nfunction generateSuggestions(dim: DimensionScore): string[] {\n  switch (dim.dimension) {\n    case 'syntax':\n      return [\n        'Fix TypeScript compilation errors',\n        'Use proper Playwright imports',\n        'Ensure all brackets are balanced',\n      ];\n    case 'pattern':\n      return [\n        'Use recognized Playwright patterns',\n        'Follow established test structure',\n        'Add test.step() for better organization',\n      ];\n    case 'selector':\n      return [\n        'Use data-testid attributes for stability',\n        'Prefer getByRole for accessibility',\n        'Avoid CSS selectors with class names',\n      ];\n    case 'agreement':\n      return [\n        'Increase sample count for better consensus',\n        'Review disagreement areas manually',\n      ];\n    default:\n      return [];\n  }\n}\n\n// \n// EXPORTS FOR QUICK CHECKS\n// \n\n/**\n * Quick confidence check (single dimension)\n */\nexport function quickConfidenceCheck(\n  code: string,\n  dimension: ConfidenceDimension\n): number {\n  switch (dimension) {\n    case 'syntax':\n      return validateSyntax(code).score;\n    case 'pattern':\n      return matchPatterns(code).score;\n    case 'selector':\n      return analyzeSelectors(code).score;\n    case 'agreement':\n      return 0.7; // Cannot calculate without multiple samples\n  }\n}\n\n/**\n * Check if code passes minimum confidence\n */\nexport function passesMinimumConfidence(\n  code: string,\n  minOverall: number = 0.7,\n  minPerDimension: number = 0.4\n): boolean {\n  const syntaxScore = validateSyntax(code).score;\n  if (syntaxScore < minPerDimension) return false;\n\n  const patternScore = matchPatterns(code).score;\n  if (patternScore < minPerDimension) return false;\n\n  const selectorScore = analyzeSelectors(code).score;\n  if (selectorScore < minPerDimension) return false;\n\n  // Calculate approximate overall\n  const overall = (syntaxScore + patternScore + selectorScore) / 3;\n  return overall >= minOverall;\n}\n\n/**\n * Get blocking issues (reasons code would be rejected)\n */\nexport function getBlockingIssues(code: string): string[] {\n  const issues: string[] = [];\n\n  const syntax = validateSyntax(code);\n  if (syntax.errors.length > 0) {\n    issues.push(`${syntax.errors.length} syntax error(s)`);\n  }\n\n  const selectors = analyzeSelectors(code);\n  const fragileCount = selectors.selectors.filter(s => s.isFragile).length;\n  if (fragileCount > selectors.selectors.length * 0.5) {\n    issues.push(`${fragileCount} fragile selector(s)`);\n  }\n\n  return issues;\n}\n","/**\n * @module uncertainty/multi-sampler\n * @description Multi-sampling for uncertainty quantification\n *\n * Generates multiple code samples at different temperatures and\n * analyzes agreement to quantify uncertainty.\n *\n * @see research/2026-02-02_autogen-enhancement-implementation-plan.md\n */\nimport { writeFileSync, readFileSync, existsSync, mkdirSync } from 'node:fs';\nimport { join } from 'node:path';\nimport {\n  CodeSample,\n  AgreementAnalysisResult,\n  DisagreementArea,\n} from './types.js';\nimport { getAutogenArtifact, ensureAutogenDir } from '../utils/paths.js';\nimport { TokenUsage } from '../shared/types.js';\n\n// \n// TYPES\n// \n\nexport interface MultiSamplerConfig {\n  /** Number of samples to generate */\n  sampleCount: number;\n  /** Temperatures for each sample (length should match sampleCount) */\n  temperatures: number[];\n  /** Minimum agreement score to accept consensus */\n  minAgreementScore: number;\n  /** Whether to save samples to disk */\n  persistSamples: boolean;\n}\n\nexport interface MultiSampleRequest {\n  /** Prompt for code generation */\n  prompt: string;\n  /** Journey ID for tracking */\n  journeyId: string;\n  /** Configuration */\n  config: MultiSamplerConfig;\n}\n\nexport interface MultiSampleResult {\n  /** Generated samples */\n  samples: CodeSample[];\n  /** Agreement analysis */\n  agreement: AgreementAnalysisResult;\n  /** Best sample (highest agreement or first if no consensus) */\n  bestSample: CodeSample;\n  /** Total tokens used across all samples */\n  totalTokenUsage: TokenUsage;\n  /** Path to samples directory (if persisted) */\n  samplesDir?: string;\n}\n\nexport interface CodeGenerator {\n  /** Generate code from a prompt */\n  generate(_prompt: string, _temperature: number): Promise<{\n    code: string;\n    tokenUsage: TokenUsage;\n  }>;\n}\n\nexport const DEFAULT_MULTI_SAMPLER_CONFIG: MultiSamplerConfig = {\n  sampleCount: 3,\n  temperatures: [0.2, 0.5, 0.8],\n  minAgreementScore: 0.7,\n  persistSamples: true,\n};\n\n// \n// CODE STRUCTURE ANALYSIS\n// \n\ninterface CodeStructure {\n  imports: string[];\n  testBlocks: string[];\n  assertions: string[];\n  selectors: string[];\n  actions: string[];\n}\n\n/**\n * Extract structural elements from code\n */\nfunction extractStructure(code: string): CodeStructure {\n  const lines = code.split('\\n');\n\n  const imports: string[] = [];\n  const testBlocks: string[] = [];\n  const assertions: string[] = [];\n  const selectors: string[] = [];\n  const actions: string[] = [];\n\n  for (const line of lines) {\n    const trimmed = line.trim();\n\n    // Imports\n    if (trimmed.startsWith('import ')) {\n      imports.push(trimmed);\n    }\n\n    // Test blocks\n    if (trimmed.match(/^(test|it|describe)\\s*\\(/)) {\n      const nameMatch = trimmed.match(/['\"]([^'\"]+)['\"]/);\n      if (nameMatch && nameMatch[1]) {\n        testBlocks.push(nameMatch[1]);\n      }\n    }\n\n    // Assertions (expect statements)\n    if (trimmed.includes('expect(') || trimmed.includes('.should')) {\n      const assertMatch = trimmed.match(/expect\\(([^)]+)\\)|\\.should\\(([^)]+)\\)/);\n      if (assertMatch) {\n        assertions.push(assertMatch[0]);\n      }\n    }\n\n    // Selectors\n    const selectorMatches = trimmed.matchAll(/(?:locator|getBy\\w+)\\(['\"]([^'\"]+)['\"]\\)/g);\n    for (const match of selectorMatches) {\n      if (match[1]) {\n        selectors.push(match[1]);\n      }\n    }\n\n    // Actions\n    if (trimmed.match(/\\.(click|fill|type|press|check|uncheck|select|hover)\\(/)) {\n      actions.push(trimmed.substring(0, 100));\n    }\n  }\n\n  return { imports, testBlocks, assertions, selectors, actions };\n}\n\n/**\n * Calculate similarity between two arrays\n */\nfunction arraySimilarity(a: string[], b: string[]): number {\n  if (a.length === 0 && b.length === 0) return 1;\n  if (a.length === 0 || b.length === 0) return 0;\n\n  const setA = new Set(a);\n  const setB = new Set(b);\n\n  const intersection = [...setA].filter(x => setB.has(x)).length;\n  const union = new Set([...setA, ...setB]).size;\n\n  return intersection / union;\n}\n\n/**\n * Calculate structural agreement between two code samples\n */\nfunction calculateStructuralAgreement(\n  struct1: CodeStructure,\n  struct2: CodeStructure\n): number {\n  const weights = {\n    imports: 0.1,\n    testBlocks: 0.2,\n    assertions: 0.3,\n    selectors: 0.25,\n    actions: 0.15,\n  };\n\n  let score = 0;\n  score += weights.imports * arraySimilarity(struct1.imports, struct2.imports);\n  score += weights.testBlocks * arraySimilarity(struct1.testBlocks, struct2.testBlocks);\n  score += weights.assertions * arraySimilarity(struct1.assertions, struct2.assertions);\n  score += weights.selectors * arraySimilarity(struct1.selectors, struct2.selectors);\n  score += weights.actions * arraySimilarity(struct1.actions, struct2.actions);\n\n  return score;\n}\n\n// \n// AGREEMENT ANALYSIS\n// \n\n/**\n * Find disagreement areas between samples\n */\nfunction findDisagreements(structures: CodeStructure[]): DisagreementArea[] {\n  const areas: DisagreementArea[] = [];\n\n  // Check selectors disagreement\n  const allSelectors = structures.flatMap(s => s.selectors);\n  const selectorCounts = new Map<string, number>();\n  for (const sel of allSelectors) {\n    selectorCounts.set(sel, (selectorCounts.get(sel) || 0) + 1);\n  }\n\n  const uniqueSelectors = [...selectorCounts.entries()]\n    .filter(([, count]) => count < structures.length)\n    .map(([sel]) => sel);\n\n  if (uniqueSelectors.length > 0) {\n    const voteCounts: Record<string, number> = {};\n    for (const [sel, count] of selectorCounts) {\n      voteCounts[sel] = count;\n    }\n    areas.push({\n      area: 'selectors',\n      variants: uniqueSelectors,\n      voteCounts,\n      confidence: selectorCounts.size > 0 ? Math.max(...selectorCounts.values()) / structures.length : 0,\n    });\n  }\n\n  // Check assertions disagreement\n  const allAssertions = structures.flatMap(s => s.assertions);\n  const assertionCounts = new Map<string, number>();\n  for (const a of allAssertions) {\n    assertionCounts.set(a, (assertionCounts.get(a) || 0) + 1);\n  }\n\n  const uniqueAssertions = [...assertionCounts.entries()]\n    .filter(([, count]) => count < structures.length)\n    .map(([a]) => a);\n\n  if (uniqueAssertions.length > 0) {\n    const voteCounts: Record<string, number> = {};\n    for (const [a, count] of assertionCounts) {\n      voteCounts[a] = count;\n    }\n    areas.push({\n      area: 'assertions',\n      variants: uniqueAssertions,\n      voteCounts,\n      confidence: assertionCounts.size > 0 ? Math.max(...assertionCounts.values()) / structures.length : 0,\n    });\n  }\n\n  return areas;\n}\n\n/**\n * Analyze agreement across multiple samples\n */\nexport function analyzeAgreement(samples: CodeSample[]): AgreementAnalysisResult {\n  if (samples.length === 0) {\n    return {\n      score: 0,\n      sampleCount: 0,\n      structuralAgreement: 0,\n      selectorAgreement: 0,\n      flowAgreement: 0,\n      assertionAgreement: 0,\n      disagreementAreas: [],\n    };\n  }\n\n  if (samples.length === 1) {\n    return {\n      score: 1, // Single sample has perfect agreement with itself\n      sampleCount: 1,\n      structuralAgreement: 1,\n      selectorAgreement: 1,\n      flowAgreement: 1,\n      assertionAgreement: 1,\n      consensusCode: samples[0]?.code || '',\n      disagreementAreas: [],\n    };\n  }\n\n  // Extract structures\n  const structures = samples.map(s => extractStructure(s.code));\n\n  // Calculate pairwise agreements\n  let totalStructural = 0;\n  let totalSelector = 0;\n  let totalAssertion = 0;\n  let pairCount = 0;\n\n  for (let i = 0; i < structures.length; i++) {\n    for (let j = i + 1; j < structures.length; j++) {\n      const structI = structures[i];\n      const structJ = structures[j];\n      if (structI && structJ) {\n        totalStructural += calculateStructuralAgreement(structI, structJ);\n        totalSelector += arraySimilarity(structI.selectors, structJ.selectors);\n        totalAssertion += arraySimilarity(structI.assertions, structJ.assertions);\n        pairCount++;\n      }\n    }\n  }\n\n  const structuralAgreement = totalStructural / pairCount;\n  const selectorAgreement = totalSelector / pairCount;\n  const assertionAgreement = totalAssertion / pairCount;\n\n  // Flow agreement based on action sequence similarity\n  let totalFlow = 0;\n  for (let i = 0; i < structures.length; i++) {\n    for (let j = i + 1; j < structures.length; j++) {\n      const structI = structures[i];\n      const structJ = structures[j];\n      if (structI && structJ) {\n        totalFlow += arraySimilarity(structI.actions, structJ.actions);\n      }\n    }\n  }\n  const flowAgreement = pairCount > 0 ? totalFlow / pairCount : 1;\n\n  // Overall score (weighted)\n  const score = (\n    structuralAgreement * 0.3 +\n    selectorAgreement * 0.3 +\n    assertionAgreement * 0.25 +\n    flowAgreement * 0.15\n  );\n\n  // Find disagreement areas\n  const disagreementAreas = findDisagreements(structures);\n\n  // Determine consensus code (sample with highest agreement to others)\n  let bestSampleIndex = 0;\n  let bestAvgAgreement = 0;\n\n  for (let i = 0; i < samples.length; i++) {\n    let avgAgreement = 0;\n    for (let j = 0; j < samples.length; j++) {\n      if (i !== j) {\n        const structI = structures[i];\n        const structJ = structures[j];\n        if (structI && structJ) {\n          avgAgreement += calculateStructuralAgreement(structI, structJ);\n        }\n      }\n    }\n    avgAgreement /= (samples.length - 1);\n    if (avgAgreement > bestAvgAgreement) {\n      bestAvgAgreement = avgAgreement;\n      bestSampleIndex = i;\n    }\n  }\n\n  return {\n    score,\n    sampleCount: samples.length,\n    structuralAgreement,\n    selectorAgreement,\n    flowAgreement,\n    assertionAgreement,\n    consensusCode: samples[bestSampleIndex]?.code || '',\n    disagreementAreas,\n  };\n}\n\n// \n// MULTI-SAMPLER\n// \n\n/**\n * Generate multiple code samples and analyze agreement\n */\nexport async function generateMultipleSamples(\n  request: MultiSampleRequest,\n  generator: CodeGenerator\n): Promise<MultiSampleResult> {\n  const { prompt, journeyId, config } = request;\n  const samples: CodeSample[] = [];\n  const totalTokenUsage: TokenUsage = { promptTokens: 0, completionTokens: 0, totalTokens: 0, estimatedCostUsd: 0 };\n\n  // Generate samples at different temperatures\n  for (let i = 0; i < config.sampleCount; i++) {\n    const temperature = config.temperatures[i] ?? 0.5;\n\n    try {\n      const result = await generator.generate(prompt, temperature);\n\n      samples.push({\n        id: `sample-${i}-t${temperature}`,\n        code: result.code,\n        temperature,\n        tokenUsage: result.tokenUsage,\n      });\n\n      totalTokenUsage.promptTokens += result.tokenUsage.promptTokens;\n      totalTokenUsage.completionTokens += result.tokenUsage.completionTokens;\n      totalTokenUsage.totalTokens += result.tokenUsage.totalTokens;\n    } catch (error) {\n      // Continue with other samples on error\n      console.warn(`Sample ${i} generation failed:`, error);\n    }\n  }\n\n  // Analyze agreement\n  const agreement = analyzeAgreement(samples);\n\n  // Select best sample\n  const bestSampleIndex = samples.findIndex(s => s.code === agreement.consensusCode);\n  const bestSample = (bestSampleIndex >= 0 ? samples[bestSampleIndex] : samples[0]) || samples[0];\n\n  // Persist samples if configured\n  let samplesDir: string | undefined;\n  if (config.persistSamples && samples.length > 0) {\n    await ensureAutogenDir();\n    samplesDir = getAutogenArtifact('samples');\n    mkdirSync(samplesDir, { recursive: true });\n\n    // Save each sample\n    for (let i = 0; i < samples.length; i++) {\n      const sample = samples[i];\n      if (!sample) continue;\n      const samplePath = join(samplesDir, `${journeyId}-sample-${i}.ts`);\n      writeFileSync(samplePath, sample.code, 'utf-8');\n    }\n\n    // Save agreement analysis\n    const agreementPath = getAutogenArtifact('agreement');\n    writeFileSync(agreementPath, JSON.stringify({\n      journeyId,\n      agreement,\n      samples: samples.map(s => ({\n        id: s.id,\n        temperature: s.temperature,\n        tokenUsage: s.tokenUsage,\n      })),\n      totalTokenUsage,\n      generatedAt: new Date().toISOString(),\n    }, null, 2), 'utf-8');\n  }\n\n  return {\n    samples,\n    agreement,\n    bestSample: bestSample ?? samples[0]!,\n    totalTokenUsage,\n    samplesDir,\n  };\n}\n\n/**\n * Load previously generated samples\n */\nexport function loadSamples(journeyId: string): CodeSample[] | null {\n  const samplesDir = getAutogenArtifact('samples');\n  const agreementPath = getAutogenArtifact('agreement');\n\n  if (!existsSync(agreementPath)) {\n    return null;\n  }\n\n  try {\n    const agreementData = JSON.parse(readFileSync(agreementPath, 'utf-8'));\n    if (agreementData.journeyId !== journeyId) {\n      return null;\n    }\n\n    const samples: CodeSample[] = [];\n    for (let i = 0; ; i++) {\n      const samplePath = join(samplesDir, `${journeyId}-sample-${i}.ts`);\n      if (!existsSync(samplePath)) break;\n\n      const code = readFileSync(samplePath, 'utf-8');\n      const meta = agreementData.samples?.[i] || { id: `sample-${i}`, temperature: 0.5 };\n\n      samples.push({\n        id: meta.id || `sample-${i}`,\n        code,\n        temperature: meta.temperature ?? 0.5,\n        tokenUsage: meta.tokenUsage,\n      });\n    }\n\n    return samples.length > 0 ? samples : null;\n  } catch {\n    return null;\n  }\n}\n\n// \n// ORCHESTRATOR SUPPORT\n// \n\n/**\n * Output for orchestrator to generate multiple samples\n */\nexport interface OrchestratorSampleRequest {\n  /** The prompt to use */\n  prompt: string;\n  /** Journey ID */\n  journeyId: string;\n  /** Temperatures to sample at */\n  temperatures: number[];\n  /** Instructions for the orchestrator */\n  instructions: string;\n}\n\n/**\n * Generate instructions for orchestrator to create multiple samples\n */\nexport function createOrchestratorSampleRequest(\n  prompt: string,\n  journeyId: string,\n  config: MultiSamplerConfig = DEFAULT_MULTI_SAMPLER_CONFIG\n): OrchestratorSampleRequest {\n  return {\n    prompt,\n    journeyId,\n    temperatures: config.temperatures,\n    instructions: `\nGenerate ${config.sampleCount} different versions of the Playwright test code.\nFor each version, use a different \"creative temperature\":\n${config.temperatures.map((t, i) => `- Version ${i + 1}: Temperature ${t} (${t < 0.3 ? 'conservative' : t < 0.6 ? 'balanced' : 'creative'})`).join('\\n')}\n\nSave each version as a separate code block labeled with the version number.\nThe goal is to explore different approaches and identify areas of agreement/disagreement.\n\nAfter generating all versions, provide a brief analysis:\n1. What elements are consistent across all versions (high agreement)\n2. What elements differ between versions (disagreement areas)\n3. Which version you recommend as the best consensus\n\nMinimum agreement score threshold: ${config.minAgreementScore}\n`,\n  };\n}\n\n/**\n * Process orchestrator-provided samples\n */\nexport function processOrchestratorSamples(\n  samples: Array<{ code: string; temperature: number }>,\n  _journeyId: string\n): MultiSampleResult {\n  const codeSamples: CodeSample[] = samples.map((s, i) => ({\n    id: `orchestrator-sample-${i}`,\n    code: s.code,\n    temperature: s.temperature,\n  }));\n\n  const agreement = analyzeAgreement(codeSamples);\n\n  const bestSampleIndex = codeSamples.findIndex(s => s.code === agreement.consensusCode);\n  const bestSample = (bestSampleIndex >= 0 ? codeSamples[bestSampleIndex] : codeSamples[0]) ?? codeSamples[0]!;\n\n  return {\n    samples: codeSamples,\n    agreement,\n    bestSample,\n    totalTokenUsage: { promptTokens: 0, completionTokens: 0, totalTokens: 0, estimatedCostUsd: 0 },\n  };\n}\n","/**\n * @module uncertainty\n * @description Uncertainty Quantification strategy for confidence scoring\n */\n\n// Types\nexport * from './types.js';\n\n// Syntax Validator\nexport {\n  validateSyntax,\n  createSyntaxDimensionScore,\n  quickSyntaxCheck,\n  getDeprecatedAPIs,\n} from './syntax-validator.js';\n\n// Pattern Matcher\nexport {\n  matchPatterns,\n  createPatternDimensionScore,\n  getPatternCategories,\n  hasMinimumPatterns,\n  getBuiltinPatterns,\n  type PatternDefinition,\n  type PatternCategory,\n  type PatternMatcherOptions,\n} from './pattern-matcher.js';\n\n// Selector Analyzer\nexport {\n  analyzeSelectors,\n  createSelectorDimensionScore,\n  usesRecommendedSelectors,\n  identifyStrategy,\n  isSelectorFragile,\n} from './selector-analyzer.js';\n\n// Confidence Scorer\nexport {\n  calculateConfidence,\n  calculateConfidenceWithSamples,\n  quickConfidenceCheck,\n  passesMinimumConfidence,\n  getBlockingIssues,\n  type UncertaintyLLMClient,\n  type ScorerOptions,\n} from './confidence-scorer.js';\n\n// Multi-Sampler (Hybrid Agentic Architecture)\nexport {\n  generateMultipleSamples,\n  analyzeAgreement,\n  loadSamples,\n  createOrchestratorSampleRequest,\n  processOrchestratorSamples,\n  DEFAULT_MULTI_SAMPLER_CONFIG,\n  type MultiSamplerConfig,\n  type MultiSampleRequest,\n  type MultiSampleResult,\n  type CodeGenerator,\n  type OrchestratorSampleRequest,\n} from './multi-sampler.js';\n","/**\n * @artk/core-autogen - Deterministic Test Generation Engine\n *\n * Transforms clarified Journey markdown files into Playwright E2E tests.\n *\n * @packageDocumentation\n * @module @artk/core-autogen\n */\n\n// Core types\nexport * from './ir/types.js';\n\n// IR builders and serialization\nexport * from './ir/builder.js';\nexport * from './ir/serialize.js';\n\n// Configuration\nexport * from './config/schema.js';\nexport * from './config/loader.js';\n\n// Journey parsing\nexport * from './journey/parseJourney.js';\nexport * from './journey/normalize.js';\nexport * from './journey/hintPatterns.js';\nexport * from './journey/parseHints.js';\n\n// Mapping\nexport * from './mapping/patterns.js';\nexport * from './mapping/glossary.js';\nexport * from './mapping/stepMapper.js';\n\n// Selectors\nexport * from './selectors/priority.js';\nexport * from './selectors/infer.js';\nexport * from './selectors/catalogSchema.js';\nexport * from './selectors/catalog.js';\nexport * from './selectors/scanner.js';\nexport * from './selectors/debt.js';\n\n// Code generation\nexport * from './codegen/generateTest.js';\nexport * from './codegen/generateModule.js';\nexport * from './codegen/astEdit.js';\nexport * from './codegen/registry.js';\nexport * from './codegen/blocks.js';\n\n// Utilities\nexport * from './utils/escaping.js';\nexport * from './utils/version.js';\nexport * from './utils/parsing.js';\nexport * from './utils/result.js';\n\n// Path utilities (Hybrid Agentic Architecture)\nexport {\n  getPackageRoot,\n  getTemplatesDir,\n  getTemplatePath,\n  getHarnessRoot,\n  getArtkDir,\n  getLlkbRoot,\n  // AutoGen pipeline paths\n  getAutogenDir,\n  getAutogenArtifact,\n  ensureAutogenDir,\n  cleanAutogenArtifacts,\n  hasAutogenArtifacts,\n  type AutogenArtifact,\n} from './utils/paths.js';\n\n// Validation\nexport * from './validate/index.js';\n\n// Verification\nexport * from './verify/index.js';\n\n// Healing\nexport * from './heal/index.js';\n\n// Instance lifecycle\nexport * from './instance/install.js';\nexport * from './instance/upgrade.js';\n\n// Enhancement strategies (AutoGen 2.0)\n// Shared infrastructure for enhancement strategies\nexport * as enhancementShared from './shared/index.js';\n\n// Structured Chain-of-Thought (SCoT) planning\nexport * as scot from './scot/index.js';\n\n// Self-Refinement loops for iterative fixing\nexport * as refinement from './refinement/index.js';\n\n// Uncertainty Quantification for confidence scoring\nexport * as uncertainty from './uncertainty/index.js';\n\n// Main API\nimport { parseJourney, parseJourneyContent } from './journey/parseJourney.js';\nimport { normalizeJourney } from './journey/normalize.js';\nimport { generateTest, type GenerateTestOptions, type GenerateTestResult } from './codegen/generateTest.js';\nimport { generateModule, type GenerateModuleOptions, type GenerateModuleResult } from './codegen/generateModule.js';\nimport { loadConfig } from './config/loader.js';\nimport { initializeLlkb, isLlkbAvailable } from './mapping/stepMapper.js';\nimport type { AutogenConfig } from './config/schema.js';\nimport type { IRJourney } from './ir/types.js';\n\n/**\n * Options for the main generation pipeline\n */\nexport interface GenerateJourneyTestsOptions {\n  /** Journey file paths or content */\n  journeys: string[];\n  /** Whether inputs are file paths (true) or content (false) */\n  isFilePaths?: boolean;\n  /** Output directory for generated files */\n  outputDir?: string;\n  /** Configuration object or path to config file */\n  config?: AutogenConfig | string;\n  /** Generate modules alongside tests */\n  generateModules?: boolean;\n  /** Test generation options */\n  testOptions?: GenerateTestOptions;\n  /** Module generation options */\n  moduleOptions?: GenerateModuleOptions;\n  /** Whether to use LLKB patterns for step mapping (default: true) */\n  useLlkb?: boolean;\n  /** LLKB root directory (default: .artk/llkb) */\n  llkbRoot?: string;\n}\n\n/**\n * Result of the generation pipeline\n */\nexport interface GenerateJourneyTestsResult {\n  /** Generated test files */\n  tests: Array<{\n    journeyId: string;\n    filename: string;\n    code: string;\n  }>;\n  /** Generated module files (if requested) */\n  modules: Array<{\n    moduleName: string;\n    filename: string;\n    code: string;\n  }>;\n  /** Warnings encountered during generation */\n  warnings: string[];\n  /** Errors encountered (generation continues on non-fatal errors) */\n  errors: string[];\n  /** Whether LLKB patterns were used */\n  llkbEnabled?: boolean;\n}\n\n// Re-export LLKB availability check\nexport { initializeLlkb, isLlkbAvailable };\n\n/**\n * Main API: Generate Playwright tests from Journey files\n *\n * @example\n * ```typescript\n * import { generateJourneyTests } from '@artk/core-autogen';\n *\n * const result = await generateJourneyTests({\n *   journeys: ['journeys/login.md', 'journeys/checkout.md'],\n *   isFilePaths: true,\n *   generateModules: true,\n * });\n *\n * for (const test of result.tests) {\n *   console.log(`Generated: ${test.filename}`);\n * }\n * ```\n */\nexport async function generateJourneyTests(\n  options: GenerateJourneyTestsOptions\n): Promise<GenerateJourneyTestsResult> {\n  const {\n    journeys,\n    isFilePaths = true,\n    config,\n    generateModules = false,\n    testOptions = {},\n    moduleOptions = {},\n    useLlkb = true,\n  } = options;\n\n  const result: GenerateJourneyTestsResult = {\n    tests: [],\n    modules: [],\n    warnings: [],\n    errors: [],\n  };\n\n  // Initialize LLKB if enabled (Phase 4 integration)\n  if (useLlkb) {\n    const llkbLoaded = await initializeLlkb();\n    if (llkbLoaded) {\n      result.llkbEnabled = true;\n    }\n  }\n\n  // Load config if provided (reserved for future use)\n  let resolvedConfig: AutogenConfig | undefined;\n  void resolvedConfig; // Reserved for future path resolution\n  if (config) {\n    if (typeof config === 'string') {\n      try {\n        resolvedConfig = loadConfig(config);\n      } catch (err) {\n        result.errors.push(`Failed to load config: ${err instanceof Error ? err.message : String(err)}`);\n      }\n    } else {\n      resolvedConfig = config;\n    }\n  }\n\n  // Process each journey\n  for (const journey of journeys) {\n    try {\n      // Parse journey\n      const parsed = isFilePaths\n        ? parseJourney(journey)\n        : parseJourneyContent(journey, 'inline');\n\n      // Normalize to IR\n      const normalized = normalizeJourney(parsed);\n\n      // Add any mapping warnings\n      result.warnings.push(...normalized.warnings);\n\n      // Generate test\n      const testResult = generateTest(normalized.journey, testOptions);\n      result.tests.push({\n        journeyId: testResult.journeyId,\n        filename: testResult.filename,\n        code: testResult.code,\n      });\n\n      // Generate module if requested\n      if (generateModules) {\n        const moduleResult = generateModule(normalized.journey, moduleOptions);\n        result.modules.push({\n          moduleName: moduleResult.moduleName,\n          filename: moduleResult.filename,\n          code: moduleResult.code,\n        });\n      }\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      result.errors.push(`Failed to process journey ${journey}: ${errorMessage}`);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Generate a single test from an IR Journey\n */\nexport function generateTestFromIR(\n  journey: IRJourney,\n  options?: GenerateTestOptions\n): GenerateTestResult {\n  return generateTest(journey, options);\n}\n\n/**\n * Regenerate a test using managed blocks strategy\n *\n * This preserves user code outside of ARTK:BEGIN/END GENERATED markers\n * while updating the generated portions.\n *\n * @example\n * ```typescript\n * import { regenerateTestWithBlocks, parseAndNormalize } from '@artk/core-autogen';\n *\n * const { journey } = parseAndNormalize('journeys/login.md');\n * const existingCode = readFileSync('tests/login.spec.ts', 'utf-8');\n *\n * const result = regenerateTestWithBlocks(journey, existingCode);\n * writeFileSync('tests/login.spec.ts', result.code);\n *\n * // User code outside ARTK markers is preserved\n * // Generated code inside markers is updated\n * ```\n */\nexport function regenerateTestWithBlocks(\n  journey: IRJourney,\n  existingCode: string,\n  options?: Omit<GenerateTestOptions, 'strategy' | 'existingCode'>\n): GenerateTestResult {\n  return generateTest(journey, {\n    ...options,\n    strategy: 'blocks',\n    existingCode,\n  });\n}\n\n/**\n * Generate a single module from an IR Journey\n */\nexport function generateModuleFromIR(\n  journey: IRJourney,\n  options?: GenerateModuleOptions\n): GenerateModuleResult {\n  return generateModule(journey, options);\n}\n\n/**\n * Parse and normalize a journey file\n */\nexport function parseAndNormalize(filePath: string): {\n  journey: IRJourney;\n  warnings: string[];\n} {\n  const parsed = parseJourney(filePath);\n  const normalized = normalizeJourney(parsed);\n  return {\n    journey: normalized.journey,\n    warnings: normalized.warnings,\n  };\n}\n\n/**\n * Version of the autogen engine\n */\nexport const VERSION = '1.0.0';\n\n// Validation API\nimport {\n  validateCode,\n  validateCodeSync,\n  type CodeValidationResult,\n  type CodeValidationOptions,\n} from './validate/code.js';\n\n/**\n * Options for validating a journey\n */\nexport interface ValidateJourneyOptions extends CodeValidationOptions {\n  /** Journey ID to validate */\n  journeyId?: string;\n  /** Whether inputs are file paths (true) or content (false) */\n  isFilePath?: boolean;\n}\n\n/**\n * Result of journey validation\n */\nexport interface ValidateJourneyResult extends CodeValidationResult {\n  /** The generated code that was validated */\n  generatedCode?: string;\n}\n\n/**\n * Validate a generated journey test\n *\n * @example\n * ```typescript\n * import { validateJourney } from '@artk/core-autogen';\n *\n * const result = await validateJourney('journeys/login.md', {\n *   isFilePath: true,\n *   runLint: true,\n * });\n *\n * if (result.valid) {\n *   console.log('Journey passes validation');\n * } else {\n *   console.log('Issues:', result.issues);\n * }\n * ```\n */\nexport async function validateJourney(\n  journeyInput: string,\n  options: ValidateJourneyOptions = {}\n): Promise<ValidateJourneyResult> {\n  const { isFilePath = true, runLint = false, ...validationOptions } = options;\n\n  try {\n    // Parse journey\n    const parsed = isFilePath\n      ? parseJourney(journeyInput)\n      : parseJourneyContent(journeyInput, 'inline');\n\n    // Normalize to IR\n    const normalized = normalizeJourney(parsed);\n\n    // Generate test code\n    const testResult = generateTest(normalized.journey);\n\n    // Validate the generated code\n    const validationResult = runLint\n      ? await validateCode(testResult.code, normalized.journey, parsed.frontmatter, validationOptions)\n      : validateCodeSync(testResult.code, normalized.journey, parsed.frontmatter, validationOptions);\n\n    return {\n      ...validationResult,\n      generatedCode: testResult.code,\n    };\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    return {\n      valid: false,\n      journeyId: options.journeyId || 'unknown',\n      issues: [\n        {\n          code: 'JOURNEY_PARSE_ERROR',\n          message: `Failed to parse or generate: ${errorMessage}`,\n          severity: 'error',\n        },\n      ],\n      counts: { errors: 1, warnings: 0, info: 0 },\n      details: {\n        patterns: { valid: false, violationCount: 0 },\n      },\n      timestamp: new Date().toISOString(),\n    };\n  }\n}\n\n/**\n * Validate multiple journeys\n */\nexport async function validateJourneys(\n  journeys: string[],\n  options: ValidateJourneyOptions = {}\n): Promise<Map<string, ValidateJourneyResult>> {\n  const results = new Map<string, ValidateJourneyResult>();\n\n  for (const journey of journeys) {\n    const result = await validateJourney(journey, options);\n    results.set(result.journeyId, result);\n  }\n\n  return results;\n}\n\n// Verification API\nimport {\n  runPlaywrightSync,\n  type RunnerOptions,\n} from './verify/runner.js';\nimport {\n  generateVerifySummary,\n  type VerifySummary,\n} from './verify/summary.js';\nimport { writeFileSync, mkdirSync } from 'node:fs';\nimport { join } from 'node:path';\nimport { tmpdir } from 'node:os';\n\n/**\n * Options for verifying a journey\n */\nexport interface VerifyJourneyOptions extends RunnerOptions {\n  /** Journey ID to verify */\n  journeyId?: string;\n  /** Whether input is a file path (true) or content (false) */\n  isFilePath?: boolean;\n  /** Output directory for generated test */\n  outputDir?: string;\n  /** Whether to check stability (repeat runs) */\n  checkStability?: boolean;\n  /** Number of stability runs */\n  stabilityRuns?: number;\n  /** Whether to attempt healing on failure */\n  heal?: boolean;\n  /** Maximum healing attempts */\n  maxHealAttempts?: number;\n}\n\n/**\n * Result of journey verification\n */\nexport interface VerifyJourneyResult extends VerifySummary {\n  /** The generated test code */\n  generatedCode?: string;\n  /** Path to generated test file */\n  testFilePath?: string;\n  /** Healing result (if heal was enabled) */\n  healing?: {\n    attempted: boolean;\n    success: boolean;\n    attempts: number;\n    appliedFix?: string;\n    logPath?: string;\n  };\n}\n\n/**\n * Verify a journey by generating and running tests\n *\n * @example\n * ```typescript\n * import { verifyJourney } from '@artk/core-autogen';\n *\n * const result = await verifyJourney('journeys/login.md', {\n *   isFilePath: true,\n *   checkStability: true,\n * });\n *\n * if (result.status === 'passed') {\n *   console.log('Journey verification passed!');\n * } else {\n *   console.log('Failures:', result.failures.tests);\n * }\n * ```\n */\nexport async function verifyJourney(\n  journeyInput: string,\n  options: VerifyJourneyOptions = {}\n): Promise<VerifyJourneyResult> {\n  const {\n    isFilePath = true,\n    outputDir,\n    checkStability = false,\n    stabilityRuns = 3,\n    heal = false,\n    maxHealAttempts = 3,\n    ...runnerOptions\n  } = options;\n\n  try {\n    // Parse journey\n    const parsed = isFilePath\n      ? parseJourney(journeyInput)\n      : parseJourneyContent(journeyInput, 'inline');\n\n    const journeyId = parsed.frontmatter.id;\n\n    // Normalize to IR\n    const normalized = normalizeJourney(parsed);\n\n    // Generate test code\n    const testResult = generateTest(normalized.journey);\n\n    // Write test to file\n    const testDir = outputDir || join(tmpdir(), `autogen-verify-${Date.now()}`);\n    mkdirSync(testDir, { recursive: true });\n    const testFilePath = join(testDir, testResult.filename);\n    writeFileSync(testFilePath, testResult.code, 'utf-8');\n\n    // Run the test\n    const runResult = runPlaywrightSync({\n      ...runnerOptions,\n      testFile: testFilePath,\n      cwd: testDir,\n      repeatEach: checkStability ? stabilityRuns : undefined,\n      failOnFlaky: checkStability,\n    });\n\n    // Generate summary\n    let summary = generateVerifySummary(runResult, {\n      journeyId,\n    });\n\n    let healingResult: VerifyJourneyResult['healing'];\n\n    // Attempt healing if test failed and heal is enabled\n    if (heal && summary.status === 'failed') {\n      const { runHealingLoop, DEFAULT_HEALING_CONFIG } = await import('./heal/index.js');\n\n      const healResult = await runHealingLoop({\n        journeyId,\n        testFile: testFilePath,\n        outputDir: testDir,\n        config: {\n          ...DEFAULT_HEALING_CONFIG,\n          maxAttempts: maxHealAttempts,\n        },\n        verifyFn: async () => {\n          const rerunResult = runPlaywrightSync({\n            ...runnerOptions,\n            testFile: testFilePath,\n            cwd: testDir,\n          });\n          return generateVerifySummary(rerunResult, { journeyId });\n        },\n      });\n\n      healingResult = {\n        attempted: true,\n        success: healResult.success,\n        attempts: healResult.attempts,\n        appliedFix: healResult.appliedFix,\n        logPath: healResult.logPath,\n      };\n\n      // If healed, update summary\n      if (healResult.success) {\n        const finalResult = runPlaywrightSync({\n          ...runnerOptions,\n          testFile: testFilePath,\n          cwd: testDir,\n        });\n        summary = generateVerifySummary(finalResult, { journeyId });\n      }\n    }\n\n    return {\n      ...summary,\n      generatedCode: testResult.code,\n      testFilePath,\n      healing: healingResult,\n    };\n  } catch {\n    return {\n      status: 'error',\n      journeyId: options.journeyId,\n      timestamp: new Date().toISOString(),\n      duration: 0,\n      counts: { total: 0, passed: 0, failed: 0, skipped: 0, flaky: 0 },\n      failures: {\n        tests: [],\n        classifications: {},\n        stats: {},\n      },\n      runner: { exitCode: 1, command: '' },\n    };\n  }\n}\n\n/**\n * Verify multiple journeys\n */\nexport async function verifyJourneys(\n  journeys: string[],\n  options: VerifyJourneyOptions = {}\n): Promise<Map<string, VerifyJourneyResult>> {\n  const results = new Map<string, VerifyJourneyResult>();\n\n  for (const journey of journeys) {\n    const result = await verifyJourney(journey, options);\n    results.set(result.journeyId || journey, result);\n  }\n\n  return results;\n}\n","/**\n * @module pipeline/state\n * @description Pipeline state management for the Hybrid Agentic architecture\n *\n * Persists pipeline state to .artk/autogen/pipeline-state.json so that:\n * - Orchestrator can resume interrupted pipelines\n * - Status command has accurate information\n * - Commands can validate they're being called in correct order\n *\n * @see research/2026-02-02_autogen-enhancement-implementation-plan.md\n */\nimport { readFileSync, writeFileSync, existsSync, renameSync, unlinkSync } from 'node:fs';\nimport { dirname, join } from 'node:path';\nimport { z } from 'zod';\nimport { getAutogenArtifact, ensureAutogenDir } from '../utils/paths.js';\n\n// \n// TYPES\n// \n\nexport type PipelineStage =\n  | 'initial'       // No artifacts\n  | 'analyzed'      // analysis.json exists\n  | 'planned'       // plan.json exists\n  | 'generated'     // Tests generated\n  | 'tested'        // Tests executed\n  | 'refining'      // In refinement loop\n  | 'completed'     // All tests pass\n  | 'blocked';      // Circuit breaker triggered\n\nexport interface PipelineState {\n  version: '1.0';\n  stage: PipelineStage;\n  lastCommand: string;\n  lastCommandAt: string;\n  journeyIds: string[];\n  testPaths: string[];\n  refinementAttempts: number;\n  isBlocked: boolean;\n  blockedReason?: string;\n  history: PipelineHistoryEntry[];\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport interface PipelineHistoryEntry {\n  command: string;\n  stage: PipelineStage;\n  timestamp: string;\n  success: boolean;\n  details?: Record<string, unknown>;\n}\n\n// \n// VALIDATION SCHEMA\n// \n\n/**\n * Valid pipeline stages\n */\nconst VALID_STAGES: PipelineStage[] = [\n  'initial', 'analyzed', 'planned', 'generated',\n  'tested', 'refining', 'completed', 'blocked'\n];\n\n/**\n * Zod schema for validating pipeline state\n */\nconst PipelineHistoryEntrySchema = z.object({\n  command: z.string(),\n  stage: z.enum(['initial', 'analyzed', 'planned', 'generated', 'tested', 'refining', 'completed', 'blocked']),\n  timestamp: z.string(),\n  success: z.boolean(),\n  details: z.record(z.unknown()).optional(),\n});\n\nconst PipelineStateSchema = z.object({\n  version: z.literal('1.0'),\n  stage: z.enum(['initial', 'analyzed', 'planned', 'generated', 'tested', 'refining', 'completed', 'blocked']),\n  lastCommand: z.string(),\n  lastCommandAt: z.string(),\n  journeyIds: z.array(z.string()),\n  testPaths: z.array(z.string()),\n  refinementAttempts: z.number(),\n  isBlocked: z.boolean(),\n  blockedReason: z.string().optional(),\n  history: z.array(PipelineHistoryEntrySchema),\n  createdAt: z.string(),\n  updatedAt: z.string(),\n}).passthrough(); // Allow unknown fields for forward compatibility\n\n/**\n * Result of loading pipeline state\n */\nexport interface LoadStateResult {\n  state: PipelineState;\n  wasCorrupted: boolean;\n  wasReset: boolean;\n  backupPath?: string;\n}\n\n// \n// DEFAULTS\n// \n\nfunction createEmptyState(): PipelineState {\n  const now = new Date().toISOString();\n  return {\n    version: '1.0',\n    stage: 'initial',\n    lastCommand: 'init',\n    lastCommandAt: now,\n    journeyIds: [],\n    testPaths: [],\n    refinementAttempts: 0,\n    isBlocked: false,\n    history: [],\n    createdAt: now,\n    updatedAt: now,\n  };\n}\n\n// \n// STATE OPERATIONS\n// \n\n/**\n * Create a backup of a corrupted state file\n */\nfunction backupCorruptedFile(statePath: string): string | undefined {\n  const backupPath = `${statePath}.corrupted.${Date.now()}`;\n  try {\n    renameSync(statePath, backupPath);\n    return backupPath;\n  } catch {\n    // If we can't rename, try to leave the original and just warn\n    return undefined;\n  }\n}\n\n/**\n * Load pipeline state from disk\n *\n * Features:\n * - Validates state against Zod schema\n * - Creates backup of corrupted files\n * - Logs warnings for issues\n * - Returns empty state on unrecoverable errors\n */\nexport function loadPipelineState(baseDir?: string): PipelineState {\n  const statePath = getAutogenArtifact('state', baseDir);\n\n  if (!existsSync(statePath)) {\n    return createEmptyState();\n  }\n\n  let content: string;\n  let parsed: unknown;\n\n  // Step 1: Read file\n  try {\n    content = readFileSync(statePath, 'utf-8');\n  } catch (error) {\n    console.warn(`Warning: Cannot read pipeline state file: ${statePath}`);\n    console.warn(`  Error: ${error instanceof Error ? error.message : 'Unknown'}`);\n    return createEmptyState();\n  }\n\n  // Step 2: Parse JSON\n  try {\n    parsed = JSON.parse(content);\n  } catch (error) {\n    console.warn(`Warning: Pipeline state file contains invalid JSON, creating backup and resetting.`);\n    console.warn(`  Error: ${error instanceof Error ? error.message : 'Unknown'}`);\n\n    const backupPath = backupCorruptedFile(statePath);\n    if (backupPath) {\n      console.warn(`  Backup saved to: ${backupPath}`);\n    }\n\n    return createEmptyState();\n  }\n\n  // Step 3: Validate against schema\n  const validation = PipelineStateSchema.safeParse(parsed);\n\n  if (!validation.success) {\n    console.warn(`Warning: Pipeline state file has invalid structure, creating backup and resetting.`);\n\n    // Log first few validation errors for debugging\n    const errors = validation.error.errors.slice(0, 3);\n    for (const err of errors) {\n      console.warn(`  - ${err.path.join('.')}: ${err.message}`);\n    }\n    if (validation.error.errors.length > 3) {\n      console.warn(`  ... and ${validation.error.errors.length - 3} more errors`);\n    }\n\n    const backupPath = backupCorruptedFile(statePath);\n    if (backupPath) {\n      console.warn(`  Backup saved to: ${backupPath}`);\n    }\n\n    return createEmptyState();\n  }\n\n  const state = validation.data as PipelineState;\n\n  // Step 4: Warn about unknown fields (for forward compatibility)\n  const knownFields = new Set([\n    'version', 'stage', 'lastCommand', 'lastCommandAt', 'journeyIds',\n    'testPaths', 'refinementAttempts', 'isBlocked', 'blockedReason',\n    'history', 'createdAt', 'updatedAt'\n  ]);\n  const unknownFields = Object.keys(parsed as object).filter(k => !knownFields.has(k));\n  if (unknownFields.length > 0) {\n    console.warn(`Warning: Pipeline state has unknown fields (may be from newer version): ${unknownFields.join(', ')}`);\n  }\n\n  // Step 5: Validate stage is in valid list (extra safety)\n  if (!VALID_STAGES.includes(state.stage)) {\n    console.warn(`Warning: Invalid pipeline stage \"${state.stage}\", resetting to \"initial\"`);\n    state.stage = 'initial';\n  }\n\n  return state;\n}\n\n/**\n * Load pipeline state with detailed result\n *\n * Same as loadPipelineState but returns additional metadata about\n * whether the state was corrupted, reset, or backed up.\n */\nexport function loadPipelineStateWithInfo(baseDir?: string): LoadStateResult {\n  const statePath = getAutogenArtifact('state', baseDir);\n\n  if (!existsSync(statePath)) {\n    return {\n      state: createEmptyState(),\n      wasCorrupted: false,\n      wasReset: true,\n    };\n  }\n\n  let content: string;\n  let parsed: unknown;\n\n  // Step 1: Read file\n  try {\n    content = readFileSync(statePath, 'utf-8');\n  } catch (error) {\n    console.warn(`Warning: Cannot read pipeline state file: ${statePath}`);\n    console.warn(`  Error: ${error instanceof Error ? error.message : 'Unknown'}`);\n    return {\n      state: createEmptyState(),\n      wasCorrupted: true,\n      wasReset: true,\n    };\n  }\n\n  // Step 2: Parse JSON\n  try {\n    parsed = JSON.parse(content);\n  } catch (error) {\n    console.warn(`Warning: Pipeline state file contains invalid JSON, creating backup and resetting.`);\n    console.warn(`  Error: ${error instanceof Error ? error.message : 'Unknown'}`);\n\n    const backupPath = backupCorruptedFile(statePath);\n    if (backupPath) {\n      console.warn(`  Backup saved to: ${backupPath}`);\n    }\n\n    return {\n      state: createEmptyState(),\n      wasCorrupted: true,\n      wasReset: true,\n      backupPath,\n    };\n  }\n\n  // Step 3: Validate against schema\n  const validation = PipelineStateSchema.safeParse(parsed);\n\n  if (!validation.success) {\n    console.warn(`Warning: Pipeline state file has invalid structure, creating backup and resetting.`);\n\n    const errors = validation.error.errors.slice(0, 3);\n    for (const err of errors) {\n      console.warn(`  - ${err.path.join('.')}: ${err.message}`);\n    }\n    if (validation.error.errors.length > 3) {\n      console.warn(`  ... and ${validation.error.errors.length - 3} more errors`);\n    }\n\n    const backupPath = backupCorruptedFile(statePath);\n    if (backupPath) {\n      console.warn(`  Backup saved to: ${backupPath}`);\n    }\n\n    return {\n      state: createEmptyState(),\n      wasCorrupted: true,\n      wasReset: true,\n      backupPath,\n    };\n  }\n\n  return {\n    state: validation.data as PipelineState,\n    wasCorrupted: false,\n    wasReset: false,\n  };\n}\n\n/**\n * Save pipeline state to disk atomically\n *\n * Uses write-to-temp + rename pattern for atomic writes.\n * This prevents file corruption if two processes write simultaneously\n * or if the process is interrupted during write.\n */\nexport async function savePipelineState(\n  state: PipelineState,\n  baseDir?: string\n): Promise<void> {\n  await ensureAutogenDir(baseDir);\n  const statePath = getAutogenArtifact('state', baseDir);\n\n  state.updatedAt = new Date().toISOString();\n  const content = JSON.stringify(state, null, 2);\n\n  // Atomic write: write to temp file in same directory, then rename\n  // Rename is atomic on most filesystems (POSIX guarantees it)\n  const tempPath = join(dirname(statePath), `.state-${process.pid}-${Date.now()}.tmp`);\n\n  try {\n    writeFileSync(tempPath, content, 'utf-8');\n    renameSync(tempPath, statePath);\n  } catch (err) {\n    // Clean up temp file on error\n    try {\n      if (existsSync(tempPath)) {\n        unlinkSync(tempPath);\n      }\n    } catch {\n      // Ignore cleanup errors\n    }\n    throw err;\n  }\n}\n\n/**\n * Update pipeline state after a command execution\n */\nexport async function updatePipelineState(\n  command: string,\n  stage: PipelineStage,\n  success: boolean,\n  details?: Record<string, unknown>,\n  baseDir?: string\n): Promise<PipelineState> {\n  const state = loadPipelineState(baseDir);\n\n  const now = new Date().toISOString();\n\n  // Update state\n  state.stage = stage;\n  state.lastCommand = command;\n  state.lastCommandAt = now;\n\n  // Add to history (keep last 100 entries)\n  state.history.push({\n    command,\n    stage,\n    timestamp: now,\n    success,\n    details,\n  });\n  const HISTORY_MAX_ENTRIES = 100;\n  if (state.history.length > HISTORY_MAX_ENTRIES) {\n    state.history = state.history.slice(-HISTORY_MAX_ENTRIES);\n  }\n\n  // Update specific fields based on command\n  if (details?.journeyIds) {\n    state.journeyIds = details.journeyIds as string[];\n  }\n  if (details?.testPaths) {\n    state.testPaths = details.testPaths as string[];\n  }\n  if (details?.refinementAttempts !== undefined) {\n    state.refinementAttempts = details.refinementAttempts as number;\n  }\n  if (details?.isBlocked !== undefined) {\n    state.isBlocked = details.isBlocked as boolean;\n    state.blockedReason = details.blockedReason as string | undefined;\n  }\n\n  await savePipelineState(state, baseDir);\n  return state;\n}\n\n/**\n * Reset pipeline state (for clean command)\n */\nexport async function resetPipelineState(baseDir?: string): Promise<void> {\n  await savePipelineState(createEmptyState(), baseDir);\n}\n\n/**\n * Check if pipeline can proceed to a given stage\n */\nexport function canProceedTo(\n  currentState: PipelineState,\n  targetStage: PipelineStage\n): { allowed: boolean; reason?: string } {\n  // Define valid transitions\n  const validTransitions: Record<PipelineStage, PipelineStage[]> = {\n    initial: ['analyzed'],\n    analyzed: ['planned', 'initial'], // Can go back via clean\n    planned: ['generated', 'analyzed', 'initial'],\n    generated: ['tested', 'planned', 'initial'],\n    tested: ['refining', 'completed', 'generated', 'initial'],\n    refining: ['tested', 'completed', 'blocked', 'initial'],\n    completed: ['initial', 'analyzed'], // Can restart\n    blocked: ['initial', 'analyzed'], // Can only restart or re-analyze\n  };\n\n  const allowed = validTransitions[currentState.stage]?.includes(targetStage) ?? false;\n\n  if (!allowed) {\n    return {\n      allowed: false,\n      reason: `Cannot transition from '${currentState.stage}' to '${targetStage}'. ` +\n        `Valid transitions: ${validTransitions[currentState.stage]?.join(', ') || 'none'}`,\n    };\n  }\n\n  // Special case: blocked state needs manual intervention\n  if (currentState.isBlocked && !['initial', 'analyzed'].includes(targetStage)) {\n    return {\n      allowed: false,\n      reason: `Pipeline is blocked: ${currentState.blockedReason}. Clean or re-analyze to continue.`,\n    };\n  }\n\n  return { allowed: true };\n}\n\n/**\n * Get a summary of the current pipeline state\n */\nexport function getPipelineStateSummary(state: PipelineState): string {\n  const lines: string[] = [\n    `Stage: ${state.stage}`,\n    `Last command: ${state.lastCommand} at ${state.lastCommandAt}`,\n  ];\n\n  if (state.journeyIds.length > 0) {\n    lines.push(`Journeys: ${state.journeyIds.length}`);\n  }\n  if (state.testPaths.length > 0) {\n    lines.push(`Tests: ${state.testPaths.length}`);\n  }\n  if (state.refinementAttempts > 0) {\n    lines.push(`Refinement attempts: ${state.refinementAttempts}`);\n  }\n  if (state.isBlocked) {\n    lines.push(`BLOCKED: ${state.blockedReason}`);\n  }\n\n  return lines.join('\\n');\n}\n","/**\n * CLI Analyze Command - Analyze journey for test generation\n *\n * Part of the Hybrid Agentic architecture where the CLI provides\n * analysis data and the orchestrating LLM makes decisions.\n *\n * @see research/2026-02-02_autogen-enhancement-implementation-plan.md\n */\nimport { parseArgs } from 'node:util';\nimport { readFileSync, writeFileSync, existsSync } from 'node:fs';\nimport { basename } from 'node:path';\nimport fg from 'fast-glob';\nimport yaml from 'yaml';\nimport {\n  getHarnessRoot,\n  getAutogenArtifact,\n  ensureAutogenDir,\n  validatePath,\n  PathTraversalError,\n} from '../utils/paths.js';\nimport { updatePipelineState, loadPipelineState, canProceedTo } from '../pipeline/state.js';\nimport { getTelemetry } from '../shared/telemetry.js';\n\n// \n// TYPES\n// \n\nexport interface JourneyAnalysis {\n  journeyId: string;\n  journeyPath: string;\n  title: string;\n  tier: string;\n  status: string;\n  actor: string;\n  scope: string[];\n  acceptanceCriteria: string[];\n  steps: StepAnalysis[];\n  dependencies: string[];\n  complexity: ComplexityScore;\n  warnings: string[];\n  analyzedAt: string;\n}\n\nexport interface StepAnalysis {\n  index: number;\n  text: string;\n  type: StepType;\n  hasSelector: boolean;\n  hasAssertion: boolean;\n  estimatedComplexity: 'low' | 'medium' | 'high';\n  keywords: string[];\n}\n\nexport type StepType =\n  | 'navigation'\n  | 'interaction'\n  | 'assertion'\n  | 'wait'\n  | 'form'\n  | 'unknown';\n\nexport interface ComplexityScore {\n  overall: 'simple' | 'moderate' | 'complex';\n  stepCount: number;\n  assertionCount: number;\n  interactionCount: number;\n  formSteps: number;\n  navigationSteps: number;\n  estimatedLOC: number;\n}\n\nexport interface AnalysisOutput {\n  version: '1.0';\n  harnessRoot: string;\n  journeys: JourneyAnalysis[];\n  summary: AnalysisSummary;\n  analyzedAt: string;\n}\n\nexport interface AnalysisSummary {\n  totalJourneys: number;\n  totalSteps: number;\n  complexityDistribution: Record<string, number>;\n  commonKeywords: string[];\n}\n\n// \n// USAGE\n// \n\nconst USAGE = `\nUsage: artk-autogen analyze [options] <journey-files...>\n\nAnalyze journey files and output structured analysis for the orchestrating LLM.\n\nArguments:\n  journey-files    Journey file paths or glob patterns\n\nOptions:\n  -o, --output <path>    Output path for analysis.json (default: .artk/autogen/analysis.json)\n  --json                 Output JSON to stdout instead of file\n  -q, --quiet            Suppress output except errors\n  -f, --force            Skip pipeline state validation\n  -h, --help             Show this help message\n\nExamples:\n  artk-autogen analyze journeys/login.md\n  artk-autogen analyze \"journeys/*.md\"\n  artk-autogen analyze journeys/*.md --json\n  artk-autogen analyze journeys/*.md -o custom/analysis.json\n`;\n\n// \n// STEP ANALYSIS\n// \n\nconst STEP_PATTERNS = {\n  navigation: [\n    /navigate/i, /go to/i, /open/i, /visit/i, /load/i, /url/i,\n  ],\n  interaction: [\n    /click/i, /tap/i, /press/i, /select/i, /choose/i, /toggle/i,\n    /expand/i, /collapse/i, /hover/i, /drag/i, /drop/i,\n  ],\n  assertion: [\n    /see/i, /verify/i, /should/i, /expect/i, /confirm/i, /check/i,\n    /visible/i, /displayed/i, /appears/i, /shows/i, /contains/i,\n  ],\n  wait: [\n    /wait/i, /until/i, /loading/i, /spinner/i, /timeout/i,\n  ],\n  form: [\n    /enter/i, /type/i, /fill/i, /input/i, /submit/i, /form/i,\n    /field/i, /text/i, /password/i, /email/i, /upload/i,\n  ],\n};\n\nfunction classifyStep(stepText: string): StepType {\n  for (const [type, patterns] of Object.entries(STEP_PATTERNS)) {\n    if (patterns.some(p => p.test(stepText))) {\n      return type as StepType;\n    }\n  }\n  return 'unknown';\n}\n\nfunction extractKeywords(stepText: string): string[] {\n  // Extract meaningful words (nouns, verbs related to UI)\n  const uiKeywords = [\n    'button', 'link', 'input', 'field', 'form', 'modal', 'dialog',\n    'dropdown', 'menu', 'tab', 'panel', 'table', 'row', 'cell',\n    'checkbox', 'radio', 'toggle', 'switch', 'slider', 'spinner',\n    'toast', 'alert', 'notification', 'message', 'error', 'success',\n    'header', 'footer', 'sidebar', 'nav', 'navigation', 'search',\n    'filter', 'sort', 'pagination', 'page', 'screen', 'view',\n  ];\n\n  const words = stepText.toLowerCase().split(/\\s+/);\n  return words.filter(w => uiKeywords.includes(w) || w.length > 3);\n}\n\nfunction hasSelector(stepText: string): boolean {\n  // Check for selector-like patterns\n  return /[\"'].*[\"']/.test(stepText) ||\n    /data-testid/i.test(stepText) ||\n    /\\[.*\\]/.test(stepText) ||\n    /#\\w+/.test(stepText) ||\n    /\\.\\w+/.test(stepText);\n}\n\nfunction hasAssertion(stepText: string): boolean {\n  return STEP_PATTERNS.assertion.some(p => p.test(stepText));\n}\n\nfunction estimateComplexity(stepText: string, type: StepType): 'low' | 'medium' | 'high' {\n  const text = stepText.toLowerCase();\n\n  // High complexity indicators\n  if (text.includes('table') || text.includes('grid') || text.includes('ag-grid')) {\n    return 'high';\n  }\n  if (text.includes('drag') || text.includes('drop')) {\n    return 'high';\n  }\n  if (text.includes('upload') || text.includes('file')) {\n    return 'high';\n  }\n  if (text.includes('iframe') || text.includes('frame')) {\n    return 'high';\n  }\n\n  // Medium complexity indicators\n  if (type === 'form' || type === 'wait') {\n    return 'medium';\n  }\n  if (text.includes('modal') || text.includes('dialog')) {\n    return 'medium';\n  }\n\n  return 'low';\n}\n\nfunction analyzeStep(stepText: string, index: number): StepAnalysis {\n  const type = classifyStep(stepText);\n  return {\n    index,\n    text: stepText,\n    type,\n    hasSelector: hasSelector(stepText),\n    hasAssertion: hasAssertion(stepText),\n    estimatedComplexity: estimateComplexity(stepText, type),\n    keywords: extractKeywords(stepText),\n  };\n}\n\n// \n// JOURNEY PARSING\n// \n\ninterface JourneyFrontmatter {\n  id?: string;\n  title?: string;\n  tier?: string;\n  status?: string;\n  actor?: string;\n  scope?: string[];\n  dependencies?: string[];\n}\n\nfunction parseJourneyFile(filePath: string): JourneyAnalysis {\n  const content = readFileSync(filePath, 'utf-8');\n  const warnings: string[] = [];\n\n  // Extract frontmatter\n  let frontmatter: JourneyFrontmatter = {};\n  const fmMatch = content.match(/^---\\n([\\s\\S]*?)\\n---/);\n  if (fmMatch && fmMatch[1]) {\n    try {\n      frontmatter = yaml.parse(fmMatch[1]) || {};\n    } catch (e) {\n      warnings.push(`Failed to parse frontmatter: ${e}`);\n    }\n  }\n\n  // Extract acceptance criteria (## Acceptance Criteria section)\n  const acceptanceCriteria: string[] = [];\n  const acMatch = content.match(/##\\s*Acceptance Criteria\\s*\\n([\\s\\S]*?)(?=\\n##|\\n---|$)/i);\n  if (acMatch && acMatch[1]) {\n    const lines = acMatch[1].split('\\n');\n    for (const line of lines) {\n      const trimmed = line.trim();\n      if (trimmed.startsWith('- ') || trimmed.startsWith('* ') || /^\\d+\\./.test(trimmed)) {\n        acceptanceCriteria.push(trimmed.replace(/^[-*\\d.]+\\s*/, ''));\n      }\n    }\n  }\n\n  // Extract steps (## Steps or ## Procedure section)\n  const steps: StepAnalysis[] = [];\n  const stepsMatch = content.match(/##\\s*(?:Steps|Procedure|Test Steps)\\s*\\n([\\s\\S]*?)(?=\\n##|\\n---|$)/i);\n  if (stepsMatch && stepsMatch[1]) {\n    const lines = stepsMatch[1].split('\\n');\n    let stepIndex = 0;\n    for (const line of lines) {\n      const trimmed = line.trim();\n      if (trimmed.startsWith('- ') || trimmed.startsWith('* ') || /^\\d+\\./.test(trimmed)) {\n        const stepText = trimmed.replace(/^[-*\\d.]+\\s*/, '');\n        if (stepText) {\n          steps.push(analyzeStep(stepText, stepIndex++));\n        }\n      }\n    }\n  }\n\n  // Calculate complexity\n  const stepCount = steps.length;\n  const assertionCount = steps.filter(s => s.hasAssertion).length;\n  const interactionCount = steps.filter(s => s.type === 'interaction').length;\n  const formSteps = steps.filter(s => s.type === 'form').length;\n  const navigationSteps = steps.filter(s => s.type === 'navigation').length;\n\n  let overall: 'simple' | 'moderate' | 'complex' = 'simple';\n  if (stepCount > 15 || steps.some(s => s.estimatedComplexity === 'high')) {\n    overall = 'complex';\n  } else if (stepCount > 8 || formSteps > 3) {\n    overall = 'moderate';\n  }\n\n  // Estimate LOC (rough approximation)\n  const estimatedLOC = 20 + stepCount * 5 + assertionCount * 3 + formSteps * 8;\n\n  const journeyId = frontmatter.id || basename(filePath, '.md');\n\n  return {\n    journeyId,\n    journeyPath: filePath,\n    title: frontmatter.title || journeyId,\n    tier: frontmatter.tier || 'regression',\n    status: frontmatter.status || 'proposed',\n    actor: frontmatter.actor || 'user',\n    scope: frontmatter.scope || [],\n    acceptanceCriteria,\n    steps,\n    dependencies: frontmatter.dependencies || [],\n    complexity: {\n      overall,\n      stepCount,\n      assertionCount,\n      interactionCount,\n      formSteps,\n      navigationSteps,\n      estimatedLOC,\n    },\n    warnings,\n    analyzedAt: new Date().toISOString(),\n  };\n}\n\n// \n// MAIN COMMAND\n// \n\nexport async function runAnalyze(args: string[]): Promise<void> {\n  const { values, positionals } = parseArgs({\n    args,\n    options: {\n      output: { type: 'string', short: 'o' },\n      json: { type: 'boolean', default: false },\n      quiet: { type: 'boolean', short: 'q', default: false },\n      force: { type: 'boolean', short: 'f', default: false },\n      help: { type: 'boolean', short: 'h', default: false },\n    },\n    allowPositionals: true,\n  });\n\n  if (values.help) {\n    console.log(USAGE);\n    return;\n  }\n\n  if (positionals.length === 0) {\n    console.error('Error: No journey files specified');\n    console.log(USAGE);\n    process.exit(1);\n  }\n\n  const quiet = values.quiet;\n  const outputJson = values.json;\n  const force = values.force;\n\n  // Validate pipeline state transition (unless --force)\n  if (!force) {\n    const currentState = await loadPipelineState();\n    const transition = canProceedTo(currentState, 'analyzed');\n    if (!transition.allowed) {\n      console.error(`Error: ${transition.reason}`);\n      console.error('Use --force to bypass state validation.');\n      process.exit(1);\n    }\n  } else if (!quiet && !outputJson) {\n    console.log('Warning: Bypassing pipeline state validation (--force)');\n  }\n\n  // Initialize telemetry\n  const telemetry = getTelemetry();\n  await telemetry.load();\n  const eventId = telemetry.trackCommandStart('analyze');\n\n  const harnessRoot = getHarnessRoot();\n\n  // Expand glob patterns\n  const journeyFiles = await fg(positionals, {\n    absolute: true,\n    cwd: harnessRoot,\n  });\n\n  if (journeyFiles.length === 0) {\n    console.error('Error: No journey files found matching the patterns');\n    process.exit(1);\n  }\n\n  // SECURITY: Validate all paths are within harness root to prevent path traversal\n  const validatedFiles: string[] = [];\n  for (const file of journeyFiles) {\n    try {\n      const validated = validatePath(file, harnessRoot);\n      validatedFiles.push(validated);\n    } catch (error) {\n      if (error instanceof PathTraversalError) {\n        console.error(`Warning: Skipping file outside harness root: ${file}`);\n        continue;\n      }\n      throw error;\n    }\n  }\n\n  if (validatedFiles.length === 0) {\n    console.error('Error: No valid journey files within harness root');\n    process.exit(1);\n  }\n\n  if (!quiet && !outputJson) {\n    console.log(`Analyzing ${validatedFiles.length} journey file(s)...`);\n  }\n\n  // Analyze each journey\n  const journeys: JourneyAnalysis[] = [];\n  const allKeywords: string[] = [];\n\n  for (const file of validatedFiles) {\n    if (!existsSync(file)) {\n      console.error(`Warning: File not found: ${file}`);\n      continue;\n    }\n    const analysis = parseJourneyFile(file);\n    journeys.push(analysis);\n    for (const step of analysis.steps) {\n      allKeywords.push(...step.keywords);\n    }\n  }\n\n  // Calculate summary\n  const complexityDistribution: Record<string, number> = {\n    simple: 0,\n    moderate: 0,\n    complex: 0,\n  };\n  for (const j of journeys) {\n    const level = j.complexity.overall;\n    if (complexityDistribution[level] !== undefined) {\n      complexityDistribution[level]++;\n    }\n  }\n\n  // Find common keywords\n  const keywordCounts = new Map<string, number>();\n  for (const kw of allKeywords) {\n    keywordCounts.set(kw, (keywordCounts.get(kw) || 0) + 1);\n  }\n  const commonKeywords = [...keywordCounts.entries()]\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, 10)\n    .map(([kw]) => kw);\n\n  const output: AnalysisOutput = {\n    version: '1.0',\n    harnessRoot,\n    journeys,\n    summary: {\n      totalJourneys: journeys.length,\n      totalSteps: journeys.reduce((sum, j) => sum + j.steps.length, 0),\n      complexityDistribution,\n      commonKeywords,\n    },\n    analyzedAt: new Date().toISOString(),\n  };\n\n  // Output\n  if (outputJson) {\n    console.log(JSON.stringify(output, null, 2));\n  } else {\n    // Write to file\n    const outputPath = values.output || getAutogenArtifact('analysis');\n    await ensureAutogenDir();\n    writeFileSync(outputPath, JSON.stringify(output, null, 2), 'utf-8');\n\n    if (!quiet) {\n      console.log(`\\nAnalysis complete:`);\n      console.log(`  Journeys: ${output.summary.totalJourneys}`);\n      console.log(`  Steps: ${output.summary.totalSteps}`);\n      console.log(`  Complexity: ${JSON.stringify(complexityDistribution)}`);\n      console.log(`\\nOutput: ${outputPath}`);\n    }\n  }\n\n  // Update pipeline state\n  await updatePipelineState('analyze', 'analyzed', true, {\n    journeyIds: journeys.map(j => j.journeyId),\n  });\n\n  // Track command completion\n  telemetry.trackCommandEnd(eventId, true, {\n    journeyCount: journeys.length,\n    stepCount: output.summary.totalSteps,\n  });\n  await telemetry.save();\n}\n","/**\n * Enhanced Normalization Pipeline for Step Text\n * Implements Tier 1 of the coverage improvement strategy:\n * - Stemming (verb form normalization)\n * - Glossary expansion\n * - Canonical form transformation\n * - Whitespace and punctuation normalization\n *\n * @see research/2026-02-03_multi-ai-debate-coverage-improvement.md\n */\n\n/**\n * Common verb stems for normalization\n * Maps various verb forms to their base form\n */\nconst VERB_STEMS: Record<string, string> = {\n  // Click variants\n  clicking: 'click',\n  clicked: 'click',\n  clicks: 'click',\n\n  // Fill variants\n  filling: 'fill',\n  filled: 'fill',\n  fills: 'fill',\n  entering: 'fill',\n  entered: 'fill',\n  enters: 'fill',\n  typing: 'fill',\n  typed: 'fill',\n  types: 'fill',\n\n  // Select variants\n  selecting: 'select',\n  selected: 'select',\n  selects: 'select',\n  choosing: 'select',\n  chose: 'select',\n  chosen: 'select',\n  chooses: 'select',\n\n  // Check variants\n  checking: 'check',\n  checked: 'check',\n  checks: 'check',\n\n  // Uncheck variants\n  unchecking: 'uncheck',\n  unchecked: 'uncheck',\n  unchecks: 'uncheck',\n\n  // Navigate variants\n  navigating: 'navigate',\n  navigated: 'navigate',\n  navigates: 'navigate',\n  going: 'navigate',\n  went: 'navigate',\n  goes: 'navigate',\n  visiting: 'navigate',\n  visited: 'navigate',\n  visits: 'navigate',\n  opening: 'navigate',\n  opened: 'navigate',\n  opens: 'navigate',\n\n  // See/Verify variants\n  seeing: 'see',\n  saw: 'see',\n  seen: 'see',\n  sees: 'see',\n  verifying: 'verify',\n  verified: 'verify',\n  verifies: 'verify',\n  confirming: 'verify',\n  confirmed: 'verify',\n  confirms: 'verify',\n  ensuring: 'verify',\n  ensured: 'verify',\n  ensures: 'verify',\n\n  // Wait variants\n  waiting: 'wait',\n  waited: 'wait',\n  waits: 'wait',\n\n  // Submit variants\n  submitting: 'submit',\n  submitted: 'submit',\n  submits: 'submit',\n\n  // Press variants\n  pressing: 'press',\n  pressed: 'press',\n  presses: 'press',\n\n  // Hover variants\n  hovering: 'hover',\n  hovered: 'hover',\n  hovers: 'hover',\n\n  // Scroll variants\n  scrolling: 'scroll',\n  scrolled: 'scroll',\n  scrolls: 'scroll',\n\n  // Focus variants\n  focusing: 'focus',\n  focused: 'focus',\n  focuses: 'focus',\n\n  // Drag variants\n  dragging: 'drag',\n  dragged: 'drag',\n  drags: 'drag',\n\n  // Drop variants\n  dropping: 'drop',\n  dropped: 'drop',\n  drops: 'drop',\n\n  // Clear variants\n  clearing: 'clear',\n  cleared: 'clear',\n  clears: 'clear',\n\n  // Upload variants\n  uploading: 'upload',\n  uploaded: 'upload',\n  uploads: 'upload',\n\n  // Download variants\n  downloading: 'download',\n  downloaded: 'download',\n  downloads: 'download',\n\n  // Assert/Expect variants\n  asserting: 'assert',\n  asserted: 'assert',\n  asserts: 'assert',\n  expecting: 'expect',\n  expected: 'expect',\n  expects: 'expect',\n\n  // Show/Display variants\n  showing: 'show',\n  showed: 'show',\n  shown: 'show',\n  shows: 'show',\n  displaying: 'display',\n  displayed: 'display',\n  displays: 'display',\n\n  // Hide variants\n  hiding: 'hide',\n  hid: 'hide',\n  hidden: 'hide',\n  hides: 'hide',\n\n  // Enable/Disable variants\n  enabling: 'enable',\n  enabled: 'enable',\n  enables: 'enable',\n  disabling: 'disable',\n  disabled: 'disable',\n  disables: 'disable',\n\n  // Compound verb forms (hyphenated and spaced)\n  'double-click': 'dblclick',\n  'double click': 'dblclick',\n  'double-clicking': 'dblclick',\n  'double clicking': 'dblclick',\n  'double-clicked': 'dblclick',\n  'double clicked': 'dblclick',\n  doubleclick: 'dblclick',\n  doubleclicking: 'dblclick',\n  doubleclicked: 'dblclick',\n\n  'right-click': 'rightclick',\n  'right click': 'rightclick',\n  'right-clicking': 'rightclick',\n  'right clicking': 'rightclick',\n  'right-clicked': 'rightclick',\n  'right clicked': 'rightclick',\n  rightclick: 'rightclick',\n  rightclicking: 'rightclick',\n  rightclicked: 'rightclick',\n\n  'drag-and-drop': 'dragdrop',\n  'drag and drop': 'dragdrop',\n  'drag-n-drop': 'dragdrop',\n\n  'sign-in': 'login',\n  'sign in': 'login',\n  'signing-in': 'login',\n  'signing in': 'login',\n  'signed-in': 'login',\n  'signed in': 'login',\n  signin: 'login',\n\n  'log-in': 'login',\n  'log in': 'login',\n  'logging-in': 'login',\n  'logging in': 'login',\n  'logged-in': 'login',\n  'logged in': 'login',\n\n  'sign-out': 'logout',\n  'sign out': 'logout',\n  'signing-out': 'logout',\n  'signing out': 'logout',\n  'signed-out': 'logout',\n  'signed out': 'logout',\n  signout: 'logout',\n\n  'log-out': 'logout',\n  'log out': 'logout',\n  'logging-out': 'logout',\n  'logging out': 'logout',\n  'logged-out': 'logout',\n  'logged out': 'logout',\n\n  'sign-up': 'register',\n  'sign up': 'register',\n  'signing-up': 'register',\n  'signing up': 'register',\n  'signed-up': 'register',\n  'signed up': 'register',\n  signup: 'register',\n};\n\n/**\n * Expanded glossary for abbreviation and synonym expansion\n */\nconst ABBREVIATION_EXPANSIONS: Record<string, string> = {\n  // Common abbreviations\n  btn: 'button',\n  msg: 'message',\n  err: 'error',\n  pwd: 'password',\n  usr: 'user',\n  nav: 'navigation',\n  pg: 'page',\n  txt: 'text',\n  num: 'number',\n  val: 'value',\n  img: 'image',\n  pic: 'picture',\n  lbl: 'label',\n  chk: 'checkbox',\n  chkbox: 'checkbox',\n  cb: 'checkbox',\n  rb: 'radio',\n  dd: 'dropdown',\n  sel: 'select',\n  dlg: 'dialog',\n  mdl: 'modal',\n  lnk: 'link',\n  tbl: 'table',\n  col: 'column',\n  hdr: 'header',\n  ftr: 'footer',\n  sec: 'section',\n\n  // UI element synonyms\n  textbox: 'field',\n  'text field': 'field',\n  'text input': 'field',\n  'input field': 'field',\n  inputbox: 'field',\n  combobox: 'dropdown',\n  'combo box': 'dropdown',\n  selectbox: 'dropdown',\n  'select box': 'dropdown',\n  picker: 'dropdown',\n  listbox: 'dropdown',\n  'list box': 'dropdown',\n\n  // Action synonyms\n  'sign in': 'login',\n  'log in': 'login',\n  signin: 'login',\n  'sign out': 'logout',\n  'log out': 'logout',\n  signout: 'logout',\n\n  // Common element names\n  'submit button': 'submit',\n  'cancel button': 'cancel',\n  'ok button': 'ok',\n  'close button': 'close',\n  'save button': 'save',\n  'delete button': 'delete',\n  'edit button': 'edit',\n  'add button': 'add',\n  'remove button': 'remove',\n  'search button': 'search',\n  'search box': 'search field',\n  'search bar': 'search field',\n};\n\n/**\n * Words to remove (articles, prepositions that don't add meaning)\n */\nconst STOP_WORDS = new Set([\n  'the', 'a', 'an', 'is', 'are', 'was', 'were', 'be', 'been', 'being',\n  'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could',\n  'should', 'may', 'might', 'must', 'shall', 'can', 'need', 'dare',\n  'ought', 'used', 'to', 'of', 'in', 'for', 'on', 'with', 'at', 'by',\n  'from', 'up', 'about', 'into', 'through', 'during', 'before', 'after',\n  'above', 'below', 'between', 'under', 'again', 'further', 'then',\n  'once', 'here', 'there', 'when', 'where', 'why', 'how', 'all', 'each',\n  'few', 'more', 'most', 'other', 'some', 'such', 'no', 'nor', 'not',\n  'only', 'own', 'same', 'so', 'than', 'too', 'very', 'just', 'and',\n]);\n\n/**\n * User/Actor prefixes to remove\n */\nconst ACTOR_PREFIXES = [\n  /^user\\s+/i,\n  /^the user\\s+/i,\n  /^i\\s+/i,\n  /^we\\s+/i,\n  /^they\\s+/i,\n  /^customer\\s+/i,\n  /^visitor\\s+/i,\n  /^admin\\s+/i,\n  /^administrator\\s+/i,\n];\n\n/**\n * Normalize options\n */\nexport interface NormalizeOptions {\n  /** Apply verb stemming */\n  stemVerbs?: boolean;\n  /** Expand abbreviations */\n  expandAbbreviations?: boolean;\n  /** Remove stop words */\n  removeStopWords?: boolean;\n  /** Remove actor prefixes (e.g., \"user clicks\" -> \"click\") */\n  removeActorPrefixes?: boolean;\n  /** Lowercase everything */\n  lowercase?: boolean;\n  /** Preserve quoted strings */\n  preserveQuoted?: boolean;\n}\n\nconst DEFAULT_OPTIONS: NormalizeOptions = {\n  stemVerbs: true,\n  expandAbbreviations: true,\n  removeStopWords: false, // Keep stop words by default for better pattern matching\n  removeActorPrefixes: true,\n  lowercase: true,\n  preserveQuoted: true,\n};\n\n/**\n * Stem a single word (verb normalization)\n */\nexport function stemWord(word: string): string {\n  const lower = word.toLowerCase();\n  return VERB_STEMS[lower] ?? lower;\n}\n\n/**\n * Expand abbreviations in text\n */\nexport function expandAbbreviations(text: string): string {\n  let result = text.toLowerCase();\n\n  // Sort by length (longest first) to avoid partial replacements\n  const sorted = Object.entries(ABBREVIATION_EXPANSIONS)\n    .sort(([a], [b]) => b.length - a.length);\n\n  for (const [abbr, expansion] of sorted) {\n    // Word boundary replacement\n    const regex = new RegExp(`\\\\b${escapeRegex(abbr)}\\\\b`, 'gi');\n    result = result.replace(regex, expansion);\n  }\n\n  return result;\n}\n\n/**\n * Escape regex special characters\n */\nfunction escapeRegex(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\n/**\n * Remove actor prefixes from step text\n */\nexport function removeActorPrefixes(text: string): string {\n  let result = text;\n  for (const pattern of ACTOR_PREFIXES) {\n    result = result.replace(pattern, '');\n  }\n  return result.trim();\n}\n\n/**\n * Remove stop words from text\n */\nexport function removeStopWords(text: string): string {\n  const words = text.split(/\\s+/);\n  const filtered = words.filter(word => !STOP_WORDS.has(word.toLowerCase()));\n  return filtered.join(' ');\n}\n\n/**\n * Extract quoted strings and replace with placeholders\n * Returns the modified text and a map of placeholders to original values\n */\nfunction extractQuotedStrings(text: string): { text: string; quotes: Map<string, string> } {\n  const quotes = new Map<string, string>();\n  let placeholderIndex = 0;\n\n  const processedText = text.replace(/(['\"])([^'\"]*)\\1/g, (_match, quote, content) => {\n    const placeholder = `__QUOTED_${placeholderIndex}__`;\n    quotes.set(placeholder, `${quote}${content}${quote}`);\n    placeholderIndex++;\n    return placeholder;\n  });\n\n  return { text: processedText, quotes };\n}\n\n/**\n * Restore quoted strings from placeholders\n */\nfunction restoreQuotedStrings(text: string, quotes: Map<string, string>): string {\n  let result = text;\n  for (const [placeholder, original] of quotes) {\n    result = result.replace(placeholder, original);\n  }\n  return result;\n}\n\n/**\n * Enhanced step text normalization\n * Applies all normalization transformations\n */\nexport function normalizeStepTextEnhanced(text: string, options: NormalizeOptions = {}): string {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n\n  let result = text.trim();\n\n  // Extract quoted strings to preserve them\n  let quotesMap = new Map<string, string>();\n  if (opts.preserveQuoted) {\n    const extracted = extractQuotedStrings(result);\n    result = extracted.text;\n    quotesMap = extracted.quotes;\n  }\n\n  // Remove actor prefixes first\n  if (opts.removeActorPrefixes) {\n    result = removeActorPrefixes(result);\n  }\n\n  // Lowercase\n  if (opts.lowercase) {\n    result = result.toLowerCase();\n  }\n\n  // Expand abbreviations\n  if (opts.expandAbbreviations) {\n    result = expandAbbreviations(result);\n  }\n\n  // Stem verbs (word by word)\n  if (opts.stemVerbs) {\n    const words = result.split(/\\s+/);\n    result = words.map(word => {\n      // Don't stem placeholders or words with special chars\n      if (word.startsWith('__QUOTED_') || /[^a-z]/.test(word)) {\n        return word;\n      }\n      return stemWord(word);\n    }).join(' ');\n  }\n\n  // Remove stop words (optional, off by default)\n  if (opts.removeStopWords) {\n    result = removeStopWords(result);\n  }\n\n  // Normalize whitespace\n  result = result.replace(/\\s+/g, ' ').trim();\n\n  // Restore quoted strings\n  if (opts.preserveQuoted) {\n    result = restoreQuotedStrings(result, quotesMap);\n  }\n\n  return result;\n}\n\n/**\n * Get the canonical form of a step (most normalized version)\n */\nexport function getCanonicalForm(text: string): string {\n  return normalizeStepTextEnhanced(text, {\n    stemVerbs: true,\n    expandAbbreviations: true,\n    removeStopWords: true,\n    removeActorPrefixes: true,\n    lowercase: true,\n    preserveQuoted: true,\n  });\n}\n\n/**\n * Get a less aggressive normalization (preserves more structure)\n */\nexport function getLightNormalization(text: string): string {\n  return normalizeStepTextEnhanced(text, {\n    stemVerbs: true,\n    expandAbbreviations: true,\n    removeStopWords: false,\n    removeActorPrefixes: true,\n    lowercase: true,\n    preserveQuoted: true,\n  });\n}\n\n/**\n * Check if two step texts are semantically equivalent after normalization\n */\nexport function areStepsEquivalent(step1: string, step2: string): boolean {\n  const canonical1 = getCanonicalForm(step1);\n  const canonical2 = getCanonicalForm(step2);\n  return canonical1 === canonical2;\n}\n\n/**\n * Get all possible normalizations of a step (for fuzzy matching)\n */\nexport function getAllNormalizations(text: string): string[] {\n  const normalizations = new Set<string>();\n\n  // Original (lowercased)\n  normalizations.add(text.toLowerCase().trim());\n\n  // Light normalization\n  normalizations.add(getLightNormalization(text));\n\n  // Full canonical form\n  normalizations.add(getCanonicalForm(text));\n\n  // Without actor prefix only\n  normalizations.add(removeActorPrefixes(text.toLowerCase().trim()));\n\n  return Array.from(normalizations);\n}\n","/**\n * Fuzzy Matcher - Tier 4 in the coverage improvement architecture\n * Uses Levenshtein distance with high confidence threshold\n *\n * Coverage Flow: Normalization  Core Patterns  LLKB  Fuzzy  LLM  TODO\n *\n * @see research/2026-02-03_multi-ai-debate-coverage-improvement.md\n */\nimport { calculateSimilarity } from './patternDistance.js';\nimport { getCanonicalForm } from './normalize.js';\nimport { allPatterns, type StepPattern } from './patterns.js';\nimport type { IRPrimitive } from '../ir/types.js';\n\n/**\n * Fuzzy match configuration\n */\nexport interface FuzzyMatchConfig {\n  /** Minimum similarity threshold (0-1, default: 0.85) */\n  minSimilarity?: number;\n  /** Use normalized text for comparison (default: true) */\n  useNormalization?: boolean;\n  /** Maximum candidates to consider (default: 10) */\n  maxCandidates?: number;\n  /** Enable debug logging (default: false) */\n  debug?: boolean;\n}\n\n/**\n * Fuzzy match result\n */\nexport interface FuzzyMatchResult {\n  /** The matched primitive */\n  primitive: IRPrimitive;\n  /** The pattern that matched */\n  patternName: string;\n  /** Similarity score (0-1) */\n  similarity: number;\n  /** The example that was matched */\n  matchedExample: string;\n  /** Original input text */\n  originalText: string;\n  /** Normalized input text */\n  normalizedText: string;\n}\n\n/**\n * Pattern with examples for fuzzy matching\n */\ninterface PatternWithExamples {\n  pattern: StepPattern;\n  examples: string[];\n}\n\n/**\n * Generate canonical examples for each pattern type\n */\nfunction getPatternExamples(pattern: StepPattern): string[] {\n  const examples: string[] = [];\n  const name = pattern.name.toLowerCase();\n\n  // Navigation patterns\n  if (name.includes('navigate') || name.includes('goto')) {\n    examples.push(\n      'navigate to /home',\n      'go to /login',\n      'open /dashboard',\n      'visit the homepage',\n      'navigate to the settings page'\n    );\n  }\n\n  // Click patterns\n  if (name.includes('click')) {\n    examples.push(\n      'click the submit button',\n      'click on save',\n      'click cancel button',\n      'press the login button',\n      'tap the menu icon'\n    );\n  }\n\n  // Fill/Enter patterns\n  if (name.includes('fill') || name.includes('enter') || name.includes('type')) {\n    examples.push(\n      'enter username in the username field',\n      'fill password in password field',\n      'type hello in the search box',\n      'input test@example.com in email field',\n      'enter value into the input'\n    );\n  }\n\n  // See/Verify patterns\n  if (name.includes('see') || name.includes('visible') || name.includes('verify')) {\n    examples.push(\n      'see the welcome message',\n      'verify the success message is displayed',\n      'confirm the error appears',\n      'should see login button',\n      'expect the form to be visible'\n    );\n  }\n\n  // Wait patterns\n  if (name.includes('wait')) {\n    examples.push(\n      'wait for network idle',\n      'wait for page to load',\n      'wait 3 seconds',\n      'wait for the spinner to disappear',\n      'wait until the modal closes'\n    );\n  }\n\n  // Select patterns\n  if (name.includes('select')) {\n    examples.push(\n      'select option 1 from dropdown',\n      'choose value from the list',\n      'pick an item from menu',\n      'select country from country dropdown'\n    );\n  }\n\n  // Check/Uncheck patterns\n  if (name.includes('check')) {\n    examples.push(\n      'check the checkbox',\n      'tick the agreement box',\n      'check remember me',\n      'uncheck the newsletter option'\n    );\n  }\n\n  // Upload patterns\n  if (name.includes('upload')) {\n    examples.push(\n      'upload file.pdf',\n      'attach document.docx',\n      'upload image to the form'\n    );\n  }\n\n  // Hover patterns\n  if (name.includes('hover')) {\n    examples.push(\n      'hover over the menu',\n      'mouse over the dropdown',\n      'hover on the button'\n    );\n  }\n\n  // Scroll patterns\n  if (name.includes('scroll')) {\n    examples.push(\n      'scroll down',\n      'scroll to the bottom',\n      'scroll to element'\n    );\n  }\n\n  // Press patterns (keyboard)\n  if (name.includes('press')) {\n    examples.push(\n      'press enter',\n      'press tab',\n      'press escape key',\n      'hit the enter key'\n    );\n  }\n\n  // Table patterns\n  if (name.includes('table') || name.includes('grid')) {\n    examples.push(\n      'see 5 rows in the table',\n      'verify table has data',\n      'check grid contains value'\n    );\n  }\n\n  // Text assertion patterns\n  if (name.includes('text') || name.includes('contain')) {\n    examples.push(\n      'see text welcome back',\n      'page contains login form',\n      'element has text submit'\n    );\n  }\n\n  return examples;\n}\n\n/**\n * Build pattern examples cache\n */\nfunction buildPatternExamplesCache(): PatternWithExamples[] {\n  return allPatterns.map(pattern => ({\n    pattern,\n    examples: getPatternExamples(pattern),\n  }));\n}\n\n// Cached pattern examples\nlet patternExamplesCache: PatternWithExamples[] | null = null;\n\n/**\n * Get or build pattern examples cache\n */\nfunction getPatternExamples_cached(): PatternWithExamples[] {\n  if (!patternExamplesCache) {\n    patternExamplesCache = buildPatternExamplesCache();\n  }\n  return patternExamplesCache;\n}\n\n/**\n * Find best fuzzy match for step text\n *\n * @param text - Step text to match\n * @param config - Fuzzy match configuration\n * @returns Best match if similarity >= threshold, null otherwise\n */\nexport function fuzzyMatch(\n  text: string,\n  config: FuzzyMatchConfig = {}\n): FuzzyMatchResult | null {\n  const {\n    minSimilarity = 0.85,\n    useNormalization = true,\n    maxCandidates = 10,\n    debug = false,\n  } = config;\n\n  const trimmedText = text.trim();\n  const normalizedText = useNormalization\n    ? getCanonicalForm(trimmedText)\n    : trimmedText.toLowerCase();\n\n  // Get pattern examples\n  const patternsWithExamples = getPatternExamples_cached();\n\n  // Score all candidates\n  const candidates: Array<{\n    pattern: StepPattern;\n    example: string;\n    similarity: number;\n  }> = [];\n\n  // Track best match for early termination\n  let bestSimilarity = 0;\n\n  outer: for (const { pattern, examples } of patternsWithExamples) {\n    for (const example of examples) {\n      const normalizedExample = useNormalization\n        ? getCanonicalForm(example)\n        : example.toLowerCase();\n\n      const similarity = calculateSimilarity(normalizedText, normalizedExample);\n\n      if (similarity >= minSimilarity) {\n        candidates.push({ pattern, example, similarity });\n\n        // Track best similarity for early termination\n        if (similarity > bestSimilarity) {\n          bestSimilarity = similarity;\n        }\n\n        // Early termination: if we find a perfect or near-perfect match, stop searching\n        if (similarity >= 0.98) {\n          break outer;\n        }\n      }\n    }\n  }\n\n  // Sort by similarity (descending)\n  candidates.sort((a, b) => b.similarity - a.similarity);\n\n  // Take top candidates\n  const topCandidates = candidates.slice(0, maxCandidates);\n\n  if (debug && topCandidates.length > 0) {\n    console.log(\n      `[FuzzyMatcher] Top ${topCandidates.length} candidates for \"${trimmedText}\":`\n    );\n    for (const c of topCandidates) {\n      console.log(`  ${c.pattern.name}: ${(c.similarity * 100).toFixed(1)}% (vs \"${c.example}\")`);\n    }\n  }\n\n  // Return best match if above threshold\n  if (topCandidates.length > 0) {\n    const best = topCandidates[0]!;\n\n    // Try to extract primitive using the pattern\n    const match = trimmedText.match(best.pattern.regex);\n    if (match) {\n      const primitive = best.pattern.extract(match);\n      if (primitive) {\n        return {\n          primitive,\n          patternName: best.pattern.name,\n          similarity: best.similarity,\n          matchedExample: best.example,\n          originalText: trimmedText,\n          normalizedText,\n        };\n      }\n    }\n\n    // Pattern didn't extract - try to create a generic primitive\n    // based on the pattern type (only for very high confidence)\n    if (best.similarity >= 0.90) {\n      const genericPrimitive = createGenericPrimitive(best.pattern, trimmedText);\n      if (genericPrimitive) {\n        if (debug) {\n          console.log(\n            `[FuzzyMatcher] Created generic primitive for ${best.pattern.name}`\n          );\n        }\n        return {\n          primitive: genericPrimitive,\n          patternName: `${best.pattern.name}:fuzzy`,\n          similarity: best.similarity,\n          matchedExample: best.example,\n          originalText: trimmedText,\n          normalizedText,\n        };\n      }\n    }\n  }\n\n  if (debug) {\n    console.log(`[FuzzyMatcher] No match above ${minSimilarity * 100}% for \"${trimmedText}\"`);\n  }\n\n  return null;\n}\n\n/**\n * Create a generic primitive when pattern extraction fails but similarity is very high\n * Returns properly typed IR primitives that match the schema\n */\nfunction createGenericPrimitive(pattern: StepPattern, text: string): IRPrimitive | null {\n  const type = pattern.primitiveType;\n\n  // Extract quoted strings from text\n  const quotedStrings = text.match(/[\"']([^\"']+)[\"']/g)?.map(s => s.slice(1, -1)) || [];\n  const targetStr = quotedStrings[0] || extractTarget(text) || 'element';\n  const valueStr = quotedStrings[1] || quotedStrings[0] || '';\n\n  // Helper to create a locator from extracted text\n  const makeLocator = (value: string) => ({\n    strategy: 'text' as const,\n    value: value,\n  });\n\n  switch (type) {\n    case 'click':\n    case 'dblclick':\n    case 'rightClick':\n      return { type, locator: makeLocator(targetStr) };\n\n    case 'fill':\n      return {\n        type: 'fill',\n        locator: makeLocator(targetStr),\n        value: { type: 'literal', value: valueStr },\n      };\n\n    case 'goto': {\n      // Extract URL or path\n      const urlMatch = text.match(/(?:to|\\/)\\s*([\\/\\w.-]+)/i);\n      return {\n        type: 'goto',\n        url: urlMatch?.[1] || '/',\n      };\n    }\n\n    case 'waitForTimeout': {\n      // Check for time-based wait\n      const timeMatch = text.match(/(\\d+)\\s*(?:second|sec|ms|millisecond)/i);\n      if (timeMatch) {\n        const amount = parseInt(timeMatch[1]!, 10);\n        const unit = text.toLowerCase().includes('ms') ? 'ms' : 's';\n        return {\n          type: 'waitForTimeout',\n          ms: unit === 'ms' ? amount : amount * 1000,\n        };\n      }\n      return { type: 'waitForTimeout', ms: 1000 };\n    }\n\n    case 'waitForNetworkIdle':\n      return { type: 'waitForNetworkIdle' };\n\n    case 'waitForVisible':\n      return { type: 'waitForVisible', locator: makeLocator(targetStr) };\n\n    case 'waitForHidden':\n      return { type: 'waitForHidden', locator: makeLocator(targetStr) };\n\n    case 'expectVisible':\n    case 'expectNotVisible':\n    case 'expectHidden':\n      return { type, locator: makeLocator(targetStr) };\n\n    case 'expectText':\n      return {\n        type: 'expectText',\n        locator: makeLocator(targetStr),\n        text: valueStr,\n      };\n\n    case 'select':\n      return {\n        type: 'select',\n        locator: makeLocator(targetStr),\n        option: valueStr,\n      };\n\n    case 'hover':\n    case 'focus':\n    case 'clear':\n    case 'check':\n    case 'uncheck':\n      return { type, locator: makeLocator(targetStr) };\n\n    case 'press': {\n      // Extract key name\n      const keyMatch = text.match(/(?:press|hit|key)\\s+(\\w+)/i);\n      return {\n        type: 'press',\n        key: keyMatch?.[1] || 'Enter',\n      };\n    }\n\n    default:\n      // Type doesn't have a direct mapping - return null\n      return null;\n  }\n}\n\n/**\n * Extract potential target from step text\n */\nfunction extractTarget(text: string): string | null {\n  // Try to extract target from common patterns\n  const patterns = [\n    /(?:the|a)\\s+[\"']?(\\w+(?:\\s+\\w+)?)[\"']?\\s+(?:button|field|input|link|element)/i,\n    /(?:on|click|tap|press)\\s+(?:the\\s+)?[\"']?(\\w+(?:\\s+\\w+)?)[\"']?/i,\n    /(?:in|into)\\s+(?:the\\s+)?[\"']?(\\w+(?:\\s+\\w+)?)[\"']?\\s+(?:field|input)/i,\n  ];\n\n  for (const pattern of patterns) {\n    const match = text.match(pattern);\n    if (match?.[1]) {\n      return match[1];\n    }\n  }\n\n  return null;\n}\n\n/**\n * Get fuzzy match statistics\n */\nexport function getFuzzyMatchStats(): {\n  patternsWithExamples: number;\n  totalExamples: number;\n  examplesByType: Record<string, number>;\n} {\n  const patternsWithExamples = getPatternExamples_cached();\n\n  const examplesByType: Record<string, number> = {};\n  let totalExamples = 0;\n\n  for (const { pattern, examples } of patternsWithExamples) {\n    const type = pattern.primitiveType;\n    examplesByType[type] = (examplesByType[type] || 0) + examples.length;\n    totalExamples += examples.length;\n  }\n\n  return {\n    patternsWithExamples: patternsWithExamples.length,\n    totalExamples,\n    examplesByType,\n  };\n}\n\n/**\n * Clear the pattern examples cache (for testing)\n */\nexport function clearFuzzyMatchCache(): void {\n  patternExamplesCache = null;\n}\n","/**\n * Unified Pattern Matcher - Single entry point for all pattern matching\n * Combines core patterns (patterns.ts) with LLKB learned patterns and fuzzy matching\n *\n * Coverage Flow: Normalization  Core Patterns  LLKB  Fuzzy  LLM  TODO\n *\n * This eliminates duplicate pattern logic in plan.ts and ensures consistent\n * pattern matching behavior across the entire system.\n *\n * @see research/2026-02-03_unified-pattern-matching-plan.md Phase 2\n * @see research/2026-02-03_multi-ai-debate-coverage-improvement.md\n */\nimport { allPatterns, type StepPattern } from './patterns.js';\nimport { matchLlkbPattern, loadLearnedPatterns } from '../llkb/patternExtension.js';\nimport { fuzzyMatch } from './fuzzyMatcher.js';\nimport type { IRPrimitive } from '../ir/types.js';\n\n/**\n * Options for unified pattern matching\n */\nexport interface UnifiedMatchOptions {\n  /** Use LLKB learned patterns as fallback (default: true) */\n  useLlkb?: boolean;\n  /** LLKB root directory (auto-detected if not provided) */\n  llkbRoot?: string;\n  /** Minimum confidence for LLKB patterns (default: 0.7) */\n  minLlkbConfidence?: number;\n  /** Use fuzzy matching as final fallback before TODO (default: true) */\n  useFuzzy?: boolean;\n  /** Minimum similarity for fuzzy matching (default: 0.85) */\n  minFuzzySimilarity?: number;\n  /** Enable debug logging (default: false) */\n  debug?: boolean;\n}\n\n/**\n * Result of unified pattern matching\n */\nexport interface UnifiedMatchResult {\n  /** The matched IR primitive, or null if no match */\n  primitive: IRPrimitive | null;\n  /** Source of the match */\n  source: 'core' | 'llkb' | 'fuzzy' | 'none';\n  /** Pattern name that matched (if core or fuzzy) */\n  patternName?: string;\n  /** LLKB pattern ID (if LLKB) */\n  llkbPatternId?: string;\n  /** LLKB confidence (if LLKB) */\n  llkbConfidence?: number;\n  /** Fuzzy match similarity score (if fuzzy) */\n  fuzzySimilarity?: number;\n  /** Fuzzy matched example (if fuzzy) */\n  fuzzyMatchedExample?: string;\n}\n\n/**\n * Match step text against unified pattern system\n *\n * Priority order (Coverage Flow):\n * 1. Core patterns from patterns.ts (84+ patterns)\n * 2. LLKB learned patterns (dynamic, confidence-filtered)\n * 3. Fuzzy matching (high similarity threshold, 0.85+)\n * 4. No match  TODO (or LLM fallback in future)\n *\n * @param text - Step text to match\n * @param options - Matching options\n * @returns Match result with primitive and source\n */\nexport function unifiedMatch(\n  text: string,\n  options: UnifiedMatchOptions = {}\n): UnifiedMatchResult {\n  const {\n    useLlkb = true,\n    llkbRoot,\n    minLlkbConfidence = 0.7,\n    useFuzzy = true,\n    minFuzzySimilarity = 0.85,\n    debug = false,\n  } = options;\n\n  const trimmedText = text.trim();\n\n  // 1. Try core patterns first (highest priority)\n  for (const pattern of allPatterns) {\n    const match = trimmedText.match(pattern.regex);\n    if (match) {\n      const primitive = pattern.extract(match);\n      if (primitive) {\n        if (debug) {\n          console.log(`[UnifiedMatcher] Core match: ${pattern.name} for \"${trimmedText}\"`);\n        }\n        return {\n          primitive,\n          source: 'core',\n          patternName: pattern.name,\n        };\n      }\n    }\n  }\n\n  // 2. Try LLKB patterns as fallback\n  if (useLlkb) {\n    try {\n      const llkbMatch = matchLlkbPattern(trimmedText, {\n        llkbRoot,\n        minConfidence: minLlkbConfidence,\n      });\n\n      if (llkbMatch) {\n        if (debug) {\n          console.log(\n            `[UnifiedMatcher] LLKB match: ${llkbMatch.patternId} (confidence: ${llkbMatch.confidence}) for \"${trimmedText}\"`\n          );\n        }\n        return {\n          primitive: llkbMatch.primitive,\n          source: 'llkb',\n          llkbPatternId: llkbMatch.patternId,\n          llkbConfidence: llkbMatch.confidence,\n        };\n      }\n    } catch (err) {\n      // LLKB might not be initialized - continue without it\n      if (debug) {\n        console.log(`[UnifiedMatcher] LLKB lookup failed: ${err}`);\n      }\n    }\n  }\n\n  // 3. Try fuzzy matching as final fallback before TODO\n  if (useFuzzy) {\n    try {\n      const fuzzyResult = fuzzyMatch(trimmedText, {\n        minSimilarity: minFuzzySimilarity,\n        useNormalization: true,\n        debug,\n      });\n\n      if (fuzzyResult) {\n        if (debug) {\n          console.log(\n            `[UnifiedMatcher] Fuzzy match: ${fuzzyResult.patternName} (similarity: ${(fuzzyResult.similarity * 100).toFixed(1)}%) for \"${trimmedText}\"`\n          );\n        }\n        return {\n          primitive: fuzzyResult.primitive,\n          source: 'fuzzy',\n          patternName: fuzzyResult.patternName,\n          fuzzySimilarity: fuzzyResult.similarity,\n          fuzzyMatchedExample: fuzzyResult.matchedExample,\n        };\n      }\n    } catch (err) {\n      // Fuzzy matching failed - continue without it\n      if (debug) {\n        console.log(`[UnifiedMatcher] Fuzzy matching failed: ${err}`);\n      }\n    }\n  }\n\n  // 4. No match found  TODO (or LLM fallback in future)\n  if (debug) {\n    console.log(`[UnifiedMatcher] No match for: \"${trimmedText}\"`);\n  }\n\n  return {\n    primitive: null,\n    source: 'none',\n  };\n}\n\n/**\n * Match step text and return all potential matches (for debugging)\n */\nexport function unifiedMatchAll(\n  text: string,\n  options: UnifiedMatchOptions = {}\n): Array<{ source: 'core' | 'llkb' | 'fuzzy'; name: string; primitive: IRPrimitive; confidence?: number; similarity?: number }> {\n  const trimmedText = text.trim();\n  const matches: Array<{ source: 'core' | 'llkb' | 'fuzzy'; name: string; primitive: IRPrimitive; confidence?: number; similarity?: number }> = [];\n\n  // Core patterns\n  for (const pattern of allPatterns) {\n    const match = trimmedText.match(pattern.regex);\n    if (match) {\n      const primitive = pattern.extract(match);\n      if (primitive) {\n        matches.push({\n          source: 'core',\n          name: pattern.name,\n          primitive,\n        });\n      }\n    }\n  }\n\n  // LLKB patterns\n  if (options.useLlkb !== false) {\n    try {\n      const llkbMatch = matchLlkbPattern(trimmedText, {\n        llkbRoot: options.llkbRoot,\n        minConfidence: 0, // Get all LLKB matches for debugging\n      });\n\n      if (llkbMatch) {\n        matches.push({\n          source: 'llkb',\n          name: llkbMatch.patternId,\n          primitive: llkbMatch.primitive,\n          confidence: llkbMatch.confidence,\n        });\n      }\n    } catch {\n      // Ignore LLKB errors in debug mode\n    }\n  }\n\n  // Fuzzy matches\n  if (options.useFuzzy !== false) {\n    try {\n      const fuzzyResult = fuzzyMatch(trimmedText, {\n        minSimilarity: 0.5, // Lower threshold for debugging (show more candidates)\n        useNormalization: true,\n      });\n\n      if (fuzzyResult) {\n        matches.push({\n          source: 'fuzzy',\n          name: fuzzyResult.patternName,\n          primitive: fuzzyResult.primitive,\n          similarity: fuzzyResult.similarity,\n        });\n      }\n    } catch {\n      // Ignore fuzzy errors in debug mode\n    }\n  }\n\n  return matches;\n}\n\n/**\n * Get statistics about the unified matcher\n */\nexport function getUnifiedMatcherStats(options?: { llkbRoot?: string }): {\n  corePatternCount: number;\n  llkbPatternCount: number;\n  totalPatterns: number;\n  coreCategories: Record<string, number>;\n} {\n  let llkbPatternCount = 0;\n\n  try {\n    const llkbPatterns = loadLearnedPatterns({ llkbRoot: options?.llkbRoot });\n    llkbPatternCount = llkbPatterns.length;\n  } catch {\n    // LLKB might not be available\n  }\n\n  // Count core patterns by category\n  const coreCategories: Record<string, number> = {};\n  for (const pattern of allPatterns) {\n    const category = pattern.name.split('-')[0] || 'other';\n    coreCategories[category] = (coreCategories[category] || 0) + 1;\n  }\n\n  return {\n    corePatternCount: allPatterns.length,\n    llkbPatternCount,\n    totalPatterns: allPatterns.length + llkbPatternCount,\n    coreCategories,\n  };\n}\n\n/**\n * Warm up the pattern cache for better performance\n * Call this before batch processing\n */\nexport async function warmUpUnifiedMatcher(options?: { llkbRoot?: string }): Promise<void> {\n  // Load LLKB patterns into cache\n  try {\n    loadLearnedPatterns({ llkbRoot: options?.llkbRoot, bypassCache: true });\n  } catch {\n    // LLKB might not be available\n  }\n}\n\n/**\n * Check if text matches any pattern (without extracting)\n * Useful for quick filtering\n */\nexport function hasPatternMatch(text: string, options: UnifiedMatchOptions = {}): boolean {\n  const result = unifiedMatch(text, options);\n  return result.primitive !== null;\n}\n\n/**\n * Get pattern name for matched text (for telemetry/logging)\n */\nexport function getMatchedPatternName(text: string, options: UnifiedMatchOptions = {}): string | null {\n  const result = unifiedMatch(text, options);\n\n  if (result.source === 'core' && result.patternName) {\n    return result.patternName;\n  }\n\n  if (result.source === 'llkb' && result.llkbPatternId) {\n    return `llkb:${result.llkbPatternId}`;\n  }\n\n  return null;\n}\n\n/**\n * Export for testing - get all core patterns\n */\nexport function getCorePatterns(): StepPattern[] {\n  return [...allPatterns];\n}\n","/**\n * Adapter to convert IR Primitives to PlannedActions\n * This enables plan.ts to use the unified pattern matching system\n *\n * @see research/2026-02-03_unified-pattern-matching-plan.md Phase 1\n */\nimport type { IRPrimitive, LocatorSpec, ValueSpec } from '../ir/types.js';\nimport type { PlannedAction } from '../cli/plan.js';\n\n/**\n * Convert an IR Primitive to a PlannedAction\n * This is the bridge between the unified pattern system and plan.ts\n */\nexport function irPrimitiveToPlannedAction(primitive: IRPrimitive): PlannedAction {\n  switch (primitive.type) {\n    // \n    // NAVIGATION\n    // \n    case 'goto':\n      return { type: 'navigate', target: primitive.url };\n\n    case 'reload':\n      return { type: 'reload' };\n\n    case 'goBack':\n      return { type: 'goBack' };\n\n    case 'goForward':\n      return { type: 'goForward' };\n\n    case 'waitForURL':\n      return {\n        type: 'waitForURL',\n        target: typeof primitive.pattern === 'string' ? primitive.pattern : primitive.pattern.source,\n      };\n\n    case 'waitForResponse':\n      return { type: 'waitForNetwork', target: primitive.urlPattern };\n\n    case 'waitForLoadingComplete':\n      return { type: 'wait', options: { timeout: primitive.timeout ?? 5000 } };\n\n    // \n    // WAIT PRIMITIVES\n    // \n    case 'waitForVisible':\n      return { type: 'waitForVisible', target: locatorToTarget(primitive.locator) };\n\n    case 'waitForHidden':\n      return { type: 'waitForHidden', target: locatorToTarget(primitive.locator) };\n\n    case 'waitForTimeout':\n      return { type: 'wait', options: { timeout: primitive.ms } };\n\n    case 'waitForNetworkIdle':\n      return { type: 'waitForNetwork' };\n\n    // \n    // CLICK INTERACTIONS\n    // \n    case 'click':\n      return { type: 'click', target: locatorToTarget(primitive.locator) };\n\n    case 'dblclick':\n      return { type: 'dblclick', target: locatorToTarget(primitive.locator) };\n\n    case 'rightClick':\n      return { type: 'rightClick', target: locatorToTarget(primitive.locator) };\n\n    // \n    // FORM INTERACTIONS\n    // \n    case 'fill':\n      return {\n        type: 'fill',\n        target: locatorToTarget(primitive.locator),\n        value: valueToString(primitive.value),\n      };\n\n    case 'select':\n      return {\n        type: 'select',\n        target: locatorToTarget(primitive.locator),\n        value: primitive.option,\n      };\n\n    case 'check':\n      return { type: 'check', target: locatorToTarget(primitive.locator) };\n\n    case 'uncheck':\n      return { type: 'uncheck', target: locatorToTarget(primitive.locator) };\n\n    case 'clear':\n      return { type: 'clear', target: locatorToTarget(primitive.locator) };\n\n    case 'upload':\n      return {\n        type: 'upload',\n        target: locatorToTarget(primitive.locator),\n        files: primitive.files,\n      };\n\n    // \n    // OTHER INTERACTIONS\n    // \n    case 'press':\n      return { type: 'press', key: primitive.key };\n\n    case 'hover':\n      return { type: 'hover', target: locatorToTarget(primitive.locator) };\n\n    case 'focus':\n      return { type: 'focus', target: locatorToTarget(primitive.locator) };\n\n    // \n    // ASSERTIONS\n    // \n    case 'expectVisible':\n      return { type: 'assert', target: locatorToTarget(primitive.locator) };\n\n    case 'expectNotVisible':\n    case 'expectHidden':\n      return { type: 'assertHidden', target: locatorToTarget(primitive.locator) };\n\n    case 'expectText':\n      return {\n        type: 'assertText',\n        target: locatorToTarget(primitive.locator),\n        value: typeof primitive.text === 'string' ? primitive.text : primitive.text.source,\n      };\n\n    case 'expectContainsText':\n      return {\n        type: 'assertText',\n        target: locatorToTarget(primitive.locator),\n        value: primitive.text,\n      };\n\n    case 'expectValue':\n      return {\n        type: 'assertValue',\n        target: locatorToTarget(primitive.locator),\n        value: primitive.value,\n      };\n\n    case 'expectChecked':\n      return { type: 'assertChecked', target: locatorToTarget(primitive.locator) };\n\n    case 'expectEnabled':\n      return { type: 'assertEnabled', target: locatorToTarget(primitive.locator) };\n\n    case 'expectDisabled':\n      return { type: 'assertDisabled', target: locatorToTarget(primitive.locator) };\n\n    case 'expectURL':\n      return {\n        type: 'assertURL',\n        target: typeof primitive.pattern === 'string' ? primitive.pattern : primitive.pattern.source,\n      };\n\n    case 'expectTitle':\n      return {\n        type: 'assertTitle',\n        target: typeof primitive.title === 'string' ? primitive.title : primitive.title.source,\n      };\n\n    case 'expectCount':\n      return {\n        type: 'assertCount',\n        target: locatorToTarget(primitive.locator),\n        count: primitive.count,\n      };\n\n    // \n    // SIGNALS (TOASTS, MODALS, ALERTS)\n    // \n    case 'expectToast':\n      return {\n        type: 'assertToast',\n        toastType: primitive.toastType,\n        value: primitive.message,\n      };\n\n    case 'dismissModal':\n      return { type: 'dismissModal' };\n\n    case 'acceptAlert':\n      return { type: 'acceptAlert' };\n\n    case 'dismissAlert':\n      return { type: 'dismissAlert' };\n\n    // \n    // MODULE CALLS\n    // \n    case 'callModule':\n      return {\n        type: 'callModule',\n        module: primitive.module,\n        method: primitive.method,\n      };\n\n    // \n    // BLOCKED/TODO\n    // \n    case 'blocked':\n      return { type: 'custom', target: primitive.sourceText };\n\n    default:\n      // Exhaustiveness check - this should never happen if all types are handled\n      const _exhaustive: never = primitive;\n      return { type: 'custom', target: String((_exhaustive as IRPrimitive).type) };\n  }\n}\n\n/**\n * Convert a LocatorSpec to a target string for PlannedAction\n */\nfunction locatorToTarget(locator: LocatorSpec): string {\n  switch (locator.strategy) {\n    case 'role':\n      // For role locators, include the accessible name if available\n      if (locator.options?.name) {\n        return `${locator.value}:${locator.options.name}`;\n      }\n      return locator.value;\n\n    case 'placeholder':\n      // For placeholder locators, use placeholder: prefix\n      return `placeholder:${locator.value}`;\n\n    case 'label':\n    case 'text':\n    case 'testid':\n      return locator.value;\n\n    case 'css':\n      // For CSS selectors, return as-is\n      return locator.value;\n\n    default:\n      return locator.value;\n  }\n}\n\n/**\n * Convert a ValueSpec to a string for PlannedAction\n */\nfunction valueToString(value: ValueSpec): string {\n  switch (value.type) {\n    case 'literal':\n      return value.value;\n\n    case 'actor':\n      // Actor reference: {{email}}, {{password}}\n      return `{{${value.value}}}`;\n\n    case 'testData':\n      // Test data reference: $user.email\n      return `$${value.value}`;\n\n    case 'generated':\n      // Generated value: ${runId}, ${timestamp}\n      return value.value;\n\n    case 'runId':\n      return '${runId}';\n\n    default:\n      return value.value || '';\n  }\n}\n\n/**\n * Convert PlannedAction back to an IR Primitive (for round-trip consistency)\n * This is useful for testing and debugging\n */\nexport function plannedActionToIRPrimitive(action: PlannedAction): IRPrimitive | null {\n  switch (action.type) {\n    case 'navigate':\n      return { type: 'goto', url: action.target || '/' };\n\n    case 'reload':\n      return { type: 'reload' };\n\n    case 'goBack':\n      return { type: 'goBack' };\n\n    case 'goForward':\n      return { type: 'goForward' };\n\n    case 'click':\n      return { type: 'click', locator: targetToLocator(action.target || '') };\n\n    case 'dblclick':\n      return { type: 'dblclick', locator: targetToLocator(action.target || '') };\n\n    case 'rightClick':\n      return { type: 'rightClick', locator: targetToLocator(action.target || '') };\n\n    case 'fill':\n      return {\n        type: 'fill',\n        locator: targetToLocator(action.target || ''),\n        value: stringToValue(action.value || ''),\n      };\n\n    case 'select':\n      return {\n        type: 'select',\n        locator: targetToLocator(action.target || ''),\n        option: action.value || '',\n      };\n\n    case 'check':\n      return { type: 'check', locator: targetToLocator(action.target || '') };\n\n    case 'uncheck':\n      return { type: 'uncheck', locator: targetToLocator(action.target || '') };\n\n    case 'press':\n      return { type: 'press', key: action.key || 'Enter' };\n\n    case 'hover':\n      return { type: 'hover', locator: targetToLocator(action.target || '') };\n\n    case 'focus':\n      return { type: 'focus', locator: targetToLocator(action.target || '') };\n\n    case 'clear':\n      return { type: 'clear', locator: targetToLocator(action.target || '') };\n\n    case 'assert':\n      return { type: 'expectVisible', locator: targetToLocator(action.target || '') };\n\n    case 'assertHidden':\n      return { type: 'expectHidden', locator: targetToLocator(action.target || '') };\n\n    case 'assertText':\n      return {\n        type: 'expectText',\n        locator: targetToLocator(action.target || ''),\n        text: action.value || '',\n      };\n\n    case 'assertURL':\n      return { type: 'expectURL', pattern: action.target || '/' };\n\n    case 'assertTitle':\n      return { type: 'expectTitle', title: action.target || '' };\n\n    case 'assertToast':\n      return {\n        type: 'expectToast',\n        toastType: action.toastType || 'info',\n        message: action.value,\n      };\n\n    case 'waitForVisible':\n      return { type: 'waitForVisible', locator: targetToLocator(action.target || '') };\n\n    case 'waitForHidden':\n      return { type: 'waitForHidden', locator: targetToLocator(action.target || '') };\n\n    case 'waitForNetwork':\n      return { type: 'waitForNetworkIdle' };\n\n    case 'wait':\n      return { type: 'waitForTimeout', ms: (action.options?.timeout as number) || 5000 };\n\n    case 'dismissModal':\n      return { type: 'dismissModal' };\n\n    case 'acceptAlert':\n      return { type: 'acceptAlert' };\n\n    case 'dismissAlert':\n      return { type: 'dismissAlert' };\n\n    case 'callModule':\n      return {\n        type: 'callModule',\n        module: action.module || 'unknown',\n        method: action.method || 'unknown',\n      };\n\n    case 'custom':\n      return { type: 'blocked', reason: 'custom action', sourceText: action.target || '' };\n\n    default:\n      return null;\n  }\n}\n\n/**\n * Convert a target string back to a LocatorSpec\n */\nfunction targetToLocator(target: string): LocatorSpec {\n  // Check for role:name pattern (e.g., \"button:Submit\")\n  const roleMatch = target.match(/^(\\w+):(.+)$/);\n  if (roleMatch) {\n    return {\n      strategy: 'role',\n      value: roleMatch[1]!,\n      options: { name: roleMatch[2] },\n    };\n  }\n\n  // Default to text locator\n  return { strategy: 'text', value: target };\n}\n\n/**\n * Convert a string value back to a ValueSpec\n */\nfunction stringToValue(str: string): ValueSpec {\n  // Actor reference: {{email}}\n  if (/^\\{\\{.+\\}\\}$/.test(str)) {\n    return { type: 'actor', value: str.slice(2, -2) };\n  }\n\n  // Test data reference: $user.email\n  if (/^\\$.+/.test(str)) {\n    return { type: 'testData', value: str.slice(1) };\n  }\n\n  // Generated value: ${runId}\n  if (/\\$\\{.+\\}/.test(str)) {\n    return { type: 'generated', value: str };\n  }\n\n  // Literal\n  return { type: 'literal', value: str };\n}\n","/**\n * CLI Plan Command - Create test generation plan\n *\n * Part of the Hybrid Agentic architecture. The orchestrating LLM can\n * either use the plan command to create a default plan, or create\n * the plan directly and pass it to generate.\n *\n * @see research/2026-02-02_autogen-enhancement-implementation-plan.md\n */\nimport { parseArgs } from 'node:util';\nimport { readFileSync, writeFileSync, existsSync } from 'node:fs';\nimport {\n  getAutogenArtifact,\n  ensureAutogenDir,\n} from '../utils/paths.js';\nimport { updatePipelineState, loadPipelineState, canProceedTo } from '../pipeline/state.js';\nimport { getTelemetry } from '../shared/telemetry.js';\nimport {\n  createOrchestratorSampleRequest,\n  DEFAULT_MULTI_SAMPLER_CONFIG,\n  type OrchestratorSampleRequest,\n} from '../uncertainty/multi-sampler.js';\nimport type { AnalysisOutput, JourneyAnalysis } from './analyze.js';\nimport { unifiedMatch } from '../mapping/unifiedMatcher.js';\nimport { irPrimitiveToPlannedAction } from '../mapping/plannedActionAdapter.js';\n\n// \n// TYPES\n// \n\nexport interface TestPlan {\n  version: '1.0';\n  journeyId: string;\n  journeyPath: string;\n  strategy: PlanStrategy;\n  steps: PlannedStep[];\n  modules: PlannedModule[];\n  imports: string[];\n  fixtures: string[];\n  configuration: PlanConfiguration;\n  createdAt: string;\n  createdBy: 'cli' | 'orchestrator';\n  /** Multi-sample request for orchestrator (when strategy is 'multi-sample') */\n  multiSampleRequest?: OrchestratorSampleRequest;\n}\n\nexport type PlanStrategy = 'direct' | 'scot' | 'multi-sample';\n\nexport interface PlannedStep {\n  index: number;\n  description: string;\n  action: PlannedAction;\n  expectedOutcome?: string;\n  selectors?: SelectorHint[];\n  assertions?: AssertionHint[];\n  waitCondition?: string;\n  notes?: string;\n}\n\nexport interface PlannedAction {\n  type:\n    // Navigation\n    | 'navigate' | 'reload' | 'goBack' | 'goForward'\n    // Interactions\n    | 'click' | 'dblclick' | 'rightClick' | 'fill' | 'select' | 'check' | 'uncheck'\n    | 'press' | 'hover' | 'focus' | 'clear' | 'upload'\n    // Assertions\n    | 'assert' | 'assertText' | 'assertValue' | 'assertChecked' | 'assertEnabled'\n    | 'assertDisabled' | 'assertURL' | 'assertTitle' | 'assertHidden' | 'assertCount'\n    // Waits\n    | 'wait' | 'waitForVisible' | 'waitForHidden' | 'waitForURL' | 'waitForNetwork'\n    // Signals\n    | 'assertToast' | 'dismissModal' | 'acceptAlert' | 'dismissAlert'\n    // Module calls\n    | 'callModule'\n    // Custom/fallback\n    | 'custom';\n  target?: string;\n  value?: string;\n  /** For callModule: module name */\n  module?: string;\n  /** For callModule: method name */\n  method?: string;\n  /** For press: key name */\n  key?: string;\n  /** For upload: file paths */\n  files?: string[];\n  /** For assertCount: expected count */\n  count?: number;\n  /** For assertToast: toast type */\n  toastType?: 'success' | 'error' | 'info' | 'warning';\n  options?: Record<string, unknown>;\n}\n\nexport interface SelectorHint {\n  strategy: 'testId' | 'role' | 'text' | 'label' | 'css' | 'xpath';\n  value: string;\n  confidence: number;\n}\n\nexport interface AssertionHint {\n  type: 'visible' | 'text' | 'value' | 'enabled' | 'checked' | 'url' | 'title';\n  expected?: string;\n}\n\nexport interface PlannedModule {\n  name: string;\n  type: 'page' | 'flow' | 'component';\n  methods: string[];\n}\n\nexport interface PlanConfiguration {\n  timeout: number;\n  retries: number;\n  parallel: boolean;\n  screenshot: 'on' | 'off' | 'only-on-failure';\n  video: 'on' | 'off' | 'retain-on-failure';\n  trace: 'on' | 'off' | 'retain-on-failure';\n}\n\nexport interface PlanOutput {\n  version: '1.0';\n  plans: TestPlan[];\n  summary: PlanSummary;\n  createdAt: string;\n}\n\nexport interface PlanSummary {\n  totalPlans: number;\n  totalSteps: number;\n  strategies: Record<PlanStrategy, number>;\n  estimatedTestTime: number; // seconds\n}\n\n// \n// USAGE\n// \n\nconst USAGE = `\nUsage: artk-autogen plan [options]\n\nCreate test generation plan from analysis or direct input.\n\nOptions:\n  -a, --analysis <path>  Path to analysis.json (default: .artk/autogen/analysis.json)\n  -j, --journey <id>     Plan for specific journey ID only\n  -s, --strategy <type>  Generation strategy: direct, scot, multi-sample (default: direct)\n  -o, --output <path>    Output path for plan.json (default: .artk/autogen/plan.json)\n  --json                 Output JSON to stdout instead of file\n  -q, --quiet            Suppress output except errors\n  -f, --force            Skip pipeline state validation\n  -h, --help             Show this help message\n\nExamples:\n  artk-autogen plan\n  artk-autogen plan --analysis custom/analysis.json\n  artk-autogen plan --journey JRN-0001 --strategy scot\n  artk-autogen plan --json\n`;\n\n// \n// PLAN GENERATION\n// \n\nconst DEFAULT_CONFIG: PlanConfiguration = {\n  timeout: 30000,\n  retries: 2,\n  parallel: false,\n  screenshot: 'only-on-failure',\n  video: 'retain-on-failure',\n  trace: 'retain-on-failure',\n};\n\n/**\n * Convert journey step to planned action using unified pattern matching\n *\n * This uses the unified matcher (patterns.ts + LLKB) instead of duplicating\n * pattern matching logic here.\n *\n * @see research/2026-02-03_unified-pattern-matching-plan.md Phase 3\n */\nfunction convertStepToAction(step: JourneyAnalysis['steps'][0], options?: { llkbRoot?: string }): PlannedAction {\n  // Use unified pattern matching (core patterns + LLKB)\n  const result = unifiedMatch(step.text, {\n    useLlkb: true,\n    llkbRoot: options?.llkbRoot,\n  });\n\n  if (result.primitive) {\n    // Convert IR primitive to PlannedAction\n    return irPrimitiveToPlannedAction(result.primitive);\n  }\n\n  // Fallback: return custom action with original text\n  return { type: 'custom', target: step.text };\n}\n\nfunction inferSelectors(step: JourneyAnalysis['steps'][0]): SelectorHint[] {\n  const selectors: SelectorHint[] = [];\n  const text = step.text.toLowerCase();\n\n  // Check for data-testid hints\n  const testIdMatch = text.match(/data-testid\\s*[=:]\\s*[\"']?([^\"'\\s]+)/i);\n  if (testIdMatch && testIdMatch[1]) {\n    selectors.push({\n      strategy: 'testId',\n      value: testIdMatch[1],\n      confidence: 0.95,\n    });\n  }\n\n  // Check for button/link names (suggest role-based)\n  const buttonMatch = text.match(/(?:click|press)\\s+(?:the\\s+)?[\"']?(\\w+)[\"']?\\s*button/i);\n  if (buttonMatch && buttonMatch[1]) {\n    selectors.push({\n      strategy: 'role',\n      value: `button[name=\"${buttonMatch[1]}\"]`,\n      confidence: 0.7,\n    });\n  }\n\n  // Check for links\n  const linkMatch = text.match(/(?:click|press)\\s+(?:the\\s+)?[\"']?([^\"']+)[\"']?\\s*link/i);\n  if (linkMatch && linkMatch[1]) {\n    selectors.push({\n      strategy: 'role',\n      value: `link[name=\"${linkMatch[1]}\"]`,\n      confidence: 0.7,\n    });\n  }\n\n  // Check for text content\n  const textMatch = text.match(/(?:with|containing|text)\\s+[\"']([^\"']+)[\"']/i);\n  if (textMatch && textMatch[1]) {\n    selectors.push({\n      strategy: 'text',\n      value: textMatch[1],\n      confidence: 0.6,\n    });\n  }\n\n  return selectors;\n}\n\nfunction inferAssertions(step: JourneyAnalysis['steps'][0]): AssertionHint[] {\n  const assertions: AssertionHint[] = [];\n  const text = step.text.toLowerCase();\n\n  if (text.includes('visible') || text.includes('see') || text.includes('displayed')) {\n    assertions.push({ type: 'visible' });\n  }\n\n  if (text.includes('text') || text.includes('message') || text.includes('shows')) {\n    const textMatch = text.match(/[\"']([^\"']+)[\"']/);\n    assertions.push({\n      type: 'text',\n      expected: textMatch?.[1],\n    });\n  }\n\n  if (text.includes('url') || text.includes('navigate')) {\n    const urlMatch = text.match(/url\\s+(?:is|contains)?\\s*[\"']?([^\"'\\s]+)/i);\n    assertions.push({\n      type: 'url',\n      expected: urlMatch?.[1],\n    });\n  }\n\n  return assertions;\n}\n\nfunction createPlanFromJourney(\n  journey: JourneyAnalysis,\n  strategy: PlanStrategy\n): TestPlan {\n  const steps: PlannedStep[] = journey.steps.map((step, idx) => ({\n    index: idx,\n    description: step.text,\n    action: convertStepToAction(step),\n    selectors: inferSelectors(step),\n    assertions: step.hasAssertion ? inferAssertions(step) : undefined,\n    waitCondition: step.type === 'wait' ? 'networkidle' : undefined,\n  }));\n\n  // Infer modules needed\n  const modules: PlannedModule[] = [];\n\n  // Check if auth is needed\n  if (journey.scope.includes('auth') || journey.steps.some(s => s.text.toLowerCase().includes('login'))) {\n    modules.push({\n      name: 'auth',\n      type: 'flow',\n      methods: ['login', 'logout'],\n    });\n  }\n\n  // Check for navigation patterns\n  const hasNavigation = journey.steps.some(s => s.type === 'navigation');\n  if (hasNavigation) {\n    modules.push({\n      name: 'navigation',\n      type: 'flow',\n      methods: ['navigateTo'],\n    });\n  }\n\n  // Check for form interactions\n  const hasForms = journey.steps.some(s => s.type === 'form');\n  if (hasForms) {\n    modules.push({\n      name: 'forms',\n      type: 'component',\n      methods: ['fillForm', 'submitForm'],\n    });\n  }\n\n  // Standard imports\n  const imports = ['test', 'expect'];\n\n  // Fixtures based on dependencies\n  const fixtures: string[] = [];\n  if (modules.some(m => m.name === 'auth')) {\n    fixtures.push('authenticatedPage');\n  }\n\n  // Adjust config based on complexity\n  const config = { ...DEFAULT_CONFIG };\n  if (journey.complexity.overall === 'complex') {\n    config.timeout = 60000;\n    config.retries = 3;\n    config.trace = 'on';\n  }\n\n  const plan: TestPlan = {\n    version: '1.0',\n    journeyId: journey.journeyId,\n    journeyPath: journey.journeyPath,\n    strategy,\n    steps,\n    modules,\n    imports,\n    fixtures,\n    configuration: config,\n    createdAt: new Date().toISOString(),\n    createdBy: 'cli',\n  };\n\n  // Add multi-sample request if strategy is multi-sample\n  if (strategy === 'multi-sample') {\n    const prompt = createMultiSamplePrompt(journey, steps);\n    plan.multiSampleRequest = createOrchestratorSampleRequest(\n      prompt,\n      journey.journeyId,\n      DEFAULT_MULTI_SAMPLER_CONFIG\n    );\n  }\n\n  return plan;\n}\n\n/**\n * Create a prompt for multi-sample generation\n */\nfunction createMultiSamplePrompt(journey: JourneyAnalysis, steps: PlannedStep[]): string {\n  const stepDescriptions = steps.map((s, i) =>\n    `${i + 1}. ${s.description} (${s.action.type})`\n  ).join('\\n');\n\n  return `Generate a Playwright test for the following journey:\n\nJourney ID: ${journey.journeyId}\nTitle: ${journey.title}\nTier: ${journey.tier}\nComplexity: ${journey.complexity.overall}\n\nSteps:\n${stepDescriptions}\n\nAcceptance Criteria:\n${journey.acceptanceCriteria.map(ac => `- ${ac}`).join('\\n')}\n\nRequirements:\n- Use Playwright Test syntax with TypeScript\n- Use data-testid selectors where possible\n- Include proper assertions for each acceptance criterion\n- Add appropriate wait conditions for async operations\n- Follow Playwright best practices for reliability`;\n}\n\n// \n// MAIN COMMAND\n// \n\nexport async function runPlan(args: string[]): Promise<void> {\n  const { values } = parseArgs({\n    args,\n    options: {\n      analysis: { type: 'string', short: 'a' },\n      journey: { type: 'string', short: 'j' },\n      strategy: { type: 'string', short: 's', default: 'direct' },\n      output: { type: 'string', short: 'o' },\n      json: { type: 'boolean', default: false },\n      quiet: { type: 'boolean', short: 'q', default: false },\n      force: { type: 'boolean', short: 'f', default: false },\n      help: { type: 'boolean', short: 'h', default: false },\n    },\n    allowPositionals: true,\n  });\n\n  if (values.help) {\n    console.log(USAGE);\n    return;\n  }\n\n  const quiet = values.quiet;\n  const outputJson = values.json;\n  const force = values.force;\n  const strategyInput = values.strategy?.toLowerCase().trim() || 'direct';\n\n  // Validate and normalize strategy\n  const validStrategies = ['direct', 'scot', 'multi-sample'];\n  if (!validStrategies.includes(strategyInput)) {\n    console.error(`Error: Invalid strategy \"${strategyInput}\". Use: ${validStrategies.join(', ')}`);\n    process.exit(1);\n  }\n  const strategy = strategyInput as PlanStrategy;\n\n  // Initialize telemetry\n  const telemetry = getTelemetry();\n  await telemetry.load();\n  const eventId = telemetry.trackCommandStart('plan');\n\n  // Validate pipeline state transition (unless --force)\n  const pipelineState = await loadPipelineState();\n  if (!force) {\n    const transition = canProceedTo(pipelineState, 'planned');\n    if (!transition.allowed) {\n      console.error(`Error: ${transition.reason}`);\n      console.error('Use --force to bypass state validation.');\n      process.exit(1);\n    }\n  } else if (!quiet && !outputJson) {\n    console.log('Warning: Bypassing pipeline state validation (--force)');\n  }\n\n  // Load analysis\n  const analysisPath = values.analysis || getAutogenArtifact('analysis');\n  if (!existsSync(analysisPath)) {\n    console.error(`Error: Analysis file not found: ${analysisPath}`);\n    console.error('Run \"artk-autogen analyze\" first.');\n    process.exit(1);\n  }\n\n  let analysis: AnalysisOutput;\n  try {\n    analysis = JSON.parse(readFileSync(analysisPath, 'utf-8'));\n  } catch (e) {\n    console.error(`Error: Failed to parse analysis file: ${e}`);\n    process.exit(1);\n  }\n\n  // Filter journeys if specific one requested\n  let journeys = analysis.journeys;\n  if (values.journey) {\n    journeys = journeys.filter(j => j.journeyId === values.journey);\n    if (journeys.length === 0) {\n      console.error(`Error: Journey \"${values.journey}\" not found in analysis`);\n      process.exit(1);\n    }\n  }\n\n  if (!quiet && !outputJson) {\n    console.log(`Creating plan for ${journeys.length} journey(s) with strategy: ${strategy}`);\n  }\n\n  // Create plans\n  const plans: TestPlan[] = journeys.map(j => createPlanFromJourney(j, strategy));\n\n  // Calculate summary\n  const strategyCount: Record<PlanStrategy, number> = {\n    direct: 0,\n    scot: 0,\n    'multi-sample': 0,\n  };\n  for (const p of plans) {\n    strategyCount[p.strategy]++;\n  }\n\n  const totalSteps = plans.reduce((sum, p) => sum + p.steps.length, 0);\n  // Rough estimate: 2 seconds per step average\n  const estimatedTestTime = totalSteps * 2;\n\n  const output: PlanOutput = {\n    version: '1.0',\n    plans,\n    summary: {\n      totalPlans: plans.length,\n      totalSteps,\n      strategies: strategyCount,\n      estimatedTestTime,\n    },\n    createdAt: new Date().toISOString(),\n  };\n\n  // Output\n  if (outputJson) {\n    console.log(JSON.stringify(output, null, 2));\n  } else {\n    // Write to file\n    const outputPath = values.output || getAutogenArtifact('plan');\n    await ensureAutogenDir();\n    writeFileSync(outputPath, JSON.stringify(output, null, 2), 'utf-8');\n\n    if (!quiet) {\n      console.log(`\\nPlan created:`);\n      console.log(`  Plans: ${output.summary.totalPlans}`);\n      console.log(`  Steps: ${output.summary.totalSteps}`);\n      console.log(`  Strategy: ${strategy}`);\n      console.log(`  Est. time: ${Math.ceil(estimatedTestTime / 60)} min`);\n\n      // Show multi-sample info if applicable\n      const multiSamplePlans = plans.filter(p => p.multiSampleRequest);\n      if (multiSamplePlans.length > 0) {\n        console.log(`  Multi-sample enabled: ${multiSamplePlans.length} plan(s)`);\n      }\n\n      console.log(`\\nOutput: ${outputPath}`);\n    }\n  }\n\n  // Update pipeline state\n  await updatePipelineState('plan', 'planned', true, {\n    journeyIds: plans.map(p => p.journeyId),\n  });\n\n  // Track command completion\n  telemetry.trackCommandEnd(eventId, true, {\n    planCount: plans.length,\n    stepCount: totalSteps,\n    strategy,\n  });\n  await telemetry.save();\n}\n","/**\n * Telemetry for blocked steps - Records blocked steps for pattern analysis\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md Phase 3\n */\nimport { existsSync, readFileSync, appendFileSync, mkdirSync, unlinkSync } from 'node:fs';\nimport { join, dirname } from 'node:path';\nimport { getArtkDir } from '../utils/paths.js';\n\n/**\n * Record for a blocked step\n */\nexport interface BlockedStepRecord {\n  /** ISO timestamp when the step was blocked */\n  timestamp: string;\n  /** Journey ID where this step was found */\n  journeyId: string;\n  /** Original step text that was blocked */\n  stepText: string;\n  /** Normalized text (lowercase, trimmed) */\n  normalizedText: string;\n  /** Category of the step */\n  category: 'navigation' | 'interaction' | 'assertion' | 'wait' | 'unknown';\n  /** Reason the step was blocked */\n  reason: string;\n  /** Suggested fix from the system */\n  suggestedFix?: string;\n  /** User's manual fix (if captured) */\n  userFix?: string;\n  /** Nearest pattern that almost matched */\n  nearestPattern?: string;\n  /** Distance to nearest pattern */\n  nearestDistance?: number;\n}\n\n/**\n * Pattern gap identified from telemetry analysis\n */\nexport interface PatternGap {\n  /** Example text that represents this gap */\n  exampleText: string;\n  /** Normalized form of the text */\n  normalizedText: string;\n  /** Number of times this gap was encountered */\n  count: number;\n  /** Category of the gap */\n  category: string;\n  /** All unique step texts that fall into this gap */\n  variants: string[];\n  /** Suggested regex pattern to add */\n  suggestedPattern?: string;\n  /** First occurrence timestamp */\n  firstSeen: string;\n  /** Last occurrence timestamp */\n  lastSeen: string;\n}\n\n/**\n * Telemetry statistics\n */\nexport interface TelemetryStats {\n  /** Total number of blocked steps recorded */\n  totalRecords: number;\n  /** Unique patterns identified */\n  uniquePatterns: number;\n  /** Records by category */\n  byCategory: Record<string, number>;\n  /** Date range of records */\n  dateRange: {\n    earliest: string;\n    latest: string;\n  };\n}\n\n/**\n * Telemetry file name\n */\nconst TELEMETRY_FILE = 'blocked-steps-telemetry.jsonl';\n\n/**\n * Get the telemetry file path.\n *\n * Automatically infers the correct .artk directory location by:\n * 1. Using explicit baseDir if provided\n * 2. Finding artk-e2e/.artk from project root\n * 3. Finding .artk in current directory if inside harness\n *\n * @param baseDir - Optional explicit base directory override\n * @returns Path to the telemetry file\n */\nexport function getTelemetryPath(baseDir?: string): string {\n  const artkDir = getArtkDir(baseDir);\n  return join(artkDir, TELEMETRY_FILE);\n}\n\n/**\n * Ensure the telemetry directory exists\n */\nfunction ensureTelemetryDir(telemetryPath: string): void {\n  const dir = dirname(telemetryPath);\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n}\n\n/**\n * Normalize step text for telemetry comparison\n * (Simpler normalization than glossary - for deduplication purposes)\n */\nexport function normalizeStepTextForTelemetry(text: string): string {\n  return text\n    .toLowerCase()\n    .trim()\n    // Remove common articles\n    .replace(/\\b(the|a|an)\\b/g, '')\n    // Remove extra whitespace\n    .replace(/\\s+/g, ' ')\n    // Remove quoted values but keep structure\n    .replace(/\"[^\"]*\"/g, '\"\"')\n    .replace(/'[^']*'/g, \"''\")\n    .trim();\n}\n\n/**\n * Categorize a step based on its text\n */\nexport function categorizeStepText(text: string): BlockedStepRecord['category'] {\n  const lower = text.toLowerCase();\n\n  if (\n    lower.includes('navigate') ||\n    lower.includes('go to') ||\n    lower.includes('open') ||\n    lower.includes('visit')\n  ) {\n    return 'navigation';\n  }\n\n  if (\n    lower.includes('click') ||\n    lower.includes('fill') ||\n    lower.includes('enter') ||\n    lower.includes('type') ||\n    lower.includes('select') ||\n    lower.includes('check') ||\n    lower.includes('press') ||\n    lower.includes('submit') ||\n    lower.includes('input')\n  ) {\n    return 'interaction';\n  }\n\n  if (\n    lower.includes('see') ||\n    lower.includes('visible') ||\n    lower.includes('verify') ||\n    lower.includes('assert') ||\n    lower.includes('confirm') ||\n    lower.includes('should') ||\n    lower.includes('ensure') ||\n    lower.includes('expect') ||\n    lower.includes('display')\n  ) {\n    return 'assertion';\n  }\n\n  if (lower.includes('wait') || lower.includes('load') || lower.includes('until')) {\n    return 'wait';\n  }\n\n  return 'unknown';\n}\n\n/**\n * Record a blocked step to the telemetry file\n */\nexport function recordBlockedStep(\n  record: Omit<BlockedStepRecord, 'timestamp' | 'normalizedText' | 'category'> & {\n    category?: BlockedStepRecord['category'];\n  },\n  options: { baseDir?: string } = {}\n): void {\n  const telemetryPath = getTelemetryPath(options.baseDir);\n  ensureTelemetryDir(telemetryPath);\n\n  const fullRecord: BlockedStepRecord = {\n    ...record,\n    timestamp: new Date().toISOString(),\n    normalizedText: normalizeStepTextForTelemetry(record.stepText),\n    category: record.category || categorizeStepText(record.stepText),\n  };\n\n  appendFileSync(telemetryPath, JSON.stringify(fullRecord) + '\\n');\n}\n\n/**\n * Read all blocked step records from the telemetry file\n */\nexport function readBlockedStepRecords(options: { baseDir?: string } = {}): BlockedStepRecord[] {\n  const telemetryPath = getTelemetryPath(options.baseDir);\n\n  if (!existsSync(telemetryPath)) {\n    return [];\n  }\n\n  try {\n    const content = readFileSync(telemetryPath, 'utf-8');\n    return content\n      .split('\\n')\n      .filter(Boolean)\n      .map((line) => {\n        try {\n          return JSON.parse(line) as BlockedStepRecord;\n        } catch {\n          return null;\n        }\n      })\n      .filter((record): record is BlockedStepRecord => record !== null);\n  } catch {\n    return [];\n  }\n}\n\n/**\n * Calculate similarity between two normalized texts\n * Uses simple token-based Jaccard similarity\n */\nfunction calculateTokenSimilarity(a: string, b: string): number {\n  const tokensA = new Set(a.split(' ').filter(Boolean));\n  const tokensB = new Set(b.split(' ').filter(Boolean));\n\n  if (tokensA.size === 0 && tokensB.size === 0) return 1;\n  if (tokensA.size === 0 || tokensB.size === 0) return 0;\n\n  const intersection = new Set([...tokensA].filter((x) => tokensB.has(x)));\n  const union = new Set([...tokensA, ...tokensB]);\n\n  return intersection.size / union.size;\n}\n\n/**\n * Group blocked step records by similarity\n */\nfunction groupBySimilarity(\n  records: BlockedStepRecord[],\n  threshold: number = 0.7\n): Map<string, BlockedStepRecord[]> {\n  const groups = new Map<string, BlockedStepRecord[]>();\n  const processed = new Set<number>();\n\n  for (let i = 0; i < records.length; i++) {\n    if (processed.has(i)) continue;\n\n    const record = records[i]!;\n    const normalized = record.normalizedText;\n    const group: BlockedStepRecord[] = [record];\n    processed.add(i);\n\n    // Find similar records\n    for (let j = i + 1; j < records.length; j++) {\n      if (processed.has(j)) continue;\n\n      const other = records[j]!;\n      const similarity = calculateTokenSimilarity(normalized, other.normalizedText);\n\n      if (similarity >= threshold) {\n        group.push(other);\n        processed.add(j);\n      }\n    }\n\n    groups.set(normalized, group);\n  }\n\n  return groups;\n}\n\n/**\n * Analyze blocked steps to find top pattern gaps\n */\nexport function analyzeBlockedPatterns(options: { baseDir?: string; limit?: number } = {}): PatternGap[] {\n  const records = readBlockedStepRecords(options);\n\n  if (records.length === 0) {\n    return [];\n  }\n\n  const groups = groupBySimilarity(records);\n  const gaps: PatternGap[] = [];\n\n  for (const [normalizedText, groupRecords] of groups) {\n    const timestamps = groupRecords.map((r) => r.timestamp).sort();\n    const variants = [...new Set(groupRecords.map((r) => r.stepText))];\n\n    gaps.push({\n      exampleText: groupRecords[0]!.stepText,\n      normalizedText,\n      count: groupRecords.length,\n      category: groupRecords[0]!.category,\n      variants,\n      suggestedPattern: generateSuggestedPattern(variants),\n      firstSeen: timestamps[0]!,\n      lastSeen: timestamps[timestamps.length - 1]!,\n    });\n  }\n\n  // Sort by count (most frequent first)\n  gaps.sort((a, b) => b.count - a.count);\n\n  return options.limit ? gaps.slice(0, options.limit) : gaps;\n}\n\n/**\n * Generate a suggested regex pattern from examples\n */\nfunction generateSuggestedPattern(variants: string[]): string | undefined {\n  if (variants.length === 0) return undefined;\n\n  // Find common prefix and suffix\n  const example = variants[0]!.toLowerCase();\n\n  // Extract quoted values and replace with placeholders\n  const pattern = example\n    .replace(/\"[^\"]+\"/g, '\"([^\"]+)\"')\n    .replace(/'[^']+'/g, \"'([^']+)'\")\n    // Escape special regex chars (except those we use)\n    .replace(/[.*+?^${}()|[\\]\\\\]/g, (char) => {\n      if (char === '(' || char === ')' || char === '[' || char === ']' || char === '+') {\n        return char;\n      }\n      return '\\\\' + char;\n    });\n\n  return `^(?:user\\\\s+)?${pattern}$`;\n}\n\n/**\n * Get telemetry statistics\n */\nexport function getTelemetryStats(options: { baseDir?: string } = {}): TelemetryStats {\n  const records = readBlockedStepRecords(options);\n\n  if (records.length === 0) {\n    return {\n      totalRecords: 0,\n      uniquePatterns: 0,\n      byCategory: {},\n      dateRange: {\n        earliest: '',\n        latest: '',\n      },\n    };\n  }\n\n  const byCategory: Record<string, number> = {};\n  const normalizedSet = new Set<string>();\n  const timestamps = records.map((r) => r.timestamp).sort();\n\n  for (const record of records) {\n    byCategory[record.category] = (byCategory[record.category] || 0) + 1;\n    normalizedSet.add(record.normalizedText);\n  }\n\n  return {\n    totalRecords: records.length,\n    uniquePatterns: normalizedSet.size,\n    byCategory,\n    dateRange: {\n      earliest: timestamps[0]!,\n      latest: timestamps[timestamps.length - 1]!,\n    },\n  };\n}\n\n/**\n * Record a user fix for a previously blocked step\n */\nexport function recordUserFix(\n  originalStepText: string,\n  userFixedText: string,\n  options: { baseDir?: string } = {}\n): void {\n  const records = readBlockedStepRecords(options);\n  const normalizedOriginal = normalizeStepTextForTelemetry(originalStepText);\n\n  // Find matching record and update it (append new record with fix)\n  const matchingRecord = records.find((r) => r.normalizedText === normalizedOriginal && !r.userFix);\n\n  if (matchingRecord) {\n    // Record the user fix - timestamp and normalizedText will be set by recordBlockedStep\n    // eslint-disable-next-line no-unused-vars\n    const { timestamp: _t, normalizedText: _n, ...recordWithoutTimestamp } = matchingRecord;\n    recordBlockedStep(\n      {\n        ...recordWithoutTimestamp,\n        userFix: userFixedText,\n      },\n      options\n    );\n  }\n}\n\n/**\n * Clear telemetry data (for testing or reset)\n */\nexport function clearTelemetry(options: { baseDir?: string } = {}): void {\n  const telemetryPath = getTelemetryPath(options.baseDir);\n  if (existsSync(telemetryPath)) {\n    unlinkSync(telemetryPath);\n  }\n}\n","/**\n * Enhanced analysis of blocked steps for AI-assisted fixing\n */\n\nimport { findNearestPattern, type NearestPatternResult, type PatternDefinition } from './patternDistance.js';\nimport type { StepPattern } from './patterns.js';\n\nexport type StepCategory = 'navigation' | 'interaction' | 'assertion' | 'wait' | 'unknown';\n\nexport interface StepSuggestion {\n  priority: number;\n  text: string;\n  explanation: string;\n  confidence: number;\n}\n\nexport interface BlockedStepAnalysis {\n  step: string;\n  reason: string;\n  suggestions: StepSuggestion[];\n  nearestPattern?: NearestPatternResult;\n  machineHintSuggestion?: string;\n  category: StepCategory;\n}\n\n/**\n * Categorize a step based on its text\n */\nexport function categorizeStep(text: string): StepCategory {\n  const lowerText = text.toLowerCase();\n\n  if (lowerText.includes('navigate') || lowerText.includes('go to') ||\n      lowerText.includes('open') || lowerText.includes('visit')) {\n    return 'navigation';\n  }\n\n  if (lowerText.includes('click') || lowerText.includes('fill') ||\n      lowerText.includes('enter') || lowerText.includes('type') ||\n      lowerText.includes('select') || lowerText.includes('check') ||\n      lowerText.includes('press')) {\n    return 'interaction';\n  }\n\n  if (lowerText.includes('see') || lowerText.includes('visible') ||\n      lowerText.includes('verify') || lowerText.includes('assert') ||\n      lowerText.includes('confirm') || lowerText.includes('should') ||\n      lowerText.includes('expect')) {\n    return 'assertion';\n  }\n\n  if (lowerText.includes('wait') || lowerText.includes('load') ||\n      lowerText.includes('until') || lowerText.includes('appear')) {\n    return 'wait';\n  }\n\n  return 'unknown';\n}\n\n/**\n * Infer a machine hint from step text\n */\nexport function inferMachineHint(text: string): string | undefined {\n  const lowerText = text.toLowerCase();\n\n  // Extract element name from quotes\n  const quotedMatch = text.match(/['\"]([^'\"]+)['\"]/);\n  const elementName = quotedMatch?.[1];\n\n  if (!elementName) return undefined;\n\n  // Suggest hint based on context (check more specific terms first)\n  if (lowerText.includes('link')) {\n    return `(role=link, name=${elementName})`;\n  }\n\n  if (lowerText.includes('button') || lowerText.includes('click')) {\n    return `(role=button, name=${elementName})`;\n  }\n\n  if (lowerText.includes('field') || lowerText.includes('input') ||\n      lowerText.includes('enter') || lowerText.includes('type')) {\n    return `(role=textbox, name=${elementName})`;\n  }\n\n  if (lowerText.includes('heading')) {\n    return `(role=heading, name=${elementName})`;\n  }\n\n  if (lowerText.includes('checkbox')) {\n    return `(role=checkbox, name=${elementName})`;\n  }\n\n  return `(text=${elementName})`;\n}\n\n/**\n * Get suggestions for navigation steps\n */\nexport function getNavigationSuggestions(text: string): StepSuggestion[] {\n  const suggestions: StepSuggestion[] = [];\n  const urlMatch = text.match(/\\/[a-zA-Z0-9/_-]+/);\n\n  if (urlMatch) {\n    suggestions.push({\n      priority: 1,\n      text: `User navigates to ${urlMatch[0]}`,\n      explanation: 'Standard navigation pattern',\n      confidence: 0.9,\n    });\n  } else {\n    suggestions.push({\n      priority: 1,\n      text: 'User navigates to /[path]',\n      explanation: 'Add explicit URL path',\n      confidence: 0.5,\n    });\n  }\n\n  return suggestions;\n}\n\n/**\n * Get suggestions for interaction steps\n */\nexport function getInteractionSuggestions(text: string): StepSuggestion[] {\n  const suggestions: StepSuggestion[] = [];\n  const quotedMatch = text.match(/['\"]([^'\"]+)['\"]/);\n  const elementName = quotedMatch?.[1] || '[element]';\n  const lowerText = text.toLowerCase();\n\n  if (lowerText.includes('click')) {\n    suggestions.push({\n      priority: 1,\n      text: `User clicks '${elementName}' button \\`(role=button, name=${elementName})\\``,\n      explanation: 'Add role=button locator hint',\n      confidence: 0.85,\n    });\n  }\n\n  if (lowerText.includes('fill') || lowerText.includes('enter') ||\n      lowerText.includes('type')) {\n    // Try to extract value being entered\n    const valueMatch = text.match(/['\"]([^'\"]+)['\"]/);\n    const value = valueMatch?.[1] || 'value';\n    suggestions.push({\n      priority: 1,\n      text: `User enters '${value}' in '${elementName}' field \\`(role=textbox, name=${elementName})\\``,\n      explanation: 'Add role=textbox locator hint',\n      confidence: 0.85,\n    });\n  }\n\n  return suggestions;\n}\n\n/**\n * Get suggestions for assertion steps\n */\nexport function getAssertionSuggestions(text: string): StepSuggestion[] {\n  const suggestions: StepSuggestion[] = [];\n  const quotedMatch = text.match(/['\"]([^'\"]+)['\"]/);\n  const content = quotedMatch?.[1] || '[content]';\n\n  suggestions.push({\n    priority: 1,\n    text: `User should see '${content}' \\`(text=${content})\\``,\n    explanation: 'Standard visibility assertion',\n    confidence: 0.8,\n  });\n\n  suggestions.push({\n    priority: 2,\n    text: `**Assert**: '${content}' is visible \\`(role=heading, name=${content})\\``,\n    explanation: 'Structured assertion format with heading role',\n    confidence: 0.7,\n  });\n\n  return suggestions;\n}\n\n/**\n * Get suggestions for wait steps\n */\nexport function getWaitSuggestions(_text: string): StepSuggestion[] {\n  const suggestions: StepSuggestion[] = [];\n\n  suggestions.push({\n    priority: 1,\n    text: 'Wait for network idle `(signal=networkidle)`',\n    explanation: 'Standard network wait pattern',\n    confidence: 0.8,\n  });\n\n  suggestions.push({\n    priority: 2,\n    text: 'Wait for page to load `(signal=load)`',\n    explanation: 'Wait for load event',\n    confidence: 0.7,\n  });\n\n  return suggestions;\n}\n\n/**\n * Get generic suggestions for unknown step categories\n */\nexport function getGenericSuggestions(text: string): StepSuggestion[] {\n  return [{\n    priority: 1,\n    text: `**Action**: ${text}`,\n    explanation: 'Use structured format with Action prefix',\n    confidence: 0.5,\n  }];\n}\n\n/**\n * Analyze a blocked step and generate suggestions\n */\nexport function analyzeBlockedStep(\n  step: string,\n  reason: string,\n  patterns?: Map<string, PatternDefinition> | StepPattern[]\n): BlockedStepAnalysis {\n  const category = categorizeStep(step);\n\n  const analysis: BlockedStepAnalysis = {\n    step,\n    reason,\n    suggestions: [],\n    category,\n  };\n\n  // Find nearest pattern if patterns provided\n  if (patterns) {\n    const nearest = findNearestPattern(step, patterns);\n    if (nearest) {\n      analysis.nearestPattern = nearest;\n    }\n  }\n\n  // Generate category-specific suggestions\n  switch (category) {\n    case 'navigation':\n      analysis.suggestions = getNavigationSuggestions(step);\n      break;\n    case 'interaction':\n      analysis.suggestions = getInteractionSuggestions(step);\n      analysis.machineHintSuggestion = inferMachineHint(step);\n      break;\n    case 'assertion':\n      analysis.suggestions = getAssertionSuggestions(step);\n      break;\n    case 'wait':\n      analysis.suggestions = getWaitSuggestions(step);\n      break;\n    default:\n      analysis.suggestions = getGenericSuggestions(step);\n  }\n\n  return analysis;\n}\n\n/**\n * Format a blocked step analysis for console output\n */\nexport function formatBlockedStepAnalysis(analysis: BlockedStepAnalysis): string {\n  const lines: string[] = [];\n\n  lines.push(`\\n  Step: \"${analysis.step}\"`);\n  lines.push(`  Category: ${analysis.category}`);\n  lines.push(`  Reason: ${analysis.reason}`);\n\n  if (analysis.nearestPattern) {\n    lines.push(`  Nearest pattern: ${analysis.nearestPattern.name}`);\n    lines.push(`  Example that works: \"${analysis.nearestPattern.exampleMatch}\"`);\n    lines.push(`  Why it didn't match: ${analysis.nearestPattern.mismatchReason}`);\n  }\n\n  lines.push('  Suggestions:');\n  for (const suggestion of analysis.suggestions) {\n    lines.push(`    ${suggestion.priority}. ${suggestion.text}`);\n    lines.push(`       (${suggestion.explanation}, confidence: ${(suggestion.confidence * 100).toFixed(0)}%)`);\n  }\n\n  if (analysis.machineHintSuggestion) {\n    lines.push(`  Suggested hint: ${analysis.machineHintSuggestion}`);\n  }\n\n  return lines.join('\\n');\n}\n","/**\n * CLI Generate Command - Generate Playwright tests from Journey files\n * @see T094 - Create CLI entry point for generation\n * @see research/2026-01-23_llkb-autogen-integration-specification.md (LLKB integration)\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md (telemetry)\n */\nimport { parseArgs } from 'node:util';\nimport { writeFileSync, mkdirSync, existsSync, readFileSync } from 'node:fs';\nimport { join, dirname, basename, resolve, relative } from 'node:path';\nimport fg from 'fast-glob';\nimport { generateJourneyTests, type GenerateJourneyTestsOptions } from '../index.js';\nimport { loadConfigs } from '../config/loader.js';\nimport { loadExtendedGlossary, getGlossaryStats } from '../mapping/glossary.js';\nimport { recordBlockedStep } from '../mapping/telemetry.js';\nimport { analyzeBlockedStep, formatBlockedStepAnalysis } from '../mapping/blockedStepAnalysis.js';\nimport { updatePipelineState, loadPipelineState, canProceedTo } from '../pipeline/state.js';\nimport { getTelemetry } from '../shared/telemetry.js';\nimport { recordPatternSuccess } from '../llkb/patternExtension.js';\nimport { plannedActionToIRPrimitive } from '../mapping/plannedActionAdapter.js';\nimport type { PlanOutput, TestPlan, PlannedStep } from './plan.js';\n\n// \n// PLAN-BASED GENERATION\n// \n\ninterface GenerateOptions {\n  output?: string;\n  modules: boolean;\n  config?: string;\n  'dry-run': boolean;\n  quiet: boolean;\n  'llkb-config'?: string;\n  'llkb-glossary'?: string;\n  'no-llkb': boolean;\n}\n\n/**\n * Generate tests from a plan file\n */\nasync function runGenerateFromPlan(\n  planPath: string,\n  journeyFilter: string | undefined,\n  options: GenerateOptions\n): Promise<void> {\n  const quiet = options.quiet;\n  const dryRun = options['dry-run'];\n  const outputDir = options.output || './tests/generated';\n\n  // Load plan\n  let planOutput: PlanOutput;\n  try {\n    planOutput = JSON.parse(readFileSync(planPath, 'utf-8'));\n  } catch (e) {\n    console.error(`Error: Failed to parse plan file: ${e}`);\n    process.exit(1);\n  }\n\n  // Filter plans if journey specified\n  let plans = planOutput.plans || [];\n  if (journeyFilter) {\n    plans = plans.filter(p => p.journeyId === journeyFilter);\n    if (plans.length === 0) {\n      console.error(`Error: No plans found for journey \"${journeyFilter}\"`);\n      process.exit(1);\n    }\n  }\n\n  if (!quiet) {\n    console.log(`Generating tests from plan: ${plans.length} journey(s)`);\n  }\n\n  // Load LLKB configs/glossary if provided\n  await loadLlkbResources(options, quiet);\n\n  // Generate from each plan\n  const allTests: { filename: string; code: string }[] = [];\n  const allModules: { filename: string; code: string }[] = [];\n  const allWarnings: string[] = [];\n  const allErrors: string[] = [];\n\n  // Track LLKB learning stats\n  let totalLlkbRecorded = 0;\n  let totalLlkbSkipped = 0;\n  const useLlkb = !options['no-llkb'];\n\n  for (const plan of plans) {\n    if (!quiet) {\n      console.log(`  Processing: ${plan.journeyId}`);\n    }\n\n    // Prefer generating from plan steps when available (already structured with actions)\n    // This avoids re-parsing markdown and potentially losing step information\n    if (plan.steps && plan.steps.length > 0 && plan.steps.some(s => s.action)) {\n      // Plan has structured steps with actions - use direct generation\n      const code = generateCodeFromPlan(plan);\n      allTests.push({\n        filename: `${plan.journeyId.toLowerCase()}.spec.ts`,\n        code,\n      });\n\n      // Record successful patterns to LLKB for learning (if enabled)\n      if (useLlkb && !dryRun) {\n        const llkbResult = recordLlkbLearning(plan, { quiet });\n        totalLlkbRecorded += llkbResult.recorded;\n        totalLlkbSkipped += llkbResult.skipped;\n      }\n    } else if (plan.journeyPath && existsSync(plan.journeyPath)) {\n      // Fallback: re-parse journey file if plan lacks structured steps\n      const genOptions: GenerateJourneyTestsOptions = {\n        journeys: [plan.journeyPath],\n        isFilePaths: true,\n        outputDir,\n        generateModules: options.modules,\n      };\n\n      if (options.config) {\n        genOptions.config = options.config;\n      }\n\n      const result = await generateJourneyTests(genOptions);\n      allTests.push(...result.tests);\n      allModules.push(...result.modules);\n      allWarnings.push(...result.warnings);\n      allErrors.push(...result.errors);\n    } else {\n      // No steps and no journey path - generate empty stub\n      const code = generateCodeFromPlan(plan);\n      allTests.push({\n        filename: `${plan.journeyId.toLowerCase()}.spec.ts`,\n        code,\n      });\n    }\n  }\n\n  // Write files\n  if (!dryRun) {\n    if (!existsSync(outputDir)) {\n      mkdirSync(outputDir, { recursive: true });\n    }\n\n    for (const test of allTests) {\n      // SECURITY: Validate path to prevent traversal attacks\n      const filePath = validateOutputPath(outputDir, test.filename);\n      mkdirSync(dirname(filePath), { recursive: true });\n      writeFileSync(filePath, test.code, 'utf-8');\n      if (!quiet) {\n        console.log(`Generated: ${filePath}`);\n      }\n    }\n\n    for (const mod of allModules) {\n      // SECURITY: Validate path to prevent traversal attacks\n      const filePath = validateOutputPath(outputDir, join('modules', mod.filename));\n      mkdirSync(dirname(filePath), { recursive: true });\n      writeFileSync(filePath, mod.code, 'utf-8');\n      if (!quiet) {\n        console.log(`Generated: ${filePath}`);\n      }\n    }\n  } else {\n    if (!quiet) {\n      console.log('\\n[Dry run] Would generate:');\n      for (const test of allTests) {\n        console.log(`  - ${join(outputDir, test.filename)}`);\n      }\n      for (const mod of allModules) {\n        console.log(`  - ${join(outputDir, 'modules', mod.filename)}`);\n      }\n    }\n  }\n\n  // Summary\n  if (!quiet) {\n    console.log(`\\nSummary:`);\n    console.log(`  Tests: ${allTests.length}`);\n    console.log(`  Modules: ${allModules.length}`);\n    console.log(`  Errors: ${allErrors.length}`);\n    console.log(`  Warnings: ${allWarnings.length}`);\n    if (useLlkb && (totalLlkbRecorded > 0 || totalLlkbSkipped > 0)) {\n      console.log(`  LLKB patterns learned: ${totalLlkbRecorded} (${totalLlkbSkipped} skipped)`);\n    }\n  }\n\n  if (allErrors.length > 0) {\n    console.error('\\nErrors:');\n    for (const error of allErrors) {\n      console.error(`  - ${error}`);\n    }\n    process.exit(1);\n  }\n}\n\n/**\n * Record successful pattern matches to LLKB for learning\n * This enables the system to learn from successful generations\n */\nfunction recordLlkbLearning(\n  plan: TestPlan,\n  options: { llkbRoot?: string; quiet?: boolean } = {}\n): { recorded: number; skipped: number } {\n  let recorded = 0;\n  let skipped = 0;\n\n  for (const step of plan.steps) {\n    // Skip custom/TODO actions - these weren't successfully matched\n    if (step.action.type === 'custom') {\n      skipped++;\n      continue;\n    }\n\n    // Convert the PlannedAction back to an IR Primitive for recording\n    const primitive = plannedActionToIRPrimitive(step.action);\n    if (!primitive) {\n      skipped++;\n      continue;\n    }\n\n    try {\n      // Record the successful pattern match\n      recordPatternSuccess(\n        step.description,\n        primitive,\n        plan.journeyId,\n        { llkbRoot: options.llkbRoot }\n      );\n      recorded++;\n    } catch (err) {\n      // LLKB recording is non-fatal - continue generation\n      if (!options.quiet) {\n        console.warn(`  Warning: Failed to record LLKB pattern: ${err}`);\n      }\n      skipped++;\n    }\n  }\n\n  return { recorded, skipped };\n}\n\n/**\n * Generate test code directly from a plan\n * This is used when the orchestrator creates plans without journey files\n */\nfunction generateCodeFromPlan(plan: TestPlan): string {\n  const imports = plan.imports.join(', ');\n\n  // Ensure 'page' is always included in fixtures (required for most Playwright operations)\n  // This prevents broken tests when plan.fixtures doesn't include 'page'\n  const fixtureSet = new Set(plan.fixtures);\n  if (fixtureSet.size > 0 && !fixtureSet.has('page')) {\n    fixtureSet.add('page');\n  }\n  const fixtureList = fixtureSet.size > 0 ? Array.from(fixtureSet) : ['page'];\n  const fixtures = `{ ${fixtureList.join(', ')} }`;\n\n  const steps = plan.steps.map((step, idx) => {\n    const code = generateActionCode(step.action, step.waitCondition);\n    return `    // Step ${idx + 1}: ${step.description}\\n${code}`;\n  }).join('\\n\\n');\n\n  return `/**\n * @journey ${plan.journeyId}\n * @generated ${plan.createdAt}\n * @strategy ${plan.strategy}\n */\nimport { ${imports} } from '@playwright/test';\n\ntest.describe('${plan.journeyId}', () => {\n  test('should complete journey', async (${fixtures}) => {\n${steps}\n  });\n});\n`;\n}\n\n/**\n * Escape string for use in generated code (single-quoted strings)\n *\n * SECURITY: Escapes all characters that could break out of single-quoted strings\n * or enable code injection:\n * - Backslash: literal backslashes\n * - Single quote: string delimiter\n * - Backtick: template literal delimiter (prevents ${} injection)\n * - Dollar sign: prevents ${} template injection even outside backticks\n * - Newline/carriage return: prevents multi-line injection\n */\nfunction escapeStringForCode(str: string): string {\n  return str\n    .replace(/\\\\/g, '\\\\\\\\')       // Escape backslashes first\n    .replace(/'/g, \"\\\\'\")          // Escape single quotes\n    .replace(/`/g, '\\\\`')          // Escape backticks (template literals)\n    .replace(/\\$/g, '\\\\$')         // Escape dollar signs (prevent ${} injection)\n    .replace(/\\n/g, '\\\\n')         // Escape newlines\n    .replace(/\\r/g, '\\\\r');        // Escape carriage returns\n}\n\n/**\n * Dangerous URL schemes that could enable code execution or data exfiltration\n */\nconst DANGEROUS_URL_SCHEMES = [\n  'javascript:',\n  'data:',\n  'vbscript:',\n  'file:',\n];\n\n/**\n * Validate that a file path stays within the output directory\n *\n * SECURITY: Prevents path traversal attacks (e.g., ../../../etc/passwd)\n *\n * @throws Error if path escapes the output directory\n */\nfunction validateOutputPath(outputDir: string, filename: string): string {\n\n  // Resolve both paths to absolute\n  const resolvedOutput = resolve(outputDir);\n  const resolvedFile = resolve(outputDir, filename);\n\n  // Check that the file path starts with the output directory\n  const relativePath = relative(resolvedOutput, resolvedFile);\n\n  // If relative path starts with \"..\" or is absolute, it's escaping\n  if (relativePath.startsWith('..') || resolve(relativePath) === relativePath) {\n    throw new Error(`Security: Path traversal detected in filename \"${filename}\"`);\n  }\n\n  return resolvedFile;\n}\n\n/**\n * Validate and sanitize a URL for use in navigation\n *\n * SECURITY: Blocks dangerous URL schemes that could enable:\n * - Code execution (javascript:, vbscript:)\n * - Data exfiltration (data:)\n * - Local file access (file:)\n *\n * @returns Sanitized URL or '/' if URL is dangerous\n */\nfunction sanitizeNavigationUrl(url: string): string {\n  const trimmedUrl = url.trim().toLowerCase();\n\n  for (const scheme of DANGEROUS_URL_SCHEMES) {\n    if (trimmedUrl.startsWith(scheme)) {\n      console.warn(`Security: Blocked dangerous URL scheme \"${scheme}\" - using \"/\" instead`);\n      return '/';\n    }\n  }\n\n  return url;\n}\n\n/**\n * Generate code for a planned action\n */\nfunction generateActionCode(action: PlannedStep['action'], waitCondition?: string): string {\n  const target = action.target || '';\n  const value = action.value || '';\n\n  switch (action.type) {\n    // Navigation\n    case 'navigate':\n      return `    await page.goto('${escapeStringForCode(sanitizeNavigationUrl(target || '/'))}');`;\n    case 'reload':\n      return `    await page.reload();`;\n    case 'goBack':\n      return `    await page.goBack();`;\n    case 'goForward':\n      return `    await page.goForward();`;\n\n    // Click interactions\n    case 'click':\n      return generateClickCode(target);\n    case 'dblclick':\n      return generateClickCode(target).replace('.click()', '.dblclick()');\n    case 'rightClick':\n      return generateClickCode(target).replace('.click()', \".click({ button: 'right' })\");\n\n    // Form interactions\n    case 'fill':\n      return generateFillCode(target, value);\n    case 'select':\n      return `    await page.getByLabel('${escapeStringForCode(target)}').selectOption('${escapeStringForCode(value)}');`;\n    case 'check':\n      return `    await page.getByLabel('${escapeStringForCode(target)}').check();`;\n    case 'uncheck':\n      return `    await page.getByLabel('${escapeStringForCode(target)}').uncheck();`;\n    case 'clear':\n      return `    await page.getByLabel('${escapeStringForCode(target)}').clear();`;\n    case 'upload':\n      const files = action.files?.map(f => `'${escapeStringForCode(f)}'`).join(', ') || '';\n      return `    await page.getByLabel('${escapeStringForCode(target)}').setInputFiles([${files}]);`;\n\n    // Other interactions\n    case 'press':\n      const key = action.key || 'Enter';\n      return `    await page.keyboard.press('${key}');`;\n    case 'hover':\n      return generateClickCode(target).replace('.click()', '.hover()');\n    case 'focus':\n      return `    await page.getByLabel('${escapeStringForCode(target)}').focus();`;\n\n    // Visibility assertions\n    case 'assert':\n      return generateAssertCode(target);\n    case 'assertHidden':\n      return `    await expect(page.getByText('${escapeStringForCode(target)}')).toBeHidden();`;\n\n    // Text/value assertions\n    case 'assertText':\n      return `    await expect(page.getByText('${escapeStringForCode(target)}')).toContainText('${escapeStringForCode(value)}');`;\n    case 'assertValue':\n      return `    await expect(page.getByLabel('${escapeStringForCode(target)}')).toHaveValue('${escapeStringForCode(value)}');`;\n\n    // State assertions\n    case 'assertChecked':\n      return `    await expect(page.getByLabel('${escapeStringForCode(target)}')).toBeChecked();`;\n    case 'assertEnabled':\n      return `    await expect(page.getByLabel('${escapeStringForCode(target)}')).toBeEnabled();`;\n    case 'assertDisabled':\n      return `    await expect(page.getByLabel('${escapeStringForCode(target)}')).toBeDisabled();`;\n    case 'assertCount':\n      const count = action.count ?? 1;\n      return `    await expect(page.getByText('${escapeStringForCode(target)}')).toHaveCount(${count});`;\n\n    // Page assertions\n    case 'assertURL':\n      return `    await expect(page).toHaveURL(/${escapeStringForCode(target).replace(/\\//g, '\\\\/')}/);`;\n    case 'assertTitle':\n      return `    await expect(page).toHaveTitle('${escapeStringForCode(target)}');`;\n\n    // Toast/notification assertions\n    case 'assertToast':\n      const toastType = action.toastType || 'info';\n      const message = value ? `.getByText('${escapeStringForCode(value)}')` : '';\n      return `    await expect(page.getByRole('alert')${message}).toBeVisible(); // ${toastType} toast`;\n\n    // Modal/alert handling\n    case 'dismissModal':\n      return `    await page.getByRole('dialog').getByRole('button', { name: /close|cancel|dismiss/i }).click();`;\n    case 'acceptAlert':\n      return `    page.once('dialog', dialog => dialog.accept());`;\n    case 'dismissAlert':\n      return `    page.once('dialog', dialog => dialog.dismiss());`;\n\n    // Wait actions\n    case 'wait':\n      return `    await page.waitForLoadState('${waitCondition || 'networkidle'}');`;\n    case 'waitForVisible':\n      return `    await page.getByText('${escapeStringForCode(target)}').waitFor({ state: 'visible' });`;\n    case 'waitForHidden':\n      return `    await page.getByText('${escapeStringForCode(target)}').waitFor({ state: 'hidden' });`;\n    case 'waitForURL':\n      return `    await page.waitForURL(/${escapeStringForCode(target).replace(/\\//g, '\\\\/')}/);`;\n    case 'waitForNetwork':\n      return `    await page.waitForLoadState('networkidle');`;\n\n    // Module calls\n    case 'callModule':\n      const module = action.module || 'unknown';\n      const method = action.method || 'run';\n      return `    // Module call: ${module}.${method}()\\n    // TODO: Implement module call or use fixture`;\n\n    // Custom/fallback\n    case 'custom':\n    default:\n      return `    // TODO: ${target}`;\n  }\n}\n\n/**\n * Generate click code based on target format\n * Supports: \"button:Name\", \"link:Name\", or plain selector/text\n */\nfunction generateClickCode(target: string): string {\n  // Handle \"button:Name\" format\n  if (target.startsWith('button:')) {\n    const name = target.slice(7);\n    return `    await page.getByRole('button', { name: '${escapeStringForCode(name)}' }).click();`;\n  }\n\n  // Handle \"link:Name\" format\n  if (target.startsWith('link:')) {\n    const name = target.slice(5);\n    return `    await page.getByRole('link', { name: '${escapeStringForCode(name)}' }).click();`;\n  }\n\n  // Handle \"checkbox:Name\" format\n  if (target.startsWith('checkbox:')) {\n    const name = target.slice(9);\n    return `    await page.getByLabel('${escapeStringForCode(name)}').click();`;\n  }\n\n  // Handle \"menu:Name\" format\n  if (target.startsWith('menu:')) {\n    const name = target.slice(5);\n    return `    await page.getByRole('menuitem', { name: '${escapeStringForCode(name)}' }).click();`;\n  }\n\n  // Handle \"tab:Name\" format\n  if (target.startsWith('tab:')) {\n    const name = target.slice(4);\n    return `    await page.getByRole('tab', { name: '${escapeStringForCode(name)}' }).click();`;\n  }\n\n  // Handle \"menuitem:Name\" format (actual ARIA role)\n  if (target.startsWith('menuitem:')) {\n    const name = target.slice(9);\n    return `    await page.getByRole('menuitem', { name: '${escapeStringForCode(name)}' }).click();`;\n  }\n\n  // Default: use getByText for text content\n  return `    await page.getByText('${escapeStringForCode(target)}').click();`;\n}\n\n/**\n * Generate fill code based on target format\n * Target is typically a field label\n */\nfunction generateFillCode(target: string, value: string): string {\n  // Handle \"placeholder:Name\" format\n  if (target.startsWith('placeholder:')) {\n    const placeholder = target.slice(12);\n    return `    await page.getByPlaceholder('${escapeStringForCode(placeholder)}').fill('${escapeStringForCode(value)}');`;\n  }\n\n  // Use getByLabel for labeled inputs (most accessible approach)\n  return `    await page.getByLabel('${escapeStringForCode(target)}').fill('${escapeStringForCode(value)}');`;\n}\n\n/**\n * Generate assertion code based on target\n */\nfunction generateAssertCode(target: string): string {\n  // Handle \"status:Name\" format for status role\n  if (target.startsWith('status:')) {\n    const name = target.slice(7);\n    return `    await expect(page.getByRole('status', { name: '${escapeStringForCode(name)}' })).toBeVisible();`;\n  }\n\n  // Check if target looks like a page name\n  const lowerTarget = target.toLowerCase();\n  if (lowerTarget.includes('page') || lowerTarget.includes('dashboard') || lowerTarget.includes('home')) {\n    // For page-level assertions, check for heading or main content\n    return `    await expect(page.getByRole('heading', { level: 1 })).toContainText('${escapeStringForCode(target)}');`;\n  }\n\n  // Default: check that the text is visible\n  return `    await expect(page.getByText('${escapeStringForCode(target)}')).toBeVisible();`;\n}\n\n/**\n * Load LLKB resources (config and glossary)\n */\nasync function loadLlkbResources(options: GenerateOptions, quiet: boolean): Promise<void> {\n  const configPaths: string[] = [];\n  if (options.config) {\n    configPaths.push(options.config);\n  }\n  if (options['llkb-config'] && !options['no-llkb']) {\n    configPaths.push(options['llkb-config']);\n  }\n\n  if (configPaths.length > 1) {\n    loadConfigs(configPaths);\n    if (!quiet) {\n      console.log(`Loaded ${configPaths.length} config file(s)`);\n    }\n  }\n\n  if (options['llkb-glossary'] && !options['no-llkb']) {\n    const glossaryResult = await loadExtendedGlossary(options['llkb-glossary']);\n    if (glossaryResult.loaded) {\n      if (!quiet) {\n        console.log(\n          `Loaded LLKB glossary: ${glossaryResult.entryCount} entries` +\n            (glossaryResult.exportedAt ? ` (exported: ${glossaryResult.exportedAt})` : '')\n        );\n      }\n    } else if (!quiet) {\n      console.warn(`Warning: Failed to load LLKB glossary: ${glossaryResult.error}`);\n    }\n  }\n}\n\nconst USAGE = `\nUsage: artk-autogen generate [options] [journey-files...]\n\nGenerate Playwright tests from plan or Journey markdown files.\n\nThis command supports two modes:\n1. Plan-based (recommended): Use --plan to generate from a prepared plan\n2. Direct (legacy): Pass journey files directly for backwards compatibility\n\nArguments:\n  journey-files    Journey file paths or glob patterns (legacy mode)\n\nOptions:\n  -o, --output <dir>       Output directory for generated files (default: ./tests/generated)\n  -m, --modules            Also generate module files\n  -c, --config <file>      Path to autogen config file\n  --plan <file>            Path to plan.json (default: .artk/autogen/plan.json if exists)\n  --journey <id>           Generate only for specific journey ID from plan\n  --dry-run                Preview generation without writing files\n  -q, --quiet              Suppress output except errors\n  -f, --force              Skip pipeline state validation\n  -h, --help               Show this help message\n\nLLKB Integration Options:\n  --llkb-config <file>     Path to LLKB-generated config file\n  --llkb-glossary <file>   Path to LLKB-generated glossary file\n  --no-llkb                Disable LLKB integration even if config enables it\n\nExamples:\n  # Plan-based generation (recommended)\n  artk-autogen generate --plan .artk/autogen/plan.json\n  artk-autogen generate --plan plan.json --journey JRN-0001\n\n  # Direct generation (legacy, still supported)\n  artk-autogen generate journeys/login.md\n  artk-autogen generate \"journeys/*.md\" -o tests/e2e -m\n  artk-autogen generate journeys/*.md --llkb-config autogen-llkb.config.yml\n`;\n\nexport async function runGenerate(args: string[]): Promise<void> {\n  const { values, positionals } = parseArgs({\n    args,\n    options: {\n      output: { type: 'string', short: 'o' },\n      modules: { type: 'boolean', short: 'm', default: false },\n      config: { type: 'string', short: 'c' },\n      plan: { type: 'string' },\n      journey: { type: 'string' },\n      'dry-run': { type: 'boolean', default: false },\n      quiet: { type: 'boolean', short: 'q', default: false },\n      force: { type: 'boolean', short: 'f', default: false },\n      help: { type: 'boolean', short: 'h', default: false },\n      // LLKB integration options\n      'llkb-config': { type: 'string' },\n      'llkb-glossary': { type: 'string' },\n      'no-llkb': { type: 'boolean', default: false },\n    },\n    allowPositionals: true,\n  });\n\n  if (values.help) {\n    console.log(USAGE);\n    return;\n  }\n\n  const quiet = values.quiet;\n  const force = values.force;\n\n  // Validate pipeline state transition (unless --force)\n  if (!force) {\n    const currentState = loadPipelineState();\n    const transition = canProceedTo(currentState, 'generated');\n    if (!transition.allowed) {\n      console.error(`Error: ${transition.reason}`);\n      console.error('Use --force to bypass state validation.');\n      process.exit(1);\n    }\n  } else if (!quiet) {\n    console.log('Warning: Bypassing pipeline state validation (--force)');\n  }\n\n  // Initialize telemetry\n  const telemetry = getTelemetry();\n  await telemetry.load();\n  const eventId = telemetry.trackCommandStart('generate');\n\n  // Check for plan-based generation\n  const planPath = values.plan;\n  const journeyFilter = values.journey;\n\n  // If no positionals and no plan specified, check for default plan\n  if (positionals.length === 0 && !planPath) {\n    // Try default plan location\n    const { getAutogenArtifact } = await import('../utils/paths.js');\n    const defaultPlanPath = getAutogenArtifact('plan');\n    if (existsSync(defaultPlanPath)) {\n      // Use plan-based generation\n      await runGenerateFromPlan(defaultPlanPath, journeyFilter, values);\n      // Track completion for plan-based generation\n      await updatePipelineState('generate', 'generated', true, { mode: 'plan' });\n      telemetry.trackCommandEnd(eventId, true, { mode: 'plan-based-default' });\n      await telemetry.save();\n      return;\n    }\n    console.error('Error: No journey files specified and no plan found');\n    console.log('Run \"artk-autogen analyze\" and \"artk-autogen plan\" first, or provide journey files.');\n    console.log(USAGE);\n    telemetry.trackCommandEnd(eventId, false, { error: 'no_input' });\n    await telemetry.save();\n    process.exit(1);\n  }\n\n  // If plan is explicitly specified, use plan-based generation\n  if (planPath) {\n    if (!existsSync(planPath)) {\n      console.error(`Error: Plan file not found: ${planPath}`);\n      telemetry.trackCommandEnd(eventId, false, { error: 'plan_not_found' });\n      await telemetry.save();\n      process.exit(1);\n    }\n    await runGenerateFromPlan(planPath, journeyFilter, values);\n    // Track completion for plan-based generation\n    await updatePipelineState('generate', 'generated', true, { mode: 'plan', planPath });\n    telemetry.trackCommandEnd(eventId, true, { mode: 'plan-based-explicit' });\n    await telemetry.save();\n    return;\n  }\n\n  const outputDir = values.output || './tests/generated';\n  const dryRun = values['dry-run'];\n\n  // Load configs (base + LLKB if provided)\n  const configPaths: string[] = [];\n  if (values.config) {\n    configPaths.push(values.config);\n  }\n  if (values['llkb-config'] && !values['no-llkb']) {\n    configPaths.push(values['llkb-config']);\n  }\n\n  // Load merged config if multiple paths provided\n  const configPath = values.config;\n  if (configPaths.length > 1) {\n    // When we have multiple configs, merge them and log\n    // The merged config includes LLKB settings\n    loadConfigs(configPaths);\n    if (!quiet) {\n      console.log(`Loaded ${configPaths.length} config file(s)`);\n    }\n  }\n\n  // Load LLKB glossary if provided\n  if (values['llkb-glossary'] && !values['no-llkb']) {\n    const glossaryResult = await loadExtendedGlossary(values['llkb-glossary']);\n    if (glossaryResult.loaded) {\n      if (!quiet) {\n        console.log(\n          `Loaded LLKB glossary: ${glossaryResult.entryCount} entries` +\n            (glossaryResult.exportedAt ? ` (exported: ${glossaryResult.exportedAt})` : '')\n        );\n      }\n    } else if (!quiet) {\n      console.warn(`Warning: Failed to load LLKB glossary: ${glossaryResult.error}`);\n    }\n  }\n\n  // Expand glob patterns\n  const journeyFiles = await fg(positionals, {\n    absolute: true,\n  });\n\n  if (journeyFiles.length === 0) {\n    console.error('Error: No journey files found matching the patterns');\n    telemetry.trackCommandEnd(eventId, false, { error: 'no_matching_files' });\n    await telemetry.save();\n    process.exit(1);\n  }\n\n  if (!quiet) {\n    console.log(`Found ${journeyFiles.length} journey file(s)`);\n    // Show LLKB stats if glossary is loaded\n    const stats = getGlossaryStats();\n    if (stats.extendedEntries > 0) {\n      console.log(`LLKB glossary active: ${stats.extendedEntries} extended entries`);\n    }\n  }\n\n  // Generate tests\n  const options: GenerateJourneyTestsOptions = {\n    journeys: journeyFiles,\n    isFilePaths: true,\n    outputDir,\n    generateModules: values.modules,\n  };\n\n  if (configPath) {\n    options.config = configPath;\n  }\n\n  const result = await generateJourneyTests(options);\n\n  // Analyze and record blocked steps for telemetry\n  // Extract blocked steps from warnings (they contain \"BLOCKED:\" prefix)\n  const blockedStepWarnings = result.warnings.filter((w) => w.includes('BLOCKED:'));\n  const blockedStepAnalyses: ReturnType<typeof analyzeBlockedStep>[] = [];\n\n  if (blockedStepWarnings.length > 0) {\n    if (!quiet) {\n      console.log(`\\n Blocked Step Analysis (${blockedStepWarnings.length} blocked steps):\\n`);\n    }\n\n    for (const warning of blockedStepWarnings) {\n      // Extract step text and reason from warning (format: \"BLOCKED: stepText - reason\")\n      const match = warning.match(/BLOCKED:\\s*(.+?)(?:\\s*-\\s*(.+))?$/);\n      if (match) {\n        const stepText = match[1] || warning;\n        const reason = match[2] || 'Unknown reason';\n\n        // Analyze the blocked step\n        const analysis = analyzeBlockedStep(stepText, reason);\n        blockedStepAnalyses.push(analysis);\n\n        // Record to telemetry (for pattern gap analysis)\n        const journeyId = journeyFiles.length === 1 ? basename(journeyFiles[0]!, '.md') : 'multiple';\n        recordBlockedStep({\n          journeyId,\n          stepText,\n          reason,\n          suggestedFix: analysis.suggestions[0]?.text,\n          nearestPattern: analysis.nearestPattern?.name,\n          nearestDistance: analysis.nearestPattern?.distance,\n        });\n\n        // Print analysis (unless quiet)\n        if (!quiet) {\n          console.log(formatBlockedStepAnalysis(analysis));\n          console.log();\n        }\n      }\n    }\n\n    // Write blocked step analysis JSON for AI consumption\n    // Write when ARTK_JSON_OUTPUT is set (even in dry-run) or when not in dry-run\n    if (process.env.ARTK_JSON_OUTPUT || !dryRun) {\n      const analysisPath = join(outputDir, 'blocked-steps-analysis.json');\n      mkdirSync(dirname(analysisPath), { recursive: true });\n      writeFileSync(analysisPath, JSON.stringify(blockedStepAnalyses, null, 2), 'utf-8');\n      if (!quiet) {\n        console.log(`\\n Blocked step analysis saved to: ${analysisPath}`);\n        console.log('   Use this file to auto-fix journey steps.\\n');\n      }\n    }\n  }\n\n  // Output results\n  if (result.errors.length > 0) {\n    console.error('\\nErrors:');\n    for (const error of result.errors) {\n      console.error(`  - ${error}`);\n    }\n  }\n\n  // Filter out blocked step warnings from display (already shown above)\n  const otherWarnings = result.warnings.filter((w) => !w.includes('BLOCKED:'));\n  if (otherWarnings.length > 0 && !quiet) {\n    console.warn('\\nWarnings:');\n    for (const warning of otherWarnings) {\n      console.warn(`  - ${warning}`);\n    }\n  }\n\n  // Write files (unless dry-run)\n  if (!dryRun) {\n    // Ensure output directory exists\n    if (!existsSync(outputDir)) {\n      mkdirSync(outputDir, { recursive: true });\n    }\n\n    // Write test files\n    for (const test of result.tests) {\n      // SECURITY: Validate path to prevent traversal attacks\n      const filePath = validateOutputPath(outputDir, test.filename);\n      mkdirSync(dirname(filePath), { recursive: true });\n      writeFileSync(filePath, test.code, 'utf-8');\n      if (!quiet) {\n        console.log(`Generated: ${filePath}`);\n      }\n    }\n\n    // Write module files\n    for (const mod of result.modules) {\n      // SECURITY: Validate path to prevent traversal attacks\n      const filePath = validateOutputPath(outputDir, join('modules', mod.filename));\n      mkdirSync(dirname(filePath), { recursive: true });\n      writeFileSync(filePath, mod.code, 'utf-8');\n      if (!quiet) {\n        console.log(`Generated: ${filePath}`);\n      }\n    }\n  } else {\n    if (!quiet) {\n      console.log('\\n[Dry run] Would generate:');\n      for (const test of result.tests) {\n        console.log(`  - ${join(outputDir, test.filename)}`);\n      }\n      for (const mod of result.modules) {\n        console.log(`  - ${join(outputDir, 'modules', mod.filename)}`);\n      }\n    }\n  }\n\n  // Summary\n  if (!quiet) {\n    console.log(`\\nSummary:`);\n    console.log(`  Tests: ${result.tests.length}`);\n    console.log(`  Modules: ${result.modules.length}`);\n    console.log(`  Blocked steps: ${blockedStepAnalyses.length}`);\n    console.log(`  Errors: ${result.errors.length}`);\n    console.log(`  Warnings: ${otherWarnings.length}`);\n\n    if (blockedStepAnalyses.length > 0) {\n      console.log(`\\n Run 'artk-autogen patterns gaps' to see pattern improvement suggestions.`);\n    }\n  }\n\n  // Update pipeline state\n  const success = result.errors.length === 0;\n  await updatePipelineState('generate', 'generated', success, {\n    testsGenerated: result.tests.length,\n    modulesGenerated: result.modules.length,\n    blockedSteps: blockedStepAnalyses.length,\n  });\n\n  // Track command completion\n  telemetry.trackCommandEnd(eventId, success, {\n    tests: result.tests.length,\n    modules: result.modules.length,\n    blockedSteps: blockedStepAnalyses.length,\n    errors: result.errors.length,\n    warnings: otherWarnings.length,\n    dryRun,\n  });\n  await telemetry.save();\n\n  // Exit with error if there were errors\n  if (result.errors.length > 0) {\n    process.exit(1);\n  }\n}\n","/**\n * Blocked Step Telemetry - Track steps that couldn't be mapped for pattern gap analysis\n * @see research/2026-02-03_multi-ai-debate-coverage-improvement.md\n */\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { join, dirname } from 'node:path';\nimport { getAutogenDir } from '../utils/paths.js';\n\n/**\n * A blocked step record for telemetry\n */\nexport interface BlockedStepRecord {\n  /** Original step text */\n  stepText: string;\n  /** Journey ID where step was encountered */\n  journeyId: string;\n  /** Error type if from test failure */\n  errorType?: string;\n  /** Timestamp when recorded */\n  timestamp: string;\n  /** Normalized form of the step (if available) */\n  normalizedText?: string;\n  /** Reason step was blocked */\n  reason?: string;\n  /** Source of the blocked step (generate, run, refine) */\n  source?: 'generate' | 'run' | 'refine';\n}\n\n/**\n * Aggregated pattern gap statistics\n */\nexport interface PatternGapStats {\n  /** Total blocked steps recorded */\n  totalBlocked: number;\n  /** Blocked steps by error type */\n  byErrorType: Record<string, number>;\n  /** Blocked steps by journey */\n  byJourney: Record<string, number>;\n  /** Top 20 most common blocked step patterns */\n  topPatterns: Array<{\n    pattern: string;\n    count: number;\n    errorTypes: string[];\n  }>;\n  /** Last updated timestamp */\n  updatedAt: string;\n}\n\n/**\n * Storage file for blocked step telemetry\n */\nconst BLOCKED_STEPS_FILE = 'blocked-steps-telemetry.json';\nconst MAX_RECORDS = 10000; // Keep last 10k records to avoid unbounded growth\n\n/**\n * In-memory buffer for batching writes\n */\nlet pendingRecords: BlockedStepRecord[] = [];\nlet flushTimeout: NodeJS.Timeout | null = null;\nconst FLUSH_INTERVAL_MS = 5000; // Flush every 5 seconds\n\n/**\n * Get the path to the blocked steps telemetry file\n */\nfunction getBlockedStepsFilePath(): string {\n  const autogenDir = getAutogenDir();\n  return join(autogenDir, BLOCKED_STEPS_FILE);\n}\n\n/**\n * Load existing blocked step records\n */\nexport function loadBlockedSteps(): BlockedStepRecord[] {\n  const filePath = getBlockedStepsFilePath();\n\n  if (!existsSync(filePath)) {\n    return [];\n  }\n\n  try {\n    const content = readFileSync(filePath, 'utf-8');\n    const data = JSON.parse(content);\n    return Array.isArray(data.records) ? data.records : [];\n  } catch {\n    return [];\n  }\n}\n\n/**\n * Save blocked step records to storage\n */\nfunction saveBlockedSteps(records: BlockedStepRecord[]): void {\n  const filePath = getBlockedStepsFilePath();\n  const dir = dirname(filePath);\n\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n\n  // Keep only the most recent records\n  const trimmedRecords = records.slice(-MAX_RECORDS);\n\n  const data = {\n    version: '1.0.0',\n    lastUpdated: new Date().toISOString(),\n    recordCount: trimmedRecords.length,\n    records: trimmedRecords,\n  };\n\n  writeFileSync(filePath, JSON.stringify(data, null, 2), 'utf-8');\n}\n\n/**\n * Flush pending records to storage\n */\nfunction flushPendingRecords(): void {\n  if (pendingRecords.length === 0) return;\n\n  const existing = loadBlockedSteps();\n  const combined = [...existing, ...pendingRecords];\n  saveBlockedSteps(combined);\n  pendingRecords = [];\n\n  if (flushTimeout) {\n    clearTimeout(flushTimeout);\n    flushTimeout = null;\n  }\n}\n\n/**\n * Track a blocked step for pattern gap analysis\n * Uses batched writes to avoid excessive disk I/O\n */\nexport function trackBlockedStep(record: BlockedStepRecord): void {\n  pendingRecords.push({\n    ...record,\n    timestamp: record.timestamp || new Date().toISOString(),\n  });\n\n  // Schedule flush if not already scheduled\n  if (!flushTimeout) {\n    flushTimeout = setTimeout(flushPendingRecords, FLUSH_INTERVAL_MS);\n  }\n\n  // Immediate flush if buffer is large\n  if (pendingRecords.length >= 100) {\n    flushPendingRecords();\n  }\n}\n\n/**\n * Force flush any pending records (call before process exit)\n */\nexport function flushBlockedStepTelemetry(): void {\n  flushPendingRecords();\n}\n\n/**\n * Normalize step text for pattern grouping\n */\nfunction normalizeForGrouping(text: string): string {\n  return text\n    .toLowerCase()\n    .trim()\n    // Remove specific values in quotes\n    .replace(/\"[^\"]+\"/g, '\"VALUE\"')\n    .replace(/'[^']+'/g, \"'VALUE'\")\n    // Remove numbers\n    .replace(/\\d+/g, 'N')\n    // Remove extra whitespace\n    .replace(/\\s+/g, ' ');\n}\n\n/**\n * Analyze blocked steps and generate pattern gap statistics\n */\nexport function analyzePatternGaps(): PatternGapStats {\n  // Flush any pending records first\n  flushPendingRecords();\n\n  const records = loadBlockedSteps();\n\n  // Count by error type\n  const byErrorType: Record<string, number> = {};\n  for (const record of records) {\n    const errorType = record.errorType || 'unknown';\n    byErrorType[errorType] = (byErrorType[errorType] || 0) + 1;\n  }\n\n  // Count by journey\n  const byJourney: Record<string, number> = {};\n  for (const record of records) {\n    byJourney[record.journeyId] = (byJourney[record.journeyId] || 0) + 1;\n  }\n\n  // Group by normalized pattern\n  const patternGroups = new Map<string, {\n    count: number;\n    errorTypes: Set<string>;\n    originalTexts: string[];\n  }>();\n\n  for (const record of records) {\n    const normalizedPattern = normalizeForGrouping(record.stepText);\n    const existing = patternGroups.get(normalizedPattern);\n\n    if (existing) {\n      existing.count++;\n      if (record.errorType) {\n        existing.errorTypes.add(record.errorType);\n      }\n      if (existing.originalTexts.length < 3) {\n        existing.originalTexts.push(record.stepText);\n      }\n    } else {\n      patternGroups.set(normalizedPattern, {\n        count: 1,\n        errorTypes: new Set(record.errorType ? [record.errorType] : []),\n        originalTexts: [record.stepText],\n      });\n    }\n  }\n\n  // Get top 20 patterns\n  const topPatterns = Array.from(patternGroups.entries())\n    .map(([pattern, data]) => ({\n      pattern,\n      count: data.count,\n      errorTypes: Array.from(data.errorTypes),\n      examples: data.originalTexts,\n    }))\n    .sort((a, b) => b.count - a.count)\n    .slice(0, 20);\n\n  return {\n    totalBlocked: records.length,\n    byErrorType,\n    byJourney,\n    topPatterns,\n    updatedAt: new Date().toISOString(),\n  };\n}\n\n/**\n * Clear all blocked step telemetry (for testing)\n */\nexport function clearBlockedStepTelemetry(): void {\n  const filePath = getBlockedStepsFilePath();\n  if (existsSync(filePath)) {\n    writeFileSync(filePath, JSON.stringify({ version: '1.0.0', records: [] }), 'utf-8');\n  }\n  pendingRecords = [];\n  if (flushTimeout) {\n    clearTimeout(flushTimeout);\n    flushTimeout = null;\n  }\n}\n\n/**\n * Get suggested patterns based on blocked step analysis\n * Returns regex patterns that could cover common blocked steps\n */\nexport function suggestNewPatterns(): Array<{\n  suggestedRegex: string;\n  coveredCount: number;\n  examples: string[];\n  confidence: number;\n}> {\n  const stats = analyzePatternGaps();\n  const suggestions: Array<{\n    suggestedRegex: string;\n    coveredCount: number;\n    examples: string[];\n    confidence: number;\n  }> = [];\n\n  for (const pattern of stats.topPatterns) {\n    // Only suggest patterns that appear frequently enough\n    if (pattern.count < 3) continue;\n\n    // Generate regex from the normalized pattern\n    const regex = pattern.pattern\n      .replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n      .replace(/\"VALUE\"/g, '\"([^\"]+)\"')\n      .replace(/'VALUE'/g, \"'([^']+)'\")\n      .replace(/N/g, '\\\\d+');\n\n    // Calculate confidence based on frequency and consistency\n    const confidence = Math.min(0.9, 0.5 + (pattern.count / 50));\n\n    suggestions.push({\n      suggestedRegex: `^${regex}$`,\n      coveredCount: pattern.count,\n      examples: (pattern as { examples?: string[] }).examples || [],\n      confidence,\n    });\n  }\n\n  return suggestions.slice(0, 10); // Top 10 suggestions\n}\n\n/**\n * Register exit handlers to flush pending telemetry\n * Ensures no data loss on process termination\n */\nfunction registerExitHandlers(): void {\n  let registered = false;\n\n  const handleExit = (): void => {\n    if (!registered) {\n      registered = true;\n      flushBlockedStepTelemetry();\n    }\n  };\n\n  // Handle normal exit\n  process.on('beforeExit', handleExit);\n\n  // Handle interrupt signals\n  process.on('SIGINT', () => {\n    handleExit();\n    process.exit(0);\n  });\n\n  process.on('SIGTERM', () => {\n    handleExit();\n    process.exit(0);\n  });\n}\n\n// Register exit handlers on module load\nregisterExitHandlers();\n","/**\n * CLI Run Command - Execute test via Playwright\n *\n * Part of the Hybrid Agentic architecture. Executes a generated test\n * and outputs structured results for the orchestrating LLM to analyze.\n *\n * @see research/2026-02-02_autogen-enhancement-implementation-plan.md\n */\nimport { parseArgs } from 'node:util';\nimport { spawn } from 'node:child_process';\nimport { readFileSync, writeFileSync, existsSync } from 'node:fs';\nimport { join, basename } from 'node:path';\nimport {\n  getHarnessRoot,\n  getAutogenArtifact,\n  ensureAutogenDir,\n  validatePath,\n  PathTraversalError,\n} from '../utils/paths.js';\nimport { updatePipelineState, loadPipelineState, canProceedTo } from '../pipeline/state.js';\nimport { getTelemetry } from '../shared/telemetry.js';\nimport { checkPlaywrightInstalled } from '../refinement/playwright-runner.js';\nimport { recordPatternFailure } from '../llkb/patternExtension.js';\nimport { trackBlockedStep } from '../shared/blocked-step-telemetry.js';\n\n// \n// TYPES\n// \n\nexport interface TestRunResult {\n  version: '1.0';\n  testPath: string;\n  journeyId?: string;\n  status: 'passed' | 'failed' | 'timeout' | 'error';\n  duration: number; // ms\n  errors: TestError[];\n  output: TestOutput;\n  artifacts: TestArtifacts;\n  executedAt: string;\n}\n\nexport interface TestError {\n  message: string;\n  type: ErrorType;\n  location?: ErrorLocation;\n  snippet?: string;\n  suggestion?: string;\n}\n\nexport type ErrorType =\n  | 'selector'      // Element not found\n  | 'timeout'       // Action timed out\n  | 'assertion'     // Assertion failed\n  | 'navigation'    // Page navigation failed\n  | 'typescript'    // TypeScript/syntax error\n  | 'runtime'       // Runtime error\n  | 'unknown';\n\nexport interface ErrorLocation {\n  file: string;\n  line: number;\n  column?: number;\n}\n\nexport interface TestOutput {\n  stdout: string;\n  stderr: string;\n  exitCode: number;\n}\n\nexport interface TestArtifacts {\n  screenshot?: string;\n  video?: string;\n  trace?: string;\n  report?: string;\n}\n\nexport interface RunOutput {\n  version: '1.0';\n  results: TestRunResult[];\n  summary: RunSummary;\n  harnessRoot: string;\n  executedAt: string;\n}\n\nexport interface RunSummary {\n  total: number;\n  passed: number;\n  failed: number;\n  timeout: number;\n  error: number;\n  totalDuration: number;\n}\n\n// \n// USAGE\n// \n\nconst USAGE = `\nUsage: artk-autogen run [options] <test-files...>\n\nExecute Playwright tests and output structured results.\n\nArguments:\n  test-files       Test file paths or glob patterns\n\nOptions:\n  -o, --output <path>    Output path for results.json (default: .artk/autogen/results.json)\n  --timeout <ms>         Test timeout in milliseconds (default: 30000)\n  --retries <n>          Number of retries for failed tests (default: 0)\n  --headed               Run in headed mode\n  --debug                Run with debug mode (pause on failure)\n  --json                 Output JSON to stdout instead of file\n  -q, --quiet            Suppress output except errors\n  -f, --force            Skip pipeline state validation\n  -h, --help             Show this help message\n\nExamples:\n  artk-autogen run tests/login.spec.ts\n  artk-autogen run \"tests/*.spec.ts\"\n  artk-autogen run tests/login.spec.ts --headed --debug\n  artk-autogen run tests/login.spec.ts --json\n`;\n\n// \n// ERROR PARSING\n// \n\n/**\n * Maximum length for truncated error message fragments.\n * Messages shorter than this ending with ':' are likely split artifacts\n * from the error block parsing (e.g., \"Error: locator.click:\").\n */\nconst TRUNCATED_MESSAGE_MAX_LENGTH = 80;\n\n// Export for testing\nexport function parseErrorType(message: string): ErrorType {\n  const lower = message.toLowerCase();\n\n  // Check for TypeScript/JavaScript errors FIRST (most specific)\n  // These are compilation/syntax issues\n  if (lower.includes('ts(') || lower.includes('error ts') ||\n      /\\berror\\s+ts\\d+\\b/.test(lower)) {\n    return 'typescript';\n  }\n  if (lower.includes('syntaxerror:') || lower.includes('syntax error')) {\n    return 'typescript';\n  }\n\n  // Check for assertion errors (expect, toHave, assertion)\n  // Must come before selector check because \"expect(locator)\" contains \"locator\"\n  if (lower.includes('expect(') || lower.includes('tohave') ||\n      lower.includes('tocontain') || lower.includes('tobe') ||\n      lower.includes('assertion') || lower.includes('expected string:') ||\n      lower.includes('received string:')) {\n    return 'assertion';\n  }\n\n  // Check for timeout errors\n  // \"Timeout\" followed by time is very specific\n  if (/timeout\\s+\\d+ms/i.test(message) || lower.includes('timeout exceeded') ||\n      lower.includes('exceeded time')) {\n    return 'timeout';\n  }\n\n  // Check for navigation errors\n  if (lower.includes('page.goto') || lower.includes('net::err') ||\n      lower.includes('navigation') || lower.includes('err_name_not_resolved') ||\n      lower.includes('err_connection')) {\n    return 'navigation';\n  }\n\n  // Check for selector/locator errors\n  // These typically have \"strict mode violation\" or \"resolved to 0 elements\"\n  if (lower.includes('strict mode violation') || lower.includes('resolved to 0 elements') ||\n      lower.includes('locator.click:') || lower.includes('locator.fill:') ||\n      (lower.includes('locator') && !lower.includes('expect'))) {\n    return 'selector';\n  }\n\n  // Check for TypeError (runtime JS error)\n  if (lower.includes('typeerror:') || lower.includes('referenceerror:')) {\n    return 'runtime';\n  }\n\n  // Generic error patterns last\n  if (lower.includes('error:') || lower.includes('exception')) {\n    return 'runtime';\n  }\n\n  return 'unknown';\n}\n\n// Export for testing\nexport function parseErrorLocation(message: string): ErrorLocation | undefined {\n  // Try to parse file:line:column format\n  const match = message.match(/([^\\s:]+\\.(ts|js)):(\\d+):?(\\d+)?/);\n  if (match && match[1] && match[3]) {\n    return {\n      file: match[1],\n      line: parseInt(match[3], 10),\n      column: match[4] ? parseInt(match[4], 10) : undefined,\n    };\n  }\n  return undefined;\n}\n\n// Export for testing\nexport function suggestFix(errorType: ErrorType, message: string): string | undefined {\n  switch (errorType) {\n    case 'selector':\n      if (message.includes('locator')) {\n        return 'Check selector - element may not exist, have different selector, or need explicit wait';\n      }\n      return 'Element not found - verify selector or add explicit wait';\n\n    case 'timeout':\n      return 'Increase timeout or check if element/action is correct';\n\n    case 'assertion':\n      return 'Check expected vs actual value - may need to adjust assertion or fix test data';\n\n    case 'navigation':\n      return 'Check URL is correct and accessible - may need auth or network configuration';\n\n    case 'typescript':\n      return 'Fix TypeScript syntax error before re-running';\n\n    case 'runtime':\n      return 'Check test logic and error stack trace for root cause';\n\n    default:\n      return undefined;\n  }\n}\n\n// Export for testing\nexport function parseErrors(stdout: string, stderr: string): TestError[] {\n  const errors: TestError[] = [];\n  const combined = `${stdout}\\n${stderr}`;\n\n  // Parse Playwright error format - include TypeScript error patterns (lowercase \"error TS\")\n  const errorBlocks = combined.split(/(?=Error:||FAILED|AssertionError|\\berror TS\\d+)/);\n\n  for (const block of errorBlocks) {\n    if (!block.trim() || block.length < 20) continue;\n\n    const lowerBlock = block.toLowerCase();\n\n    // Skip non-error blocks - case insensitive check for \"error\"\n    if (!lowerBlock.includes('error') && !block.includes('') && !lowerBlock.includes('failed')) {\n      continue;\n    }\n\n    const lines = block.split('\\n');\n\n    // Extract error message - use more lines for better context\n    const message = lines.slice(0, 5).join(' ').trim().substring(0, 500);\n\n    if (!message) continue;\n\n    const errorType = parseErrorType(message);\n    const location = parseErrorLocation(block);\n\n    // Extract code snippet if available\n    const snippetMatch = block.match(/>\\s*\\d+\\s*\\|(.+)/);\n    const snippet = snippetMatch?.[1]?.trim();\n\n    // Skip truncated blocks that appear to be artifacts of aggressive splitting.\n    // A truncated block typically:\n    // - Has no location and no snippet (no useful context)\n    // - Is very short and ends with a colon (incomplete message like \"Error: locator.click:\")\n    // We preserve the more complete block that contains the actual error details.\n    // Note: We don't check errorType here because even known error types can appear\n    // as truncated fragments (e.g., \"Error: locator.click:\" is split from the full message).\n    if (!location && !snippet) {\n      const trimmedMsg = message.trim();\n      // Skip if message is clearly incomplete (ends with : and is short)\n      // This catches split artifacts like \"Error: locator.click:\"\n      if (trimmedMsg.endsWith(':') && trimmedMsg.length < TRUNCATED_MESSAGE_MAX_LENGTH) {\n        continue;\n      }\n    }\n\n    errors.push({\n      message,\n      type: errorType,\n      location,\n      snippet,\n      suggestion: suggestFix(errorType, message),\n    });\n  }\n\n  return errors;\n}\n\n// \n// PLAYWRIGHT RUNNER\n// \n\nasync function runPlaywrightTest(\n  testPath: string,\n  options: {\n    timeout: number;\n    retries: number;\n    headed: boolean;\n    debug: boolean;\n  }\n): Promise<TestRunResult> {\n  const harnessRoot = getHarnessRoot();\n  const startTime = Date.now();\n\n  // Build playwright command\n  const args = [\n    'playwright', 'test',\n    testPath,\n    '--reporter=list',\n    `--timeout=${options.timeout}`,\n    `--retries=${options.retries}`,\n  ];\n\n  if (options.headed) {\n    args.push('--headed');\n  }\n  if (options.debug) {\n    args.push('--debug');\n  }\n\n  return new Promise((resolve) => {\n    let stdout = '';\n    let stderr = '';\n\n    // SECURITY: shell: false (default) prevents command injection via test paths\n    // Node.js v14.18+ handles .cmd/.bat files on Windows automatically\n    const proc = spawn('npx', args, {\n      cwd: harnessRoot,\n      env: {\n        ...process.env,\n        // Force color output for better error parsing\n        FORCE_COLOR: '1',\n      },\n    });\n\n    proc.stdout.on('data', (data) => {\n      stdout += data.toString();\n    });\n\n    proc.stderr.on('data', (data) => {\n      stderr += data.toString();\n    });\n\n    proc.on('close', (code) => {\n      const duration = Date.now() - startTime;\n      const exitCode = code ?? 1;\n\n      // Determine status\n      let status: TestRunResult['status'] = 'passed';\n      if (exitCode !== 0) {\n        if (stdout.includes('timeout') || stderr.includes('timeout')) {\n          status = 'timeout';\n        } else if (stderr.includes('Error:') || stdout.includes('FAILED')) {\n          status = 'failed';\n        } else {\n          status = 'error';\n        }\n      }\n\n      // Parse errors\n      const errors = status !== 'passed' ? parseErrors(stdout, stderr) : [];\n\n      // Find artifacts\n      const artifacts: TestArtifacts = {};\n      const testResultsDir = join(harnessRoot, 'test-results');\n      const testName = basename(testPath, '.spec.ts');\n\n      // Check for common artifact locations\n      const possibleScreenshot = join(testResultsDir, testName, 'test-failed-1.png');\n      if (existsSync(possibleScreenshot)) {\n        artifacts.screenshot = possibleScreenshot;\n      }\n\n      const possibleTrace = join(testResultsDir, testName, 'trace.zip');\n      if (existsSync(possibleTrace)) {\n        artifacts.trace = possibleTrace;\n      }\n\n      // Extract journey ID from test file if possible\n      let journeyId: string | undefined;\n      try {\n        const testContent = readFileSync(testPath, 'utf-8');\n        const journeyMatch = testContent.match(/@journey\\s+(\\S+)/);\n        if (journeyMatch) {\n          journeyId = journeyMatch[1];\n        }\n      } catch {\n        // Ignore read errors\n      }\n\n      // Truncate output with indicator if too long\n      // Uses UTF-8 safe truncation to avoid splitting surrogate pairs (emoji, etc.)\n      const MAX_OUTPUT_SIZE = 10000;\n      const truncateWithIndicator = (text: string, name: string): string => {\n        if (text.length <= MAX_OUTPUT_SIZE) return text;\n        // Find a safe truncation point that doesn't split a surrogate pair\n        // Surrogate pairs: high surrogate (0xD800-0xDBFF) followed by low surrogate (0xDC00-0xDFFF)\n        let truncateAt = MAX_OUTPUT_SIZE;\n        const code = text.charCodeAt(truncateAt - 1);\n        // If we're about to cut in the middle of a surrogate pair, back up one character\n        if (code >= 0xD800 && code <= 0xDBFF) {\n          truncateAt--;\n        }\n        const truncated = text.slice(0, truncateAt);\n        return `${truncated}\\n\\n[${name} TRUNCATED - ${text.length - truncateAt} more characters]`;\n      };\n\n      resolve({\n        version: '1.0',\n        testPath,\n        journeyId,\n        status,\n        duration,\n        errors,\n        output: {\n          stdout: truncateWithIndicator(stdout, 'STDOUT'),\n          stderr: truncateWithIndicator(stderr, 'STDERR'),\n          exitCode,\n        },\n        artifacts,\n        executedAt: new Date().toISOString(),\n      });\n    });\n\n    proc.on('error', (err) => {\n      resolve({\n        version: '1.0',\n        testPath,\n        status: 'error',\n        duration: Date.now() - startTime,\n        errors: [{\n          message: `Failed to spawn playwright: ${err.message}`,\n          type: 'runtime',\n        }],\n        output: {\n          stdout,\n          stderr,\n          exitCode: 1,\n        },\n        artifacts: {},\n        executedAt: new Date().toISOString(),\n      });\n    });\n  });\n}\n\n// \n// MAIN COMMAND\n// \n\nexport async function runRun(args: string[]): Promise<void> {\n  const { values, positionals } = parseArgs({\n    args,\n    options: {\n      output: { type: 'string', short: 'o' },\n      timeout: { type: 'string', default: '30000' },\n      retries: { type: 'string', default: '0' },\n      headed: { type: 'boolean', default: false },\n      debug: { type: 'boolean', default: false },\n      json: { type: 'boolean', default: false },\n      quiet: { type: 'boolean', short: 'q', default: false },\n      force: { type: 'boolean', short: 'f', default: false },\n      help: { type: 'boolean', short: 'h', default: false },\n    },\n    allowPositionals: true,\n  });\n\n  if (values.help) {\n    console.log(USAGE);\n    return;\n  }\n\n  if (positionals.length === 0) {\n    console.error('Error: No test files specified');\n    console.log(USAGE);\n    process.exit(1);\n  }\n\n  const quiet = values.quiet;\n  const outputJson = values.json;\n  const force = values.force;\n\n  // Validate pipeline state transition (unless --force)\n  if (!force) {\n    const currentState = await loadPipelineState();\n    const transition = canProceedTo(currentState, 'tested');\n    if (!transition.allowed) {\n      console.error(`Error: ${transition.reason}`);\n      console.error('Use --force to bypass state validation.');\n      process.exit(1);\n    }\n  } else if (!quiet && !outputJson) {\n    console.log('Warning: Bypassing pipeline state validation (--force)');\n  }\n\n  // Validate timeout and retries\n  const timeout = parseInt(values.timeout, 10);\n  const retries = parseInt(values.retries, 10);\n\n  if (isNaN(timeout) || timeout <= 0) {\n    console.error(`Error: Invalid timeout value \"${values.timeout}\". Must be a positive number.`);\n    process.exit(1);\n  }\n\n  if (isNaN(retries) || retries < 0) {\n    console.error(`Error: Invalid retries value \"${values.retries}\". Must be a non-negative number.`);\n    process.exit(1);\n  }\n\n  // Initialize telemetry\n  const telemetry = getTelemetry();\n  await telemetry.load();\n  const eventId = telemetry.trackCommandStart('run');\n\n  // Check if Playwright is installed\n  if (!quiet && !outputJson) {\n    console.log('Checking Playwright installation...');\n  }\n\n  const playwrightCheck = await checkPlaywrightInstalled();\n  if (!playwrightCheck.installed) {\n    console.error(`Error: Playwright is not installed or not accessible.`);\n    console.error(`  ${playwrightCheck.error}`);\n    console.error('\\nTo install Playwright, run:');\n    console.error('  npx playwright install');\n    telemetry.trackError('run', 'playwright_not_installed', playwrightCheck.error || 'Unknown');\n    telemetry.trackCommandEnd(eventId, false, { error: 'playwright_not_installed' });\n    await telemetry.save();\n    process.exit(1);\n  }\n\n  if (!quiet && !outputJson) {\n    console.log(`Running ${positionals.length} test file(s) with Playwright ${playwrightCheck.version || 'unknown'}...`);\n  }\n\n  const harnessRoot = getHarnessRoot();\n  const results: TestRunResult[] = [];\n\n  // Run each test file\n  for (const testPath of positionals) {\n    // SECURITY: Validate path to prevent directory traversal attacks\n    let fullPath: string;\n    try {\n      fullPath = validatePath(testPath, harnessRoot);\n    } catch (error) {\n      if (error instanceof PathTraversalError) {\n        console.error(`Error: Path traversal detected: \"${testPath}\"`);\n        console.error(`  Paths must be within harness root: ${harnessRoot}`);\n        results.push({\n          version: '1.0',\n          testPath,\n          status: 'error',\n          duration: 0,\n          errors: [{ message: `Path traversal blocked: ${testPath}`, type: 'runtime' }],\n          output: { stdout: '', stderr: '', exitCode: 1 },\n          artifacts: {},\n          executedAt: new Date().toISOString(),\n        });\n        continue;\n      }\n      throw error;\n    }\n\n    if (!existsSync(fullPath)) {\n      console.error(`Warning: Test file not found: ${fullPath}`);\n      results.push({\n        version: '1.0',\n        testPath: fullPath,\n        status: 'error',\n        duration: 0,\n        errors: [{ message: `File not found: ${fullPath}`, type: 'runtime' }],\n        output: { stdout: '', stderr: '', exitCode: 1 },\n        artifacts: {},\n        executedAt: new Date().toISOString(),\n      });\n      continue;\n    }\n\n    if (!quiet && !outputJson) {\n      console.log(`\\nRunning: ${basename(fullPath)}`);\n    }\n\n    const result = await runPlaywrightTest(fullPath, {\n      timeout,\n      retries,\n      headed: values.headed,\n      debug: values.debug,\n    });\n\n    results.push(result);\n\n    if (!quiet && !outputJson) {\n      const icon = result.status === 'passed' ? '' : '';\n      console.log(`  ${icon} ${result.status} (${result.duration}ms)`);\n      if (result.errors.length > 0) {\n        console.log(`    Errors: ${result.errors.length}`);\n        for (const err of result.errors.slice(0, 3)) {\n          console.log(`    - [${err.type}] ${err.message.substring(0, 100)}`);\n        }\n      }\n    }\n  }\n\n  // Calculate summary\n  const summary: RunSummary = {\n    total: results.length,\n    passed: results.filter(r => r.status === 'passed').length,\n    failed: results.filter(r => r.status === 'failed').length,\n    timeout: results.filter(r => r.status === 'timeout').length,\n    error: results.filter(r => r.status === 'error').length,\n    totalDuration: results.reduce((sum, r) => sum + r.duration, 0),\n  };\n\n  const output: RunOutput = {\n    version: '1.0',\n    results,\n    summary,\n    harnessRoot,\n    executedAt: new Date().toISOString(),\n  };\n\n  // Output\n  if (outputJson) {\n    console.log(JSON.stringify(output, null, 2));\n  } else {\n    // Write to file\n    const outputPath = values.output || getAutogenArtifact('results');\n    await ensureAutogenDir();\n    writeFileSync(outputPath, JSON.stringify(output, null, 2), 'utf-8');\n\n    if (!quiet) {\n      console.log(`\\nResults:`);\n      console.log(`  Passed: ${summary.passed}`);\n      console.log(`  Failed: ${summary.failed}`);\n      console.log(`  Timeout: ${summary.timeout}`);\n      console.log(`  Error: ${summary.error}`);\n      console.log(`  Duration: ${Math.round(summary.totalDuration / 1000)}s`);\n      console.log(`\\nOutput: ${outputPath}`);\n    }\n  }\n\n  // Determine pipeline stage based on results\n  const allPassed = summary.failed === 0 && summary.error === 0 && summary.timeout === 0;\n  const pipelineStage = allPassed ? 'completed' : 'tested';\n\n  // \n  // LLKB FEEDBACK LOOP: Record pattern failures for confidence adjustment\n  // Fire-and-forget: don't block main pipeline, just log errors\n  // @see research/2026-02-03_multi-ai-debate-llkb-feedback.md\n  // \n  if (!allPassed) {\n    for (const result of results) {\n      if (result.status !== 'passed' && result.journeyId) {\n        // Record each error type as a pattern failure for LLKB learning\n        for (const error of result.errors) {\n          // Fire-and-forget: async call without await, catch errors silently\n          Promise.resolve().then(() => {\n            try {\n              // Record failure to decrease pattern confidence\n              recordPatternFailure(\n                error.message.substring(0, 500), // Truncate for pattern matching\n                result.journeyId!\n              );\n              // Track blocked step for telemetry analysis\n              trackBlockedStep({\n                stepText: error.message.substring(0, 500),\n                journeyId: result.journeyId!,\n                errorType: error.type,\n                timestamp: new Date().toISOString(),\n              });\n            } catch (e) {\n              // Silent catch - LLKB failures should never crash the pipeline\n              if (!quiet) {\n                console.warn(`LLKB recording skipped: ${e instanceof Error ? e.message : 'unknown error'}`);\n              }\n            }\n          });\n        }\n      }\n    }\n  }\n\n  // Update pipeline state\n  await updatePipelineState('run', pipelineStage, allPassed, {\n    testPaths: positionals,\n  });\n\n  // Track command completion\n  telemetry.trackCommandEnd(eventId, allPassed, {\n    passed: summary.passed,\n    failed: summary.failed,\n    timeout: summary.timeout,\n    error: summary.error,\n    duration: summary.totalDuration,\n  });\n  await telemetry.save();\n\n  // Exit with error if any tests failed\n  if (!allPassed) {\n    process.exit(1);\n  }\n}\n","/**\n * CLI Refine Command - Apply refinements based on test errors\n *\n * Part of the Hybrid Agentic architecture. This command analyzes\n * test results and outputs structured refinement suggestions for\n * the orchestrating LLM to apply.\n *\n * @see research/2026-02-02_autogen-enhancement-implementation-plan.md\n */\nimport { parseArgs } from 'node:util';\nimport { readFileSync, writeFileSync, existsSync } from 'node:fs';\nimport { join, basename } from 'node:path';\nimport {\n  getAutogenArtifact,\n  getAutogenDir,\n  ensureAutogenDir,\n} from '../utils/paths.js';\nimport { updatePipelineState, loadPipelineState, canProceedTo } from '../pipeline/state.js';\nimport { getTelemetry } from '../shared/telemetry.js';\nimport type { RunOutput, TestError, ErrorType } from './run.js';\nimport {\n  CircuitBreaker,\n  ConvergenceDetector,\n  analyzeRefinementProgress,\n  type RefinementAnalysis,\n} from '../refinement/convergence-detector.js';\nimport type { ErrorAnalysis, CircuitBreakerState, ErrorCategory, RefinementSession, FixAttempt } from '../refinement/types.js';\nimport { extractLessonsFromSession } from '../refinement/llkb-learning.js';\nimport { recordPatternSuccess } from '../llkb/patternExtension.js';\n\n// \n// HELPERS\n// \n\n/**\n * Map TestError type to ErrorAnalysis category\n */\nfunction mapErrorTypeToCategory(errorType: ErrorType): ErrorCategory {\n  switch (errorType) {\n    case 'selector':\n      return 'SELECTOR_NOT_FOUND';\n    case 'timeout':\n      return 'TIMEOUT';\n    case 'assertion':\n      return 'ASSERTION_FAILED';\n    case 'navigation':\n      return 'NAVIGATION_ERROR';\n    case 'typescript':\n      return 'SYNTAX_ERROR';\n    case 'runtime':\n      return 'RUNTIME_ERROR';\n    default:\n      return 'UNKNOWN';\n  }\n}\n\n// \n// TYPES\n// \n\nexport interface RefinementSuggestion {\n  errorType: ErrorType;\n  errorMessage: string;\n  location?: {\n    file: string;\n    line: number;\n  };\n  suggestion: string;\n  confidence: number;\n  codeChange?: CodeChange;\n  llkbPattern?: string;\n}\n\nexport interface CodeChange {\n  type: 'replace' | 'insert' | 'delete';\n  file: string;\n  line: number;\n  oldCode?: string;\n  newCode?: string;\n  explanation: string;\n}\n\nexport interface RefineOutput {\n  version: '1.0';\n  testPath: string;\n  journeyId?: string;\n  status: 'needs_refinement' | 'converged' | 'blocked';\n  errors: TestError[];\n  suggestions: RefinementSuggestion[];\n  convergence: ConvergenceInfo;\n  circuitBreaker: CircuitBreakerInfo;\n  recommendation: string;\n  refinedAt: string;\n}\n\nexport interface ConvergenceInfo {\n  attempts: number;\n  trend: 'improving' | 'degrading' | 'stagnating' | 'oscillating';\n  errorCountHistory: number[];\n  improvementPercent: number;\n}\n\nexport interface CircuitBreakerInfo {\n  isOpen: boolean;\n  reason?: string;\n  remainingAttempts: number;\n}\n\n// \n// USAGE\n// \n\nconst USAGE = `\nUsage: artk-autogen refine [options]\n\nAnalyze test results and generate refinement suggestions.\n\nOptions:\n  -r, --results <path>   Path to results.json (default: .artk/autogen/results.json)\n  -t, --test <path>      Analyze specific test file only\n  --max-attempts <n>     Max refinement attempts before stopping (default: 3)\n  --json                 Output JSON to stdout instead of file\n  -q, --quiet            Suppress output except errors\n  -f, --force            Skip pipeline state validation\n  -h, --help             Show this help message\n\nExamples:\n  artk-autogen refine\n  artk-autogen refine --test tests/login.spec.ts\n  artk-autogen refine --max-attempts 5\n  artk-autogen refine --json\n`;\n\n// \n// REFINEMENT LOGIC\n// \n\nconst SELECTOR_REFINEMENTS: Record<string, RefinementSuggestion['suggestion']> = {\n  'strict mode': 'Locator found multiple elements. Add more specific selector or use .first() / .nth(0)',\n  'timeout': 'Element not found within timeout. Check if element exists, is visible, or needs explicit wait',\n  'not found': 'Element does not exist. Verify selector is correct and element is rendered',\n  'detached': 'Element was removed from DOM. Add waitFor or re-query the element',\n};\n\nconst ASSERTION_REFINEMENTS: Record<string, RefinementSuggestion['suggestion']> = {\n  'expected': 'Assertion value mismatch. Check expected vs actual value - may be timing issue',\n  'tobehave': 'Element state assertion failed. Add explicit wait before assertion',\n  'visibility': 'Element visibility check failed. Ensure element is in viewport and not hidden',\n};\n\nconst TIMEOUT_REFINEMENTS: Record<string, RefinementSuggestion['suggestion']> = {\n  'page.goto': 'Page navigation timeout. Check URL, network conditions, or increase timeout',\n  'waitfor': 'WaitFor timeout. Element may not appear - check selector or use different wait condition',\n  'click': 'Click timeout. Element may be overlapped, disabled, or not interactable',\n};\n\nfunction generateRefinement(error: TestError): RefinementSuggestion {\n  const message = error.message.toLowerCase();\n  let suggestion = error.suggestion || 'Review the error and fix manually';\n  let confidence = 0.5;\n\n  // Match against known patterns\n  if (error.type === 'selector') {\n    for (const [pattern, sug] of Object.entries(SELECTOR_REFINEMENTS)) {\n      if (message.includes(pattern)) {\n        suggestion = sug;\n        confidence = 0.8;\n        break;\n      }\n    }\n  } else if (error.type === 'assertion') {\n    for (const [pattern, sug] of Object.entries(ASSERTION_REFINEMENTS)) {\n      if (message.includes(pattern)) {\n        suggestion = sug;\n        confidence = 0.75;\n        break;\n      }\n    }\n  } else if (error.type === 'timeout') {\n    for (const [pattern, sug] of Object.entries(TIMEOUT_REFINEMENTS)) {\n      if (message.includes(pattern)) {\n        suggestion = sug;\n        confidence = 0.7;\n        break;\n      }\n    }\n  }\n\n  // Generate code change suggestion if location is available\n  let codeChange: CodeChange | undefined;\n  if (error.location && error.snippet) {\n    codeChange = suggestCodeChange(error);\n  }\n\n  return {\n    errorType: error.type,\n    errorMessage: error.message.substring(0, 300),\n    location: error.location,\n    suggestion,\n    confidence,\n    codeChange,\n  };\n}\n\nfunction suggestCodeChange(error: TestError): CodeChange | undefined {\n  if (!error.location || !error.snippet) return undefined;\n\n  const { file, line } = error.location;\n  const snippet = error.snippet;\n\n  // Selector timeout - add explicit wait\n  if (error.type === 'timeout' && snippet.includes('locator')) {\n    return {\n      type: 'replace',\n      file,\n      line,\n      oldCode: snippet,\n      newCode: `await page.waitForSelector('${extractSelector(snippet)}', { state: 'visible' });\\n  ${snippet}`,\n      explanation: 'Add explicit waitForSelector before the action',\n    };\n  }\n\n  // Click on overlapped element - add scrollIntoView\n  if (error.type === 'selector' && error.message.includes('intercept')) {\n    return {\n      type: 'replace',\n      file,\n      line,\n      oldCode: snippet,\n      newCode: snippet.replace('.click()', '.scrollIntoViewIfNeeded();\\n  await ' + snippet.trim()),\n      explanation: 'Scroll element into view before clicking',\n    };\n  }\n\n  // Strict mode violation - use .first()\n  if (error.type === 'selector' && error.message.includes('strict')) {\n    return {\n      type: 'replace',\n      file,\n      line,\n      oldCode: snippet,\n      newCode: snippet.replace('.click()', '.first().click()'),\n      explanation: 'Use .first() to select single element from multiple matches',\n    };\n  }\n\n  return undefined;\n}\n\nfunction extractSelector(snippet: string): string {\n  const match = snippet.match(/(?:locator|getBy\\w+)\\(['\"]([^'\"]+)['\"]\\)/);\n  return match?.[1] || 'unknown';\n}\n\n// \n// STATE MANAGEMENT\n// \n\ninterface RefineState {\n  testPath: string;\n  attempts: RefineAttempt[];\n  /** Saved circuit breaker state for restoration */\n  circuitBreakerState: CircuitBreakerState;\n  /** Error count history for convergence detection */\n  errorCountHistory: number[];\n}\n\ninterface RefineAttempt {\n  attemptNumber: number;\n  errors: TestError[];\n  suggestions: RefinementSuggestion[];\n  timestamp: string;\n}\n\nfunction loadRefineState(testPath: string, maxAttempts: number): RefineState {\n  const stateDir = getAutogenDir();\n  const statePath = join(stateDir, `refine-state-${basename(testPath, '.spec.ts')}.json`);\n\n  if (existsSync(statePath)) {\n    try {\n      const loaded = JSON.parse(readFileSync(statePath, 'utf-8')) as RefineState;\n\n      // Migration: convert old format to new format if needed\n      if (!loaded.circuitBreakerState) {\n        // Old format had circuitBreaker object, migrate to new format\n        const oldState = loaded as unknown as {\n          circuitBreaker?: {\n            isOpen: boolean;\n            openReason?: string;\n            attemptCount: number;\n            errorHistory: string[];\n            tokensUsed: number;\n          };\n        };\n        loaded.circuitBreakerState = {\n          isOpen: oldState.circuitBreaker?.isOpen ?? false,\n          openReason: oldState.circuitBreaker?.openReason as CircuitBreakerState['openReason'],\n          attemptCount: oldState.circuitBreaker?.attemptCount ?? loaded.attempts.length,\n          errorHistory: oldState.circuitBreaker?.errorHistory ?? [],\n          tokensUsed: oldState.circuitBreaker?.tokensUsed ?? 0,\n          maxAttempts,\n        };\n      }\n\n      // Migration: add errorCountHistory if missing\n      if (!loaded.errorCountHistory) {\n        loaded.errorCountHistory = loaded.attempts.map(a => a.errors.length);\n      }\n\n      return loaded;\n    } catch {\n      // Corrupted state, start fresh\n    }\n  }\n\n  return {\n    testPath,\n    attempts: [],\n    circuitBreakerState: {\n      isOpen: false,\n      attemptCount: 0,\n      errorHistory: [],\n      tokensUsed: 0,\n      maxAttempts,\n    },\n    errorCountHistory: [],\n  };\n}\n\nfunction saveRefineState(state: RefineState): void {\n  const stateDir = getAutogenDir();\n  const statePath = join(stateDir, `refine-state-${basename(state.testPath, '.spec.ts')}.json`);\n  writeFileSync(statePath, JSON.stringify(state, null, 2), 'utf-8');\n}\n\n// \n// MAIN COMMAND\n// \n\nexport async function runRefine(args: string[]): Promise<void> {\n  const { values } = parseArgs({\n    args,\n    options: {\n      results: { type: 'string', short: 'r' },\n      test: { type: 'string', short: 't' },\n      'max-attempts': { type: 'string', default: '3' },\n      json: { type: 'boolean', default: false },\n      quiet: { type: 'boolean', short: 'q', default: false },\n      force: { type: 'boolean', short: 'f', default: false },\n      help: { type: 'boolean', short: 'h', default: false },\n    },\n    allowPositionals: true,\n  });\n\n  if (values.help) {\n    console.log(USAGE);\n    return;\n  }\n\n  const quiet = values.quiet;\n  const outputJson = values.json;\n  const force = values.force;\n\n  // Validate pipeline state transition (unless --force)\n  if (!force) {\n    const currentState = loadPipelineState();\n    const transition = canProceedTo(currentState, 'refining');\n    if (!transition.allowed) {\n      console.error(`Error: ${transition.reason}`);\n      console.error('Use --force to bypass state validation.');\n      process.exit(1);\n    }\n  } else if (!quiet && !outputJson) {\n    console.log('Warning: Bypassing pipeline state validation (--force)');\n  }\n\n  // Validate max-attempts\n  const maxAttempts = parseInt(values['max-attempts'], 10);\n  if (isNaN(maxAttempts) || maxAttempts <= 0) {\n    console.error(`Error: Invalid max-attempts value \"${values['max-attempts']}\". Must be a positive number.`);\n    process.exit(1);\n  }\n\n  // Initialize telemetry\n  const telemetry = getTelemetry();\n  await telemetry.load();\n  const eventId = telemetry.trackCommandStart('refine');\n\n  // Load results\n  const resultsPath = values.results || getAutogenArtifact('results');\n  if (!existsSync(resultsPath)) {\n    console.error(`Error: Results file not found: ${resultsPath}`);\n    console.error('Run \"artk-autogen run\" first.');\n    process.exit(1);\n  }\n\n  let runOutput: RunOutput;\n  try {\n    runOutput = JSON.parse(readFileSync(resultsPath, 'utf-8'));\n  } catch (e) {\n    console.error(`Error: Failed to parse results file: ${e}`);\n    process.exit(1);\n  }\n\n  // Filter to specific test if requested\n  let results = runOutput.results;\n  if (values.test) {\n    results = results.filter(r => r.testPath.includes(values.test!));\n    if (results.length === 0) {\n      console.error(`Error: No results found for test \"${values.test}\"`);\n      process.exit(1);\n    }\n  }\n\n  // Filter to failed tests only\n  const failedResults = results.filter(r => r.status !== 'passed');\n  if (failedResults.length === 0) {\n    if (!quiet && !outputJson) {\n      console.log('All tests passed - no refinement needed');\n    }\n    if (outputJson) {\n      console.log(JSON.stringify({ status: 'converged', message: 'All tests passed' }, null, 2));\n    }\n    return;\n  }\n\n  await ensureAutogenDir();\n  const outputs: RefineOutput[] = [];\n\n  for (const result of failedResults) {\n    // Load state for this test (with maxAttempts for circuit breaker config)\n    const state = loadRefineState(result.testPath, maxAttempts);\n\n    // CRITICAL FIX: Restore circuit breaker from saved state instead of replaying\n    // This prevents double-counting attempts when the CLI is run multiple times\n    const circuitBreaker = new CircuitBreaker({\n      maxAttempts,\n      initialState: state.circuitBreakerState,\n    });\n\n    // Restore convergence detector from saved error count history\n    const convergenceDetector = new ConvergenceDetector();\n    convergenceDetector.restoreFromHistory(state.errorCountHistory);\n\n    // Record ONLY the current attempt (not historical ones - they're already in saved state)\n    // Map TestError to ErrorAnalysis format\n    const currentErrors: ErrorAnalysis[] = result.errors.map(e => ({\n      fingerprint: `${e.type}:${e.message.substring(0, 50)}`,\n      category: mapErrorTypeToCategory(e.type),\n      message: e.message,\n      originalError: e.message,\n      severity: 'major' as const,\n      timestamp: new Date(),\n    }));\n    circuitBreaker.recordAttempt(currentErrors);\n    convergenceDetector.recordAttempt(currentErrors);\n\n    // Analyze progress\n    const analysis: RefinementAnalysis = analyzeRefinementProgress(\n      [], // Fix attempts not used directly\n      circuitBreaker,\n      convergenceDetector\n    );\n\n    // Generate suggestions\n    const suggestions = result.errors.map(e => generateRefinement(e));\n\n    // Determine status\n    let status: RefineOutput['status'] = 'needs_refinement';\n    let recommendation = 'Apply suggested refinements and re-run the test';\n\n    if (result.errors.length === 0) {\n      status = 'converged';\n      recommendation = 'Test is now passing';\n\n      // \n      // LLKB FEEDBACK LOOP: Extract lessons from successful refinement session\n      // Fire-and-forget: don't block main pipeline, just log errors\n      // @see research/2026-02-03_multi-ai-debate-llkb-feedback.md\n      // \n      if (result.journeyId && state.attempts.length > 0) {\n        Promise.resolve().then(() => {\n          try {\n            // Build minimal RefinementSession for lesson extraction\n            // extractLessonsFromSession only uses journeyId and attempts array\n            const session = {\n              sessionId: `refine-${Date.now()}`,\n              journeyId: result.journeyId!,\n              testFile: result.testPath,\n              startTime: new Date(state.attempts[0]?.timestamp ?? Date.now()),\n              originalCode: '',\n              currentCode: '',\n              attempts: state.attempts.map((attempt, idx): FixAttempt => ({\n                attemptNumber: attempt.attemptNumber,\n                timestamp: new Date(attempt.timestamp),\n                error: {\n                  fingerprint: `attempt-${idx}`,\n                  category: attempt.errors[0]?.type === 'selector' ? 'SELECTOR_NOT_FOUND' :\n                           attempt.errors[0]?.type === 'timeout' ? 'TIMEOUT' :\n                           attempt.errors[0]?.type === 'assertion' ? 'ASSERTION_FAILED' : 'UNKNOWN',\n                  message: attempt.errors[0]?.message ?? 'Unknown error',\n                  originalError: attempt.errors[0]?.message ?? '',\n                  severity: 'major',\n                  timestamp: new Date(attempt.timestamp),\n                },\n                proposedFixes: [],\n                appliedFix: attempt.suggestions[0] ? {\n                  type: 'OTHER',\n                  description: attempt.suggestions[0].suggestion,\n                  location: attempt.suggestions[0].location ? {\n                    file: attempt.suggestions[0].location.file,\n                    line: attempt.suggestions[0].location.line,\n                  } : { file: result.testPath, line: 0 },\n                  originalCode: '',\n                  fixedCode: attempt.suggestions[0].codeChange?.newCode ?? '',\n                  confidence: attempt.suggestions[0].confidence,\n                } : undefined,\n                outcome: idx === state.attempts.length - 1 ? 'success' : 'partial',\n              })),\n              circuitBreakerState: {\n                isOpen: false,\n                attemptCount: state.attempts.length,\n                errorHistory: [],\n                tokensUsed: 0,\n              },\n              convergenceInfo: {\n                converged: true,\n                attempts: state.attempts.length,\n                errorCountHistory: [],\n                uniqueErrorsHistory: [],\n                stagnationCount: 0,\n                trend: 'improving' as const,\n              },\n              finalStatus: 'SUCCESS' as const,\n              totalTokenUsage: {\n                promptTokens: 0,\n                completionTokens: 0,\n                totalTokens: 0,\n                estimatedCostUsd: 0,\n              },\n            } as RefinementSession;\n\n            // Extract and save lessons learned\n            const lessons = extractLessonsFromSession(session);\n            if (lessons.length > 0 && !quiet) {\n              console.log(`  LLKB: Extracted ${lessons.length} lesson(s) from successful refinement`);\n            }\n\n            // Also record successful patterns to increase confidence\n            for (const suggestion of suggestions) {\n              if (suggestion.confidence >= 0.7) {\n                recordPatternSuccess(\n                  suggestion.suggestion.substring(0, 100),\n                  { type: 'blocked', reason: 'learned', sourceText: suggestion.suggestion },\n                  result.journeyId!\n                );\n              }\n            }\n          } catch (e) {\n            // Silent catch - LLKB failures should never crash the pipeline\n            if (!quiet) {\n              console.warn(`LLKB lesson extraction skipped: ${e instanceof Error ? e.message : 'unknown error'}`);\n            }\n          }\n        });\n      }\n    } else if (analysis.recommendation === 'stop' || !analysis.shouldContinue) {\n      status = 'blocked';\n      recommendation = `Refinement blocked: ${analysis.reason}. Manual intervention required.`;\n    }\n\n    const output: RefineOutput = {\n      version: '1.0',\n      testPath: result.testPath,\n      journeyId: result.journeyId,\n      status,\n      errors: result.errors,\n      suggestions,\n      convergence: {\n        attempts: state.attempts.length + 1,\n        trend: analysis.convergence.trend,\n        errorCountHistory: analysis.convergence.errorCountHistory,\n        improvementPercent: convergenceDetector.getImprovementPercentage(),\n      },\n      circuitBreaker: {\n        isOpen: analysis.circuitBreaker.isOpen,\n        reason: analysis.circuitBreaker.openReason,\n        remainingAttempts: circuitBreaker.remainingAttempts(),\n      },\n      recommendation,\n      refinedAt: new Date().toISOString(),\n    };\n\n    outputs.push(output);\n\n    // Update state with new attempt\n    state.attempts.push({\n      attemptNumber: state.attempts.length + 1,\n      errors: result.errors,\n      suggestions,\n      timestamp: new Date().toISOString(),\n    });\n\n    // Save circuit breaker state for future restoration\n    state.circuitBreakerState = {\n      isOpen: analysis.circuitBreaker.isOpen,\n      openReason: analysis.circuitBreaker.openReason,\n      attemptCount: analysis.circuitBreaker.attemptCount,\n      errorHistory: analysis.circuitBreaker.errorHistory,\n      tokensUsed: analysis.circuitBreaker.tokensUsed,\n      maxAttempts,\n    };\n\n    // Save error count history for convergence detection restoration\n    state.errorCountHistory.push(result.errors.length);\n\n    saveRefineState(state);\n\n    if (!quiet && !outputJson) {\n      console.log(`\\nTest: ${basename(result.testPath)}`);\n      console.log(`  Status: ${status}`);\n      console.log(`  Errors: ${result.errors.length}`);\n      console.log(`  Attempt: ${state.attempts.length}/${maxAttempts}`);\n      console.log(`  Trend: ${analysis.convergence.trend}`);\n      if (suggestions.length > 0) {\n        console.log(`  Suggestions:`);\n        for (const s of suggestions.slice(0, 3)) {\n          console.log(`    - [${s.errorType}] ${s.suggestion.substring(0, 60)}`);\n        }\n      }\n    }\n  }\n\n  // Output\n  if (outputJson) {\n    console.log(JSON.stringify(outputs.length === 1 ? outputs[0] : outputs, null, 2));\n  } else if (!quiet) {\n    console.log(`\\nRefinement analysis complete:`);\n    console.log(`  Total: ${outputs.length}`);\n    console.log(`  Needs refinement: ${outputs.filter(o => o.status === 'needs_refinement').length}`);\n    console.log(`  Blocked: ${outputs.filter(o => o.status === 'blocked').length}`);\n    console.log(`  Converged: ${outputs.filter(o => o.status === 'converged').length}`);\n  }\n\n  // Determine pipeline stage based on refinement results\n  const hasBlocked = outputs.some(o => o.status === 'blocked');\n  const allConverged = outputs.every(o => o.status === 'converged');\n  const pipelineStage = hasBlocked ? 'blocked' : allConverged ? 'completed' : 'refining';\n\n  // Calculate total refinement attempts\n  const totalAttempts = outputs.reduce((sum, o) => sum + o.convergence.attempts, 0);\n\n  // Update pipeline state\n  await updatePipelineState('refine', pipelineStage, !hasBlocked, {\n    refinementAttempts: totalAttempts,\n    isBlocked: hasBlocked,\n    blockedReason: hasBlocked\n      ? outputs.find(o => o.status === 'blocked')?.recommendation\n      : undefined,\n  });\n\n  // Track command completion\n  telemetry.trackCommandEnd(eventId, !hasBlocked, {\n    totalTests: outputs.length,\n    needsRefinement: outputs.filter(o => o.status === 'needs_refinement').length,\n    blocked: outputs.filter(o => o.status === 'blocked').length,\n    converged: outputs.filter(o => o.status === 'converged').length,\n    totalAttempts,\n  });\n  await telemetry.save();\n}\n","/**\n * CLI Status Command - Show pipeline state\n *\n * Part of the Hybrid Agentic architecture. Shows current state\n * of the autogen pipeline for the orchestrating LLM to use.\n *\n * @see research/2026-02-02_autogen-enhancement-implementation-plan.md\n */\nimport { parseArgs } from 'node:util';\nimport { readFileSync, readdirSync, statSync, existsSync } from 'node:fs';\nimport { join, basename } from 'node:path';\nimport {\n  getHarnessRoot,\n  getAutogenDir,\n  getAutogenArtifact,\n  hasAutogenArtifacts,\n  type AutogenArtifact,\n} from '../utils/paths.js';\nimport {\n  loadPipelineState,\n  getPipelineStateSummary,\n  type PipelineState as PipelineStateData,\n  type PipelineStage,\n} from '../pipeline/state.js';\nimport { getTelemetry } from '../shared/telemetry.js';\nimport type { AnalysisOutput } from './analyze.js';\nimport type { PlanOutput } from './plan.js';\nimport type { RunOutput } from './run.js';\n\n// \n// TYPES\n// \n\nexport interface PipelineStatus {\n  version: '1.0';\n  harnessRoot: string;\n  autogenDir: string;\n  hasArtifacts: boolean;\n  artifacts: ArtifactStatus[];\n  pipeline: PipelineStateView;\n  persistedState?: PipelineStateData;\n  refinementStates: RefinementStateInfo[];\n  summary: StatusSummary;\n  checkedAt: string;\n}\n\nexport interface ArtifactStatus {\n  name: AutogenArtifact;\n  path: string;\n  exists: boolean;\n  size?: number;\n  modifiedAt?: string;\n  summary?: string;\n}\n\nexport interface PipelineStateView {\n  stage: PipelineStage;\n  canProceed: boolean;\n  nextAction: string;\n  blockedReason?: string;\n}\n\n// Re-export PipelineStage from state module for consumers\nexport type { PipelineStage } from '../pipeline/state.js';\n\nexport interface RefinementStateInfo {\n  testPath: string;\n  attempts: number;\n  lastStatus: string;\n  trend: string;\n  isBlocked: boolean;\n}\n\nexport interface StatusSummary {\n  totalJourneys?: number;\n  totalPlans?: number;\n  testsRun?: number;\n  testsPassed?: number;\n  testsFailed?: number;\n  refinementAttempts: number;\n}\n\n// \n// USAGE\n// \n\nconst USAGE = `\nUsage: artk-autogen status [options]\n\nShow the current state of the autogen pipeline.\n\nOptions:\n  --json                 Output JSON to stdout\n  -q, --quiet            Suppress output except errors\n  -h, --help             Show this help message\n\nExamples:\n  artk-autogen status\n  artk-autogen status --json\n`;\n\n// \n// STATUS LOGIC\n// \n\nfunction getArtifactStatus(artifact: AutogenArtifact): ArtifactStatus {\n  const path = getAutogenArtifact(artifact);\n  const exists = existsSync(path);\n\n  const status: ArtifactStatus = {\n    name: artifact,\n    path,\n    exists,\n  };\n\n  if (exists) {\n    const stat = statSync(path);\n    status.size = stat.size;\n    status.modifiedAt = stat.mtime.toISOString();\n\n    // Add summary based on artifact type\n    try {\n      if (artifact === 'analysis') {\n        const data: AnalysisOutput = JSON.parse(readFileSync(path, 'utf-8'));\n        status.summary = `${data.journeys?.length || 0} journeys, ${data.summary?.totalSteps || 0} steps`;\n      } else if (artifact === 'plan') {\n        const data: PlanOutput = JSON.parse(readFileSync(path, 'utf-8'));\n        status.summary = `${data.plans?.length || 0} plans, ${data.summary?.totalSteps || 0} steps`;\n      } else if (artifact === 'results') {\n        const data: RunOutput = JSON.parse(readFileSync(path, 'utf-8'));\n        status.summary = `${data.summary?.passed || 0}/${data.summary?.total || 0} passed`;\n      }\n    } catch {\n      status.summary = 'Error reading file';\n    }\n  }\n\n  return status;\n}\n\nfunction loadRefinementStates(): RefinementStateInfo[] {\n  const autogenDir = getAutogenDir();\n  if (!existsSync(autogenDir)) return [];\n\n  const states: RefinementStateInfo[] = [];\n\n  try {\n    const files = readdirSync(autogenDir);\n    for (const file of files) {\n      if (file.startsWith('refine-state-') && file.endsWith('.json')) {\n        const path = join(autogenDir, file);\n        try {\n          const data = JSON.parse(readFileSync(path, 'utf-8'));\n          const lastAttempt = data.attempts?.[data.attempts.length - 1];\n\n          states.push({\n            testPath: data.testPath,\n            attempts: data.attempts?.length || 0,\n            lastStatus: lastAttempt?.errors?.length > 0 ? 'failed' : 'passed',\n            trend: 'unknown', // Would need convergence detector\n            isBlocked: data.circuitBreakerState?.isOpen ?? false,  // Fixed: was incorrectly reading circuitBreaker\n          });\n        } catch {\n          // Skip corrupted files\n        }\n      }\n    }\n  } catch {\n    // Directory read error\n  }\n\n  return states;\n}\n\nfunction determinePipelineStage(artifacts: ArtifactStatus[], persistedState?: PipelineStateData): PipelineStateView {\n  const hasAnalysis = artifacts.find(a => a.name === 'analysis')?.exists;\n  const hasPlan = artifacts.find(a => a.name === 'plan')?.exists;\n  const hasResults = artifacts.find(a => a.name === 'results')?.exists;\n\n  // Check results for test status\n  let allTestsPassed = false;\n  let hasFailures = false;\n\n  if (hasResults) {\n    const resultsPath = getAutogenArtifact('results');\n    try {\n      const data: RunOutput = JSON.parse(readFileSync(resultsPath, 'utf-8'));\n      allTestsPassed = data.summary?.failed === 0 && data.summary?.error === 0;\n      hasFailures = (data.summary?.failed || 0) > 0 || (data.summary?.error || 0) > 0;\n    } catch {\n      // Ignore parse errors\n    }\n  }\n\n  // Check for blocked refinements\n  const refinementStates = loadRefinementStates();\n  const hasBlockedRefinements = refinementStates.some(s => s.isBlocked);\n\n  // Use persisted state if available and valid\n  if (persistedState && persistedState.isBlocked) {\n    return {\n      stage: 'blocked',\n      canProceed: false,\n      nextAction: 'Review blocked state and fix manually',\n      blockedReason: persistedState.blockedReason || 'Pipeline is blocked',\n    };\n  }\n\n  // Determine stage\n  if (hasBlockedRefinements) {\n    return {\n      stage: 'blocked',\n      canProceed: false,\n      nextAction: 'Review blocked refinements and fix manually',\n      blockedReason: 'Circuit breaker triggered on one or more tests',\n    };\n  }\n\n  if (allTestsPassed) {\n    return {\n      stage: 'completed',\n      canProceed: false,\n      nextAction: 'Pipeline complete - all tests passing',\n    };\n  }\n\n  if (hasFailures && refinementStates.length > 0) {\n    return {\n      stage: 'refining',\n      canProceed: true,\n      nextAction: 'Run \"artk-autogen refine\" to get refinement suggestions',\n    };\n  }\n\n  if (hasResults) {\n    return {\n      stage: 'tested',\n      canProceed: true,\n      nextAction: hasFailures\n        ? 'Run \"artk-autogen refine\" to analyze failures'\n        : 'Pipeline complete - all tests passing',\n    };\n  }\n\n  // Check if tests were generated (either persisted state or test files exist)\n  const testsGenerated = persistedState?.stage === 'generated' ||\n    (persistedState?.testPaths && persistedState.testPaths.length > 0);\n  if (testsGenerated && hasPlan) {\n    return {\n      stage: 'generated',\n      canProceed: true,\n      nextAction: 'Run \"artk-autogen run\" to execute generated tests',\n    };\n  }\n\n  if (hasPlan) {\n    return {\n      stage: 'planned',\n      canProceed: true,\n      nextAction: 'Run \"artk-autogen generate\" to generate tests from plan',\n    };\n  }\n\n  if (hasAnalysis) {\n    return {\n      stage: 'analyzed',\n      canProceed: true,\n      nextAction: 'Run \"artk-autogen plan\" to create test plan',\n    };\n  }\n\n  return {\n    stage: 'initial',\n    canProceed: true,\n    nextAction: 'Run \"artk-autogen analyze <journey-files>\" to start',\n  };\n}\n\n// \n// MAIN COMMAND\n// \n\nexport async function runStatus(args: string[]): Promise<void> {\n  const { values } = parseArgs({\n    args,\n    options: {\n      json: { type: 'boolean', default: false },\n      quiet: { type: 'boolean', short: 'q', default: false },\n      help: { type: 'boolean', short: 'h', default: false },\n    },\n    allowPositionals: true,\n  });\n\n  if (values.help) {\n    console.log(USAGE);\n    return;\n  }\n\n  const outputJson = values.json;\n  const quiet = values.quiet;\n\n  // Initialize telemetry\n  const telemetry = getTelemetry();\n  await telemetry.load();\n  const eventId = telemetry.trackCommandStart('status');\n\n  const harnessRoot = getHarnessRoot();\n  const autogenDir = getAutogenDir();\n\n  // Load persisted pipeline state\n  const persistedState = loadPipelineState();\n\n  // Check all artifacts\n  const artifactTypes: AutogenArtifact[] = [\n    'analysis', 'plan', 'state', 'results', 'telemetry',\n  ];\n  const artifacts = artifactTypes.map(a => getArtifactStatus(a));\n\n  // Load refinement states\n  const refinementStates = loadRefinementStates();\n\n  // Determine pipeline state\n  const pipeline = determinePipelineStage(artifacts, persistedState);\n\n  // Calculate summary\n  const summary: StatusSummary = {\n    refinementAttempts: refinementStates.reduce((sum, s) => sum + s.attempts, 0),\n  };\n\n  // Extract more info from artifacts\n  const analysisArtifact = artifacts.find(a => a.name === 'analysis');\n  if (analysisArtifact?.exists) {\n    try {\n      const data: AnalysisOutput = JSON.parse(readFileSync(analysisArtifact.path, 'utf-8'));\n      summary.totalJourneys = data.journeys?.length;\n    } catch {\n      // Ignore\n    }\n  }\n\n  const planArtifact = artifacts.find(a => a.name === 'plan');\n  if (planArtifact?.exists) {\n    try {\n      const data: PlanOutput = JSON.parse(readFileSync(planArtifact.path, 'utf-8'));\n      summary.totalPlans = data.plans?.length;\n    } catch {\n      // Ignore\n    }\n  }\n\n  const resultsArtifact = artifacts.find(a => a.name === 'results');\n  if (resultsArtifact?.exists) {\n    try {\n      const data: RunOutput = JSON.parse(readFileSync(resultsArtifact.path, 'utf-8'));\n      summary.testsRun = data.summary?.total;\n      summary.testsPassed = data.summary?.passed;\n      summary.testsFailed = data.summary?.failed;\n    } catch {\n      // Ignore\n    }\n  }\n\n  const status: PipelineStatus = {\n    version: '1.0',\n    harnessRoot,\n    autogenDir,\n    hasArtifacts: hasAutogenArtifacts(),\n    artifacts,\n    pipeline,\n    persistedState,\n    refinementStates,\n    summary,\n    checkedAt: new Date().toISOString(),\n  };\n\n  // Output\n  if (outputJson) {\n    console.log(JSON.stringify(status, null, 2));\n  } else if (!quiet) {\n    console.log('AutoGen Pipeline Status');\n    console.log(''.repeat(50));\n    console.log(`Harness: ${harnessRoot}`);\n    console.log(`Stage: ${pipeline.stage}`);\n    console.log(`Can proceed: ${pipeline.canProceed ? 'Yes' : 'No'}`);\n    console.log(`Next action: ${pipeline.nextAction}`);\n    if (pipeline.blockedReason) {\n      console.log(`Blocked: ${pipeline.blockedReason}`);\n    }\n\n    console.log('\\nArtifacts:');\n    for (const artifact of artifacts) {\n      const icon = artifact.exists ? '' : '';\n      const summary = artifact.summary ? ` (${artifact.summary})` : '';\n      console.log(`  ${icon} ${artifact.name}${summary}`);\n    }\n\n    if (refinementStates.length > 0) {\n      console.log('\\nRefinement States:');\n      for (const state of refinementStates) {\n        const icon = state.isBlocked ? '' : '';\n        console.log(`  ${icon} ${basename(state.testPath)}: ${state.attempts} attempts, ${state.lastStatus}`);\n      }\n    }\n\n    if (summary.testsRun !== undefined) {\n      console.log('\\nSummary:');\n      console.log(`  Journeys: ${summary.totalJourneys || 'N/A'}`);\n      console.log(`  Plans: ${summary.totalPlans || 'N/A'}`);\n      console.log(`  Tests: ${summary.testsPassed}/${summary.testsRun} passed`);\n      console.log(`  Refinement attempts: ${summary.refinementAttempts}`);\n    }\n\n    // Show persisted state info if available\n    if (persistedState && persistedState.stage !== 'initial') {\n      console.log('\\nPersisted State:');\n      console.log(`  ${getPipelineStateSummary(persistedState)}`);\n    }\n  }\n\n  // Track command completion\n  telemetry.trackCommandEnd(eventId, true, {\n    stage: pipeline.stage,\n    hasArtifacts: status.hasArtifacts,\n    refinementStates: refinementStates.length,\n  });\n  await telemetry.save();\n}\n","/**\n * CLI Clean Command - Clean autogen artifacts\n *\n * Part of the Hybrid Agentic architecture. Cleans all autogen\n * artifacts for a fresh start.\n *\n * @see research/2026-02-02_autogen-enhancement-implementation-plan.md\n */\nimport { parseArgs } from 'node:util';\nimport { readdirSync, rmSync, existsSync, statSync } from 'node:fs';\nimport { join } from 'node:path';\nimport {\n  getAutogenDir,\n  cleanAutogenArtifacts,\n  hasAutogenArtifacts,\n} from '../utils/paths.js';\nimport { resetPipelineState } from '../pipeline/state.js';\nimport { getTelemetry } from '../shared/telemetry.js';\n\n// \n// USAGE\n// \n\nconst USAGE = `\nUsage: artk-autogen clean [options]\n\nClean autogen artifacts for a fresh start.\n\nOptions:\n  --dry-run              Show what would be deleted without deleting\n  --keep-analysis        Keep analysis.json (only clean generated files)\n  --keep-plan            Keep plan.json\n  -f, --force            Skip confirmation\n  -q, --quiet            Suppress output except errors\n  -h, --help             Show this help message\n\nExamples:\n  artk-autogen clean\n  artk-autogen clean --dry-run\n  artk-autogen clean --keep-analysis\n  artk-autogen clean --force\n`;\n\n// \n// CLEAN LOGIC\n// \n\nfunction listArtifacts(): { path: string; size: number; isDir: boolean }[] {\n  const autogenDir = getAutogenDir();\n  if (!existsSync(autogenDir)) return [];\n\n  const items: { path: string; size: number; isDir: boolean }[] = [];\n\n  try {\n    const entries = readdirSync(autogenDir, { withFileTypes: true });\n    for (const entry of entries) {\n      const fullPath = join(autogenDir, entry.name);\n      const stat = statSync(fullPath);\n      items.push({\n        path: fullPath,\n        size: entry.isDirectory() ? getDirSize(fullPath) : stat.size,\n        isDir: entry.isDirectory(),\n      });\n    }\n  } catch {\n    // Directory read error\n  }\n\n  return items;\n}\n\nfunction getDirSize(dirPath: string): number {\n  let size = 0;\n  try {\n    const entries = readdirSync(dirPath, { withFileTypes: true });\n    for (const entry of entries) {\n      const fullPath = join(dirPath, entry.name);\n      if (entry.isDirectory()) {\n        size += getDirSize(fullPath);\n      } else {\n        size += statSync(fullPath).size;\n      }\n    }\n  } catch {\n    // Ignore errors\n  }\n  return size;\n}\n\nfunction formatSize(bytes: number): string {\n  if (bytes < 1024) return `${bytes} B`;\n  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n}\n\n// \n// MAIN COMMAND\n// \n\nexport async function runClean(args: string[]): Promise<void> {\n  const { values } = parseArgs({\n    args,\n    options: {\n      'dry-run': { type: 'boolean', default: false },\n      'keep-analysis': { type: 'boolean', default: false },\n      'keep-plan': { type: 'boolean', default: false },\n      force: { type: 'boolean', short: 'f', default: false },\n      quiet: { type: 'boolean', short: 'q', default: false },\n      help: { type: 'boolean', short: 'h', default: false },\n    },\n    allowPositionals: true,\n  });\n\n  if (values.help) {\n    console.log(USAGE);\n    return;\n  }\n\n  const dryRun = values['dry-run'];\n  const keepAnalysis = values['keep-analysis'];\n  const keepPlan = values['keep-plan'];\n  const force = values.force;\n  const quiet = values.quiet;\n\n  // Initialize telemetry\n  const telemetry = getTelemetry();\n  await telemetry.load();\n  const eventId = telemetry.trackCommandStart('clean');\n\n  if (!hasAutogenArtifacts()) {\n    if (!quiet) {\n      console.log('No autogen artifacts to clean.');\n    }\n    telemetry.trackCommandEnd(eventId, true, { skipped: true, reason: 'no_artifacts' });\n    await telemetry.save();\n    return;\n  }\n\n  // List what will be deleted\n  const artifacts = listArtifacts();\n  const toDelete: typeof artifacts = [];\n  const toKeep: typeof artifacts = [];\n\n  for (const artifact of artifacts) {\n    const name = artifact.path.split('/').pop() || '';\n\n    if (keepAnalysis && name === 'analysis.json') {\n      toKeep.push(artifact);\n    } else if (keepPlan && name === 'plan.json') {\n      toKeep.push(artifact);\n    } else {\n      toDelete.push(artifact);\n    }\n  }\n\n  if (toDelete.length === 0) {\n    if (!quiet) {\n      console.log('Nothing to delete (all artifacts are marked to keep).');\n    }\n    telemetry.trackCommandEnd(eventId, true, { skipped: true, reason: 'nothing_to_delete' });\n    await telemetry.save();\n    return;\n  }\n\n  const totalSize = toDelete.reduce((sum, a) => sum + a.size, 0);\n\n  // Show preview\n  if (!quiet || dryRun) {\n    console.log(dryRun ? 'Would delete:' : 'Will delete:');\n    for (const artifact of toDelete) {\n      const name = artifact.path.split('/').pop();\n      const type = artifact.isDir ? '(dir)' : '';\n      console.log(`  - ${name} ${type} [${formatSize(artifact.size)}]`);\n    }\n    console.log(`\\nTotal: ${formatSize(totalSize)}`);\n\n    if (toKeep.length > 0) {\n      console.log('\\nKeeping:');\n      for (const artifact of toKeep) {\n        const name = artifact.path.split('/').pop();\n        console.log(`  - ${name}`);\n      }\n    }\n  }\n\n  if (dryRun) {\n    telemetry.trackCommandEnd(eventId, true, { dryRun: true, wouldDelete: toDelete.length });\n    await telemetry.save();\n    return;\n  }\n\n  // Confirm unless forced\n  if (!force && !quiet) {\n    const readline = await import('node:readline');\n    const rl = readline.createInterface({\n      input: process.stdin,\n      output: process.stdout,\n    });\n\n    const answer = await new Promise<string>((resolve) => {\n      rl.question('\\nProceed with deletion? [y/N] ', (ans) => {\n        rl.close();\n        resolve(ans);\n      });\n    });\n\n    if (answer.toLowerCase() !== 'y' && answer.toLowerCase() !== 'yes') {\n      console.log('Aborted.');\n      telemetry.trackCommandEnd(eventId, true, { aborted: true });\n      await telemetry.save();\n      return;\n    }\n  }\n\n  // Delete\n  const deleted: string[] = [];\n  const errors: string[] = [];\n\n  for (const artifact of toDelete) {\n    try {\n      rmSync(artifact.path, { recursive: true });\n      deleted.push(artifact.path);\n    } catch (e) {\n      errors.push(`Failed to delete ${artifact.path}: ${e}`);\n    }\n  }\n\n  // Report\n  if (!quiet) {\n    console.log(`\\nDeleted ${deleted.length} item(s)`);\n    if (errors.length > 0) {\n      console.error('\\nErrors:');\n      for (const err of errors) {\n        console.error(`  ${err}`);\n      }\n    }\n  }\n\n  // Recreate empty directory structure if completely cleaned\n  if (toKeep.length === 0) {\n    await cleanAutogenArtifacts();\n    // Reset pipeline state to initial\n    await resetPipelineState();\n    if (!quiet) {\n      console.log('Recreated empty autogen directory.');\n      console.log('Reset pipeline state to initial.');\n    }\n  }\n\n  // Track command completion\n  telemetry.trackCommandEnd(eventId, errors.length === 0, {\n    deleted: deleted.length,\n    kept: toKeep.length,\n    errors: errors.length,\n    totalSize,\n    dryRun,\n  });\n  await telemetry.save();\n}\n","/**\n * CLI Validate Command - Validate generated test code\n * @see T095 - Create CLI entry point for validation\n */\nimport { parseArgs } from 'node:util';\nimport fg from 'fast-glob';\nimport { validateJourneys, type ValidateJourneyResult } from '../index.js';\n\nconst USAGE = `\nUsage: artk-autogen validate [options] <files...>\n\nValidate journey files or generated test code.\n\nArguments:\n  files    Journey files or test files to validate\n\nOptions:\n  --lint             Run ESLint checks (slower but more thorough)\n  --format <type>    Output format: text, json, or summary (default: text)\n  --strict           Fail on warnings too\n  -q, --quiet        Only show errors\n  -h, --help         Show this help message\n\nExamples:\n  artk-autogen validate journeys/login.md\n  artk-autogen validate \"journeys/*.md\" --lint\n  artk-autogen validate journeys/*.md --format json\n`;\n\nexport async function runValidate(args: string[]): Promise<void> {\n  const { values, positionals } = parseArgs({\n    args,\n    options: {\n      lint: { type: 'boolean', default: false },\n      format: { type: 'string', default: 'text' },\n      strict: { type: 'boolean', default: false },\n      quiet: { type: 'boolean', short: 'q', default: false },\n      help: { type: 'boolean', short: 'h', default: false },\n    },\n    allowPositionals: true,\n  });\n\n  if (values.help) {\n    console.log(USAGE);\n    return;\n  }\n\n  if (positionals.length === 0) {\n    console.error('Error: No files specified');\n    console.log(USAGE);\n    process.exit(1);\n  }\n\n  // Expand glob patterns\n  const files = await fg(positionals, {\n    absolute: true,\n  });\n\n  if (files.length === 0) {\n    console.error('Error: No files found matching the patterns');\n    process.exit(1);\n  }\n\n  if (!values.quiet && values.format === 'text') {\n    console.log(`Validating ${files.length} file(s)...`);\n  }\n\n  // Validate each file\n  const results = await validateJourneys(files, {\n    runLint: values.lint,\n  });\n\n  // Format output\n  if (values.format === 'json') {\n    const output: Record<string, ValidateJourneyResult> = {};\n    for (const [id, result] of results) {\n      output[id] = result;\n    }\n    console.log(JSON.stringify(output, null, 2));\n  } else if (values.format === 'summary') {\n    let totalErrors = 0;\n    let totalWarnings = 0;\n    let passed = 0;\n    let failed = 0;\n\n    for (const [, result] of results) {\n      totalErrors += result.counts.errors;\n      totalWarnings += result.counts.warnings;\n      if (result.valid) {\n        passed++;\n      } else {\n        failed++;\n      }\n    }\n\n    console.log(`\\nValidation Summary:`);\n    console.log(`  Passed: ${passed}`);\n    console.log(`  Failed: ${failed}`);\n    console.log(`  Total Errors: ${totalErrors}`);\n    console.log(`  Total Warnings: ${totalWarnings}`);\n  } else {\n    // Text format\n    for (const [journeyId, result] of results) {\n      const status = result.valid ? '' : '';\n      if (!values.quiet || !result.valid) {\n        console.log(`\\n${status} ${journeyId}`);\n      }\n\n      if (!result.valid || (result.counts.warnings > 0 && !values.quiet)) {\n        for (const issue of result.issues) {\n          const icon = issue.severity === 'error' ? '  ' : issue.severity === 'warning' ? '  ' : '  ';\n          if (!values.quiet || issue.severity === 'error') {\n            console.log(`${icon} [${issue.code}] ${issue.message}`);\n            if (issue.field) {\n              console.log(`    field: ${issue.field}`);\n            }\n            if (issue.suggestion) {\n              console.log(`     ${issue.suggestion}`);\n            }\n          }\n        }\n      }\n    }\n\n    // Summary\n    if (!values.quiet) {\n      let passed = 0;\n      let failed = 0;\n      for (const [, result] of results) {\n        if (result.valid) {\n          passed++;\n        } else {\n          failed++;\n        }\n      }\n      console.log(`\\n${passed} passed, ${failed} failed`);\n    }\n  }\n\n  // Determine exit code\n  let hasErrors = false;\n  let hasWarnings = false;\n  for (const [, result] of results) {\n    if (!result.valid) {\n      hasErrors = true;\n    }\n    if (result.counts.warnings > 0) {\n      hasWarnings = true;\n    }\n  }\n\n  if (hasErrors) {\n    process.exit(1);\n  }\n  if (values.strict && hasWarnings) {\n    process.exit(1);\n  }\n}\n","/**\n * CLI Verify Command - Run and verify generated tests\n * @see T096 - Create CLI entry point for verification\n */\nimport { parseArgs } from 'node:util';\nimport fg from 'fast-glob';\nimport { verifyJourneys, type VerifyJourneyResult } from '../index.js';\nimport { parseIntSafe } from '../utils/parsing.js';\n\nconst USAGE = `\nUsage: artk-autogen verify [options] <journey-files...>\n\nGenerate and run Playwright tests from Journey files to verify they work.\n\nArguments:\n  journey-files    Journey file paths or glob patterns\n\nOptions:\n  -o, --output <dir>       Output directory for generated tests\n  --heal                   Attempt to heal failing tests\n  --max-heal <n>           Maximum healing attempts (default: 3)\n  --stability              Run stability checks (repeat tests)\n  --stability-runs <n>     Number of stability runs (default: 3)\n  --format <type>          Output format: text, json (default: text)\n  --reporter <name>        Playwright reporter (default: list)\n  --timeout <ms>           Test timeout in milliseconds\n  -q, --quiet              Suppress output except errors\n  -h, --help               Show this help message\n\nExamples:\n  artk-autogen verify journeys/login.md\n  artk-autogen verify \"journeys/*.md\" --heal\n  artk-autogen verify journeys/login.md --stability --stability-runs 5\n`;\n\nexport async function runVerify(args: string[]): Promise<void> {\n  const { values, positionals } = parseArgs({\n    args,\n    options: {\n      output: { type: 'string', short: 'o' },\n      heal: { type: 'boolean', default: false },\n      'max-heal': { type: 'string', default: '3' },\n      stability: { type: 'boolean', default: false },\n      'stability-runs': { type: 'string', default: '3' },\n      format: { type: 'string', default: 'text' },\n      reporter: { type: 'string', default: 'list' },\n      timeout: { type: 'string' },\n      quiet: { type: 'boolean', short: 'q', default: false },\n      help: { type: 'boolean', short: 'h', default: false },\n    },\n    allowPositionals: true,\n  });\n\n  if (values.help) {\n    console.log(USAGE);\n    return;\n  }\n\n  if (positionals.length === 0) {\n    console.error('Error: No journey files specified');\n    console.log(USAGE);\n    process.exit(1);\n  }\n\n  // Expand glob patterns\n  const journeyFiles = await fg(positionals, {\n    absolute: true,\n  });\n\n  if (journeyFiles.length === 0) {\n    console.error('Error: No journey files found matching the patterns');\n    process.exit(1);\n  }\n\n  if (!values.quiet && values.format === 'text') {\n    console.log(`Verifying ${journeyFiles.length} journey(s)...`);\n  }\n\n  // Verify each journey\n  const results = await verifyJourneys(journeyFiles, {\n    outputDir: values.output,\n    heal: values.heal,\n    maxHealAttempts: parseIntSafe(values['max-heal'], 'max-heal', 3),\n    checkStability: values.stability,\n    stabilityRuns: parseIntSafe(values['stability-runs'], 'stability-runs', 3),\n    reporter: values.reporter,\n    timeout: values.timeout ? parseIntSafe(values.timeout, 'timeout', 30000) : undefined,\n  });\n\n  // Format output\n  if (values.format === 'json') {\n    const output: Record<string, VerifyJourneyResult> = {};\n    for (const [id, result] of results) {\n      output[id] = result;\n    }\n    console.log(JSON.stringify(output, null, 2));\n  } else {\n    // Text format\n    for (const [journeyId, result] of results) {\n      const statusIcon = result.status === 'passed' ? '' : result.status === 'failed' ? '' : '';\n\n      if (!values.quiet || result.status !== 'passed') {\n        console.log(`\\n${statusIcon} ${journeyId}`);\n        console.log(`  Status: ${result.status}`);\n        console.log(`  Duration: ${result.duration}ms`);\n        console.log(`  Tests: ${result.counts.passed}/${result.counts.total} passed`);\n\n        if (result.counts.flaky > 0) {\n          console.log(`  Flaky: ${result.counts.flaky}`);\n        }\n\n        if (result.healing) {\n          console.log(`  Healing:`);\n          console.log(`    Attempted: ${result.healing.attempted}`);\n          console.log(`    Success: ${result.healing.success}`);\n          console.log(`    Attempts: ${result.healing.attempts}`);\n          if (result.healing.appliedFix) {\n            console.log(`    Applied: ${result.healing.appliedFix}`);\n          }\n        }\n\n        if (result.failures.tests.length > 0) {\n          console.log(`  Failures:`);\n          for (const testName of result.failures.tests.slice(0, 5)) {\n            const classification = result.failures.classifications[testName];\n            console.log(`    - ${testName}`);\n            if (classification) {\n              console.log(`      ${classification.category}: ${classification.explanation.substring(0, 100)}`);\n            }\n          }\n          if (result.failures.tests.length > 5) {\n            console.log(`    ... and ${result.failures.tests.length - 5} more`);\n          }\n        }\n\n        if (result.testFilePath && !values.quiet) {\n          console.log(`  Test file: ${result.testFilePath}`);\n        }\n      }\n    }\n\n    // Summary\n    if (!values.quiet) {\n      let passed = 0;\n      let failed = 0;\n      let healed = 0;\n\n      for (const [, result] of results) {\n        if (result.status === 'passed') {\n          passed++;\n        } else {\n          failed++;\n        }\n        if (result.healing?.success) {\n          healed++;\n        }\n      }\n\n      console.log(`\\nSummary:`);\n      console.log(`  Passed: ${passed}`);\n      console.log(`  Failed: ${failed}`);\n      if (healed > 0) {\n        console.log(`  Healed: ${healed}`);\n      }\n    }\n  }\n\n  // Determine exit code\n  let hasFailures = false;\n  for (const [, result] of results) {\n    if (result.status === 'failed' || result.status === 'error') {\n      hasFailures = true;\n      break;\n    }\n  }\n\n  if (hasFailures) {\n    process.exit(1);\n  }\n}\n","import { parseArgs } from 'node:util';\nimport { installAutogenInstance } from '../instance/install.js';\n\nexport async function runInstall(args: string[]): Promise<void> {\n  const { values } = parseArgs({\n    args,\n    options: {\n      dir: { type: 'string', short: 'd', default: '.' },\n      name: { type: 'string', short: 'n' },\n      'base-url': { type: 'string' },\n      'skip-existing': { type: 'boolean', default: false },\n      'no-example': { type: 'boolean', default: false },\n      force: { type: 'boolean', short: 'f', default: false },\n    },\n    allowPositionals: true,\n  });\n\n  console.log('Installing ARTK autogen...\\n');\n\n  const result = await installAutogenInstance({\n    rootDir: values.dir as string,\n    projectName: values.name as string | undefined,\n    baseUrl: values['base-url'] as string | undefined,\n    skipIfExists: values['skip-existing'] as boolean,\n    includeExample: !values['no-example'],\n    force: values.force as boolean,\n  });\n\n  if (result.success) {\n    console.log(' Installation complete\\n');\n\n    if (result.created.length > 0) {\n      console.log('Created:');\n      for (const path of result.created) {\n        console.log(`  + ${path}`);\n      }\n    }\n\n    if (result.skipped.length > 0) {\n      console.log('\\nSkipped (already exists):');\n      for (const path of result.skipped) {\n        console.log(`  - ${path}`);\n      }\n    }\n\n    console.log('\\nNext steps:');\n    console.log('  1. Edit autogen.config.yml with your project settings');\n    console.log('  2. Create Journeys in journeys/ directory');\n    console.log('  3. Run: npx artk-autogen generate <journey.md>');\n  } else {\n    console.error(' Installation failed:\\n');\n    for (const error of result.errors) {\n      console.error(`  ${error}`);\n    }\n    process.exit(1);\n  }\n}\n","import { parseArgs } from 'node:util';\nimport { upgradeAutogenInstance } from '../instance/upgrade.js';\n\nexport async function runUpgrade(args: string[]): Promise<void> {\n  const { values } = parseArgs({\n    args,\n    options: {\n      dir: { type: 'string', short: 'd', default: '.' },\n      'dry-run': { type: 'boolean', default: false },\n      'no-backup': { type: 'boolean', default: false },\n    },\n    allowPositionals: true,\n  });\n\n  console.log('Upgrading ARTK autogen...\\n');\n\n  const result = await upgradeAutogenInstance({\n    rootDir: values.dir as string,\n    dryRun: values['dry-run'] as boolean,\n    backup: !values['no-backup'],\n  });\n\n  if (values['dry-run']) {\n    console.log('[DRY RUN] No changes written\\n');\n  }\n\n  console.log(`Version: ${result.fromVersion}  ${result.toVersion}\\n`);\n\n  if (result.changes.length > 0) {\n    console.log('Changes:');\n    for (const change of result.changes) {\n      console.log(`  ${change.description}`);\n      console.log(`     ${change.path}`);\n    }\n  }\n\n  if (result.backupPath) {\n    console.log(`\\nBackup: ${result.backupPath}`);\n  }\n\n  if (!result.success) {\n    console.error('\\n Upgrade failed:');\n    for (const error of result.errors) {\n      console.error(`  ${error}`);\n    }\n    process.exit(1);\n  }\n\n  console.log('\\n Upgrade complete');\n}\n","/**\n * LLKB Pattern Promotion - Automated promotion of learned patterns to higher tiers\n * Implements the learning loop that improves coverage over time\n *\n * @see research/2026-02-03_multi-ai-debate-coverage-improvement.md\n */\nimport { existsSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { join, dirname } from 'node:path';\nimport {\n  loadLearnedPatterns,\n  saveLearnedPatterns,\n  generateRegexFromText,\n  type LearnedPattern,\n} from './patternExtension.js';\nimport { getLlkbRoot } from '../utils/paths.js';\nimport type { IRPrimitive } from '../ir/types.js';\n\n/**\n * Promotion criteria configuration\n */\nexport interface PromotionCriteria {\n  /** Minimum confidence score (default: 0.9) */\n  minConfidence: number;\n  /** Minimum number of successful uses (default: 5) */\n  minSuccessCount: number;\n  /** Minimum number of unique source journeys (default: 2) */\n  minSourceJourneys: number;\n  /** Maximum fail count allowed (default: 2) */\n  maxFailCount: number;\n  /** Minimum success rate (default: 0.85) */\n  minSuccessRate: number;\n}\n\n/**\n * Default promotion criteria\n */\nexport const DEFAULT_PROMOTION_CRITERIA: PromotionCriteria = {\n  minConfidence: 0.9,\n  minSuccessCount: 5,\n  minSourceJourneys: 2,\n  maxFailCount: 2,\n  minSuccessRate: 0.85,\n};\n\n/**\n * A promoted pattern ready for code generation\n */\nexport interface PromotedPatternDefinition {\n  /** Pattern name for the code */\n  name: string;\n  /** The regex pattern */\n  regex: string;\n  /** The IR primitive type */\n  primitiveType: IRPrimitive['type'];\n  /** Example step text */\n  example: string;\n  /** Extraction logic description */\n  extractionLogic: string;\n  /** Source LLKB pattern ID */\n  llkbPatternId: string;\n  /** Confidence at promotion time */\n  confidenceAtPromotion: number;\n  /** Source journeys count */\n  sourceJourneysCount: number;\n  /** Promotion timestamp */\n  promotedAt: string;\n}\n\n/**\n * Promotion report\n */\nexport interface PromotionReport {\n  /** Timestamp of the analysis */\n  analyzedAt: string;\n  /** Total patterns analyzed */\n  totalPatterns: number;\n  /** Patterns that meet promotion criteria */\n  promotablePatterns: PromotedPatternDefinition[];\n  /** Patterns that are close to promotion (need more data) */\n  nearPromotionPatterns: Array<{\n    pattern: LearnedPattern;\n    missingCriteria: string[];\n    estimatedUsesNeeded: number;\n  }>;\n  /** Statistics */\n  stats: {\n    alreadyPromoted: number;\n    eligibleForPromotion: number;\n    nearPromotion: number;\n    needsMoreData: number;\n  };\n}\n\n/**\n * Generate a pattern name from step text\n */\nfunction generatePatternName(text: string, primitiveType: string): string {\n  // Clean the text and extract key words\n  const words = text\n    .toLowerCase()\n    .replace(/[\"']/g, '')\n    .split(/\\s+/)\n    .filter(w => w.length > 2)\n    .slice(0, 4);\n\n  // Create camelCase name\n  const baseName = words\n    .map((w, i) => (i === 0 ? w : w.charAt(0).toUpperCase() + w.slice(1)))\n    .join('');\n\n  return `llkb-${primitiveType}-${baseName}`;\n}\n\n/**\n * Generate extraction logic description from primitive\n */\nfunction generateExtractionLogic(primitive: IRPrimitive): string {\n  const type = primitive.type;\n\n  switch (type) {\n    case 'click':\n    case 'dblclick':\n    case 'rightClick':\n    case 'hover':\n    case 'focus':\n    case 'clear':\n    case 'check':\n    case 'uncheck':\n      return `Extract locator from match groups, return { type: '${type}', locator: { strategy, value } }`;\n    case 'fill':\n      return `Extract locator and value from match groups, return { type: 'fill', locator, value: { type: 'literal', value } }`;\n    case 'goto':\n      return `Extract URL/path from match groups, return { type: 'goto', url }`;\n    case 'expectVisible':\n    case 'expectNotVisible':\n    case 'expectHidden':\n    case 'expectEnabled':\n    case 'expectDisabled':\n      return `Extract locator from match groups, return { type: '${type}', locator }`;\n    case 'expectText':\n    case 'expectContainsText':\n      return `Extract locator and text from match groups, return { type: '${type}', locator, text }`;\n    case 'waitForTimeout':\n      return `Extract milliseconds from match groups, return { type: 'waitForTimeout', ms }`;\n    case 'waitForNetworkIdle':\n      return `Return { type: 'waitForNetworkIdle' }`;\n    case 'waitForVisible':\n    case 'waitForHidden':\n      return `Extract locator from match groups, return { type: '${type}', locator }`;\n    case 'select':\n      return `Extract locator and option from match groups, return { type: 'select', locator, option }`;\n    case 'press':\n      return `Extract key from match groups, return { type: 'press', key }`;\n    default:\n      return `Extract parameters from match groups, return primitive`;\n  }\n}\n\n/**\n * Check if a pattern meets promotion criteria\n */\nexport function meetsPromotionCriteria(\n  pattern: LearnedPattern,\n  criteria: PromotionCriteria = DEFAULT_PROMOTION_CRITERIA\n): { meets: boolean; missingCriteria: string[] } {\n  const missingCriteria: string[] = [];\n\n  if (pattern.confidence < criteria.minConfidence) {\n    missingCriteria.push(`confidence: ${(pattern.confidence * 100).toFixed(1)}% < ${(criteria.minConfidence * 100).toFixed(1)}%`);\n  }\n\n  if (pattern.successCount < criteria.minSuccessCount) {\n    missingCriteria.push(`successCount: ${pattern.successCount} < ${criteria.minSuccessCount}`);\n  }\n\n  if (pattern.sourceJourneys.length < criteria.minSourceJourneys) {\n    missingCriteria.push(`sourceJourneys: ${pattern.sourceJourneys.length} < ${criteria.minSourceJourneys}`);\n  }\n\n  if (pattern.failCount > criteria.maxFailCount) {\n    missingCriteria.push(`failCount: ${pattern.failCount} > ${criteria.maxFailCount}`);\n  }\n\n  const successRate = pattern.successCount / (pattern.successCount + pattern.failCount || 1);\n  if (successRate < criteria.minSuccessRate) {\n    missingCriteria.push(`successRate: ${(successRate * 100).toFixed(1)}% < ${(criteria.minSuccessRate * 100).toFixed(1)}%`);\n  }\n\n  return {\n    meets: missingCriteria.length === 0,\n    missingCriteria,\n  };\n}\n\n/**\n * Estimate how many more uses needed for promotion\n */\nfunction estimateUsesNeeded(\n  pattern: LearnedPattern,\n  criteria: PromotionCriteria\n): number {\n  const needed: number[] = [];\n\n  // Success count needed\n  if (pattern.successCount < criteria.minSuccessCount) {\n    needed.push(criteria.minSuccessCount - pattern.successCount);\n  }\n\n  // Confidence needed (rough estimate)\n  if (pattern.confidence < criteria.minConfidence) {\n    // Estimate successes needed to reach target confidence\n    // Using simplified Wilson score approximation\n    const targetSuccesses = Math.ceil(\n      criteria.minSuccessCount * (1 + pattern.failCount / 5)\n    );\n    needed.push(Math.max(0, targetSuccesses - pattern.successCount));\n  }\n\n  return Math.max(...needed, 1);\n}\n\n/**\n * Analyze patterns and generate promotion report\n */\nexport function analyzeForPromotion(options: {\n  llkbRoot?: string;\n  criteria?: Partial<PromotionCriteria>;\n}): PromotionReport {\n  const criteria: PromotionCriteria = {\n    ...DEFAULT_PROMOTION_CRITERIA,\n    ...options.criteria,\n  };\n\n  const patterns = loadLearnedPatterns({ llkbRoot: options.llkbRoot });\n\n  const promotablePatterns: PromotedPatternDefinition[] = [];\n  const nearPromotionPatterns: PromotionReport['nearPromotionPatterns'] = [];\n\n  let alreadyPromoted = 0;\n  let needsMoreData = 0;\n\n  for (const pattern of patterns) {\n    if (pattern.promotedToCore) {\n      alreadyPromoted++;\n      continue;\n    }\n\n    const { meets, missingCriteria } = meetsPromotionCriteria(pattern, criteria);\n\n    if (meets) {\n      // Pattern is ready for promotion\n      promotablePatterns.push({\n        name: generatePatternName(pattern.originalText, pattern.mappedPrimitive.type),\n        regex: generateRegexFromText(pattern.originalText),\n        primitiveType: pattern.mappedPrimitive.type,\n        example: pattern.originalText,\n        extractionLogic: generateExtractionLogic(pattern.mappedPrimitive),\n        llkbPatternId: pattern.id,\n        confidenceAtPromotion: pattern.confidence,\n        sourceJourneysCount: pattern.sourceJourneys.length,\n        promotedAt: new Date().toISOString(),\n      });\n    } else if (missingCriteria.length <= 2 && pattern.successCount >= 2) {\n      // Pattern is close to promotion\n      nearPromotionPatterns.push({\n        pattern,\n        missingCriteria,\n        estimatedUsesNeeded: estimateUsesNeeded(pattern, criteria),\n      });\n    } else {\n      needsMoreData++;\n    }\n  }\n\n  return {\n    analyzedAt: new Date().toISOString(),\n    totalPatterns: patterns.length,\n    promotablePatterns,\n    nearPromotionPatterns,\n    stats: {\n      alreadyPromoted,\n      eligibleForPromotion: promotablePatterns.length,\n      nearPromotion: nearPromotionPatterns.length,\n      needsMoreData,\n    },\n  };\n}\n\n/**\n * Generate TypeScript code for promoted patterns\n */\nexport function generatePromotedPatternsCode(\n  patterns: PromotedPatternDefinition[]\n): string {\n  if (patterns.length === 0) {\n    return '// No patterns ready for promotion\\n';\n  }\n\n  const lines: string[] = [\n    '/**',\n    ' * LLKB-Promoted Patterns',\n    ` * Generated at: ${new Date().toISOString()}`,\n    ' * Review and merge into patterns.ts after validation',\n    ' */',\n    '',\n    \"import type { StepPattern } from './patterns.js';\",\n    '',\n    'export const llkbPromotedPatterns: StepPattern[] = [',\n  ];\n\n  for (const pattern of patterns) {\n    lines.push('  {');\n    lines.push(`    name: '${pattern.name}',`);\n    lines.push(`    regex: /${pattern.regex}/i,`);\n    lines.push(`    primitiveType: '${pattern.primitiveType}',`);\n    lines.push('    extract: (match: RegExpMatchArray) => {');\n    lines.push(`      // ${pattern.extractionLogic}`);\n    lines.push(`      // Example: \"${pattern.example}\"`);\n    lines.push(`      // LLKB Pattern ID: ${pattern.llkbPatternId}`);\n    lines.push(`      // Confidence at promotion: ${(pattern.confidenceAtPromotion * 100).toFixed(1)}%`);\n    // Generate actual JavaScript code, not JSON\n    lines.push(`      ${generateExtractorCode(pattern.primitiveType)}`);\n    lines.push('    },');\n    lines.push('  },');\n  }\n\n  lines.push('];');\n  lines.push('');\n\n  return lines.join('\\n');\n}\n\n/**\n * Generate JavaScript extractor code for a primitive type\n * Returns actual executable code, not JSON-serialized strings\n */\nfunction generateExtractorCode(type: IRPrimitive['type']): string {\n  switch (type) {\n    case 'click':\n    case 'dblclick':\n    case 'rightClick':\n    case 'hover':\n    case 'focus':\n    case 'clear':\n    case 'check':\n    case 'uncheck':\n      return `return { type: '${type}', locator: { strategy: 'text', value: match[1] || 'element' } };`;\n\n    case 'fill':\n      return `return { type: 'fill', locator: { strategy: 'text', value: match[1] || 'field' }, value: { type: 'literal', value: match[2] || '' } };`;\n\n    case 'goto':\n      return `return { type: 'goto', url: match[1] || '/' };`;\n\n    case 'expectVisible':\n    case 'expectNotVisible':\n    case 'expectHidden':\n    case 'expectEnabled':\n    case 'expectDisabled':\n    case 'waitForVisible':\n    case 'waitForHidden':\n      return `return { type: '${type}', locator: { strategy: 'text', value: match[1] || 'element' } };`;\n\n    case 'expectText':\n    case 'expectContainsText':\n      return `return { type: '${type}', locator: { strategy: 'text', value: match[1] || 'element' }, text: match[2] || '' };`;\n\n    case 'waitForTimeout':\n      return `return { type: 'waitForTimeout', ms: parseInt(match[1], 10) || 1000 };`;\n\n    case 'waitForNetworkIdle':\n      return `return { type: 'waitForNetworkIdle' };`;\n\n    case 'select':\n      return `return { type: 'select', locator: { strategy: 'text', value: match[1] || 'dropdown' }, option: match[2] || '' };`;\n\n    case 'press':\n      return `return { type: 'press', key: match[1] || 'Enter' };`;\n\n    default:\n      return `return { type: 'blocked', reason: 'Unknown type: ${type}', sourceText: match[0] || '' };`;\n  }\n}\n\n/**\n * Export promotion report to file\n */\nexport function exportPromotionReport(\n  report: PromotionReport,\n  options: { outputDir?: string; llkbRoot?: string }\n): { reportPath: string; codePath?: string } {\n  const outputDir = options.outputDir || dirname(getLlkbRoot(options.llkbRoot));\n\n  if (!existsSync(outputDir)) {\n    mkdirSync(outputDir, { recursive: true });\n  }\n\n  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n\n  // Write JSON report\n  const reportPath = join(outputDir, `promotion-report-${timestamp}.json`);\n  writeFileSync(reportPath, JSON.stringify(report, null, 2), 'utf-8');\n\n  // Write TypeScript code if there are promotable patterns\n  let codePath: string | undefined;\n  if (report.promotablePatterns.length > 0) {\n    codePath = join(outputDir, `llkb-promoted-patterns-${timestamp}.ts`);\n    const code = generatePromotedPatternsCode(report.promotablePatterns);\n    writeFileSync(codePath, code, 'utf-8');\n  }\n\n  return { reportPath, codePath };\n}\n\n/**\n * Promote patterns and update LLKB storage\n */\nexport function promotePatterns(options: {\n  llkbRoot?: string;\n  patternIds?: string[];\n  criteria?: Partial<PromotionCriteria>;\n}): {\n  promoted: string[];\n  skipped: string[];\n} {\n  const patterns = loadLearnedPatterns({ llkbRoot: options.llkbRoot });\n  const criteria: PromotionCriteria = {\n    ...DEFAULT_PROMOTION_CRITERIA,\n    ...options.criteria,\n  };\n\n  const promoted: string[] = [];\n  const skipped: string[] = [];\n  const now = new Date().toISOString();\n\n  for (const pattern of patterns) {\n    // Skip if already promoted\n    if (pattern.promotedToCore) {\n      continue;\n    }\n\n    // If specific IDs provided, only process those\n    if (options.patternIds && !options.patternIds.includes(pattern.id)) {\n      continue;\n    }\n\n    const { meets } = meetsPromotionCriteria(pattern, criteria);\n\n    if (meets) {\n      pattern.promotedToCore = true;\n      pattern.promotedAt = now;\n      promoted.push(pattern.id);\n    } else {\n      skipped.push(pattern.id);\n    }\n  }\n\n  if (promoted.length > 0) {\n    saveLearnedPatterns(patterns, { llkbRoot: options.llkbRoot });\n  }\n\n  return { promoted, skipped };\n}\n\n/**\n * Get promotion summary statistics\n */\nexport function getPromotionStats(options: { llkbRoot?: string }): {\n  total: number;\n  promoted: number;\n  promotable: number;\n  nearPromotion: number;\n  needsWork: number;\n  promotionRate: number;\n} {\n  const report = analyzeForPromotion(options);\n\n  return {\n    total: report.totalPatterns,\n    promoted: report.stats.alreadyPromoted,\n    promotable: report.stats.eligibleForPromotion,\n    nearPromotion: report.stats.nearPromotion,\n    needsWork: report.stats.needsMoreData,\n    promotionRate: report.totalPatterns > 0\n      ? (report.stats.alreadyPromoted + report.stats.eligibleForPromotion) / report.totalPatterns\n      : 0,\n  };\n}\n","/**\n * ARTK AutoGen CLI - Pattern Analysis Command\n * Analyzes blocked step telemetry to identify pattern gaps\n *\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md Phase 3\n * @see research/2026-02-03_multi-ai-debate-coverage-improvement.md\n */\nimport { parseArgs } from 'node:util';\nimport { createInterface } from 'node:readline';\nimport {\n  analyzeBlockedPatterns,\n  getTelemetryStats,\n  readBlockedStepRecords,\n  clearTelemetry,\n  type PatternGap,\n  type TelemetryStats,\n} from '../mapping/telemetry.js';\nimport { PATTERN_VERSION, getAllPatternNames } from '../mapping/patterns.js';\nimport {\n  analyzePatternGaps,\n  suggestNewPatterns,\n} from '../shared/blocked-step-telemetry.js';\nimport {\n  analyzeForPromotion,\n  exportPromotionReport,\n  getPromotionStats,\n} from '../llkb/patternPromotion.js';\nimport { getPatternStats } from '../llkb/patternExtension.js';\n\nconst PATTERNS_USAGE = `\nUsage: artk-autogen patterns <subcommand> [options]\n\nSubcommands:\n  gaps        Analyze blocked steps and show pattern gaps\n  suggest     Generate suggested patterns from telemetry (with regex)\n  stats       Show telemetry statistics (combined: telemetry + LLKB)\n  list        List all available patterns\n  promotion   Show LLKB pattern promotion status and candidates\n  export      Export gaps as JSON for pattern development\n  clear       Clear telemetry data (use with caution)\n\nOptions:\n  --dir, -d <path>    Base directory (default: current directory)\n  --limit, -n <num>   Limit number of results (default: 20)\n  --json              Output as JSON\n  --category, -c      Filter by category (navigation|interaction|assertion|wait|unknown)\n  --force, -f         Skip confirmation prompts (for clear command)\n  --output, -o        Output directory for promotion reports\n  -h, --help          Show this help message\n\nExamples:\n  artk-autogen patterns gaps                    # Show top 20 pattern gaps\n  artk-autogen patterns gaps --limit 50         # Show top 50 pattern gaps\n  artk-autogen patterns suggest                 # Get suggested patterns with regex\n  artk-autogen patterns suggest --json          # Get suggestions as JSON\n  artk-autogen patterns stats                   # Show combined statistics\n  artk-autogen patterns promotion               # Show LLKB promotion candidates\n  artk-autogen patterns promotion --json        # Export promotion report\n  artk-autogen patterns list                    # List all patterns\n  artk-autogen patterns export --json           # Export gaps as JSON\n  artk-autogen patterns clear                   # Clear telemetry (with confirmation)\n`;\n\n/**\n * Format a pattern gap for console output\n */\nfunction formatPatternGap(gap: PatternGap, index: number): string {\n  const lines: string[] = [];\n  lines.push(`  ${index + 1}. [${gap.count}x] \"${gap.exampleText}\"`);\n  lines.push(`     Category: ${gap.category}`);\n  lines.push(`     First seen: ${new Date(gap.firstSeen).toLocaleDateString()}`);\n\n  if (gap.variants.length > 1) {\n    lines.push(`     Variants: ${gap.variants.length} unique phrasings`);\n    // Show first 3 variants\n    for (const variant of gap.variants.slice(0, 3)) {\n      if (variant !== gap.exampleText) {\n        lines.push(`       - \"${variant}\"`);\n      }\n    }\n    if (gap.variants.length > 3) {\n      lines.push(`       ... and ${gap.variants.length - 3} more`);\n    }\n  }\n\n  if (gap.suggestedPattern) {\n    lines.push(`     Suggested pattern: ${gap.suggestedPattern}`);\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Format telemetry stats for console output\n */\nfunction formatStats(stats: TelemetryStats): string {\n  const lines: string[] = [];\n  lines.push('\\n Blocked Steps Telemetry Statistics\\n');\n  lines.push(`  Total Records: ${stats.totalRecords}`);\n  lines.push(`  Unique Patterns: ${stats.uniquePatterns}`);\n\n  if (stats.totalRecords > 0) {\n    lines.push('\\n  By Category:');\n    for (const [category, count] of Object.entries(stats.byCategory)) {\n      const percentage = ((count / stats.totalRecords) * 100).toFixed(1);\n      lines.push(`    ${category}: ${count} (${percentage}%)`);\n    }\n\n    lines.push('\\n  Date Range:');\n    lines.push(`    Earliest: ${new Date(stats.dateRange.earliest).toLocaleString()}`);\n    lines.push(`    Latest: ${new Date(stats.dateRange.latest).toLocaleString()}`);\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Run the patterns gaps subcommand\n */\nasync function runGaps(options: {\n  baseDir?: string;\n  limit: number;\n  json: boolean;\n  category?: string;\n}): Promise<void> {\n  let gaps = analyzeBlockedPatterns({\n    baseDir: options.baseDir,\n    limit: options.category ? undefined : options.limit, // Don't limit before filtering\n  });\n\n  // Filter by category if specified\n  if (options.category) {\n    gaps = gaps.filter((g) => g.category.toLowerCase().includes(options.category!.toLowerCase()));\n    gaps = gaps.slice(0, options.limit);\n  }\n\n  if (gaps.length === 0) {\n    console.log('\\n No blocked step gaps found. Either no blocked steps have been recorded,');\n    console.log('   or all steps have been successfully matched to patterns.\\n');\n    return;\n  }\n\n  if (options.json) {\n    console.log(JSON.stringify(gaps, null, 2));\n    return;\n  }\n\n  console.log(`\\n Top ${gaps.length} Pattern Gaps (from blocked steps)\\n`);\n  console.log(`Pattern Version: ${PATTERN_VERSION}\\n`);\n\n  for (let i = 0; i < gaps.length; i++) {\n    console.log(formatPatternGap(gaps[i]!, i));\n    console.log();\n  }\n\n  console.log(' To add these patterns, edit: autogen/src/mapping/patterns.ts');\n  console.log('   Use the suggested patterns as starting points.\\n');\n}\n\n/**\n * Run the patterns list subcommand\n */\nasync function runList(options: { json: boolean }): Promise<void> {\n  const patternNames = getAllPatternNames();\n\n  if (options.json) {\n    console.log(\n      JSON.stringify(\n        {\n          version: PATTERN_VERSION,\n          count: patternNames.length,\n          patterns: patternNames,\n        },\n        null,\n        2\n      )\n    );\n    return;\n  }\n\n  console.log(`\\n Available Patterns (v${PATTERN_VERSION})\\n`);\n  console.log(`Total: ${patternNames.length} patterns\\n`);\n\n  // Group by category\n  const groups: Record<string, string[]> = {};\n  for (const name of patternNames) {\n    const category = name.split('-')[0] || 'other';\n    if (!groups[category]) {\n      groups[category] = [];\n    }\n    groups[category].push(name);\n  }\n\n  for (const [category, names] of Object.entries(groups).sort()) {\n    console.log(`  ${category}:`);\n    for (const name of names) {\n      console.log(`    - ${name}`);\n    }\n    console.log();\n  }\n}\n\n/**\n * Run the patterns export subcommand\n */\nasync function runExport(options: { baseDir?: string }): Promise<void> {\n  const gaps = analyzeBlockedPatterns({ baseDir: options.baseDir });\n  const stats = getTelemetryStats({ baseDir: options.baseDir });\n  const records = readBlockedStepRecords({ baseDir: options.baseDir });\n\n  const exportData = {\n    exportedAt: new Date().toISOString(),\n    patternVersion: PATTERN_VERSION,\n    statistics: stats,\n    gaps,\n    rawRecords: records,\n  };\n\n  console.log(JSON.stringify(exportData, null, 2));\n}\n\n/**\n * Prompt user for confirmation\n */\nasync function confirmAction(message: string): Promise<boolean> {\n  const rl = createInterface({\n    input: process.stdin,\n    output: process.stdout,\n  });\n\n  return new Promise((resolve) => {\n    rl.question(`${message} (y/N): `, (answer) => {\n      rl.close();\n      resolve(answer.toLowerCase() === 'y' || answer.toLowerCase() === 'yes');\n    });\n  });\n}\n\n/**\n * Run the patterns clear subcommand\n */\nasync function runClear(options: { baseDir?: string; force?: boolean }): Promise<void> {\n  const stats = getTelemetryStats({ baseDir: options.baseDir });\n\n  if (stats.totalRecords === 0) {\n    console.log('\\n No telemetry data to clear.\\n');\n    return;\n  }\n\n  console.log(`\\n  This will delete ${stats.totalRecords} blocked step records.`);\n  console.log('   This action cannot be undone.\\n');\n\n  // Require confirmation unless --force is specified\n  if (!options.force) {\n    const confirmed = await confirmAction('Are you sure you want to proceed?');\n    if (!confirmed) {\n      console.log('Operation cancelled.\\n');\n      return;\n    }\n  }\n\n  clearTelemetry({ baseDir: options.baseDir });\n  console.log(' Telemetry data cleared.\\n');\n}\n\n/**\n * Run the patterns suggest subcommand\n */\nasync function runSuggest(options: { json: boolean; limit: number }): Promise<void> {\n  const suggestions = suggestNewPatterns();\n\n  if (suggestions.length === 0) {\n    console.log('\\n No pattern suggestions available.');\n    console.log('   Record more blocked steps to generate suggestions.\\n');\n    return;\n  }\n\n  const limitedSuggestions = suggestions.slice(0, options.limit);\n\n  if (options.json) {\n    console.log(JSON.stringify(limitedSuggestions, null, 2));\n    return;\n  }\n\n  console.log(`\\n Suggested New Patterns (${limitedSuggestions.length} of ${suggestions.length})\\n`);\n  console.log('These patterns are generated from frequently blocked steps:\\n');\n\n  for (let i = 0; i < limitedSuggestions.length; i++) {\n    const suggestion = limitedSuggestions[i]!;\n    console.log(`  ${i + 1}. Pattern (${suggestion.coveredCount}x blocked)`);\n    console.log(`     Regex: ${suggestion.suggestedRegex}`);\n    console.log(`     Confidence: ${(suggestion.confidence * 100).toFixed(0)}%`);\n    if (suggestion.examples.length > 0) {\n      console.log('     Examples:');\n      for (const example of suggestion.examples.slice(0, 3)) {\n        console.log(`       - \"${example}\"`);\n      }\n    }\n    console.log();\n  }\n\n  console.log(' Review these patterns and add validated ones to patterns.ts\\n');\n}\n\n/**\n * Run the patterns promotion subcommand\n */\nasync function runPromotion(options: {\n  baseDir?: string;\n  json: boolean;\n  outputDir?: string;\n}): Promise<void> {\n  // Get LLKB stats\n  let llkbStats;\n  try {\n    llkbStats = getPatternStats({ llkbRoot: options.baseDir });\n  } catch {\n    llkbStats = null;\n  }\n\n  // Analyze for promotion\n  let report;\n  try {\n    report = analyzeForPromotion({ llkbRoot: options.baseDir });\n  } catch {\n    report = null;\n  }\n\n  if (options.json) {\n    console.log(JSON.stringify({\n      llkbStats,\n      promotionReport: report,\n    }, null, 2));\n    return;\n  }\n\n  console.log('\\n LLKB Pattern Promotion Status\\n');\n\n  if (!llkbStats || llkbStats.total === 0) {\n    console.log('  No LLKB patterns recorded yet.');\n    console.log('  Patterns are learned as tests are run and refined.\\n');\n    return;\n  }\n\n  console.log('  LLKB Statistics:');\n  console.log(`    Total learned patterns: ${llkbStats.total}`);\n  console.log(`    Already promoted: ${llkbStats.promoted}`);\n  console.log(`    High confidence (0.7): ${llkbStats.highConfidence}`);\n  console.log(`    Low confidence (<0.3): ${llkbStats.lowConfidence}`);\n  console.log(`    Average confidence: ${(llkbStats.avgConfidence * 100).toFixed(1)}%`);\n  console.log(`    Total successes: ${llkbStats.totalSuccesses}`);\n  console.log(`    Total failures: ${llkbStats.totalFailures}\\n`);\n\n  if (report) {\n    const stats = getPromotionStats({ llkbRoot: options.baseDir });\n\n    console.log('  Promotion Analysis:');\n    console.log(`    Eligible for promotion: ${stats.promotable}`);\n    console.log(`    Near promotion (need more data): ${stats.nearPromotion}`);\n    console.log(`    Need more work: ${stats.needsWork}`);\n    console.log(`    Overall promotion rate: ${(stats.promotionRate * 100).toFixed(1)}%\\n`);\n\n    if (report.promotablePatterns.length > 0) {\n      console.log('   Patterns Ready for Promotion:\\n');\n      for (const pattern of report.promotablePatterns.slice(0, 5)) {\n        console.log(`    - ${pattern.name}`);\n        console.log(`      Regex: ${pattern.regex}`);\n        console.log(`      Type: ${pattern.primitiveType}`);\n        console.log(`      Confidence: ${(pattern.confidenceAtPromotion * 100).toFixed(1)}%`);\n        console.log(`      Example: \"${pattern.example}\"\\n`);\n      }\n\n      if (report.promotablePatterns.length > 5) {\n        console.log(`    ... and ${report.promotablePatterns.length - 5} more patterns\\n`);\n      }\n\n      if (options.outputDir) {\n        const { reportPath, codePath } = exportPromotionReport(report, { outputDir: options.outputDir });\n        console.log(`   Exported promotion report to: ${reportPath}`);\n        if (codePath) {\n          console.log(`   Exported TypeScript code to: ${codePath}`);\n        }\n        console.log();\n      }\n    }\n\n    if (report.nearPromotionPatterns.length > 0) {\n      console.log('   Patterns Near Promotion:\\n');\n      for (const near of report.nearPromotionPatterns.slice(0, 3)) {\n        console.log(`    - \"${near.pattern.originalText}\"`);\n        console.log(`      Missing: ${near.missingCriteria.join(', ')}`);\n        console.log(`      Est. uses needed: ${near.estimatedUsesNeeded}\\n`);\n      }\n    }\n  }\n\n  console.log(' Use \"artk-autogen patterns promotion --json -o ./reports\" to export detailed report\\n');\n}\n\n/**\n * Run the enhanced stats subcommand (combined telemetry + LLKB)\n */\nasync function runEnhancedStats(options: { baseDir?: string; json: boolean }): Promise<void> {\n  const telemetryStats = getTelemetryStats({ baseDir: options.baseDir });\n\n  // Get shared telemetry stats\n  let sharedStats;\n  try {\n    sharedStats = analyzePatternGaps();\n  } catch {\n    sharedStats = null;\n  }\n\n  // Get LLKB stats\n  let llkbStats;\n  try {\n    llkbStats = getPatternStats({ llkbRoot: options.baseDir });\n  } catch {\n    llkbStats = null;\n  }\n\n  if (options.json) {\n    console.log(JSON.stringify({\n      telemetry: telemetryStats,\n      sharedTelemetry: sharedStats,\n      llkb: llkbStats,\n    }, null, 2));\n    return;\n  }\n\n  console.log(formatStats(telemetryStats));\n\n  if (sharedStats && sharedStats.totalBlocked > 0) {\n    console.log('\\n Shared Blocked Step Telemetry:\\n');\n    console.log(`  Total blocked steps: ${sharedStats.totalBlocked}`);\n    console.log(`  Unique patterns: ${sharedStats.topPatterns.length}`);\n    console.log('\\n  Top blocked patterns:');\n    for (const pattern of sharedStats.topPatterns.slice(0, 5)) {\n      console.log(`    [${pattern.count}x] ${pattern.pattern.substring(0, 60)}...`);\n    }\n  }\n\n  if (llkbStats && llkbStats.total > 0) {\n    console.log('\\n LLKB Pattern Statistics:\\n');\n    console.log(`  Total learned: ${llkbStats.total}`);\n    console.log(`  Promoted: ${llkbStats.promoted}`);\n    console.log(`  High confidence: ${llkbStats.highConfidence}`);\n    console.log(`  Avg confidence: ${(llkbStats.avgConfidence * 100).toFixed(1)}%`);\n  }\n\n  console.log();\n}\n\n/**\n * Main entry point for patterns command\n */\nexport async function runPatterns(args: string[]): Promise<void> {\n  // Parse arguments\n  const { values, positionals } = parseArgs({\n    args,\n    options: {\n      dir: { type: 'string', short: 'd' },\n      limit: { type: 'string', short: 'n', default: '20' },\n      json: { type: 'boolean', default: false },\n      category: { type: 'string', short: 'c' },\n      force: { type: 'boolean', short: 'f', default: false },\n      output: { type: 'string', short: 'o' },\n      help: { type: 'boolean', short: 'h' },\n    },\n    allowPositionals: true,\n  });\n\n  if (values.help || positionals.length === 0) {\n    console.log(PATTERNS_USAGE);\n    return;\n  }\n\n  const subcommand = positionals[0];\n  const options = {\n    baseDir: values.dir,\n    limit: parseInt(values.limit as string, 10) || 20,\n    json: values.json as boolean,\n    category: values.category as string | undefined,\n    outputDir: values.output as string | undefined,\n  };\n\n  switch (subcommand) {\n    case 'gaps':\n      await runGaps(options);\n      break;\n    case 'suggest':\n      await runSuggest({ json: options.json, limit: options.limit });\n      break;\n    case 'stats':\n      await runEnhancedStats(options);\n      break;\n    case 'list':\n      await runList(options);\n      break;\n    case 'promotion':\n      await runPromotion(options);\n      break;\n    case 'export':\n      await runExport(options);\n      break;\n    case 'clear':\n      await runClear({ baseDir: options.baseDir, force: values.force as boolean });\n      break;\n    default:\n      console.error(`Unknown subcommand: ${subcommand}`);\n      console.log(PATTERNS_USAGE);\n      process.exit(1);\n  }\n}\n","/**\n * ARTK AutoGen CLI - LLKB Patterns Command\n * Manage learned patterns from LLKB integration\n *\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md Phase 4\n */\nimport { parseArgs } from 'node:util';\nimport { createInterface } from 'node:readline';\nimport * as path from 'node:path';\nimport { fileURLToPath } from 'node:url';\n\n// __dirname may exist in CJS builds (injected by tsup/Node.js) but not in ESM\ndeclare const __dirname: string | undefined;\nimport {\n  loadLearnedPatterns,\n  getPatternsFilePath,\n  invalidatePatternCache,\n  getPromotablePatterns,\n  markPatternsPromoted,\n  prunePatterns,\n  getPatternStats,\n  exportPatternsToConfig,\n  clearLearnedPatterns,\n  type LearnedPattern,\n  type PromotedPattern,\n} from '../llkb/patternExtension.js';\n\nconst LLKB_PATTERNS_USAGE = `\nUsage: artk-autogen llkb-patterns <subcommand> [options]\n\nSubcommands:\n  list        List all learned patterns\n  stats       Show pattern statistics\n  promote     Check and display patterns ready for promotion\n  export      Export patterns to LLKB config format\n  prune       Remove low-quality patterns\n  clear       Clear all learned patterns (use with caution)\n  discover    Run full LLKB discovery pipeline on a project\n  reseed      Re-apply universal seed patterns (restores seeds after clear)\n\nOptions:\n  --llkb-root, -r <path>       LLKB root directory (default: .artk/llkb)\n  --project-root, -p <path>    Project root directory (default: cwd, for discover)\n  --limit, -n <num>            Limit number of results (default: 20)\n  --min-confidence <num>       Minimum confidence threshold (default: varies by command)\n  --json                       Output as JSON\n  --force, -f                  Skip confirmation prompts (for clear command)\n  -h, --help                   Show this help message\n\nExamples:\n  artk-autogen llkb-patterns list                    # List top 20 learned patterns\n  artk-autogen llkb-patterns list --limit 50         # List top 50 patterns\n  artk-autogen llkb-patterns stats                   # Show statistics\n  artk-autogen llkb-patterns promote                 # Show promotable patterns\n  artk-autogen llkb-patterns export                  # Export to config file\n  artk-autogen llkb-patterns prune --min-confidence 0.3  # Remove low-confidence patterns\n  artk-autogen llkb-patterns clear                   # Clear all patterns (with confirmation)\n  artk-autogen llkb-patterns clear --force           # Clear all patterns (no confirmation)\n  artk-autogen llkb-patterns discover                # Run discovery on current project\n  artk-autogen llkb-patterns discover -p /path/to/project  # Discover with explicit project root\n  artk-autogen llkb-patterns reseed                  # Re-apply 39 universal seed patterns\n`;\n\n/**\n * Format a learned pattern for console output\n */\nfunction formatPattern(pattern: LearnedPattern, index: number): string {\n  const lines: string[] = [];\n  const confidenceStr = (pattern.confidence * 100).toFixed(0);\n  const status = pattern.promotedToCore ? '[PROMOTED]' : '';\n\n  lines.push(`  ${index + 1}. [${confidenceStr}%] \"${pattern.originalText}\" ${status}`);\n  lines.push(`     ID: ${pattern.id}`);\n  lines.push(`     Type: ${pattern.mappedPrimitive.type}`);\n  lines.push(`     Success: ${pattern.successCount}, Fail: ${pattern.failCount}`);\n  lines.push(`     Sources: ${pattern.sourceJourneys.length} journey(s)`);\n  lines.push(`     Last used: ${new Date(pattern.lastUsed).toLocaleDateString()}`);\n\n  return lines.join('\\n');\n}\n\n/**\n * Format a promotable pattern for console output\n */\nfunction formatPromotablePattern(promoted: PromotedPattern, index: number): string {\n  const lines: string[] = [];\n  const { pattern } = promoted;\n\n  lines.push(`  ${index + 1}. \"${pattern.originalText}\"`);\n  lines.push(`     ID: ${pattern.id}`);\n  lines.push(`     Confidence: ${(pattern.confidence * 100).toFixed(0)}%`);\n  lines.push(`     Priority: ${promoted.priority.toFixed(1)}`);\n  lines.push(`     Generated regex: ${promoted.generatedRegex}`);\n  lines.push(`     Primitive: ${JSON.stringify(pattern.mappedPrimitive)}`);\n\n  return lines.join('\\n');\n}\n\n/**\n * Run the list subcommand\n */\nasync function runList(options: {\n  llkbRoot?: string;\n  limit: number;\n  json: boolean;\n}): Promise<void> {\n  const patterns = loadLearnedPatterns({ llkbRoot: options.llkbRoot });\n\n  if (patterns.length === 0) {\n    console.log('\\n No learned patterns found.');\n    console.log('   Patterns are learned when tests pass after manual fixes.\\n');\n    return;\n  }\n\n  // Sort by confidence descending\n  const sorted = patterns.sort((a, b) => b.confidence - a.confidence).slice(0, options.limit);\n\n  if (options.json) {\n    console.log(JSON.stringify(sorted, null, 2));\n    return;\n  }\n\n  console.log(`\\n Learned Patterns (${sorted.length} of ${patterns.length})\\n`);\n\n  for (let i = 0; i < sorted.length; i++) {\n    console.log(formatPattern(sorted[i]!, i));\n    console.log();\n  }\n}\n\n/**\n * Run the stats subcommand\n */\nasync function runStats(options: { llkbRoot?: string; json: boolean }): Promise<void> {\n  const stats = getPatternStats({ llkbRoot: options.llkbRoot });\n\n  if (options.json) {\n    console.log(JSON.stringify(stats, null, 2));\n    return;\n  }\n\n  console.log('\\n LLKB Pattern Statistics\\n');\n  console.log(`  Total patterns: ${stats.total}`);\n  console.log(`  Promoted to core: ${stats.promoted}`);\n  console.log(`  High confidence (70%): ${stats.highConfidence}`);\n  console.log(`  Low confidence (<30%): ${stats.lowConfidence}`);\n  console.log(`  Average confidence: ${(stats.avgConfidence * 100).toFixed(1)}%`);\n  console.log(`  Total successes: ${stats.totalSuccesses}`);\n  console.log(`  Total failures: ${stats.totalFailures}`);\n  console.log();\n}\n\n/**\n * Run the promote subcommand\n */\nasync function runPromote(options: {\n  llkbRoot?: string;\n  json: boolean;\n  apply: boolean;\n}): Promise<void> {\n  const promotable = getPromotablePatterns({ llkbRoot: options.llkbRoot });\n\n  if (promotable.length === 0) {\n    console.log('\\n No patterns ready for promotion.');\n    console.log('   Patterns need 90% confidence, 5 successes, and 2 source journeys.\\n');\n    return;\n  }\n\n  if (options.json) {\n    console.log(JSON.stringify(promotable, null, 2));\n    return;\n  }\n\n  console.log(`\\n Patterns Ready for Promotion (${promotable.length})\\n`);\n\n  for (let i = 0; i < promotable.length; i++) {\n    console.log(formatPromotablePattern(promotable[i]!, i));\n    console.log();\n  }\n\n  if (options.apply) {\n    const ids = promotable.map((p) => p.pattern.id);\n    markPatternsPromoted(ids, { llkbRoot: options.llkbRoot });\n    console.log(`\\n Marked ${ids.length} patterns as promoted.\\n`);\n  } else {\n    console.log(' Run with --apply to mark these patterns as promoted.\\n');\n  }\n}\n\n/**\n * Run the export subcommand\n */\nasync function runExport(options: {\n  llkbRoot?: string;\n  outputPath?: string;\n  minConfidence: number;\n}): Promise<void> {\n  const result = exportPatternsToConfig({\n    llkbRoot: options.llkbRoot,\n    outputPath: options.outputPath,\n    minConfidence: options.minConfidence,\n  });\n\n  console.log(`\\n Exported ${result.exported} patterns to: ${result.path}\\n`);\n}\n\n/**\n * Run the prune subcommand\n */\nasync function runPrune(options: {\n  llkbRoot?: string;\n  minConfidence: number;\n  minSuccess: number;\n  maxAgeDays: number;\n}): Promise<void> {\n  const result = prunePatterns({\n    llkbRoot: options.llkbRoot,\n    minConfidence: options.minConfidence,\n    minSuccess: options.minSuccess,\n    maxAgeDays: options.maxAgeDays,\n  });\n\n  console.log(`\\n Pruned ${result.removed} low-quality patterns.`);\n  console.log(`   Remaining: ${result.remaining} patterns.\\n`);\n}\n\n/**\n * Prompt user for confirmation\n */\nasync function confirmAction(message: string): Promise<boolean> {\n  const rl = createInterface({\n    input: process.stdin,\n    output: process.stdout,\n  });\n\n  return new Promise((resolve) => {\n    rl.question(`${message} (y/N): `, (answer) => {\n      rl.close();\n      resolve(answer.toLowerCase() === 'y' || answer.toLowerCase() === 'yes');\n    });\n  });\n}\n\n/**\n * Run the clear subcommand\n */\nasync function runClear(options: { llkbRoot?: string; force?: boolean }): Promise<void> {\n  const stats = getPatternStats({ llkbRoot: options.llkbRoot });\n\n  if (stats.total === 0) {\n    console.log('\\n No patterns to clear.\\n');\n    return;\n  }\n\n  console.log(`\\n  This will delete ${stats.total} learned patterns.`);\n  console.log('   This action cannot be undone.\\n');\n\n  // Require confirmation unless --force is specified\n  if (!options.force) {\n    const confirmed = await confirmAction('Are you sure you want to proceed?');\n    if (!confirmed) {\n      console.log('Operation cancelled.\\n');\n      return;\n    }\n  }\n\n  clearLearnedPatterns({ llkbRoot: options.llkbRoot });\n  console.log(' All learned patterns cleared.\\n');\n}\n\n/**\n * Run the reseed subcommand  re-apply universal seed patterns.\n *\n * Seeds are written in persistence format (irPrimitive: string).\n * loadLearnedPatterns() normalizes them to runtime format on next load.\n * Existing patterns with matching normalizedText are not overwritten.\n */\nasync function runReseed(options: { llkbRoot?: string; json: boolean }): Promise<void> {\n  // Read raw file to preserve existing pattern shapes\n  const filePath = getPatternsFilePath(options.llkbRoot);\n  const { existsSync: fileExists, readFileSync: readFile } = await import('node:fs');\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let rawPatterns: any[] = [];\n  if (fileExists(filePath)) {\n    try {\n      const data = JSON.parse(readFile(filePath, 'utf-8'));\n      rawPatterns = Array.isArray(data.patterns) ? data.patterns : [];\n    } catch {\n      // Corrupted file  start fresh\n    }\n  }\n\n  // Resolve seed patterns from core LLKB\n  const currentDir = getCurrentDir();\n  const seedPaths = [\n    path.resolve(currentDir, '..', '..', '..', 'dist', 'llkb', 'index.js'),\n    path.resolve(currentDir, '..', '..', '..', 'llkb', 'universal-seeds.js'),\n  ];\n\n  let createSeeds: (() => Array<Record<string, unknown>>) | null = null;\n  for (const seedPath of seedPaths) {\n    try {\n      const mod = await import(seedPath);\n      createSeeds = mod.createUniversalSeedPatterns;\n      break;\n    } catch {\n      // Try next\n    }\n  }\n\n  if (!createSeeds) {\n    console.error(' Could not resolve universal seeds module.');\n    process.exit(1);\n  }\n\n  const seeds = createSeeds();\n  const existingTexts = new Set(\n    rawPatterns.map((p: Record<string, unknown>) =>\n      (p.normalizedText as string) || ''\n    )\n  );\n  let added = 0;\n  let skipped = 0;\n\n  for (const seed of seeds) {\n    if (existingTexts.has(seed.normalizedText as string)) {\n      skipped++;\n    } else {\n      // Add in persistence format  loadLearnedPatterns normalizes on load\n      rawPatterns.push(seed);\n      added++;\n    }\n  }\n\n  // Write directly to file (persistence format)\n  const data = {\n    version: '1.0.0',\n    lastUpdated: new Date().toISOString(),\n    patterns: rawPatterns,\n  };\n  // Write raw to preserve existing shapes + seed persistence format\n  const { writeFileSync: writeFile, mkdirSync: mkDir, renameSync: renameFile } = await import('node:fs');\n  const dir = path.dirname(filePath);\n  if (!fileExists(dir)) {\n    mkDir(dir, { recursive: true });\n  }\n  const content = JSON.stringify(data, null, 2);\n  const tempPath = `${filePath}.tmp.${Date.now()}`;\n  writeFile(tempPath, content, 'utf-8');\n  renameFile(tempPath, filePath);\n\n  // Invalidate cache\n  invalidatePatternCache();\n\n  if (options.json) {\n    console.log(JSON.stringify({ added, skipped, total: rawPatterns.length }));\n    return;\n  }\n\n  console.log(`\\n Universal seed patterns applied:`);\n  console.log(`   Added:   ${added}`);\n  console.log(`   Skipped: ${skipped} (already exist)`);\n  console.log(`   Total:   ${rawPatterns.length} patterns\\n`);\n}\n\n/** Result type for the pipeline module */\ninterface PipelineModule {\n  runFullDiscoveryPipeline: (\n    projectRoot: string,\n    llkbDir: string,\n    options?: Record<string, unknown>\n  ) => Promise<{\n    success: boolean;\n    profile: unknown;\n    patternsFile: unknown;\n    stats: {\n      durationMs: number;\n      patternSources: Record<string, number>;\n      totalBeforeQC: number;\n      totalAfterQC: number;\n      mining: Record<string, number> | null;\n    };\n    warnings: string[];\n    errors: string[];\n  }>;\n}\n\n/**\n * Get the directory of the current module (ESM-safe).\n */\nfunction getCurrentDir(): string {\n  try {\n    return path.dirname(fileURLToPath(import.meta.url));\n  } catch {\n    // Fallback for CJS (tsup CJS build injects __dirname)\n    if (typeof __dirname === 'string') {\n      return __dirname;\n    }\n    return process.cwd();\n  }\n}\n\n/**\n * Resolve the core LLKB pipeline module.\n *\n * Tries multiple resolution strategies:\n * 1. Monorepo: autogen/dist/cli/  core/typescript/dist/llkb/index.js (bundled barrel)\n * 2. Monorepo dev (tsx): autogen/src/cli/  core/typescript/llkb/index.ts (source)\n * 3. Vendored: node_modules/@artk/core/dist/llkb/index.js\n */\nasync function resolvePipeline(): Promise<PipelineModule> {\n  const currentDir = getCurrentDir();\n  const tried: string[] = [];\n\n  // Strategy 1: Monorepo built output\n  // From autogen/dist/cli/  ../../../dist/llkb/index.js\n  const builtPath = path.resolve(currentDir, '..', '..', '..', 'dist', 'llkb', 'index.js');\n  tried.push(builtPath);\n  try {\n    return await import(builtPath);\n  } catch {\n    // Not found, try next\n  }\n\n  // Strategy 2: Monorepo dev mode (running via tsx from source)\n  // From autogen/src/cli/  ../../../llkb/index.ts (ts-node/tsx resolves .ts)\n  const devPath = path.resolve(currentDir, '..', '..', '..', 'llkb', 'index.js');\n  tried.push(devPath);\n  try {\n    return await import(devPath);\n  } catch {\n    // Not found, try next\n  }\n\n  // Strategy 3: Vendored @artk/core (client project)\n  // From node_modules/@artk/core-autogen/dist/cli/  ../../core/dist/llkb/index.js\n  const vendoredPath = path.resolve(currentDir, '..', '..', 'core', 'dist', 'llkb', 'index.js');\n  tried.push(vendoredPath);\n  try {\n    return await import(vendoredPath);\n  } catch {\n    // Not found\n  }\n\n  throw new Error(\n    'Could not resolve @artk/core LLKB pipeline module.\\n' +\n    'Ensure you are running from the ARTK monorepo or a project with @artk/core installed.\\n' +\n    `Tried:\\n${tried.map(p => `  - ${p}`).join('\\n')}`\n  );\n}\n\n/**\n * Run the discover subcommand  full LLKB discovery pipeline\n */\nasync function runDiscover(options: {\n  llkbRoot?: string;\n  projectRoot?: string;\n  json: boolean;\n}): Promise<void> {\n  const projectRoot = options.projectRoot\n    ? path.resolve(options.projectRoot)\n    : process.cwd();\n  const llkbRoot = options.llkbRoot\n    ? path.resolve(options.llkbRoot)\n    : path.join(process.cwd(), '.artk', 'llkb');\n\n  // Validate directories exist\n  const { existsSync } = await import('node:fs');\n  if (!existsSync(projectRoot)) {\n    console.error(` Project root does not exist: ${projectRoot}`);\n    process.exit(1);\n  }\n  if (!existsSync(llkbRoot)) {\n    console.error(` LLKB root does not exist: ${llkbRoot}`);\n    console.error(`   Run 'artk init' or 'artk llkb init' first to create the LLKB directory.`);\n    process.exit(1);\n  }\n\n  if (!options.json) {\n    console.log(`\\n Running LLKB discovery pipeline...`);\n    console.log(`   Project root: ${projectRoot}`);\n    console.log(`   LLKB root:    ${llkbRoot}\\n`);\n  }\n\n  let pipeline: PipelineModule;\n  try {\n    pipeline = await resolvePipeline();\n  } catch (err) {\n    console.error(` ${err instanceof Error ? err.message : 'Failed to load pipeline module'}`);\n    process.exit(1);\n  }\n\n  const result = await pipeline.runFullDiscoveryPipeline(projectRoot, llkbRoot);\n\n  if (options.json) {\n    console.log(JSON.stringify({\n      success: result.success,\n      stats: result.stats,\n      warnings: result.warnings,\n      errors: result.errors,\n    }, null, 2));\n    return;\n  }\n\n  if (!result.success) {\n    console.error(' Discovery pipeline failed');\n    for (const error of result.errors) {\n      console.error(`   ${error}`);\n    }\n    process.exit(1);\n  }\n\n  const s = result.stats;\n  const durationSec = (s.durationMs / 1000).toFixed(1);\n\n  console.log(` Discovery pipeline completed`);\n  console.log(`   Duration: ${durationSec}s`);\n  console.log(`   Patterns before QC: ${s.totalBeforeQC}`);\n  console.log(`   Patterns after QC:  ${s.totalAfterQC}`);\n  console.log();\n  console.log(` Pattern Sources:`);\n  console.log(`   Discovery:       ${s.patternSources.discovery}`);\n  console.log(`   Templates:       ${s.patternSources.templates}`);\n  console.log(`   Framework Packs: ${s.patternSources.frameworkPacks}`);\n  console.log(`   i18n:            ${s.patternSources.i18n}`);\n  console.log(`   Analytics:       ${s.patternSources.analytics}`);\n  console.log(`   Feature Flags:   ${s.patternSources.featureFlags}`);\n\n  if (s.mining) {\n    console.log();\n    console.log(`  Mining Results:`);\n    console.log(`   Entities: ${s.mining.entitiesFound} | Routes: ${s.mining.routesFound}`);\n    console.log(`   Forms: ${s.mining.formsFound} | Tables: ${s.mining.tablesFound} | Modals: ${s.mining.modalsFound}`);\n    console.log(`   Files scanned: ${s.mining.filesScanned}`);\n  }\n\n  if (result.warnings.length > 0) {\n    console.log();\n    console.log(`  Warnings:`);\n    for (const warning of result.warnings) {\n      console.log(`   ${warning}`);\n    }\n  }\n\n  console.log();\n}\n\n/**\n * Main entry point for llkb-patterns command\n */\nexport async function runLlkbPatterns(args: string[]): Promise<void> {\n  const { values, positionals } = parseArgs({\n    args,\n    options: {\n      'llkb-root': { type: 'string', short: 'r' },\n      'project-root': { type: 'string', short: 'p' },\n      limit: { type: 'string', short: 'n', default: '20' },\n      'min-confidence': { type: 'string', default: '0.7' },\n      'min-success': { type: 'string', default: '1' },\n      'max-age-days': { type: 'string', default: '90' },\n      output: { type: 'string', short: 'o' },\n      json: { type: 'boolean', default: false },\n      apply: { type: 'boolean', default: false },\n      force: { type: 'boolean', short: 'f', default: false },\n      help: { type: 'boolean', short: 'h' },\n    },\n    allowPositionals: true,\n  });\n\n  if (values.help || positionals.length === 0) {\n    console.log(LLKB_PATTERNS_USAGE);\n    return;\n  }\n\n  const subcommand = positionals[0];\n  const baseOptions = {\n    llkbRoot: values['llkb-root'] as string | undefined,\n    json: values.json as boolean,\n  };\n\n  switch (subcommand) {\n    case 'list':\n      await runList({\n        ...baseOptions,\n        limit: parseInt(values.limit as string, 10) || 20,\n      });\n      break;\n\n    case 'stats':\n      await runStats(baseOptions);\n      break;\n\n    case 'promote':\n      await runPromote({\n        ...baseOptions,\n        apply: values.apply as boolean,\n      });\n      break;\n\n    case 'export':\n      await runExport({\n        llkbRoot: baseOptions.llkbRoot,\n        outputPath: values.output as string | undefined,\n        minConfidence: parseFloat(values['min-confidence'] as string) || 0.7,\n      });\n      break;\n\n    case 'prune':\n      await runPrune({\n        llkbRoot: baseOptions.llkbRoot,\n        minConfidence: parseFloat(values['min-confidence'] as string) || 0.3,\n        minSuccess: parseInt(values['min-success'] as string, 10) || 1,\n        maxAgeDays: parseInt(values['max-age-days'] as string, 10) || 90,\n      });\n      break;\n\n    case 'clear':\n      await runClear({ llkbRoot: baseOptions.llkbRoot, force: values.force as boolean });\n      break;\n\n    case 'discover':\n      await runDiscover({\n        ...baseOptions,\n        projectRoot: values['project-root'] as string | undefined,\n      });\n      break;\n\n    case 'reseed':\n      await runReseed(baseOptions);\n      break;\n\n    default:\n      console.error(`Unknown subcommand: ${subcommand}`);\n      console.log(LLKB_PATTERNS_USAGE);\n      process.exit(1);\n  }\n}\n","#!/usr/bin/env node\n/**\n * ARTK AutoGen CLI - Command-line interface for test generation\n */\nimport { VERSION } from '../index.js';\n\nconst USAGE = `\nUsage: artk-autogen <command> [options]\n\nPipeline Commands (Hybrid Agentic Architecture):\n  analyze        Analyze journey files and output structured analysis\n  plan           Create test generation plan from analysis\n  generate       Generate Playwright tests from plan (or journey files)\n  run            Execute tests via Playwright\n  refine         Analyze failures and generate refinement suggestions\n  status         Show pipeline state\n  clean          Clean autogen artifacts\n\nValidation Commands:\n  validate       Validate generated test code\n  verify         Run and verify generated tests\n\nManagement Commands:\n  install        Install ARTK autogen instance in a project\n  upgrade        Upgrade ARTK autogen instance to new version\n  patterns       Analyze blocked step telemetry and pattern gaps\n  llkb-patterns  Manage learned patterns from LLKB integration\n\nOptions:\n  -h, --help      Show this help message\n  -v, --version   Show version\n\nExamples:\n  # Pipeline workflow\n  artk-autogen analyze \"journeys/*.md\"\n  artk-autogen plan --strategy scot\n  artk-autogen generate --output tests/\n  artk-autogen run tests/*.spec.ts\n  artk-autogen refine\n  artk-autogen status\n\n  # Legacy workflow (still supported)\n  artk-autogen generate journeys/login.md -o tests/ -m\n\n  # Management\n  artk-autogen install --dir ./my-project\n  artk-autogen patterns gaps --limit 20\n`;\n\nasync function main(): Promise<void> {\n  const args = process.argv.slice(2);\n\n  if (args.length === 0) {\n    console.log(USAGE);\n    process.exit(0);\n  }\n\n  const command = args[0];\n\n  // Check for global flags\n  if (command === '-h' || command === '--help') {\n    console.log(USAGE);\n    process.exit(0);\n  }\n\n  if (command === '-v' || command === '--version') {\n    console.log(`@artk/core-autogen v${VERSION}`);\n    process.exit(0);\n  }\n\n  // Route to subcommands\n  const subArgs = args.slice(1);\n\n  try {\n    switch (command) {\n      // \n      // PIPELINE COMMANDS (Hybrid Agentic Architecture)\n      // \n      case 'analyze': {\n        const { runAnalyze } = await import('./analyze.js');\n        await runAnalyze(subArgs);\n        break;\n      }\n      case 'plan': {\n        const { runPlan } = await import('./plan.js');\n        await runPlan(subArgs);\n        break;\n      }\n      case 'generate': {\n        const { runGenerate } = await import('./generate.js');\n        await runGenerate(subArgs);\n        break;\n      }\n      case 'run': {\n        const { runRun } = await import('./run.js');\n        await runRun(subArgs);\n        break;\n      }\n      case 'refine': {\n        const { runRefine } = await import('./refine.js');\n        await runRefine(subArgs);\n        break;\n      }\n      case 'status': {\n        const { runStatus } = await import('./status.js');\n        await runStatus(subArgs);\n        break;\n      }\n      case 'clean': {\n        const { runClean } = await import('./clean.js');\n        await runClean(subArgs);\n        break;\n      }\n      // \n      // VALIDATION COMMANDS\n      // \n      case 'validate': {\n        const { runValidate } = await import('./validate.js');\n        await runValidate(subArgs);\n        break;\n      }\n      case 'verify': {\n        const { runVerify } = await import('./verify.js');\n        await runVerify(subArgs);\n        break;\n      }\n      // \n      // MANAGEMENT COMMANDS\n      // \n      case 'install': {\n        const { runInstall } = await import('./install.js');\n        await runInstall(subArgs);\n        break;\n      }\n      case 'upgrade': {\n        const { runUpgrade } = await import('./upgrade.js');\n        await runUpgrade(subArgs);\n        break;\n      }\n      case 'patterns': {\n        const { runPatterns } = await import('./patterns.js');\n        await runPatterns(subArgs);\n        break;\n      }\n      case 'llkb-patterns': {\n        const { runLlkbPatterns } = await import('./llkb-patterns.js');\n        await runLlkbPatterns(subArgs);\n        break;\n      }\n      default:\n        console.error(`Unknown command: ${command}`);\n        console.log(USAGE);\n        process.exit(1);\n    }\n  } catch (error) {\n    console.error('Error:', error instanceof Error ? error.message : String(error));\n    process.exit(1);\n  }\n}\n\nmain();\n"]}
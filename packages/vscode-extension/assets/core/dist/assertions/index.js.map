{"version":3,"sources":["../../assertions/toast.ts","../../assertions/table.ts","../../assertions/form.ts","../../assertions/loading.ts","../../assertions/url.ts","../../assertions/api.ts"],"names":["expect"],"mappings":";;;AAoCA,eAAsB,YACpB,IAAA,EACA,OAAA,EACA,OAAA,GAAiC,IACjC,MAAA,EACe;AACf,EAAA,MAAM,EAAE,IAAA,EAAM,OAAA,GAAU,GAAA,EAAM,KAAA,GAAQ,OAAM,GAAI,OAAA;AAGhD,EAAA,MAAM,WAAA,GAAc,MAAA,EAAQ,UAAA,EAAY,KAAA,IAAS;AAAA,IAC/C,iBAAA,EAAmB,uCAAA;AAAA,IAEnB,aAAA,EAAe;AAAA,GACjB;AAEA,EAAA,MAAM,EAAE,iBAAA,EAAmB,aAAA,EAAc,GAAI,WAAA;AAG7C,EAAA,MAAM,cAAA,GAAiB,IAAA,CAAK,OAAA,CAAQ,iBAAiB,CAAA;AACrD,EAAA,MAAM,OAAO,cAAc,CAAA,CAAE,WAAA,CAAY,EAAE,SAAS,CAAA;AAGpD,EAAA,IAAI,KAAA,EAAO;AACT,IAAA,MAAM,OAAO,cAAc,CAAA,CAAE,WAAW,OAAA,EAAS,EAAE,SAAS,CAAA;AAAA,EAC9D,CAAA,MAAO;AACL,IAAA,MAAM,OAAO,cAAc,CAAA,CAAE,cAAc,OAAA,EAAS,EAAE,SAAS,CAAA;AAAA,EACjE;AAGA,EAAA,IAAI,SAAS,MAAA,EAAW;AACtB,IAAA,MAAM,UAAA,GAAa,MAAM,cAAA,CAAe,YAAA,CAAa,aAAa,CAAA;AAClE,IAAA,IAAI,eAAe,IAAA,EAAM;AACvB,MAAA,MAAM,IAAI,KAAA;AAAA,QACR,CAAA,qBAAA,EAAwB,IAAI,CAAA,WAAA,EAAc,UAAA,IAAc,MAAM,CAAA,CAAA;AAAA,OAChE;AAAA,IACF;AAAA,EACF;AACF;AAqBA,eAAsB,aAAA,CACpB,IAAA,EACA,MAAA,EACA,OAAA,GAAkB,GAAA,EACH;AAEf,EAAA,MAAM,WAAA,GAAc,MAAA,EAAQ,UAAA,EAAY,KAAA,IAAS;AAAA,IAC/C,iBAAA,EAAmB,uCAGrB,CAAA;AAEA,EAAA,MAAM,EAAE,mBAAkB,GAAI,WAAA;AAG9B,EAAA,MAAM,cAAA,GAAiB,IAAA,CAAK,OAAA,CAAQ,iBAAiB,CAAA;AACrD,EAAA,MAAM,OAAO,cAAc,CAAA,CAAE,IAAI,WAAA,CAAY,EAAE,SAAS,CAAA;AAC1D;AAkBA,eAAsB,oBACpB,IAAA,EACA,OAAA,EACA,OAAA,GAAiC,IACjC,MAAA,EACe;AAEf,EAAA,MAAM,WAAA,CAAY,IAAA,EAAM,OAAA,EAAS,OAAA,EAAS,MAAM,CAAA;AAGhD,EAAA,MAAM,WAAA,GAAc,MAAA,EAAQ,UAAA,EAAY,KAAA,IAAS;AAAA,IAC/C,iBAAA,EAAmB,uCAGrB,CAAA;AAEA,EAAA,MAAM,EAAE,mBAAkB,GAAI,WAAA;AAC9B,EAAA,MAAM,EAAE,OAAA,GAAU,GAAA,EAAK,GAAI,OAAA;AAG3B,EAAA,MAAM,cAAA,GAAiB,IAAA,CAAK,OAAA,CAAQ,iBAAiB,CAAA;AACrD,EAAA,MAAM,MAAA,CAAO,cAAc,CAAA,CAAE,GAAA,CAAI,YAAY,EAAE,OAAA,EAAS,OAAA,GAAU,CAAA,EAAG,CAAA;AACvE;AC5GA,eAAsB,wBACpB,IAAA,EACA,aAAA,EACA,OAAA,EACA,OAAA,GAAiC,EAAC,EACnB;AACf,EAAA,MAAM,EAAE,OAAA,GAAU,GAAA,EAAM,KAAA,GAAQ,OAAM,GAAI,OAAA;AAG1C,EAAA,MAAM,KAAA,GAAQ,eAAA,CAAgB,IAAA,EAAM,aAAa,CAAA;AAGjD,EAAA,MAAM,IAAA,GAAO,KAAA,CAAM,OAAA,CAAQ,cAAc,CAAA,CAAE,MAAA,CAAO,EAAE,GAAA,EAAK,IAAA,CAAK,OAAA,CAAQ,IAAI,CAAA,EAAG,CAAA;AAG7E,EAAA,MAAMA,OAAO,KAAK,CAAA,CAAE,YAAA,CAAa,EAAE,SAAS,CAAA;AAC5C,EAAA,MAAM,QAAA,GAAW,MAAM,IAAA,CAAK,KAAA,EAAM;AAElC,EAAA,IAAI,aAAa,CAAA,EAAG;AAClB,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,OAAA,EAAU,aAAa,CAAA,kBAAA,CAAoB,CAAA;AAAA,EAC7D;AAGA,EAAA,MAAMA,OAAO,KAAK,CAAA,CAAE,WAAA,CAAY,EAAE,SAAS,CAAA;AAG3C,EAAA,IAAI,UAAA,GAAa,KAAA;AAEjB,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,QAAA,EAAU,CAAA,EAAA,EAAK;AACjC,IAAA,MAAM,GAAA,GAAM,IAAA,CAAK,GAAA,CAAI,CAAC,CAAA;AACtB,IAAA,MAAM,OAAA,GAAU,MAAM,cAAA,CAAe,GAAA,EAAK,SAAS,KAAK,CAAA;AAExD,IAAA,IAAI,OAAA,EAAS;AACX,MAAA,UAAA,GAAa,IAAA;AACb,MAAA;AAAA,IACF;AAAA,EACF;AAEA,EAAA,IAAI,CAAC,UAAA,EAAY;AACf,IAAA,MAAM,UAAA,GAAa,IAAA,CAAK,SAAA,CAAU,OAAO,CAAA;AACzC,IAAA,MAAM,IAAI,KAAA;AAAA,MACR,CAAA,OAAA,EAAU,aAAa,CAAA,mCAAA,EAAsC,UAAU,CAAA;AAAA,KACzE;AAAA,EACF;AACF;AAmBA,eAAsB,oBACpB,IAAA,EACA,aAAA,EACA,aAAA,EACA,OAAA,GAAiC,EAAC,EACnB;AACf,EAAA,MAAM,EAAE,OAAA,GAAU,GAAA,EAAK,GAAI,OAAA;AAG3B,EAAA,MAAM,KAAA,GAAQ,eAAA,CAAgB,IAAA,EAAM,aAAa,CAAA;AAIjD,EAAA,IAAI,gBAAgB,CAAA,EAAG;AACrB,IAAA,MAAMA,OAAO,KAAK,CAAA,CAAE,WAAA,CAAY,EAAE,SAAS,CAAA;AAAA,EAC7C,CAAA,MAAO;AAEL,IAAA,MAAMA,OAAO,KAAK,CAAA,CAAE,YAAA,CAAa,EAAE,SAAS,CAAA;AAAA,EAC9C;AAGA,EAAA,MAAM,IAAA,GAAO,KAAA,CAAM,OAAA,CAAQ,cAAc,CAAA,CAAE,MAAA,CAAO,EAAE,GAAA,EAAK,IAAA,CAAK,OAAA,CAAQ,IAAI,CAAA,EAAG,CAAA;AAG7E,EAAA,MAAMA,OAAO,IAAI,CAAA,CAAE,YAAY,aAAA,EAAe,EAAE,SAAS,CAAA;AAC3D;AAWA,SAAS,eAAA,CAAgB,MAAY,aAAA,EAAgC;AAEnE,EAAA,IAAI,CAAC,aAAA,CAAc,QAAA,CAAS,GAAG,KAAK,CAAC,aAAA,CAAc,QAAA,CAAS,GAAG,CAAA,IAAK,CAAC,aAAA,CAAc,QAAA,CAAS,GAAG,CAAA,EAAG;AAChG,IAAA,OAAO,IAAA,CAAK,YAAY,aAAa,CAAA;AAAA,EACvC;AAGA,EAAA,IAAI,kBAAkB,OAAA,EAAS;AAC7B,IAAA,OAAO,IAAA,CAAK,UAAU,OAAO,CAAA;AAAA,EAC/B;AAGA,EAAA,OAAO,IAAA,CAAK,QAAQ,aAAa,CAAA;AACnC;AAUA,eAAe,cAAA,CACb,GAAA,EACA,YAAA,EACA,KAAA,EACkB;AAClB,EAAA,KAAA,MAAW,CAAC,MAAA,EAAQ,aAAa,KAAK,MAAA,CAAO,OAAA,CAAQ,YAAY,CAAA,EAAG;AAElE,IAAA,MAAM,OAAO,GAAA,CAAI,OAAA,CAAQ,iBAAiB,MAAM,CAAA,kBAAA,EAAqB,MAAM,CAAA,EAAA,CAAI,CAAA;AAG/E,IAAA,IAAK,MAAM,IAAA,CAAK,KAAA,EAAM,KAAO,CAAA,EAAG;AAE9B,MAAA,MAAM,KAAA,GAAQ,GAAA,CAAI,OAAA,CAAQ,IAAI,CAAA;AAC9B,MAAA,MAAM,SAAA,GAAY,MAAM,KAAA,CAAM,KAAA,EAAM;AAGpC,MAAA,IAAI,SAAA,GAAY,KAAA;AAChB,MAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,SAAA,EAAW,CAAA,EAAA,EAAK;AAClC,QAAA,MAAM,WAAW,MAAM,KAAA,CAAM,GAAA,CAAI,CAAC,EAAE,WAAA,EAAY;AAChD,QAAA,MAAM,WAAA,GAAc,OAAO,aAAa,CAAA;AAExC,QAAA,IAAI,KAAA,GAAQ,UAAU,IAAA,EAAK,KAAM,cAAc,QAAA,EAAU,QAAA,CAAS,WAAW,CAAA,EAAG;AAC9E,UAAA,SAAA,GAAY,IAAA;AACZ,UAAA;AAAA,QACF;AAAA,MACF;AAEA,MAAA,IAAI,CAAC,SAAA,EAAW;AACd,QAAA,OAAO,KAAA;AAAA,MACT;AAAA,IACF,CAAA,MAAO;AAEL,MAAA,MAAM,QAAA,GAAW,MAAM,IAAA,CAAK,WAAA,EAAY;AACxC,MAAA,MAAM,WAAA,GAAc,OAAO,aAAa,CAAA;AAExC,MAAA,MAAM,OAAA,GAAU,QACZ,QAAA,EAAU,IAAA,OAAW,WAAA,GACrB,QAAA,EAAU,SAAS,WAAW,CAAA;AAElC,MAAA,IAAI,CAAC,OAAA,EAAS;AACZ,QAAA,OAAO,KAAA;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAEA,EAAA,OAAO,IAAA;AACT;AAeA,eAAsB,gBAAA,CACpB,IAAA,EACA,aAAA,EACA,OAAA,GAAiC,EAAC,EACnB;AACf,EAAA,MAAM,mBAAA,CAAoB,IAAA,EAAM,aAAA,EAAe,CAAA,EAAG,OAAO,CAAA;AAC3D;ACpMA,eAAsB,qBACpB,IAAA,EACA,SAAA,EACA,eACA,OAAA,GAAiC,IACjC,MAAA,EACe;AACf,EAAA,MAAM,EAAE,OAAA,GAAU,GAAA,EAAM,KAAA,GAAQ,OAAM,GAAI,OAAA;AAG1C,EAAA,MAAM,UAAA,GAAa,MAAA,EAAQ,UAAA,EAAY,IAAA,IAAQ;AAAA,IAC7C,aAAA,EAAe,0EAEjB,CAAA;AAEA,EAAA,MAAM,EAAE,eAAc,GAAI,UAAA;AAG1B,EAAA,MAAM,kBAAA,GAAqB,aAAA,CAAc,OAAA,CAAQ,UAAA,EAAY,SAAS,CAAA;AAGtE,EAAA,MAAM,YAAA,GAAe,IAAA,CAAK,OAAA,CAAQ,kBAAkB,CAAA;AAGpD,EAAA,MAAMA,OAAO,YAAY,CAAA,CAAE,WAAA,CAAY,EAAE,SAAS,CAAA;AAGlD,EAAA,IAAI,KAAA,EAAO;AACT,IAAA,MAAMA,OAAO,YAAY,CAAA,CAAE,WAAW,aAAA,EAAe,EAAE,SAAS,CAAA;AAAA,EAClE,CAAA,MAAO;AACL,IAAA,MAAMA,OAAO,YAAY,CAAA,CAAE,cAAc,aAAA,EAAe,EAAE,SAAS,CAAA;AAAA,EACrE;AACF;AAmBA,eAAsB,gBACpB,IAAA,EACA,YAAA,EACA,OAAA,GAA+B,IAC/B,MAAA,EACe;AACf,EAAA,MAAM,EAAE,OAAA,GAAU,GAAA,EAAK,GAAI,OAAA;AAG3B,EAAA,MAAM,UAAA,GAAa,MAAA,EAAQ,UAAA,EAAY,IAAA,IAAQ;AAAA,IAE7C,iBAAA,EAAmB;AAAA,GACrB;AAEA,EAAA,MAAM,EAAE,mBAAkB,GAAI,UAAA;AAG9B,EAAA,MAAM,IAAA,GAAO,cAAA,CAAe,IAAA,EAAM,YAAY,CAAA;AAC9C,EAAA,MAAMA,OAAO,IAAI,CAAA,CAAE,WAAA,CAAY,EAAE,SAAS,CAAA;AAG1C,EAAA,MAAM,aAAA,GAAgB,IAAA,CAAK,OAAA,CAAQ,iBAAiB,CAAA;AACpD,EAAA,MAAMA,OAAO,aAAa,CAAA,CAAE,YAAY,CAAA,EAAG,EAAE,SAAS,CAAA;AACxD;AAgBA,eAAsB,uBACpB,IAAA,EACA,SAAA,EACA,OAAA,GAAiC,IACjC,MAAA,EACe;AACf,EAAA,MAAM,EAAE,OAAA,GAAU,GAAA,EAAK,GAAI,OAAA;AAG3B,EAAA,MAAM,UAAA,GAAa,MAAA,EAAQ,UAAA,EAAY,IAAA,IAAQ;AAAA,IAC7C,aAAA,EAAe,0EAEjB,CAAA;AAEA,EAAA,MAAM,EAAE,eAAc,GAAI,UAAA;AAG1B,EAAA,MAAM,kBAAA,GAAqB,aAAA,CAAc,OAAA,CAAQ,UAAA,EAAY,SAAS,CAAA;AAGtE,EAAA,MAAM,YAAA,GAAe,IAAA,CAAK,OAAA,CAAQ,kBAAkB,CAAA;AAGpD,EAAA,MAAMA,OAAO,YAAY,CAAA,CAAE,IAAI,WAAA,CAAY,EAAE,SAAS,CAAA;AACxD;AAoBA,eAAsB,gBACpB,IAAA,EACA,YAAA,EACA,eACA,OAAA,GAAiC,IACjC,MAAA,EACe;AACf,EAAA,MAAM,EAAE,OAAA,GAAU,GAAA,EAAM,KAAA,GAAQ,OAAM,GAAI,OAAA;AAG1C,EAAA,MAAM,UAAA,GAAa,MAAA,EAAQ,UAAA,EAAY,IAAA,IAAQ;AAAA,IAE7C,iBAAA,EAAmB;AAAA,GACrB;AAEA,EAAA,MAAM,EAAE,mBAAkB,GAAI,UAAA;AAG9B,EAAA,MAAM,IAAA,GAAO,cAAA,CAAe,IAAA,EAAM,YAAY,CAAA;AAC9C,EAAA,MAAMA,OAAO,IAAI,CAAA,CAAE,WAAA,CAAY,EAAE,SAAS,CAAA;AAG1C,EAAA,MAAM,SAAA,GAAY,IAAA,CAAK,OAAA,CAAQ,iBAAiB,CAAA;AAChD,EAAA,MAAMA,OAAO,SAAS,CAAA,CAAE,WAAA,CAAY,EAAE,SAAS,CAAA;AAG/C,EAAA,IAAI,KAAA,EAAO;AACT,IAAA,MAAMA,OAAO,SAAS,CAAA,CAAE,WAAW,aAAA,EAAe,EAAE,SAAS,CAAA;AAAA,EAC/D,CAAA,MAAO;AACL,IAAA,MAAMA,OAAO,SAAS,CAAA,CAAE,cAAc,aAAA,EAAe,EAAE,SAAS,CAAA;AAAA,EAClE;AACF;AASA,SAAS,cAAA,CAAe,MAAY,YAAA,EAA+B;AAEjE,EAAA,IAAI,CAAC,YAAA,CAAa,QAAA,CAAS,GAAG,KAAK,CAAC,YAAA,CAAa,QAAA,CAAS,GAAG,CAAA,IAAK,CAAC,YAAA,CAAa,QAAA,CAAS,GAAG,CAAA,EAAG;AAC7F,IAAA,OAAO,IAAA,CAAK,YAAY,YAAY,CAAA;AAAA,EACtC;AAGA,EAAA,IAAI,iBAAiB,MAAA,EAAQ;AAC3B,IAAA,OAAO,IAAA,CAAK,UAAU,MAAM,CAAA;AAAA,EAC9B;AAGA,EAAA,OAAO,IAAA,CAAK,QAAQ,YAAY,CAAA;AAClC;AC7MA,IAAM,yBAAA,GAA4B;AAAA,EAChC,uBAAA;AAAA,EACA,UAAA;AAAA,EACA,UAAA;AAAA,EACA,oBAAA;AAAA,EACA,kBAAA;AAAA,EACA;AACF,CAAA;AAuBA,eAAsB,aAAA,CACpB,IAAA,EACA,OAAA,GAA+B,IAC/B,MAAA,EACe;AACf,EAAA,MAAM,EAAE,OAAA,GAAU,GAAA,EAAM,SAAA,EAAU,GAAI,OAAA;AAGtC,EAAA,MAAM,gBAAA,GACJ,SAAA,IACA,MAAA,EAAQ,UAAA,EAAY,SAAS,SAAA,IAC7B,yBAAA;AAGF,EAAA,MAAM,gBAAA,GAAmB,gBAAA,CAAiB,IAAA,CAAK,IAAI,CAAA;AACnD,EAAA,MAAM,gBAAA,GAAmB,IAAA,CAAK,OAAA,CAAQ,gBAAgB,CAAA;AAGtD,EAAA,MAAMA,MAAAA,CAAO,iBAAiB,KAAA,EAAO,EAAE,WAAA,CAAY,EAAE,SAAS,CAAA;AAChE;AAoBA,eAAsB,gBAAA,CACpB,IAAA,EACA,OAAA,GAA+B,IAC/B,MAAA,EACe;AACf,EAAA,MAAM,EAAE,OAAA,GAAU,GAAA,EAAM,SAAA,EAAU,GAAI,OAAA;AAGtC,EAAA,MAAM,gBAAA,GACJ,SAAA,IACA,MAAA,EAAQ,UAAA,EAAY,SAAS,SAAA,IAC7B,yBAAA;AAGF,EAAA,KAAA,MAAW,YAAY,gBAAA,EAAkB;AACvC,IAAA,MAAM,gBAAA,GAAmB,IAAA,CAAK,OAAA,CAAQ,QAAQ,CAAA;AAC9C,IAAA,MAAMA,OAAO,gBAAgB,CAAA,CAAE,IAAI,WAAA,CAAY,EAAE,SAAS,CAAA;AAAA,EAC5D;AACF;AA0BA,eAAsB,sBAAA,CACpB,IAAA,EACA,OAAA,GAA+B,IAC/B,MAAA,EACe;AACf,EAAA,MAAM,EAAE,OAAA,GAAU,GAAA,EAAO,SAAA,EAAU,GAAI,OAAA;AAGvC,EAAA,MAAM,gBAAA,GACJ,SAAA,IACA,MAAA,EAAQ,UAAA,EAAY,SAAS,SAAA,IAC7B,yBAAA;AAIF,EAAA,MAAM,gBAAA,GAAmB,gBAAA,CAAiB,IAAA,CAAK,IAAI,CAAA;AACnD,EAAA,MAAM,gBAAA,GAAmB,IAAA,CAAK,OAAA,CAAQ,gBAAgB,CAAA;AAEtD,EAAA,IAAI;AACF,IAAA,MAAMA,MAAAA,CAAO,iBAAiB,KAAA,EAAO,EAAE,WAAA,CAAY,EAAE,OAAA,EAAS,GAAA,EAAM,CAAA;AAAA,EACtE,CAAA,CAAA,MAAQ;AAAA,EAER;AAGA,EAAA,KAAA,MAAW,YAAY,gBAAA,EAAkB;AACvC,IAAA,MAAM,SAAA,GAAY,IAAA,CAAK,OAAA,CAAQ,QAAQ,CAAA;AACvC,IAAA,MAAMA,OAAO,SAAS,CAAA,CAAE,IAAI,WAAA,CAAY,EAAE,SAAS,CAAA;AAAA,EACrD;AACF;AA4BA,eAAsB,wBACpB,IAAA,EACA,SAAA,EACA,OAAA,GAA+B,IAC/B,MAAA,EACe;AACf,EAAA,MAAM,EAAE,OAAA,GAAU,GAAA,EAAO,SAAA,EAAU,GAAI,OAAA;AAGvC,EAAA,MAAM,gBAAA,GACJ,SAAA,IACA,MAAA,EAAQ,UAAA,EAAY,SAAS,SAAA,IAC7B,yBAAA;AAEF,EAAA,MAAM,gBAAA,GAAmB,gBAAA,CAAiB,IAAA,CAAK,IAAI,CAAA;AACnD,EAAA,MAAM,gBAAA,GAAmB,IAAA,CAAK,OAAA,CAAQ,gBAAgB,CAAA;AAGtD,EAAA,MAAM,SAAA,EAAU;AAIhB,EAAA,MAAM,aAAA,GAAgB,IAAA,CAAK,GAAA,CAAI,OAAA,GAAU,GAAG,GAAI,CAAA;AAChD,EAAA,MAAMA,MAAAA,CAAO,iBAAiB,KAAA,EAAO,EAAE,WAAA,CAAY,EAAE,OAAA,EAAS,aAAA,EAAe,CAAA;AAG7E,EAAA,MAAM,uBAAuB,IAAA,EAAM,EAAE,OAAA,EAAS,SAAA,IAAa,MAAM,CAAA;AACnE;;;ACtLA,eAAsB,iBAAA,CACpB,IAAA,EACA,iBAAA,EACA,OAAA,GAA+B,EAAC,EACjB;AACf,EAAA,MAAM,EAAE,OAAA,GAAU,GAAA,EAAM,oBAAoB,KAAA,EAAO,UAAA,GAAa,OAAM,GAAI,OAAA;AAG1E,EAAA,MAAM,IAAA,CAAK,UAAA;AAAA,IACT,CAAC,GAAA,KAAQ;AACP,MAAA,IAAI,MAAA,GAAS,IAAI,QAAA,EAAS;AAG1B,MAAA,IAAI,iBAAA,EAAmB;AACrB,QAAA,MAAM,MAAA,GAAS,IAAI,GAAA,CAAI,MAAM,CAAA;AAC7B,QAAA,MAAA,GAAS,CAAA,EAAG,MAAA,CAAO,MAAM,CAAA,EAAG,OAAO,QAAQ,CAAA,CAAA;AAAA,MAC7C;AAGA,MAAA,IAAI,UAAA,EAAY;AACd,QAAA,MAAA,GAAS,MAAA,CAAO,KAAA,CAAM,GAAG,CAAA,CAAE,CAAC,CAAA,IAAK,MAAA;AAAA,MACnC;AAEA,MAAA,OAAO,MAAA,CAAO,SAAS,iBAAiB,CAAA;AAAA,IAC1C,CAAA;AAAA,IACA,EAAE,OAAA;AAAQ,GACZ;AACF;AAqBA,eAAsB,gBAAA,CACpB,IAAA,EACA,OAAA,EACA,OAAA,GAA+B,EAAC,EACjB;AACf,EAAA,MAAM,EAAE,OAAA,GAAU,GAAA,EAAM,oBAAoB,KAAA,EAAO,UAAA,GAAa,OAAM,GAAI,OAAA;AAG1E,EAAA,MAAM,QAAQ,OAAO,OAAA,KAAY,WAAW,IAAI,MAAA,CAAO,OAAO,CAAA,GAAI,OAAA;AAGlE,EAAA,MAAM,IAAA,CAAK,UAAA;AAAA,IACT,CAAC,GAAA,KAAQ;AACP,MAAA,IAAI,MAAA,GAAS,IAAI,QAAA,EAAS;AAG1B,MAAA,IAAI,iBAAA,EAAmB;AACrB,QAAA,MAAM,MAAA,GAAS,IAAI,GAAA,CAAI,MAAM,CAAA;AAC7B,QAAA,MAAA,GAAS,CAAA,EAAG,MAAA,CAAO,MAAM,CAAA,EAAG,OAAO,QAAQ,CAAA,CAAA;AAAA,MAC7C;AAGA,MAAA,IAAI,UAAA,EAAY;AACd,QAAA,MAAA,GAAS,MAAA,CAAO,KAAA,CAAM,GAAG,CAAA,CAAE,CAAC,CAAA,IAAK,MAAA;AAAA,MACnC;AAEA,MAAA,OAAO,KAAA,CAAM,KAAK,MAAM,CAAA;AAAA,IAC1B,CAAA;AAAA,IACA,EAAE,OAAA;AAAQ,GACZ;AACF;AAqBA,eAAsB,eAAA,CACpB,IAAA,EACA,WAAA,EACA,OAAA,GAA+B,EAAC,EACjB;AACf,EAAA,MAAM,EAAE,OAAA,GAAU,GAAA,EAAM,oBAAoB,KAAA,EAAO,UAAA,GAAa,OAAM,GAAI,OAAA;AAG1E,EAAA,IAAI,kBAAA,GAAqB,WAAA;AACzB,EAAA,IAAI,qBAAqB,UAAA,EAAY;AACnC,IAAA,MAAM,cAAA,GAAiB,IAAI,GAAA,CAAI,WAAA,EAAa,kBAAkB,CAAA;AAC9D,IAAA,IAAI,iBAAA,EAAmB;AACrB,MAAA,kBAAA,GAAqB,CAAA,EAAG,cAAA,CAAe,MAAM,CAAA,EAAG,eAAe,QAAQ,CAAA,CAAA;AAAA,IACzE;AACA,IAAA,IAAI,UAAA,EAAY;AACd,MAAA,kBAAA,GAAqB,kBAAA,CAAmB,KAAA,CAAM,GAAG,CAAA,CAAE,CAAC,CAAA,IAAK,kBAAA;AAAA,IAC3D;AAAA,EACF;AAGA,EAAA,MAAM,IAAA,CAAK,UAAA;AAAA,IACT,CAAC,GAAA,KAAQ;AACP,MAAA,IAAI,MAAA,GAAS,IAAI,QAAA,EAAS;AAG1B,MAAA,IAAI,iBAAA,EAAmB;AACrB,QAAA,MAAM,MAAA,GAAS,IAAI,GAAA,CAAI,MAAM,CAAA;AAC7B,QAAA,MAAA,GAAS,CAAA,EAAG,MAAA,CAAO,MAAM,CAAA,EAAG,OAAO,QAAQ,CAAA,CAAA;AAAA,MAC7C;AAEA,MAAA,IAAI,UAAA,EAAY;AACd,QAAA,MAAA,GAAS,MAAA,CAAO,KAAA,CAAM,GAAG,CAAA,CAAE,CAAC,CAAA,IAAK,MAAA;AAAA,MACnC;AAEA,MAAA,OAAO,MAAA,KAAW,kBAAA;AAAA,IACpB,CAAA;AAAA,IACA,EAAE,OAAA;AAAQ,GACZ;AACF;AAoBA,eAAsB,aAAA,CACpB,IAAA,EACA,YAAA,EACA,OAAA,GAA+B,EAAC,EACjB;AACf,EAAA,MAAM,EAAE,OAAA,GAAU,GAAA,EAAM,oBAAoB,KAAA,EAAO,UAAA,GAAa,OAAM,GAAI,OAAA;AAG1E,EAAA,IAAI,sBAAA,GAAyB,YAAA;AAC7B,EAAA,IAAI,qBAAqB,UAAA,EAAY;AACnC,IAAA,IAAI,iBAAA,EAAmB;AACrB,MAAA,sBAAA,GAAyB,sBAAA,CAAuB,KAAA,CAAM,GAAG,CAAA,CAAE,CAAC,CAAA,IAAK,sBAAA;AAAA,IACnE;AACA,IAAA,IAAI,UAAA,EAAY;AACd,MAAA,sBAAA,GAAyB,sBAAA,CAAuB,KAAA,CAAM,GAAG,CAAA,CAAE,CAAC,CAAA,IAAK,sBAAA;AAAA,IACnE;AAAA,EACF;AAGA,EAAA,MAAM,IAAA,CAAK,UAAA;AAAA,IACT,CAAC,GAAA,KAAQ;AACP,MAAA,IAAI,WAAW,GAAA,CAAI,QAAA;AAGnB,MAAA,IAAI,iBAAA,EAAmB;AACrB,QAAA,QAAA,GAAW,QAAA,CAAS,KAAA,CAAM,GAAG,CAAA,CAAE,CAAC,CAAA,IAAK,QAAA;AAAA,MACvC;AAEA,MAAA,IAAI,UAAA,EAAY;AACd,QAAA,QAAA,GAAW,QAAA,CAAS,KAAA,CAAM,GAAG,CAAA,CAAE,CAAC,CAAA,IAAK,QAAA;AAAA,MACvC;AAEA,MAAA,OAAO,QAAA,KAAa,sBAAA;AAAA,IACtB,CAAA;AAAA,IACA,EAAE,OAAA;AAAQ,GACZ;AACF;ACpLA,eAAsB,iBAAA,CACpB,QAAA,EACA,QAAA,EACA,OAAA,GAAuC,EAAC,EACzB;AACf,EAAA,MAAM,EAAE,cAAA,GAAiB,KAAA,EAAM,GAAI,OAAA;AAGnC,EAAA,IAAI,QAAA,CAAS,WAAW,MAAA,EAAW;AACjC,IAAAA,MAAAA,CAAO,QAAA,CAAS,MAAA,EAAO,EAAG,CAAA,gBAAA,EAAmB,QAAA,CAAS,MAAM,CAAA,CAAE,CAAA,CAAE,IAAA,CAAK,QAAA,CAAS,MAAM,CAAA;AAAA,EACtF;AAGA,EAAA,IAAI,QAAA,CAAS,gBAAgB,MAAA,EAAW;AACtC,IAAA,MAAM,iBAAA,GAAoB,QAAA,CAAS,OAAA,EAAQ,CAAE,cAAc,CAAA,IAAK,EAAA;AAChE,IAAAA,OAAO,iBAAA,EAAmB,CAAA,sBAAA,EAAyB,QAAA,CAAS,WAAW,EAAE,CAAA,CAAE,SAAA;AAAA,MACzE,QAAA,CAAS;AAAA,KACX;AAAA,EACF;AAGA,EAAA,IAAI,QAAA,CAAS,YAAY,MAAA,EAAW;AAClC,IAAA,MAAM,aAAA,GAAgB,SAAS,OAAA,EAAQ;AACvC,IAAA,KAAA,MAAW,CAAC,YAAY,aAAa,CAAA,IAAK,OAAO,OAAA,CAAQ,QAAA,CAAS,OAAO,CAAA,EAAG;AAC1E,MAAA,MAAM,WAAA,GAAc,aAAA,CAAc,UAAA,CAAW,WAAA,EAAa,CAAA;AAC1D,MAAAA,MAAAA,CAAO,aAAa,CAAA,gBAAA,EAAmB,UAAU,KAAK,aAAa,CAAA,CAAE,CAAA,CAAE,IAAA,CAAK,aAAa,CAAA;AAAA,IAC3F;AAAA,EACF;AAGA,EAAA,IAAI,QAAA,CAAS,SAAS,MAAA,EAAW;AAC/B,IAAA,MAAM,UAAA,GAAa,MAAM,QAAA,CAAS,IAAA,EAAK;AAEvC,IAAA,IAAI,cAAA,EAAgB;AAClB,MAAAA,OAAO,UAAA,EAAY,2BAA2B,CAAA,CAAE,OAAA,CAAQ,SAAS,IAAI,CAAA;AAAA,IACvE,CAAA,MAAO;AAEL,MAAA,KAAA,MAAW,CAAC,KAAK,aAAa,CAAA,IAAK,OAAO,OAAA,CAAQ,QAAA,CAAS,IAAI,CAAA,EAAG;AAChE,QAAAA,OAAO,UAAA,EAAY,CAAA,2BAAA,EAA8B,GAAG,CAAA,CAAA,CAAG,CAAA,CAAE,eAAe,GAAG,CAAA;AAC3E,QAAAA,MAAAA,CAAO,WAAW,GAAG,CAAA,EAAG,YAAY,GAAG,CAAA,UAAA,EAAa,aAAa,CAAA,CAAE,CAAA,CAAE,OAAA;AAAA,UACnE;AAAA,SACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAaA,eAAsB,iBAAiB,QAAA,EAAsC;AAC3E,EAAA,MAAM,MAAA,GAAS,SAAS,MAAA,EAAO;AAC/B,EAAAA,OAAO,MAAA,EAAQ,CAAA,4BAAA,EAA+B,MAAM,CAAA,CAAE,CAAA,CAAE,uBAAuB,GAAG,CAAA;AAClF,EAAAA,OAAO,MAAA,EAAQ,CAAA,4BAAA,EAA+B,MAAM,CAAA,CAAE,CAAA,CAAE,aAAa,GAAG,CAAA;AAC1E;AAkBA,eAAsB,cAAA,CACpB,UACA,cAAA,EACe;AACf,EAAA,MAAM,MAAA,GAAS,SAAS,MAAA,EAAO;AAE/B,EAAA,IAAI,mBAAmB,MAAA,EAAW;AAChC,IAAAA,MAAAA,CAAO,QAAQ,CAAA,gBAAA,EAAmB,cAAc,YAAY,MAAM,CAAA,CAAE,CAAA,CAAE,IAAA,CAAK,cAAc,CAAA;AAAA,EAC3F,CAAA,MAAO;AACL,IAAA,MAAM,OAAA,GAAU,MAAA,IAAU,GAAA,IAAO,MAAA,GAAS,GAAA;AAC1C,IAAAA,OAAO,OAAA,EAAS,CAAA,2CAAA,EAA8C,MAAM,CAAA,CAAE,CAAA,CAAE,KAAK,IAAI,CAAA;AAAA,EACnF;AACF;AAcA,eAAsB,sBAAA,CACpB,UACA,cAAA,EACe;AACf,EAAA,MAAM,UAAA,GAAa,MAAM,QAAA,CAAS,IAAA,EAAK;AAEvC,EAAA,KAAA,MAAW,SAAS,cAAA,EAAgB;AAClC,IAAAA,OAAO,UAAA,EAAY,CAAA,sCAAA,EAAyC,KAAK,CAAA,CAAA,CAAG,CAAA,CAAE,eAAe,KAAK,CAAA;AAAA,EAC5F;AACF;AAkBA,eAAsB,oBAAA,CACpB,UACA,cAAA,EACe;AACf,EAAA,MAAM,UAAA,GAAa,MAAM,QAAA,CAAS,IAAA,EAAK;AAEvC,EAAAA,MAAAA,CAAO,MAAM,OAAA,CAAQ,UAAU,GAAG,uCAAuC,CAAA,CAAE,KAAK,IAAI,CAAA;AAEpF,EAAA,IAAI,mBAAmB,MAAA,EAAW;AAChC,IAAAA,MAAAA;AAAA,MACE,UAAA,CAAW,MAAA;AAAA,MACX,CAAA,sBAAA,EAAyB,cAAc,CAAA,SAAA,EAAY,UAAA,CAAW,MAAM,CAAA;AAAA,KACtE,CAAE,KAAK,cAAc,CAAA;AAAA,EACvB;AACF;AAgBA,eAAsB,wBAAA,CACpB,UACA,eAAA,EACe;AAEf,EAAAA,OAAO,QAAA,CAAS,MAAA,IAAU,sCAAsC,CAAA,CAAE,KAAK,GAAG,CAAA;AAG1E,EAAA,MAAM,IAAA,GAAO,MAAM,QAAA,CAAS,IAAA,EAAK;AAGjC,EAAA,MAAM,YAAA,GACJ,KAAK,KAAA,IAAS,IAAA,CAAK,WAAW,IAAA,CAAK,YAAA,IAAgB,IAAA,CAAK,SAAA,CAAU,IAAI,CAAA;AAExE,EAAAA,MAAAA;AAAA,IACE,OAAO,YAAA,KAAiB,QAAA,IAAY,YAAA,CAAa,SAAS,eAAe,CAAA;AAAA,IACzE,CAAA,mCAAA,EAAsC,eAAe,CAAA,WAAA,EAAc,YAAY,CAAA,CAAA;AAAA,GACjF,CAAE,KAAK,IAAI,CAAA;AACb","file":"index.js","sourcesContent":["/**\n * Toast/notification assertion helpers\n *\n * Provides assertions for verifying toast notifications including type detection.\n * Implements FR-021: Toast/notification assertions with type detection\n *\n * @module assertions/toast\n */\n\nimport { expect, type Page } from '@playwright/test';\nimport type { ToastAssertionOptions } from './types.js';\nimport type { ARTKConfig } from '../config/types.js';\n\n/**\n * Assert that a toast notification with the given message appears\n *\n * @param page - Playwright page object\n * @param message - Expected toast message (supports partial match by default)\n * @param options - Toast assertion options\n * @param config - ARTK configuration (optional, will load from global if not provided)\n *\n * @example\n * ```typescript\n * // Basic toast assertion\n * await expectToast(page, 'Order created successfully');\n *\n * // Toast with type detection\n * await expectToast(page, 'Order created', { type: 'success' });\n *\n * // Exact message match\n * await expectToast(page, 'Order created successfully', { exact: true });\n *\n * // Custom timeout\n * await expectToast(page, 'Processing...', { timeout: 10000 });\n * ```\n */\nexport async function expectToast(\n  page: Page,\n  message: string,\n  options: ToastAssertionOptions = {},\n  config?: ARTKConfig\n): Promise<void> {\n  const { type, timeout = 5000, exact = false } = options;\n\n  // Load config if not provided\n  const toastConfig = config?.assertions?.toast ?? {\n    containerSelector: '[role=\"alert\"], .toast, .notification',\n    messageSelector: '.toast-message, .notification-message',\n    typeAttribute: 'data-type',\n  };\n\n  const { containerSelector, typeAttribute } = toastConfig;\n\n  // Wait for toast container to appear\n  const toastContainer = page.locator(containerSelector);\n  await expect(toastContainer).toBeVisible({ timeout });\n\n  // Check message content\n  if (exact) {\n    await expect(toastContainer).toHaveText(message, { timeout });\n  } else {\n    await expect(toastContainer).toContainText(message, { timeout });\n  }\n\n  // Check toast type if specified\n  if (type !== undefined) {\n    const actualType = await toastContainer.getAttribute(typeAttribute);\n    if (actualType !== type) {\n      throw new Error(\n        `Expected toast type \"${type}\" but got \"${actualType ?? 'none'}\"`\n      );\n    }\n  }\n}\n\n/**\n * Assert that no toast notification is currently visible\n *\n * @param page - Playwright page object\n * @param config - ARTK configuration (optional, will load from global if not provided)\n * @param timeout - Timeout in milliseconds (default: 5000)\n *\n * @example\n * ```typescript\n * // Assert no toasts are displayed\n * await expectNoToast(page);\n *\n * // With custom config\n * await expectNoToast(page, config);\n *\n * // With custom timeout\n * await expectNoToast(page, undefined, 2000);\n * ```\n */\nexport async function expectNoToast(\n  page: Page,\n  config?: ARTKConfig,\n  timeout: number = 5000\n): Promise<void> {\n  // Load config if not provided\n  const toastConfig = config?.assertions?.toast ?? {\n    containerSelector: '[role=\"alert\"], .toast, .notification',\n    messageSelector: '.toast-message, .notification-message',\n    typeAttribute: 'data-type',\n  };\n\n  const { containerSelector } = toastConfig;\n\n  // Assert toast container is not visible\n  const toastContainer = page.locator(containerSelector);\n  await expect(toastContainer).not.toBeVisible({ timeout });\n}\n\n/**\n * Wait for a toast to appear and then disappear\n *\n * Useful for transient notifications that auto-dismiss.\n *\n * @param page - Playwright page object\n * @param message - Expected toast message\n * @param options - Toast assertion options\n * @param config - ARTK configuration (optional, will load from global if not provided)\n *\n * @example\n * ```typescript\n * // Wait for success toast to appear and disappear\n * await waitForToastDismiss(page, 'Saved successfully', { type: 'success' });\n * ```\n */\nexport async function waitForToastDismiss(\n  page: Page,\n  message: string,\n  options: ToastAssertionOptions = {},\n  config?: ARTKConfig\n): Promise<void> {\n  // First assert toast appears\n  await expectToast(page, message, options, config);\n\n  // Load config if not provided\n  const toastConfig = config?.assertions?.toast ?? {\n    containerSelector: '[role=\"alert\"], .toast, .notification',\n    messageSelector: '.toast-message, .notification-message',\n    typeAttribute: 'data-type',\n  };\n\n  const { containerSelector } = toastConfig;\n  const { timeout = 5000 } = options;\n\n  // Wait for toast to disappear\n  const toastContainer = page.locator(containerSelector);\n  await expect(toastContainer).not.toBeVisible({ timeout: timeout * 2 });\n}\n","/**\n * Table assertion helpers\n *\n * Provides assertions for verifying table content and row data.\n * Implements FR-022: Table row assertions with column matching\n *\n * @module assertions/table\n */\n\nimport { expect, type Locator, type Page } from '@playwright/test';\nimport type { TableAssertionOptions, TableRowData } from './types.js';\n\n/**\n * Assert that a table contains a row matching the given data\n *\n * Searches for a table row where all specified column values match.\n * Column names should correspond to data-testid attributes or visible headers.\n *\n * @param page - Playwright page object\n * @param tableSelector - Selector for the table element (testid, role, or CSS)\n * @param rowData - Expected row data as column-value pairs\n * @param options - Table assertion options\n *\n * @example\n * ```typescript\n * // Match row by ID and status\n * await expectTableToContainRow(page, 'orders-table', {\n *   id: '12345',\n *   status: 'Active',\n *   amount: 99.99\n * });\n *\n * // Exact match\n * await expectTableToContainRow(page, 'users-table', {\n *   email: 'user@example.com'\n * }, { exact: true });\n *\n * // With custom timeout\n * await expectTableToContainRow(page, 'results-table', {\n *   name: 'Test Result'\n * }, { timeout: 10000 });\n * ```\n */\nexport async function expectTableToContainRow(\n  page: Page,\n  tableSelector: string,\n  rowData: TableRowData,\n  options: TableAssertionOptions = {}\n): Promise<void> {\n  const { timeout = 5000, exact = false } = options;\n\n  // Locate the table\n  const table = getTableLocator(page, tableSelector);\n\n  // Get all rows in the table body\n  const rows = table.locator('tbody tr, tr').filter({ has: page.locator('td') });\n\n  // First check if table exists and get row count\n  await expect(table).toBeAttached({ timeout });\n  const rowCount = await rows.count();\n\n  if (rowCount === 0) {\n    throw new Error(`Table \"${tableSelector}\" has no data rows`);\n  }\n\n  // Now verify table is visible (only after we know it has rows)\n  await expect(table).toBeVisible({ timeout });\n\n  // Search for matching row\n  let foundMatch = false;\n\n  for (let i = 0; i < rowCount; i++) {\n    const row = rows.nth(i);\n    const matches = await rowMatchesData(row, rowData, exact);\n\n    if (matches) {\n      foundMatch = true;\n      break;\n    }\n  }\n\n  if (!foundMatch) {\n    const rowDataStr = JSON.stringify(rowData);\n    throw new Error(\n      `Table \"${tableSelector}\" does not contain a row matching: ${rowDataStr}`\n    );\n  }\n}\n\n/**\n * Assert that a table has the expected number of rows\n *\n * @param page - Playwright page object\n * @param tableSelector - Selector for the table element\n * @param expectedCount - Expected number of rows\n * @param options - Table assertion options\n *\n * @example\n * ```typescript\n * // Assert table has exactly 10 rows\n * await expectTableRowCount(page, 'results-table', 10);\n *\n * // With custom timeout\n * await expectTableRowCount(page, 'orders-table', 5, { timeout: 10000 });\n * ```\n */\nexport async function expectTableRowCount(\n  page: Page,\n  tableSelector: string,\n  expectedCount: number,\n  options: TableAssertionOptions = {}\n): Promise<void> {\n  const { timeout = 5000 } = options;\n\n  // Locate the table\n  const table = getTableLocator(page, tableSelector);\n\n  // For empty tables, we don't need to check visibility\n  // (they might be hidden/collapsed when empty)\n  if (expectedCount > 0) {\n    await expect(table).toBeVisible({ timeout });\n  } else {\n    // Just wait for table to exist in DOM\n    await expect(table).toBeAttached({ timeout });\n  }\n\n  // Get all rows in the table body\n  const rows = table.locator('tbody tr, tr').filter({ has: page.locator('td') });\n\n  // Assert count\n  await expect(rows).toHaveCount(expectedCount, { timeout });\n}\n\n/**\n * Get table locator using common strategies\n *\n * Tries data-testid, role, and CSS selector in that order.\n *\n * @param page - Playwright page object\n * @param tableSelector - Table selector\n * @returns Table locator\n */\nfunction getTableLocator(page: Page, tableSelector: string): Locator {\n  // Try data-testid first\n  if (!tableSelector.includes('[') && !tableSelector.includes('.') && !tableSelector.includes('#')) {\n    return page.getByTestId(tableSelector);\n  }\n\n  // Try role if it looks like a role selector\n  if (tableSelector === 'table') {\n    return page.getByRole('table');\n  }\n\n  // Fall back to CSS selector\n  return page.locator(tableSelector);\n}\n\n/**\n * Check if a row matches the expected data\n *\n * @param row - Table row locator\n * @param expectedData - Expected column-value pairs\n * @param exact - Whether to match exactly\n * @returns True if row matches, false otherwise\n */\nasync function rowMatchesData(\n  row: Locator,\n  expectedData: TableRowData,\n  exact: boolean\n): Promise<boolean> {\n  for (const [column, expectedValue] of Object.entries(expectedData)) {\n    // Try to find cell by data-testid first\n    const cell = row.locator(`[data-testid=\"${column}\"], [data-column=\"${column}\"]`);\n\n    // If not found, try finding by column index (assuming header order)\n    if ((await cell.count()) === 0) {\n      // Fall back to all cells - this is less precise but works for simple tables\n      const cells = row.locator('td');\n      const cellCount = await cells.count();\n\n      // Try to match by cell content\n      let foundCell = false;\n      for (let i = 0; i < cellCount; i++) {\n        const cellText = await cells.nth(i).textContent();\n        const expectedStr = String(expectedValue);\n\n        if (exact ? cellText?.trim() === expectedStr : cellText?.includes(expectedStr)) {\n          foundCell = true;\n          break;\n        }\n      }\n\n      if (!foundCell) {\n        return false;\n      }\n    } else {\n      // Found cell by testid/column attribute\n      const cellText = await cell.textContent();\n      const expectedStr = String(expectedValue);\n\n      const matches = exact\n        ? cellText?.trim() === expectedStr\n        : cellText?.includes(expectedStr);\n\n      if (!matches) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * Assert that a table is empty (has no data rows)\n *\n * @param page - Playwright page object\n * @param tableSelector - Selector for the table element\n * @param options - Table assertion options\n *\n * @example\n * ```typescript\n * // Assert table is empty\n * await expectTableEmpty(page, 'results-table');\n * ```\n */\nexport async function expectTableEmpty(\n  page: Page,\n  tableSelector: string,\n  options: TableAssertionOptions = {}\n): Promise<void> {\n  await expectTableRowCount(page, tableSelector, 0, options);\n}\n","/**\n * Form validation assertion helpers\n *\n * Provides assertions for verifying form validation states and error messages.\n * Implements FR-023: Form validation error assertions\n *\n * @module assertions/form\n */\n\nimport { expect, type Locator, type Page } from '@playwright/test';\nimport type { FormFieldErrorOptions, FormValidityOptions } from './types.js';\nimport type { ARTKConfig } from '../config/types.js';\n\n/**\n * Assert that a form field displays a validation error\n *\n * @param page - Playwright page object\n * @param fieldName - Field name, label, or testid\n * @param expectedError - Expected error message (supports partial match by default)\n * @param options - Form field error options\n * @param config - ARTK configuration (optional)\n *\n * @example\n * ```typescript\n * // Assert email field has required error\n * await expectFormFieldError(page, 'email', 'Email is required');\n *\n * // Exact error message match\n * await expectFormFieldError(page, 'password', 'Password must be at least 8 characters', {\n *   exact: true\n * });\n *\n * // With custom timeout\n * await expectFormFieldError(page, 'username', 'Username taken', { timeout: 10000 });\n * ```\n */\nexport async function expectFormFieldError(\n  page: Page,\n  fieldName: string,\n  expectedError: string,\n  options: FormFieldErrorOptions = {},\n  config?: ARTKConfig\n): Promise<void> {\n  const { timeout = 5000, exact = false } = options;\n\n  // Load config if not provided\n  const formConfig = config?.assertions?.form ?? {\n    errorSelector: '[data-field-error=\"{field}\"], [data-error-for=\"{field}\"], #error-{field}',\n    formErrorSelector: '.form-error, [role=\"alert\"]',\n  };\n\n  const { errorSelector } = formConfig;\n\n  // Replace {field} placeholder with actual field name\n  const fieldErrorSelector = errorSelector.replace(/{field}/g, fieldName);\n\n  // Locate the error element\n  const errorElement = page.locator(fieldErrorSelector);\n\n  // Assert error is visible\n  await expect(errorElement).toBeVisible({ timeout });\n\n  // Check error message\n  if (exact) {\n    await expect(errorElement).toHaveText(expectedError, { timeout });\n  } else {\n    await expect(errorElement).toContainText(expectedError, { timeout });\n  }\n}\n\n/**\n * Assert that a form is valid (no validation errors)\n *\n * @param page - Playwright page object\n * @param formSelector - Form selector (testid, CSS, or role)\n * @param options - Form validity options\n * @param config - ARTK configuration (optional)\n *\n * @example\n * ```typescript\n * // Assert login form is valid\n * await expectFormValid(page, 'login-form');\n *\n * // With custom timeout\n * await expectFormValid(page, 'registration-form', { timeout: 10000 });\n * ```\n */\nexport async function expectFormValid(\n  page: Page,\n  formSelector: string,\n  options: FormValidityOptions = {},\n  config?: ARTKConfig\n): Promise<void> {\n  const { timeout = 5000 } = options;\n\n  // Load config if not provided\n  const formConfig = config?.assertions?.form ?? {\n    errorSelector: '[data-field-error], [data-error-for], [id^=\"error-\"]',\n    formErrorSelector: '.form-error, [role=\"alert\"]',\n  };\n\n  const { formErrorSelector } = formConfig;\n\n  // Locate the form\n  const form = getFormLocator(page, formSelector);\n  await expect(form).toBeVisible({ timeout });\n\n  // Assert no error elements within form\n  const errorElements = form.locator(formErrorSelector);\n  await expect(errorElements).toHaveCount(0, { timeout });\n}\n\n/**\n * Assert that a form field does NOT have a validation error\n *\n * @param page - Playwright page object\n * @param fieldName - Field name, label, or testid\n * @param options - Form field error options\n * @param config - ARTK configuration (optional)\n *\n * @example\n * ```typescript\n * // Assert email field has no error\n * await expectNoFormFieldError(page, 'email');\n * ```\n */\nexport async function expectNoFormFieldError(\n  page: Page,\n  fieldName: string,\n  options: FormFieldErrorOptions = {},\n  config?: ARTKConfig\n): Promise<void> {\n  const { timeout = 5000 } = options;\n\n  // Load config if not provided\n  const formConfig = config?.assertions?.form ?? {\n    errorSelector: '[data-field-error=\"{field}\"], [data-error-for=\"{field}\"], #error-{field}',\n    formErrorSelector: '.form-error, [role=\"alert\"]',\n  };\n\n  const { errorSelector } = formConfig;\n\n  // Replace {field} placeholder with actual field name\n  const fieldErrorSelector = errorSelector.replace(/{field}/g, fieldName);\n\n  // Locate the error element\n  const errorElement = page.locator(fieldErrorSelector);\n\n  // Assert error is not visible\n  await expect(errorElement).not.toBeVisible({ timeout });\n}\n\n/**\n * Assert that a form displays a form-level error message\n *\n * Form-level errors are typically shown at the top of the form and apply\n * to the entire form rather than a specific field.\n *\n * @param page - Playwright page object\n * @param formSelector - Form selector\n * @param expectedError - Expected error message\n * @param options - Form field error options\n * @param config - ARTK configuration (optional)\n *\n * @example\n * ```typescript\n * // Assert form shows general error\n * await expectFormError(page, 'login-form', 'Invalid credentials');\n * ```\n */\nexport async function expectFormError(\n  page: Page,\n  formSelector: string,\n  expectedError: string,\n  options: FormFieldErrorOptions = {},\n  config?: ARTKConfig\n): Promise<void> {\n  const { timeout = 5000, exact = false } = options;\n\n  // Load config if not provided\n  const formConfig = config?.assertions?.form ?? {\n    errorSelector: '[data-field-error], [data-error-for], [id^=\"error-\"]',\n    formErrorSelector: '.form-error, [role=\"alert\"]',\n  };\n\n  const { formErrorSelector } = formConfig;\n\n  // Locate the form\n  const form = getFormLocator(page, formSelector);\n  await expect(form).toBeVisible({ timeout });\n\n  // Find form-level error\n  const formError = form.locator(formErrorSelector);\n  await expect(formError).toBeVisible({ timeout });\n\n  // Check error message\n  if (exact) {\n    await expect(formError).toHaveText(expectedError, { timeout });\n  } else {\n    await expect(formError).toContainText(expectedError, { timeout });\n  }\n}\n\n/**\n * Get form locator using common strategies\n *\n * @param page - Playwright page object\n * @param formSelector - Form selector\n * @returns Form locator\n */\nfunction getFormLocator(page: Page, formSelector: string): Locator {\n  // Try data-testid first\n  if (!formSelector.includes('[') && !formSelector.includes('.') && !formSelector.includes('#')) {\n    return page.getByTestId(formSelector);\n  }\n\n  // Try role if it looks like a role selector\n  if (formSelector === 'form') {\n    return page.getByRole('form');\n  }\n\n  // Fall back to CSS selector\n  return page.locator(formSelector);\n}\n","/**\n * Loading state assertion helpers\n *\n * Provides assertions for verifying loading indicators and waiting for loading completion.\n * Implements FR-024: Loading state assertions with configurable selectors\n *\n * @module assertions/loading\n */\n\nimport { expect, type Page } from '@playwright/test';\nimport type { LoadingStateOptions } from './types.js';\nimport type { ARTKConfig } from '../config/types.js';\n\n/**\n * Default loading indicator selectors\n *\n * Used when config is not provided or custom selectors are not specified.\n */\nconst DEFAULT_LOADING_SELECTORS = [\n  '[data-loading=\"true\"]',\n  '.loading',\n  '.spinner',\n  '[aria-busy=\"true\"]',\n  '.loading-overlay',\n  '[role=\"progressbar\"]',\n];\n\n/**\n * Assert that a loading indicator is visible\n *\n * @param page - Playwright page object\n * @param options - Loading state options\n * @param config - ARTK configuration (optional)\n *\n * @example\n * ```typescript\n * // Assert any configured loading indicator is visible\n * await expectLoading(page);\n *\n * // With custom selectors\n * await expectLoading(page, {\n *   selectors: ['.custom-spinner', '#loading-overlay']\n * });\n *\n * // With custom timeout\n * await expectLoading(page, { timeout: 10000 });\n * ```\n */\nexport async function expectLoading(\n  page: Page,\n  options: LoadingStateOptions = {},\n  config?: ARTKConfig\n): Promise<void> {\n  const { timeout = 5000, selectors } = options;\n\n  // Get loading selectors from options, config, or defaults\n  const loadingSelectors =\n    selectors ??\n    config?.assertions?.loading?.selectors ??\n    DEFAULT_LOADING_SELECTORS;\n\n  // Create a combined selector for any loading indicator\n  const combinedSelector = loadingSelectors.join(', ');\n  const loadingIndicator = page.locator(combinedSelector);\n\n  // Assert at least one loading indicator is visible\n  await expect(loadingIndicator.first()).toBeVisible({ timeout });\n}\n\n/**\n * Assert that no loading indicators are visible\n *\n * @param page - Playwright page object\n * @param options - Loading state options\n * @param config - ARTK configuration (optional)\n *\n * @example\n * ```typescript\n * // Assert no loading indicators are visible\n * await expectNotLoading(page);\n *\n * // With custom selectors\n * await expectNotLoading(page, {\n *   selectors: ['.custom-spinner']\n * });\n * ```\n */\nexport async function expectNotLoading(\n  page: Page,\n  options: LoadingStateOptions = {},\n  config?: ARTKConfig\n): Promise<void> {\n  const { timeout = 5000, selectors } = options;\n\n  // Get loading selectors from options, config, or defaults\n  const loadingSelectors =\n    selectors ??\n    config?.assertions?.loading?.selectors ??\n    DEFAULT_LOADING_SELECTORS;\n\n  // Check each loading selector individually\n  for (const selector of loadingSelectors) {\n    const loadingIndicator = page.locator(selector);\n    await expect(loadingIndicator).not.toBeVisible({ timeout });\n  }\n}\n\n/**\n * Wait for all loading indicators to complete (disappear)\n *\n * This is the most commonly used loading assertion - it waits for the page\n * to finish loading before proceeding with test assertions.\n *\n * @param page - Playwright page object\n * @param options - Loading state options\n * @param config - ARTK configuration (optional)\n *\n * @example\n * ```typescript\n * // Wait for loading to complete\n * await waitForLoadingComplete(page);\n *\n * // With custom timeout (for slow operations)\n * await waitForLoadingComplete(page, { timeout: 30000 });\n *\n * // With custom loading selectors\n * await waitForLoadingComplete(page, {\n *   selectors: ['.data-grid-loading', '.chart-loading']\n * });\n * ```\n */\nexport async function waitForLoadingComplete(\n  page: Page,\n  options: LoadingStateOptions = {},\n  config?: ARTKConfig\n): Promise<void> {\n  const { timeout = 30000, selectors } = options;\n\n  // Get loading selectors from options, config, or defaults\n  const loadingSelectors =\n    selectors ??\n    config?.assertions?.loading?.selectors ??\n    DEFAULT_LOADING_SELECTORS;\n\n  // First, optionally wait for loading to start (prevents race conditions)\n  // We give it a short timeout since loading might already be in progress\n  const combinedSelector = loadingSelectors.join(', ');\n  const loadingIndicator = page.locator(combinedSelector);\n\n  try {\n    await expect(loadingIndicator.first()).toBeVisible({ timeout: 1000 });\n  } catch {\n    // Loading might have already completed or never started - that's OK\n  }\n\n  // Now wait for all loading indicators to disappear\n  for (const selector of loadingSelectors) {\n    const indicator = page.locator(selector);\n    await expect(indicator).not.toBeVisible({ timeout });\n  }\n}\n\n/**\n * Wait for a specific loading operation to start and complete\n *\n * Useful for operations where you want to ensure loading actually occurred\n * (not just that loading is currently complete).\n *\n * @param page - Playwright page object\n * @param operation - Async function that triggers the loading operation\n * @param options - Loading state options\n * @param config - ARTK configuration (optional)\n *\n * @example\n * ```typescript\n * // Wait for save operation to complete\n * await waitForLoadingOperation(page, async () => {\n *   await page.getByRole('button', { name: 'Save' }).click();\n * });\n *\n * // With custom selectors\n * await waitForLoadingOperation(\n *   page,\n *   async () => { await page.getByRole('button', { name: 'Refresh' }).click(); },\n *   { selectors: ['.table-loading'] }\n * );\n * ```\n */\nexport async function waitForLoadingOperation(\n  page: Page,\n  operation: () => Promise<void>,\n  options: LoadingStateOptions = {},\n  config?: ARTKConfig\n): Promise<void> {\n  const { timeout = 30000, selectors } = options;\n\n  // Get loading selectors from options, config, or defaults\n  const loadingSelectors =\n    selectors ??\n    config?.assertions?.loading?.selectors ??\n    DEFAULT_LOADING_SELECTORS;\n\n  const combinedSelector = loadingSelectors.join(', ');\n  const loadingIndicator = page.locator(combinedSelector);\n\n  // Trigger the operation\n  await operation();\n\n  // Wait for loading to appear - use a reasonable timeout that won't exceed test timeout\n  // Use half of the total timeout for waiting to appear, or 3s max\n  const appearTimeout = Math.min(timeout / 2, 3000);\n  await expect(loadingIndicator.first()).toBeVisible({ timeout: appearTimeout });\n\n  // Wait for loading to complete\n  await waitForLoadingComplete(page, { timeout, selectors }, config);\n}\n","/**\n * URL assertion helpers\n *\n * Provides assertions for verifying page URLs and navigation.\n *\n * @module assertions/url\n */\n\nimport type { Page } from '@playwright/test';\nimport type { UrlAssertionOptions } from './types.js';\n\n/**\n * Assert that the current URL contains the expected substring\n *\n * @param page - Playwright page object\n * @param expectedSubstring - Expected substring in URL\n * @param options - URL assertion options\n *\n * @example\n * ```typescript\n * // Assert URL contains /dashboard\n * await expectUrlContains(page, '/dashboard');\n *\n * // Assert URL contains query parameter\n * await expectUrlContains(page, 'status=active');\n *\n * // Ignore query parameters\n * await expectUrlContains(page, '/users/123', { ignoreQueryParams: true });\n *\n * // With custom timeout\n * await expectUrlContains(page, '/orders', { timeout: 10000 });\n * ```\n */\nexport async function expectUrlContains(\n  page: Page,\n  expectedSubstring: string,\n  options: UrlAssertionOptions = {}\n): Promise<void> {\n  const { timeout = 5000, ignoreQueryParams = false, ignoreHash = false } = options;\n\n  // Wait for URL to match\n  await page.waitForURL(\n    (url) => {\n      let urlStr = url.toString();\n\n      // Remove query params if requested\n      if (ignoreQueryParams) {\n        const urlObj = new URL(urlStr);\n        urlStr = `${urlObj.origin}${urlObj.pathname}`;\n      }\n\n      // Remove hash if requested\n      if (ignoreHash) {\n        urlStr = urlStr.split('#')[0] ?? urlStr;\n      }\n\n      return urlStr.includes(expectedSubstring);\n    },\n    { timeout }\n  );\n}\n\n/**\n * Assert that the current URL matches a regular expression pattern\n *\n * @param page - Playwright page object\n * @param pattern - Regular expression or string pattern\n * @param options - URL assertion options\n *\n * @example\n * ```typescript\n * // Assert URL matches pattern\n * await expectUrlMatches(page, /\\/users\\/\\d+/);\n *\n * // String pattern (converted to RegExp)\n * await expectUrlMatches(page, '/users/[0-9]+');\n *\n * // Ignore query parameters\n * await expectUrlMatches(page, /\\/orders\\/\\d+$/, { ignoreQueryParams: true });\n * ```\n */\nexport async function expectUrlMatches(\n  page: Page,\n  pattern: RegExp | string,\n  options: UrlAssertionOptions = {}\n): Promise<void> {\n  const { timeout = 5000, ignoreQueryParams = false, ignoreHash = false } = options;\n\n  // Convert string pattern to RegExp\n  const regex = typeof pattern === 'string' ? new RegExp(pattern) : pattern;\n\n  // Wait for URL to match\n  await page.waitForURL(\n    (url) => {\n      let urlStr = url.toString();\n\n      // Remove query params if requested\n      if (ignoreQueryParams) {\n        const urlObj = new URL(urlStr);\n        urlStr = `${urlObj.origin}${urlObj.pathname}`;\n      }\n\n      // Remove hash if requested\n      if (ignoreHash) {\n        urlStr = urlStr.split('#')[0] ?? urlStr;\n      }\n\n      return regex.test(urlStr);\n    },\n    { timeout }\n  );\n}\n\n/**\n * Assert that the current URL exactly equals the expected URL\n *\n * @param page - Playwright page object\n * @param expectedUrl - Expected exact URL\n * @param options - URL assertion options\n *\n * @example\n * ```typescript\n * // Assert exact URL\n * await expectUrlEquals(page, 'https://example.com/dashboard');\n *\n * // Ignore query parameters\n * await expectUrlEquals(page, 'https://example.com/users', { ignoreQueryParams: true });\n *\n * // Ignore hash\n * await expectUrlEquals(page, 'https://example.com/page', { ignoreHash: true });\n * ```\n */\nexport async function expectUrlEquals(\n  page: Page,\n  expectedUrl: string,\n  options: UrlAssertionOptions = {}\n): Promise<void> {\n  const { timeout = 5000, ignoreQueryParams = false, ignoreHash = false } = options;\n\n  // Normalize expected URL\n  let normalizedExpected = expectedUrl;\n  if (ignoreQueryParams || ignoreHash) {\n    const expectedUrlObj = new URL(expectedUrl, 'http://dummy.com');\n    if (ignoreQueryParams) {\n      normalizedExpected = `${expectedUrlObj.origin}${expectedUrlObj.pathname}`;\n    }\n    if (ignoreHash) {\n      normalizedExpected = normalizedExpected.split('#')[0] ?? normalizedExpected;\n    }\n  }\n\n  // Wait for URL to match\n  await page.waitForURL(\n    (url) => {\n      let urlStr = url.toString();\n\n      // Apply same normalization to actual URL\n      if (ignoreQueryParams) {\n        const urlObj = new URL(urlStr);\n        urlStr = `${urlObj.origin}${urlObj.pathname}`;\n      }\n\n      if (ignoreHash) {\n        urlStr = urlStr.split('#')[0] ?? urlStr;\n      }\n\n      return urlStr === normalizedExpected;\n    },\n    { timeout }\n  );\n}\n\n/**\n * Assert that the current URL path matches the expected path\n *\n * This ignores the origin (protocol + domain) and only checks the pathname.\n *\n * @param page - Playwright page object\n * @param expectedPath - Expected URL path (e.g., '/users/123')\n * @param options - URL assertion options\n *\n * @example\n * ```typescript\n * // Assert URL path is /dashboard\n * await expectUrlPath(page, '/dashboard');\n *\n * // Ignore query parameters\n * await expectUrlPath(page, '/users/123', { ignoreQueryParams: true });\n * ```\n */\nexport async function expectUrlPath(\n  page: Page,\n  expectedPath: string,\n  options: UrlAssertionOptions = {}\n): Promise<void> {\n  const { timeout = 5000, ignoreQueryParams = false, ignoreHash = false } = options;\n\n  // Normalize expected path\n  let normalizedExpectedPath = expectedPath;\n  if (ignoreQueryParams || ignoreHash) {\n    if (ignoreQueryParams) {\n      normalizedExpectedPath = normalizedExpectedPath.split('?')[0] ?? normalizedExpectedPath;\n    }\n    if (ignoreHash) {\n      normalizedExpectedPath = normalizedExpectedPath.split('#')[0] ?? normalizedExpectedPath;\n    }\n  }\n\n  // Wait for URL path to match\n  await page.waitForURL(\n    (url) => {\n      let pathname = url.pathname;\n\n      // Apply same normalization to actual pathname\n      if (ignoreQueryParams) {\n        pathname = pathname.split('?')[0] ?? pathname;\n      }\n\n      if (ignoreHash) {\n        pathname = pathname.split('#')[0] ?? pathname;\n      }\n\n      return pathname === normalizedExpectedPath;\n    },\n    { timeout }\n  );\n}\n","/**\n * API response assertion helpers\n *\n * Provides assertions for verifying API responses (status, body, headers).\n * These are helpers for E2E tests that make API calls for data setup/verification,\n * not for standalone API testing.\n *\n * @module assertions/api\n */\n\nimport { type APIResponse, expect } from '@playwright/test';\nimport type { ApiResponseAssertionOptions, ExpectedApiResponse } from './types.js';\n\n/**\n * Assert that an API response matches expected criteria\n *\n * @param response - Playwright API response object\n * @param expected - Expected response structure\n * @param options - API response assertion options\n *\n * @example\n * ```typescript\n * // Basic status check\n * const response = await apiContext.get('/api/users');\n * await expectApiResponse(response, { status: 200 });\n *\n * // Check status and body\n * await expectApiResponse(response, {\n *   status: 200,\n *   body: { success: true }\n * });\n *\n * // Check status, body, and headers\n * await expectApiResponse(response, {\n *   status: 201,\n *   body: { id: 123, name: 'Test User' },\n *   headers: { 'content-type': 'application/json' }\n * });\n *\n * // Exact body match\n * await expectApiResponse(response, {\n *   status: 200,\n *   body: { exact: 'match' }\n * }, { exactBodyMatch: true });\n * ```\n */\nexport async function expectApiResponse(\n  response: APIResponse,\n  expected: ExpectedApiResponse,\n  options: ApiResponseAssertionOptions = {}\n): Promise<void> {\n  const { exactBodyMatch = false } = options;\n\n  // Check status code\n  if (expected.status !== undefined) {\n    expect(response.status(), `Expected status ${expected.status}`).toBe(expected.status);\n  }\n\n  // Check content type\n  if (expected.contentType !== undefined) {\n    const actualContentType = response.headers()['content-type'] ?? '';\n    expect(actualContentType, `Expected content type ${expected.contentType}`).toContain(\n      expected.contentType\n    );\n  }\n\n  // Check headers\n  if (expected.headers !== undefined) {\n    const actualHeaders = response.headers();\n    for (const [headerName, expectedValue] of Object.entries(expected.headers)) {\n      const actualValue = actualHeaders[headerName.toLowerCase()];\n      expect(actualValue, `Expected header ${headerName}: ${expectedValue}`).toBe(expectedValue);\n    }\n  }\n\n  // Check body\n  if (expected.body !== undefined) {\n    const actualBody = await response.json();\n\n    if (exactBodyMatch) {\n      expect(actualBody, 'Expected exact body match').toEqual(expected.body);\n    } else {\n      // Partial match - check that all expected fields exist and match\n      for (const [key, expectedValue] of Object.entries(expected.body)) {\n        expect(actualBody, `Expected body to have key \"${key}\"`).toHaveProperty(key);\n        expect(actualBody[key], `Expected ${key} to equal ${expectedValue}`).toEqual(\n          expectedValue\n        );\n      }\n    }\n  }\n}\n\n/**\n * Assert that an API response indicates success (2xx status)\n *\n * @param response - Playwright API response object\n *\n * @example\n * ```typescript\n * const response = await apiContext.post('/api/orders', { data: orderData });\n * await expectApiSuccess(response);\n * ```\n */\nexport async function expectApiSuccess(response: APIResponse): Promise<void> {\n  const status = response.status();\n  expect(status, `Expected 2xx status but got ${status}`).toBeGreaterThanOrEqual(200);\n  expect(status, `Expected 2xx status but got ${status}`).toBeLessThan(300);\n}\n\n/**\n * Assert that an API response indicates an error (4xx or 5xx status)\n *\n * @param response - Playwright API response object\n * @param expectedStatus - Optional specific error status to check\n *\n * @example\n * ```typescript\n * // Assert any error status\n * const response = await apiContext.get('/api/invalid');\n * await expectApiError(response);\n *\n * // Assert specific error status\n * await expectApiError(response, 404);\n * ```\n */\nexport async function expectApiError(\n  response: APIResponse,\n  expectedStatus?: number\n): Promise<void> {\n  const status = response.status();\n\n  if (expectedStatus !== undefined) {\n    expect(status, `Expected status ${expectedStatus} but got ${status}`).toBe(expectedStatus);\n  } else {\n    const isError = status >= 400 && status < 600;\n    expect(isError, `Expected error status (4xx or 5xx) but got ${status}`).toBe(true);\n  }\n}\n\n/**\n * Assert that an API response body contains specific fields\n *\n * @param response - Playwright API response object\n * @param expectedFields - Array of field names that should exist in response body\n *\n * @example\n * ```typescript\n * const response = await apiContext.get('/api/users/123');\n * await expectApiBodyHasFields(response, ['id', 'name', 'email']);\n * ```\n */\nexport async function expectApiBodyHasFields(\n  response: APIResponse,\n  expectedFields: readonly string[]\n): Promise<void> {\n  const actualBody = await response.json();\n\n  for (const field of expectedFields) {\n    expect(actualBody, `Expected response body to have field \"${field}\"`).toHaveProperty(field);\n  }\n}\n\n/**\n * Assert that an API response body is an array with expected length\n *\n * @param response - Playwright API response object\n * @param expectedLength - Expected array length (or undefined to just check it's an array)\n *\n * @example\n * ```typescript\n * // Assert response is an array\n * const response = await apiContext.get('/api/users');\n * await expectApiBodyIsArray(response);\n *\n * // Assert response is an array with specific length\n * await expectApiBodyIsArray(response, 10);\n * ```\n */\nexport async function expectApiBodyIsArray(\n  response: APIResponse,\n  expectedLength?: number\n): Promise<void> {\n  const actualBody = await response.json();\n\n  expect(Array.isArray(actualBody), 'Expected response body to be an array').toBe(true);\n\n  if (expectedLength !== undefined) {\n    expect(\n      actualBody.length,\n      `Expected array length ${expectedLength} but got ${actualBody.length}`\n    ).toBe(expectedLength);\n  }\n}\n\n/**\n * Assert that an API response indicates a validation error with specific message\n *\n * Common pattern: 400 status with error message in body.\n *\n * @param response - Playwright API response object\n * @param expectedMessage - Expected error message (partial match)\n *\n * @example\n * ```typescript\n * const response = await apiContext.post('/api/users', { data: { email: 'invalid' } });\n * await expectApiValidationError(response, 'Invalid email format');\n * ```\n */\nexport async function expectApiValidationError(\n  response: APIResponse,\n  expectedMessage: string\n): Promise<void> {\n  // Check status is 400\n  expect(response.status(), 'Expected validation error status 400').toBe(400);\n\n  // Check body contains error message\n  const body = await response.json();\n\n  // Try common error field names\n  const errorMessage =\n    body.error ?? body.message ?? body.errorMessage ?? JSON.stringify(body);\n\n  expect(\n    typeof errorMessage === 'string' && errorMessage.includes(expectedMessage),\n    `Expected error message to contain \"${expectedMessage}\" but got \"${errorMessage}\"`\n  ).toBe(true);\n}\n"]}
// install/package-generator.ts
var DEFAULT_OPTIONS = {
  projectName: "artk-e2e-tests",
  description: "ARTK E2E Testing Suite",
  artkCoreVersion: "1.0.0",
  playwrightVersion: "^1.57.0",
  additionalScripts: {},
  additionalDependencies: {},
  additionalDevDependencies: {},
  includeTypeScript: true,
  typescriptVersion: "^5.3.3",
  vendored: true
};
function normalizeProjectName(name) {
  return name.toLowerCase().replace(/[^a-z0-9-]/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "");
}
function generatePackageJsonObject(options) {
  const opts = {
    ...DEFAULT_OPTIONS,
    ...options
  };
  const projectName = normalizeProjectName(opts.projectName);
  const scripts = {
    test: "playwright test",
    "test:headed": "playwright test --headed",
    "test:debug": "playwright test --debug",
    "test:ui": "playwright test --ui",
    report: "playwright show-report",
    codegen: "playwright codegen",
    ...opts.additionalScripts
  };
  const dependencies = {
    // For vendored installation, use local path
    "@artk/core": opts.vendored ? "file:./vendor/artk-core" : opts.artkCoreVersion,
    ...opts.additionalDependencies
  };
  const devDependencies = {
    "@playwright/test": opts.playwrightVersion,
    ...opts.additionalDevDependencies
  };
  if (opts.includeTypeScript) {
    devDependencies["typescript"] = opts.typescriptVersion;
    devDependencies["@types/node"] = "^20.10.0";
    scripts["typecheck"] = "tsc --noEmit";
  }
  return {
    name: projectName,
    version: "1.0.0",
    private: true,
    type: "module",
    description: opts.description,
    scripts,
    dependencies,
    devDependencies,
    engines: {
      node: ">=18.0.0"
    }
  };
}
function generatePackageJson(options) {
  const packageJson = generatePackageJsonObject(options);
  return JSON.stringify(packageJson, null, 2) + "\n";
}
function validateProjectName(name) {
  const warnings = [];
  const normalized = normalizeProjectName(name);
  if (normalized !== name.toLowerCase()) {
    warnings.push(
      `Project name normalized from "${name}" to "${normalized}"`
    );
  }
  if (normalized.length === 0) {
    return {
      valid: false,
      normalized: "artk-e2e-tests",
      warnings: ["Project name is empty, using default: artk-e2e-tests"]
    };
  }
  if (normalized.startsWith("-") || normalized.endsWith("-")) {
    warnings.push("Project name should not start or end with hyphens");
  }
  if (normalized.length > 214) {
    return {
      valid: false,
      normalized: normalized.substring(0, 214),
      warnings: ["Project name too long (max 214 characters), truncated"]
    };
  }
  return {
    valid: true,
    normalized,
    warnings
  };
}
var DEPENDENCY_VERSIONS = {
  playwright: "^1.57.0",
  typescript: "^5.3.3",
  artkCore: "1.0.0",
  node: ">=18.0.0"
};

// install/playwright-config-generator.ts
var DEFAULT_OPTIONS2 = {
  targets: [],
  defaultTarget: "",
  testDir: "tests",
  outputDir: "test-results",
  retries: 2,
  fullyParallel: true,
  workers: void 0,
  forbidOnly: true,
  timeout: 3e4,
  expectTimeout: 5e3,
  trace: "on-first-retry",
  screenshot: "only-on-failure",
  video: "on-first-retry",
  viewport: { width: 1280, height: 720 },
  headless: true,
  browsers: ["chromium"],
  includeReporter: true,
  reporter: void 0,
  useArtkHarness: true,
  includeAuthSetup: true
};
function generatePlaywrightConfig(options) {
  const opts = {
    ...DEFAULT_OPTIONS2,
    ...options
  };
  const lines = [];
  lines.push(`/**`);
  lines.push(` * Playwright Configuration`);
  lines.push(` * Generated by ARTK E2E`);
  lines.push(` * @see https://playwright.dev/docs/test-configuration`);
  lines.push(` */`);
  lines.push("");
  lines.push(`import { defineConfig, devices } from '@playwright/test';`);
  if (opts.useArtkHarness) {
    lines.push(`import { loadArtkConfig } from '@artk/core/config';`);
    lines.push(`import { validateBrowserChannel } from '@artk/core/harness';`);
  }
  lines.push("");
  lines.push(`// Load environment`);
  lines.push(`const env = process.env.ARTK_ENV || 'local';`);
  lines.push(`const isCI = !!process.env.CI;`);
  lines.push("");
  if (opts.useArtkHarness) {
    lines.push(`// Load ARTK configuration`);
    lines.push(`const artkConfig = loadArtkConfig();`);
    lines.push("");
  }
  lines.push(`export default defineConfig({`);
  lines.push(`  testDir: '${opts.testDir}',`);
  lines.push(`  outputDir: '${opts.outputDir}',`);
  lines.push(`  fullyParallel: ${opts.fullyParallel},`);
  lines.push(`  forbidOnly: isCI,`);
  lines.push(`  retries: isCI ? ${opts.retries} : 0,`);
  if (opts.workers !== void 0) {
    lines.push(`  workers: ${opts.workers},`);
  } else {
    lines.push(`  workers: isCI ? 1 : undefined,`);
  }
  lines.push(`  timeout: ${opts.timeout},`);
  lines.push(`  expect: {`);
  lines.push(`    timeout: ${opts.expectTimeout},`);
  lines.push(`  },`);
  if (opts.useArtkHarness) {
    lines.push("");
    lines.push(`  // Global setup: validate browser availability`);
    lines.push(`  async globalSetup() {`);
    lines.push(`    const config = loadArtkConfig();`);
    lines.push(`    if (config.browsers.channel && config.browsers.channel !== 'bundled') {`);
    lines.push(`      const validation = await validateBrowserChannel(config.browsers.channel);`);
    lines.push(`      if (!validation.available) {`);
    lines.push(`        console.error('\\nBrowser validation failed:\\n');`);
    lines.push(`        console.error(\`  Configured: \${config.browsers.channel}\`);`);
    lines.push(`        console.error('  Status: Not available');`);
    lines.push(`        console.error(\`  Reason: \${validation.reason}\\n\`);`);
    lines.push(`        console.error('Solutions:');`);
    lines.push(`        console.error('  1. Install the browser (see reason above)');`);
    lines.push(`        console.error(\`  2. Edit artk.config.yml and remove or change 'channel'\`);`);
    lines.push(`        console.error('  3. Run bootstrap again to auto-detect browsers\\n');`);
    lines.push(`        throw new Error(\`Browser \${config.browsers.channel} not available\`);`);
    lines.push(`      }`);
    lines.push(`      console.log(\`Browser validated: \${config.browsers.channel} v\${validation.version}\`);`);
    lines.push(`    }`);
    lines.push(`  },`);
  }
  if (opts.includeReporter) {
    lines.push(`  reporter: isCI ? 'github' : [['html', { open: 'never' }]],`);
  } else if (opts.reporter) {
    lines.push(`  reporter: ${opts.reporter},`);
  }
  lines.push(`  use: {`);
  lines.push(`    // Base URL - defaults to first target or env variable`);
  if (opts.useArtkHarness && opts.targets.length > 0) {
    const defaultTarget = opts.defaultTarget || opts.targets[0]?.name;
    lines.push(`    baseURL: artkConfig.getTargetUrl('${defaultTarget}', env),`);
  } else {
    lines.push(`    baseURL: process.env.BASE_URL || 'http://localhost:3000',`);
  }
  lines.push("");
  lines.push(`    // Tracing and screenshots`);
  lines.push(`    trace: '${opts.trace}',`);
  lines.push(`    screenshot: '${opts.screenshot}',`);
  lines.push(`    video: '${opts.video}',`);
  lines.push("");
  lines.push(`    // Viewport`);
  lines.push(`    viewport: { width: ${opts.viewport.width}, height: ${opts.viewport.height} },`);
  lines.push("");
  lines.push(`    // Headless mode`);
  lines.push(`    headless: isCI || ${opts.headless},`);
  if (opts.useArtkHarness) {
    lines.push("");
    lines.push(`    // Browser channel`);
    lines.push(`    ...(artkConfig.browsers.channel && artkConfig.browsers.channel !== 'bundled'`);
    lines.push(`      ? { channel: artkConfig.browsers.channel }`);
    lines.push(`      : {}),`);
  }
  lines.push(`  },`);
  lines.push("");
  lines.push(`  projects: [`);
  if (opts.includeAuthSetup) {
    lines.push(`    // Authentication setup`);
    lines.push(`    {`);
    lines.push(`      name: 'setup',`);
    lines.push(`      testMatch: /.*\\.setup\\.ts/,`);
    lines.push(`    },`);
    lines.push("");
  }
  for (const browser of opts.browsers) {
    const deviceName = getDeviceName(browser);
    const dependencies = opts.includeAuthSetup ? `['setup']` : "[]";
    lines.push(`    {`);
    lines.push(`      name: '${browser}',`);
    lines.push(`      use: { ...devices['${deviceName}'] },`);
    lines.push(`      dependencies: ${dependencies},`);
    lines.push(`    },`);
  }
  if (opts.targets.length > 0) {
    lines.push("");
    lines.push(`    // Target-specific projects`);
    for (const target of opts.targets) {
      lines.push(`    {`);
      lines.push(`      name: '${target.name}',`);
      lines.push(`      testDir: '${target.testDir || `tests/${target.name}`}',`);
      if (opts.useArtkHarness) {
        lines.push(`      use: {`);
        lines.push(`        baseURL: artkConfig.getTargetUrl('${target.name}', env),`);
        if (target.storageState) {
          lines.push(`        storageState: '${target.storageState}',`);
        }
        lines.push(`      },`);
      }
      lines.push(`      dependencies: ['setup'],`);
      lines.push(`    },`);
    }
  }
  lines.push(`  ],`);
  lines.push("");
  lines.push(`  // Uncomment to start your dev server before tests`);
  lines.push(`  // webServer: {`);
  lines.push(`  //   command: 'npm run dev',`);
  lines.push(`  //   url: 'http://localhost:3000',`);
  lines.push(`  //   reuseExistingServer: !isCI,`);
  lines.push(`  // },`);
  lines.push(`});`);
  lines.push("");
  return lines.join("\n");
}
function getDeviceName(browser) {
  switch (browser) {
    case "chromium":
      return "Desktop Chrome";
    case "firefox":
      return "Desktop Firefox";
    case "webkit":
      return "Desktop Safari";
  }
}
function generateMinimalPlaywrightConfig() {
  return `import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './tests',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    baseURL: process.env.BASE_URL || 'http://localhost:3000',
    trace: 'on-first-retry',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
  ],
});
`;
}
function generateTsConfig() {
  const config = {
    compilerOptions: {
      target: "ES2022",
      module: "ESNext",
      moduleResolution: "bundler",
      strict: true,
      esModuleInterop: true,
      skipLibCheck: true,
      forceConsistentCasingInFileNames: true,
      resolveJsonModule: true,
      declaration: false,
      noEmit: true,
      paths: {
        "@artk/core/*": ["./vendor/artk-core/*"]
      }
    },
    include: ["tests/**/*.ts", "playwright.config.ts"],
    exclude: ["node_modules"]
  };
  return JSON.stringify(config, null, 2) + "\n";
}

// install/gitignore-generator.ts
var DEFAULT_OPTIONS3 = {
  includeAuthStates: true,
  includeTestArtifacts: true,
  includeCoverage: true,
  includeIdeFiles: true,
  includeOsFiles: true,
  additionalPatterns: [],
  exceptions: []
};
function createAuthStatesSection() {
  return {
    header: "Auth Storage States (sensitive)",
    patterns: [
      ".auth-states/",
      "*.storageState.json",
      // But keep the directory structure
      "!.auth-states/.gitkeep"
    ]
  };
}
function createTestArtifactsSection() {
  return {
    header: "Test Artifacts",
    patterns: [
      "test-results/",
      "playwright-report/",
      "blob-report/",
      ".playwright/",
      "*.trace.zip",
      "screenshots/",
      "videos/"
    ]
  };
}
function createCoverageSection() {
  return {
    header: "Coverage",
    patterns: ["coverage/", ".nyc_output/", "*.lcov"]
  };
}
function createIdeFilesSection() {
  return {
    header: "IDE and Editor",
    patterns: [
      ".idea/",
      ".vscode/",
      "*.swp",
      "*.swo",
      "*~",
      ".project",
      ".classpath",
      ".settings/"
    ]
  };
}
function createOsFilesSection() {
  return {
    header: "OS Files",
    patterns: [
      ".DS_Store",
      "Thumbs.db",
      "Desktop.ini",
      "*.lnk"
    ]
  };
}
function createDependenciesSection() {
  return {
    header: "Dependencies",
    patterns: [
      "node_modules/",
      // Keep vendored @artk/core
      "!vendor/",
      "!vendor/**"
    ]
  };
}
function createBuildSection() {
  return {
    header: "Build Output",
    patterns: ["dist/", "build/", "*.tsbuildinfo"]
  };
}
function createEnvironmentSection() {
  return {
    header: "Environment",
    patterns: [
      ".env",
      ".env.local",
      ".env.*.local",
      // But keep example env files
      "!.env.example",
      "!.env.template"
    ]
  };
}
function createLogsSection() {
  return {
    header: "Logs",
    patterns: ["*.log", "npm-debug.log*", "yarn-debug.log*", "yarn-error.log*"]
  };
}
function formatSection(section) {
  const lines = [];
  lines.push(`# ${section.header}`);
  lines.push(...section.patterns);
  lines.push("");
  return lines.join("\n");
}
function generateGitignore(options) {
  const opts = {
    ...DEFAULT_OPTIONS3,
    ...options
  };
  const sections = [];
  const header = `# ARTK E2E .gitignore
# Generated by ARTK install
# ${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}

`;
  sections.push(createDependenciesSection());
  sections.push(createBuildSection());
  sections.push(createEnvironmentSection());
  sections.push(createLogsSection());
  if (opts.includeAuthStates) {
    sections.push(createAuthStatesSection());
  }
  if (opts.includeTestArtifacts) {
    sections.push(createTestArtifactsSection());
  }
  if (opts.includeCoverage) {
    sections.push(createCoverageSection());
  }
  if (opts.includeIdeFiles) {
    sections.push(createIdeFilesSection());
  }
  if (opts.includeOsFiles) {
    sections.push(createOsFilesSection());
  }
  if (opts.additionalPatterns.length > 0) {
    sections.push({
      header: "Additional Patterns",
      patterns: opts.additionalPatterns
    });
  }
  let content = header;
  for (const section of sections) {
    content += formatSection(section);
  }
  if (opts.exceptions.length > 0) {
    content += "# Exceptions (never ignore)\n";
    for (const exception of opts.exceptions) {
      content += `!${exception}
`;
    }
    content += "\n";
  }
  return content;
}
var GITIGNORE_PATTERNS = {
  authStates: [".auth-states/", "*.storageState.json"],
  testArtifacts: ["test-results/", "playwright-report/", "*.trace.zip"],
  coverage: ["coverage/", ".nyc_output/"],
  dependencies: ["node_modules/"],
  environment: [".env", ".env.local"]
};
function generateMinimalGitignore() {
  return `# ARTK E2E Minimal .gitignore
node_modules/
.auth-states/
test-results/
playwright-report/
.env
*.log
`;
}
function mergeGitignore(existingContent, options) {
  const artkPatterns = generateGitignore(options);
  const existingPatterns = new Set(
    existingContent.split("\n").filter((line) => line.trim() && !line.startsWith("#"))
  );
  const artkLines = artkPatterns.split("\n");
  const newPatterns = [];
  for (const line of artkLines) {
    const trimmed = line.trim();
    if (trimmed && !trimmed.startsWith("#") && !existingPatterns.has(trimmed)) {
      newPatterns.push(line);
    }
  }
  if (newPatterns.length === 0) {
    return existingContent;
  }
  const separator = existingContent.endsWith("\n") ? "" : "\n";
  return existingContent + separator + "\n# ARTK E2E Additions\n" + newPatterns.join("\n") + "\n";
}

// install/index.ts
var INSTALL_MODULE_VERSION = "1.0.0";

export { DEPENDENCY_VERSIONS, GITIGNORE_PATTERNS, INSTALL_MODULE_VERSION, generateGitignore, generateMinimalGitignore, generateMinimalPlaywrightConfig, generatePackageJson, generatePackageJsonObject, generatePlaywrightConfig, generateTsConfig, mergeGitignore, normalizeProjectName, validateProjectName };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map
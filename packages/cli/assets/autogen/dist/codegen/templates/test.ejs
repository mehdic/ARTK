/**
 * <%= journey.title %>
 * Journey: <%= journey.id %>
 * Generated by @artk/core-autogen
 *
 * @tags <%= journey.tags.join(', ') %>
 * @tier <%= journey.tier %>
 * @scope <%= journey.scope %>
 * @actor <%= journey.actor %>
 */
import { test, expect } from '@playwright/test';
<% if (journey.accessibility?.enabled) { %>
import AxeBuilder from '@axe-core/playwright';
<% } %>
<% if (imports.length > 0) { %>
<% for (const imp of imports) { %>
import { <%= imp.members.join(', ') %> } from '<%= imp.from %>';
<% } %>
<% } %>

test.describe('<%- journey.title %>', {
  tag: [<%- journey.tags.map(t => `'${t}'`).join(', ') %>],
}, () => {
<% if (journey.prerequisites && journey.prerequisites.length > 0) { %>
  // Prerequisites: The following journeys must complete first:
  // <%- journey.prerequisites.join(', ') %>
  // Note: Use Playwright project dependencies or test.beforeAll() to run prerequisites

<% } %>
<% if (journey.data) { %>
  // Data Strategy: <%= journey.data.strategy %> | Cleanup: <%= journey.data.cleanup %>
<% if (journey.data.strategy === 'seed') { %>
<% if (journey.data.seeds && journey.data.seeds.length > 0) { %>
  // Seed data references: <%- journey.data.seeds.join(', ') %>
<% } %>
  test.beforeAll(async () => {
    // Load seed data for this journey
    // Note: Implement seedData() in your test fixtures
    // await seedData([<%- (journey.data.seeds || []).map(s => `'${s}'`).join(', ') %>]);
  });

<% } else if (journey.data.strategy === 'create') { %>
<% if (journey.data.factories && journey.data.factories.length > 0) { %>
  // Factory references: <%- journey.data.factories.join(', ') %>
<% } %>
  let testData: Record<string, unknown>;

  test.beforeEach(async () => {
    // Create fresh data for each test
    // Note: Implement createTestData() in your test fixtures
    // testData = await createTestData({
    //   factories: [<%- (journey.data.factories || []).map(f => `'${f}'`).join(', ') %>],
    // });
  });

<% } else if (journey.data.strategy === 'reuse') { %>
  // Reuse strategy: Tests share existing data, no per-test setup needed
  // Ensure test data exists before running these tests
<% } %>
<% } %>
<% if (journey.setup && journey.setup.length > 0) { %>
  test.beforeEach(async ({ page }) => {
<% for (const primitive of journey.setup) { %>
    <%- renderPrimitive(primitive, '    ') %>
<% } %>
  });

<% } %>
<% if (journey.testData && journey.testData.length > 0) { %>
  // Data-Driven Tests - Parameterized with test data sets
  test.describe.each([
<% for (let i = 0; i < journey.testData.length; i++) { %>
<% const dataSet = journey.testData[i]; %>
    { testName: '<%= dataSet.name %>'<% for (const [key, value] of Object.entries(dataSet.data)) { %>, <%= key %>: <%= typeof value === 'string' ? `'${escapeString(value)}'` : JSON.stringify(value) %><% } %> }<%= i < journey.testData.length - 1 ? ',' : '' %>
<% } %>
  ])('<%= journey.id %>: <%= journey.title %> - $testName', ({ testName<% if (journey.testData && journey.testData.length > 0) { %><% const allKeys = new Set(); for (const ds of journey.testData) { for (const key of Object.keys(ds.data)) { allKeys.add(key); } } %><% for (const key of Array.from(allKeys)) { %>, <%= key %><% } %><% } %> }) => {
    test('should complete journey', async ({ page }) => {
<% for (const step of journey.steps) { %>
      // <%= step.description %>
      await test.step('<%= step.id %>: <%- escapeString(step.description) %>', async () => {
<% for (const action of step.actions) { %>
<% if (action.type === 'blocked') { %>
        // TODO: <%- escapeString(action.reason) %>
        // Source: <%- escapeString(action.sourceText) %>
<% } else { %>
        <%- renderPrimitive(action, '        ') %>
<% } %>
<% } %>
<% for (const assertion of step.assertions) { %>
        <%- renderPrimitive(assertion, '        ') %>
<% } %>
<% if (journey.visualRegression?.enabled && journey.visualRegression.snapshots?.includes(step.id)) { %>
<% const threshold = journey.visualRegression.threshold || 0.1; %>
        // Visual regression check
        await expect(page).toHaveScreenshot('<%= step.id.toLowerCase() %>-snapshot.png', {
          maxDiffPixelRatio: <%= threshold %>,
        });
<% } %>
<% if (journey.accessibility?.enabled && journey.accessibility.timing === 'inTest') { %>
<% const a11yRules = journey.accessibility.rules || []; %>
<% const a11yExclude = journey.accessibility.exclude || []; %>
        // Accessibility check (inTest mode - fails immediately if issues found)
        const a11yResults_<%= step.id.replace(/-/g, '_') %> = await new AxeBuilder({ page })<% if (a11yRules.length > 0) { %>
          .withTags(<%= JSON.stringify(a11yRules) %>)<% } %><% if (a11yExclude.length > 0) { %>
          .exclude(<%= JSON.stringify(a11yExclude) %>)<% } %>
          .analyze();
        expect(a11yResults_<%= step.id.replace(/-/g, '_') %>.violations).toEqual([]);
<% } %>
      });

<% } %>
<% if (journey.completion && journey.completion.length > 0) { %>
      // Verify completion signals
      await test.step('Verify completion', async () => {
<% for (const signal of journey.completion) { %>
<% const timeoutOpt = signal.timeout ? `, { timeout: ${signal.timeout} }` : ''; %>
<% if (signal.type === 'url') { %>
        await expect(page).toHaveURL(/<%- escapeRegex(signal.value) %>/<%- timeoutOpt %>);
<% } else if (signal.type === 'toast') { %>
        await expect(page.getByRole('alert').getByText('<%- escapeString(signal.value) %>')).toBeVisible(<%- timeoutOpt %>);
<% } else if (signal.type === 'element') { %>
        await expect(page.locator('<%- escapeString(signal.value) %>')).toBeVisible(<%- timeoutOpt %>);
<% } else if (signal.type === 'text') { %>
        await expect(page.getByText('<%- escapeString(signal.value) %>')).toBeVisible(<%- timeoutOpt %>);
<% } %>
<% } %>
      });
<% } %>
    });
  });
<% } else { %>
  test('<%= journey.id %>: <%= journey.title %>', async ({ page }) => {
<% for (const step of journey.steps) { %>
    // <%= step.description %>
    await test.step('<%= step.id %>: <%- escapeString(step.description) %>', async () => {
<% for (const action of step.actions) { %>
<% if (action.type === 'blocked') { %>
      // TODO: <%- escapeString(action.reason) %>
      // Source: <%- escapeString(action.sourceText) %>
<% } else { %>
      <%- renderPrimitive(action, '      ') %>
<% } %>
<% } %>
<% for (const assertion of step.assertions) { %>
      <%- renderPrimitive(assertion, '      ') %>
<% } %>
<% if (journey.visualRegression?.enabled && journey.visualRegression.snapshots?.includes(step.id)) { %>
<% const threshold = journey.visualRegression.threshold || 0.1; %>
      // Visual regression check
      await expect(page).toHaveScreenshot('<%= step.id.toLowerCase() %>-snapshot.png', {
        maxDiffPixelRatio: <%= threshold %>,
      });
<% } %>
<% if (journey.accessibility?.enabled && journey.accessibility.timing === 'inTest') { %>
<% const a11yRulesInTest = journey.accessibility.rules || []; %>
<% const a11yExcludeInTest = journey.accessibility.exclude || []; %>
      // Accessibility check (inTest mode - fails immediately if issues found)
      const a11yResults_<%= step.id.replace(/-/g, '_') %> = await new AxeBuilder({ page })<% if (a11yRulesInTest.length > 0) { %>
        .withTags(<%= JSON.stringify(a11yRulesInTest) %>)<% } %><% if (a11yExcludeInTest.length > 0) { %>
        .exclude(<%= JSON.stringify(a11yExcludeInTest) %>)<% } %>
        .analyze();
      expect(a11yResults_<%= step.id.replace(/-/g, '_') %>.violations).toEqual([]);
<% } %>
    });

<% } %>
<% if (journey.completion && journey.completion.length > 0) { %>
    // Verify completion signals
    await test.step('Verify completion', async () => {
<% for (const signal of journey.completion) { %>
<% const timeoutOpt = signal.timeout ? `, { timeout: ${signal.timeout} }` : ''; %>
<% if (signal.type === 'url') { %>
      await expect(page).toHaveURL(/<%- escapeRegex(signal.value) %>/<%- timeoutOpt %>);
<% } else if (signal.type === 'toast') { %>
      await expect(page.getByRole('alert').getByText('<%- escapeString(signal.value) %>')).toBeVisible(<%- timeoutOpt %>);
<% } else if (signal.type === 'element') { %>
      await expect(page.locator('<%- escapeString(signal.value) %>')).toBeVisible(<%- timeoutOpt %>);
<% } else if (signal.type === 'text') { %>
      await expect(page.getByText('<%- escapeString(signal.value) %>')).toBeVisible(<%- timeoutOpt %>);
<% } %>
<% } %>
    });
<% } %>
  });
<% } %>
<% if (journey.cleanup && journey.cleanup.length > 0) { %>

  test.afterEach(async ({ page }) => {
<% for (const primitive of journey.cleanup) { %>
    <%- renderPrimitive(primitive, '    ') %>
<% } %>
  });
<% } %>
<% if (journey.data && journey.data.cleanup && journey.data.cleanup !== 'none') { %>

  // Data cleanup strategy: <%= journey.data.cleanup %>
  test.afterEach(async () => {
<% if (journey.data.cleanup === 'required') { %>
    // Required cleanup - test fails if cleanup fails
    // Note: Implement cleanupTestData() in your test fixtures
    // await cleanupTestData(testData);
<% } else if (journey.data.cleanup === 'best-effort') { %>
    // Best-effort cleanup - test passes even if cleanup fails
    // Note: Implement cleanupTestData() in your test fixtures
    // try {
    //   await cleanupTestData(testData);
    // } catch (error) {
    //   console.warn('Cleanup failed (best-effort):', error);
    // }
<% } %>
  });
<% } %>
<% if (journey.accessibility?.enabled && journey.accessibility.timing !== 'inTest') { %>

  // Accessibility audits (afterEach mode - runs after each test completes)
  test.afterEach(async ({ page }) => {
<% const rules = journey.accessibility.rules || []; %>
<% const exclude = journey.accessibility.exclude || []; %>
    const accessibilityResults = await new AxeBuilder({ page })<% if (rules.length > 0) { %>
      .withTags(<%= JSON.stringify(rules) %>)<% } %><% if (exclude.length > 0) { %>
      .exclude(<%= JSON.stringify(exclude) %>)<% } %>
      .analyze();
    expect(accessibilityResults.violations).toEqual([]);
  });
<% } %>
<% if (journey.performance?.enabled && journey.performance.budgets) { %>

  // Performance budgets
  test.afterEach(async ({ page }) => {
    const metrics = await page.evaluate(() => {
      return new Promise((resolve) => {
        const perfData: Record<string, number> = {};

        // Collect Web Vitals
        new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            if (entry.entryType === 'largest-contentful-paint') {
              perfData.lcp = entry.startTime;
            }
          }
        }).observe({ entryTypes: ['largest-contentful-paint'] });

        new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            if (entry.name === 'first-input') {
              perfData.fid = (entry as PerformanceEventTiming).processingStart - entry.startTime;
            }
          }
        }).observe({ entryTypes: ['first-input'] });

        new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            if (entry.entryType === 'layout-shift' && !(entry as any).hadRecentInput) {
              perfData.cls = (perfData.cls || 0) + (entry as any).value;
            }
          }
        }).observe({ entryTypes: ['layout-shift'] });

        // Collect TTFB
        const navTiming = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;
        if (navTiming) {
          perfData.ttfb = navTiming.responseStart - navTiming.requestStart;
        }

        // Wait for metrics to be collected (configurable timeout, default 3000ms)
        setTimeout(() => resolve(perfData), <%= journey.performance.collectTimeout || 3000 %>);
      });
    });
<% if (journey.performance.budgets.lcp) { %>
    expect(metrics.lcp).toBeLessThan(<%= journey.performance.budgets.lcp %>);
<% } %>
<% if (journey.performance.budgets.fid) { %>
    expect(metrics.fid).toBeLessThan(<%= journey.performance.budgets.fid %>);
<% } %>
<% if (journey.performance.budgets.cls) { %>
    expect(metrics.cls).toBeLessThan(<%= journey.performance.budgets.cls %>);
<% } %>
<% if (journey.performance.budgets.ttfb) { %>
    expect(metrics.ttfb).toBeLessThan(<%= journey.performance.budgets.ttfb %>);
<% } %>
  });
<% } %>
<% if (journey.negativePaths && journey.negativePaths.length > 0) { %>

  // Negative Paths - Error Scenario Testing
  test.describe('Negative paths', () => {
<% for (const negativePath of journey.negativePaths) { %>
    test('<%= negativePath.name %> should show error', async ({ page }) => {
      // Fill form with negative input values
<% for (const [key, value] of Object.entries(negativePath.input)) { %>
<% const strValue = typeof value === 'string' ? value : String(value); %>
<% const capitalizedKey = key.charAt(0).toUpperCase() + key.slice(1); %>
      await page.getByLabel('<%= capitalizedKey %>', { exact: false }).fill('<%- escapeString(strValue) %>');
<% } %>

      // Trigger validation (click submit button if exists)
      const submitButton = page.getByRole('button', { name: /submit|save|send|create|sign|login|register/i });
      if (await submitButton.count() > 0) {
        await submitButton.first().click();
      }

      // Assert error message is displayed
<% const errorElement = negativePath.expectedElement || '[data-testid="error-message"]'; %>
<% const errorLocator = errorElement.includes('data-testid')
     ? `getByTestId('${errorElement.match(/data-testid=["']([^"']+)["']/)?.[1] || 'error-message'}')`
     : `locator('${errorElement}')`; %>
      await expect(page.<%- errorLocator %>).toContainText('<%- escapeString(negativePath.expectedError) %>');
    });

<% } %>
  });
<% } %>
});

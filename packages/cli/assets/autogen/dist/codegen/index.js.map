{"version":3,"sources":["../../src/selectors/priority.ts","../../src/codegen/blocks.ts","../../src/journey/updater.ts","../../src/utils/escaping.ts","../../src/utils/paths.ts","../../src/utils/version.ts","../../src/variants/index.ts","../../src/codegen/generateTest.ts","../../src/codegen/generateModule.ts","../../src/codegen/astEdit.ts","../../src/codegen/registry.ts"],"names":["parseYaml","stringifyYaml","readFileSync","join","existsSync","escapeString","loadDefaultTemplate","ejs","Project","toPascalCase","dirname","exports","writeFileSync"],"mappings":";;;;;;;;;;;;;;;;AAuOO,SAAS,oBAAoB,OAAA,EAA8B;AAChE,EAAA,QAAQ,QAAQ,QAAA;AAAU,IACxB,KAAK,MAAA,EAAQ;AACX,MAAA,MAAM,OAAiB,EAAC;AACxB,MAAA,IAAI,OAAA,CAAQ,SAAS,IAAA,EAAM;AACzB,QAAA,IAAA,CAAK,KAAK,CAAA,OAAA,EAAU,YAAA,CAAa,QAAQ,OAAA,CAAQ,IAAI,CAAC,CAAA,CAAA,CAAG,CAAA;AAAA,MAC3D;AACA,MAAA,IAAI,OAAA,CAAQ,SAAS,KAAA,EAAO;AAC1B,QAAA,IAAA,CAAK,KAAK,aAAa,CAAA;AAAA,MACzB;AACA,MAAA,IAAI,OAAA,CAAQ,SAAS,KAAA,EAAO;AAC1B,QAAA,IAAA,CAAK,IAAA,CAAK,CAAA,OAAA,EAAU,OAAA,CAAQ,OAAA,CAAQ,KAAK,CAAA,CAAE,CAAA;AAAA,MAC7C;AACA,MAAA,MAAM,OAAA,GAAU,KAAK,MAAA,GAAS,CAAA,GAAI,OAAO,IAAA,CAAK,IAAA,CAAK,IAAI,CAAC,CAAA,EAAA,CAAA,GAAO,EAAA;AAC/D,MAAA,OAAO,CAAA,WAAA,EAAc,OAAA,CAAQ,KAAK,CAAA,CAAA,EAAI,OAAO,CAAA,CAAA,CAAA;AAAA,IAC/C;AAAA,IACA,KAAK,OAAA,EAAS;AACZ,MAAA,MAAM,KAAA,GAAQ,OAAA,CAAQ,OAAA,EAAS,KAAA,GAAQ,mBAAA,GAAsB,EAAA;AAC7D,MAAA,OAAO,eAAe,YAAA,CAAa,OAAA,CAAQ,KAAK,CAAC,IAAI,KAAK,CAAA,CAAA,CAAA;AAAA,IAC5D;AAAA,IACA,KAAK,aAAA,EAAe;AAClB,MAAA,MAAM,KAAA,GAAQ,OAAA,CAAQ,OAAA,EAAS,KAAA,GAAQ,mBAAA,GAAsB,EAAA;AAC7D,MAAA,OAAO,qBAAqB,YAAA,CAAa,OAAA,CAAQ,KAAK,CAAC,IAAI,KAAK,CAAA,CAAA,CAAA;AAAA,IAClE;AAAA,IACA,KAAK,MAAA,EAAQ;AACX,MAAA,MAAM,KAAA,GAAQ,OAAA,CAAQ,OAAA,EAAS,KAAA,GAAQ,mBAAA,GAAsB,EAAA;AAC7D,MAAA,OAAO,cAAc,YAAA,CAAa,OAAA,CAAQ,KAAK,CAAC,IAAI,KAAK,CAAA,CAAA,CAAA;AAAA,IAC3D;AAAA,IACA,KAAK,QAAA;AACH,MAAA,OAAO,CAAA,aAAA,EAAgB,YAAA,CAAa,OAAA,CAAQ,KAAK,CAAC,CAAA,EAAA,CAAA;AAAA,IACpD,KAAK,KAAA;AACH,MAAA,OAAO,CAAA,SAAA,EAAY,YAAA,CAAa,OAAA,CAAQ,KAAK,CAAC,CAAA,EAAA,CAAA;AAAA,IAChD;AACE,MAAA,OAAO,CAAA,SAAA,EAAY,YAAA,CAAa,OAAA,CAAQ,KAAK,CAAC,CAAA,EAAA,CAAA;AAAA;AAEpD;AAKA,SAAS,aAAa,GAAA,EAAqB;AACzC,EAAA,OAAO,IAAI,OAAA,CAAQ,IAAA,EAAM,KAAK,CAAA,CAAE,OAAA,CAAQ,OAAO,KAAK,CAAA;AACtD;;;ACzQO,IAAM,WAAA,GAAc,yBAAA;AACpB,IAAM,SAAA,GAAY,uBAAA;AAClB,IAAM,gBAAA,GAAmB,iDAAA;AA4EzB,SAAS,qBAAqB,IAAA,EAAqC;AACxE,EAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,KAAA,CAAM,IAAI,CAAA;AAC7B,EAAA,MAAM,SAAyB,EAAC;AAChC,EAAA,MAAM,gBAA0B,EAAC;AACjC,EAAA,MAAM,WAA2B,EAAC;AAElC,EAAA,IAAI,OAAA,GAAU,KAAA;AACd,EAAA,IAAI,YAAA,GAA6C,IAAA;AACjD,EAAA,IAAI,eAAyB,EAAC;AAE9B,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,KAAA,CAAM,QAAQ,CAAA,EAAA,EAAK;AACrC,IAAA,MAAM,IAAA,GAAO,MAAM,CAAC,CAAA;AAGpB,IAAA,IAAI,IAAA,CAAK,QAAA,CAAS,WAAW,CAAA,EAAG;AAC9B,MAAA,IAAI,OAAA,EAAS;AAEX,QAAA,QAAA,CAAS,IAAA,CAAK;AAAA,UACZ,IAAA,EAAM,QAAA;AAAA,UACN,MAAM,CAAA,GAAI,CAAA;AAAA,UACV,OAAA,EAAS,yCAAyC,CAAA,GAAI,CAAC,sCAAsC,YAAA,EAAc,SAAA,IAAa,KAAK,CAAC,CAAA,gBAAA;AAAA,SAC/H,CAAA;AAED,QAAA,IAAI,YAAA,EAAc;AAChB,UAAA,MAAA,CAAO,IAAA,CAAK;AAAA,YACV,GAAG,YAAA;AAAA,YACH,SAAS,CAAA,GAAI,CAAA;AAAA,YACb,OAAA,EAAS,YAAA,CAAa,IAAA,CAAK,IAAI;AAAA,WAChB,CAAA;AAAA,QACnB;AAAA,MACF;AACA,MAAA,OAAA,GAAU,IAAA;AACV,MAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,KAAA,CAAM,gBAAgB,CAAA;AACzC,MAAA,YAAA,GAAe;AAAA,QACb,EAAA,EAAI,QAAQ,CAAC,CAAA;AAAA,QACb,SAAA,EAAW;AAAA,OACb;AACA,MAAA,YAAA,GAAe,EAAC;AAChB,MAAA;AAAA,IACF;AAGA,IAAA,IAAI,IAAA,CAAK,QAAA,CAAS,SAAS,CAAA,IAAK,OAAA,EAAS;AACvC,MAAA,OAAA,GAAU,KAAA;AACV,MAAA,IAAI,YAAA,EAAc;AAChB,QAAA,MAAA,CAAO,IAAA,CAAK;AAAA,UACV,GAAG,YAAA;AAAA,UACH,OAAA,EAAS,CAAA;AAAA,UACT,OAAA,EAAS,YAAA,CAAa,IAAA,CAAK,IAAI;AAAA,SAChB,CAAA;AAAA,MACnB;AACA,MAAA,YAAA,GAAe,IAAA;AACf,MAAA,YAAA,GAAe,EAAC;AAChB,MAAA;AAAA,IACF;AAGA,IAAA,IAAI,OAAA,EAAS;AACX,MAAA,YAAA,CAAa,KAAK,IAAI,CAAA;AAAA,IACxB,CAAA,MAAO;AACL,MAAA,aAAA,CAAc,KAAK,IAAI,CAAA;AAAA,IACzB;AAAA,EACF;AAGA,EAAA,IAAI,WAAW,YAAA,EAAc;AAC3B,IAAA,QAAA,CAAS,IAAA,CAAK;AAAA,MACZ,IAAA,EAAM,UAAA;AAAA,MACN,IAAA,EAAA,CAAO,YAAA,CAAa,SAAA,IAAa,CAAA,IAAK,CAAA;AAAA,MACtC,OAAA,EAAS,CAAA,wCAAA,EAAA,CAA4C,YAAA,CAAa,SAAA,IAAa,KAAK,CAAC,CAAA,wBAAA;AAAA,KACtF,CAAA;AAAA,EACH;AAEA,EAAA,OAAO;AAAA,IACL,MAAA;AAAA,IACA,aAAA;AAAA,IACA,SAAA,EAAW,OAAO,MAAA,GAAS,CAAA;AAAA,IAC3B;AAAA,GACF;AACF;AAkBO,SAAS,WAAA,CAAY,SAAiB,EAAA,EAAqB;AAChE,EAAA,MAAM,cAAc,EAAA,GAChB,CAAA,EAAG,WAAW,CAAA,IAAA,EAAO,EAAE,CAAA,CAAA,GACvB,WAAA;AAEJ,EAAA,OAAO,GAAG,WAAW;AAAA,EAAK,OAAO;AAAA,EAAK,SAAS,CAAA,CAAA;AACjD;AA8BO,SAAS,oBAAoB,OAAA,EAAsC;AACxE,EAAA,MAAM,EAAE,YAAA,EAAc,SAAA,EAAU,GAAI,OAAA;AAGpC,EAAA,IAAI,CAAC,YAAA,CAAa,IAAA,EAAK,EAAG;AACxB,IAAA,OAAO,SAAA,CACJ,GAAA,CAAI,CAAA,KAAA,KAAS,WAAA,CAAY,KAAA,CAAM,OAAA,EAAS,KAAA,CAAM,EAAE,CAAC,CAAA,CACjD,IAAA,CAAK,MAAM,CAAA;AAAA,EAChB;AAEA,EAAA,MAAM,EAAE,aAAA,EAAe,SAAA,EAAU,GAC/B,qBAAqB,YAAY,CAAA;AAEnC,EAAA,IAAI,CAAC,SAAA,EAAW;AAEd,IAAA,MAAM,SAAA,GAAY,aAAA,CAAc,IAAA,CAAK,IAAI,EAAE,IAAA,EAAK;AAChD,IAAA,MAAM,UAAA,GAAa,SAAA,CAChB,GAAA,CAAI,CAAA,KAAA,KAAS,WAAA,CAAY,KAAA,CAAM,OAAA,EAAS,KAAA,CAAM,EAAE,CAAC,CAAA,CACjD,IAAA,CAAK,MAAM,CAAA;AAEd,IAAA,OAAO,SAAA,GAAY,GAAG,SAAS;;AAAA,EAAO,UAAU,CAAA,CAAA,GAAK,UAAA;AAAA,EACvD;AAGA,EAAA,MAAM,SAAmB,EAAC;AAC1B,EAAA,MAAM,YAAA,uBAAmB,GAAA,EAAY;AAErC,EAAA,IAAI,gBAAA,GAAmB,CAAA;AACvB,EAAA,MAAM,kBAAkB,SAAA,CAAU,MAAA,CAAO,CAAA,CAAA,KAAK,CAAC,EAAE,EAAE,CAAA;AACnD,EAAA,MAAM,sBAAA,uBAA6B,GAAA,EAAY;AAG/C,EAAA,MAAM,KAAA,GAAQ,YAAA,CAAa,KAAA,CAAM,IAAI,CAAA;AACrC,EAAA,IAAI,OAAA,GAAU,KAAA;AACd,EAAA,IAAI,cAAA;AACJ,EAAA,IAAI,YAAA,GAAe,KAAA;AAEnB,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,KAAA,CAAM,QAAQ,CAAA,EAAA,EAAK;AACrC,IAAA,MAAM,IAAA,GAAO,MAAM,CAAC,CAAA;AAEpB,IAAA,IAAI,IAAA,CAAK,QAAA,CAAS,WAAW,CAAA,EAAG;AAC9B,MAAA,OAAA,GAAU,IAAA;AACV,MAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,KAAA,CAAM,gBAAgB,CAAA;AACzC,MAAA,cAAA,GAAiB,QAAQ,CAAC,CAAA;AAG1B,MAAA,IAAI,WAAA;AACJ,MAAA,IAAI,cAAA,EAAgB;AAElB,QAAA,WAAA,GAAc,SAAA,CAAU,IAAA,CAAK,CAAA,CAAA,KAAK,CAAA,CAAE,OAAO,cAAc,CAAA;AACzD,QAAA,IAAI,WAAA,EAAa;AACf,UAAA,YAAA,CAAa,IAAI,cAAc,CAAA;AAAA,QACjC;AAAA,MACF,CAAA,MAAO;AAEL,QAAA,IAAI,gBAAA,GAAmB,gBAAgB,MAAA,EAAQ;AAC7C,UAAA,WAAA,GAAc,gBAAgB,gBAAgB,CAAA;AAC9C,UAAA,sBAAA,CAAuB,IAAI,gBAAgB,CAAA;AAAA,QAC7C;AACA,QAAA,gBAAA,EAAA;AAAA,MACF;AAEA,MAAA,IAAI,WAAA,EAAa;AACf,QAAA,MAAA,CAAO,KAAK,WAAA,CAAY,WAAA,CAAY,OAAA,EAAS,WAAA,CAAY,EAAE,CAAC,CAAA;AAC5D,QAAA,YAAA,GAAe,IAAA;AAAA,MACjB,CAAA,MAAO;AAEL,QAAA,MAAA,CAAO,KAAK,IAAI,CAAA;AAChB,QAAA,YAAA,GAAe,KAAA;AAAA,MACjB;AACA,MAAA;AAAA,IACF;AAEA,IAAA,IAAI,IAAA,CAAK,QAAA,CAAS,SAAS,CAAA,IAAK,OAAA,EAAS;AACvC,MAAA,OAAA,GAAU,KAAA;AACV,MAAA,IAAI,CAAC,YAAA,EAAc;AACjB,QAAA,MAAA,CAAO,KAAK,IAAI,CAAA;AAAA,MAClB;AACA,MAAA,cAAA,GAAiB,MAAA;AACjB,MAAA,YAAA,GAAe,KAAA;AACf,MAAA;AAAA,IACF;AAGA,IAAA,IAAI,CAAC,OAAA,EAAS;AACZ,MAAA,MAAA,CAAO,KAAK,IAAI,CAAA;AAAA,IAClB,CAAA,MAAA,IAAW,CAAC,YAAA,EAAc;AACxB,MAAA,MAAA,CAAO,KAAK,IAAI,CAAA;AAAA,IAClB;AAAA,EACF;AAGA,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,SAAA,CAAU,QAAQ,CAAA,EAAA,EAAK;AACzC,IAAA,MAAM,KAAA,GAAQ,UAAU,CAAC,CAAA;AACzB,IAAA,IAAI,MAAM,EAAA,EAAI;AAEZ,MAAA,IAAI,CAAC,YAAA,CAAa,GAAA,CAAI,KAAA,CAAM,EAAE,CAAA,EAAG;AAC/B,QAAA,MAAA,CAAO,KAAK,EAAE,CAAA;AACd,QAAA,MAAA,CAAO,KAAK,WAAA,CAAY,KAAA,CAAM,OAAA,EAAS,KAAA,CAAM,EAAE,CAAC,CAAA;AAAA,MAClD;AAAA,IACF,CAAA,MAAO;AAEL,MAAA,MAAM,WAAA,GAAc,eAAA,CAAgB,OAAA,CAAQ,KAAK,CAAA;AACjD,MAAA,IAAI,CAAC,sBAAA,CAAuB,GAAA,CAAI,WAAW,CAAA,EAAG;AAC5C,QAAA,MAAA,CAAO,KAAK,EAAE,CAAA;AACd,QAAA,MAAA,CAAO,KAAK,WAAA,CAAY,KAAA,CAAM,OAAA,EAAS,KAAA,CAAM,EAAE,CAAC,CAAA;AAAA,MAClD;AAAA,IACF;AAAA,EACF;AAEA,EAAA,OAAO,MAAA,CAAO,KAAK,IAAI,CAAA;AACzB;ACjRA,SAAS,oBAAoB,OAAA,EAG3B;AACA,EAAA,MAAM,KAAA,GAAQ,OAAA,CAAQ,KAAA,CAAM,4CAA4C,CAAA;AAExE,EAAA,IAAI,CAAC,KAAA,EAAO;AACV,IAAA,MAAM,IAAI,KAAA;AAAA,MACR;AAAA,KACF;AAAA,EACF;AAEA,EAAA,OAAO;AAAA,IACL,WAAA,EAAa,MAAM,CAAC,CAAA;AAAA,IACpB,IAAA,EAAM,MAAM,CAAC;AAAA,GACf;AACF;AAKA,SAAS,qBAAqB,OAAA,EAAyB;AACrD,EAAA,OAAO,UAAA,CAAW,QAAQ,CAAA,CAAE,MAAA,CAAO,OAAO,CAAA,CAAE,MAAA,CAAO,KAAK,CAAA,CAAE,SAAA,CAAU,CAAA,EAAG,CAAC,CAAA;AAC1E;AAeO,SAAS,yBACd,OAAA,EACqB;AACrB,EAAA,MAAM;AAAA,IACJ,WAAA;AAAA,IACA,QAAA;AAAA,IACA,WAAA;AAAA,IACA,UAAU,EAAE,UAAA,EAAY,EAAC,EAAG,QAAA,EAAU,EAAC;AAAE,GAC3C,GAAI,OAAA;AAGJ,EAAA,MAAM,OAAA,GAAU,YAAA,CAAa,WAAA,EAAa,OAAO,CAAA;AAGjD,EAAA,MAAM,EAAE,WAAA,EAAa,IAAA,EAAK,GAAI,oBAAoB,OAAO,CAAA;AAGzD,EAAA,MAAM,MAAA,GAASA,MAAU,WAAW,CAAA;AAGpC,EAAA,MAAM,gBAAgB,KAAA,CAAM,OAAA,CAAQ,OAAO,KAAK,CAAA,GAC3C,OAAO,KAAA,CAA6B,GAAA;AAAA,IAAI,CAAC,CAAA,KACxC,OAAO,CAAA,KAAM,WAAW,EAAE,IAAA,EAAM,CAAA,EAAG,SAAA,EAAW,IAAI,IAAA,EAAM,EAAA,EAAG,GAAI,EAAE,GAAG,CAAA;AAAE,MAExE,EAAC;AAGL,EAAA,MAAM,IAAA,GAAO,qBAAqB,WAAW,CAAA;AAG7C,EAAA,MAAM,SAAA,GAA8B;AAAA,IAClC,IAAA,EAAM,QAAA;AAAA,IACN,SAAA,EAAA,iBAAW,IAAI,IAAA,EAAK,EAAE,WAAA,EAAY;AAAA,IAClC;AAAA,GACF;AAGA,EAAA,IAAI,CAAC,KAAA,CAAM,OAAA,CAAQ,MAAA,CAAO,KAAK,CAAA,EAAG;AAChC,IAAA,MAAA,CAAO,QAAQ,EAAC;AAAA,EAClB;AAGA,EAAA,MAAM,aAAA,GAAiB,OAAO,KAAA,CAA6B,SAAA;AAAA,IACzD,CAAC,MACC,OAAO,CAAA,KAAM,WACT,CAAA,KAAM,QAAA,GACL,EAAuB,IAAA,KAAS;AAAA,GACzC;AAGA,EAAA,IAAI,iBAAiB,CAAA,EAAG;AACtB,IAAC,MAAA,CAAO,KAAA,CAA6B,aAAa,CAAA,GAAK,SAAA;AAAA,EACzD,CAAA,MAAO;AACL,IAAC,MAAA,CAAO,KAAA,CAA6B,IAAA,CAAK,SAAS,CAAA;AAAA,EACrD;AAGA,EAAA,MAAM,YAAA,GAAe;AAAA,IACnB,YAAY,EAAC;AAAA,IACb,UAAU;AAAC,GACb;AAGA,EAAA,IAAI,CAAC,MAAA,CAAO,OAAA,IAAW,OAAO,MAAA,CAAO,YAAY,QAAA,EAAU;AACzD,IAAA,MAAA,CAAO,UAAU,EAAE,UAAA,EAAY,EAAC,EAAG,QAAA,EAAU,EAAC,EAAE;AAAA,EAClD;AAEA,EAAA,MAAM,gBAAgB,MAAA,CAAO,OAAA;AAM7B,EAAA,IAAI,CAAC,KAAA,CAAM,OAAA,CAAQ,aAAA,CAAc,UAAU,CAAA,EAAG;AAC5C,IAAA,aAAA,CAAc,aAAa,EAAC;AAAA,EAC9B;AACA,EAAA,IAAI,CAAC,KAAA,CAAM,OAAA,CAAQ,aAAA,CAAc,QAAQ,CAAA,EAAG;AAC1C,IAAA,aAAA,CAAc,WAAW,EAAC;AAAA,EAC5B;AAGA,EAAA,IAAI,QAAQ,UAAA,EAAY;AACtB,IAAA,MAAM,kBAAA,GAAqB,IAAI,GAAA,CAAI,aAAA,CAAc,UAAW,CAAA;AAC5D,IAAA,KAAA,MAAW,GAAA,IAAO,QAAQ,UAAA,EAAY;AACpC,MAAA,IAAI,CAAC,kBAAA,CAAmB,GAAA,CAAI,GAAG,CAAA,EAAG;AAChC,QAAA,YAAA,CAAa,UAAA,CAAW,KAAK,GAAG,CAAA;AAChC,QAAA,aAAA,CAAc,UAAA,CAAY,KAAK,GAAG,CAAA;AAAA,MACpC;AAAA,IACF;AAEA,IAAA,aAAA,CAAc,WAAY,IAAA,EAAK;AAAA,EACjC;AAGA,EAAA,IAAI,QAAQ,QAAA,EAAU;AACpB,IAAA,MAAM,gBAAA,GAAmB,IAAI,GAAA,CAAI,aAAA,CAAc,QAAQ,CAAA;AACvD,IAAA,KAAA,MAAW,GAAA,IAAO,QAAQ,QAAA,EAAU;AAClC,MAAA,IAAI,CAAC,gBAAA,CAAiB,GAAA,CAAI,GAAG,CAAA,EAAG;AAC9B,QAAA,YAAA,CAAa,QAAA,CAAS,KAAK,GAAG,CAAA;AAC9B,QAAA,aAAA,CAAc,QAAA,CAAS,KAAK,GAAG,CAAA;AAAA,MACjC;AAAA,IACF;AAEA,IAAA,aAAA,CAAc,SAAS,IAAA,EAAK;AAAA,EAC9B;AAGA,EAAA,MAAM,cAAA,GAAiBC,UAAc,MAAA,EAAQ;AAAA,IAC3C,SAAA,EAAW,CAAA;AAAA;AAAA,IACX,cAAA,EAAgB,OAAA;AAAA,IAChB,iBAAA,EAAmB;AAAA,GACpB,CAAA;AAED,EAAA,MAAM,UAAA,GAAa,CAAA;AAAA,EAAQ,cAAc,CAAA;AAAA,EAAQ,IAAI,CAAA,CAAA;AAGrD,EAAA,aAAA,CAAc,WAAA,EAAa,YAAY,OAAO,CAAA;AAE9C,EAAA,OAAO;AAAA,IACL,OAAA,EAAS,IAAA;AAAA,IACT,aAAA;AAAA,IACA,cAAc,MAAA,CAAO,KAAA;AAAA,IACrB;AAAA,GACF;AACF;;;AClNO,SAAS,YAAY,GAAA,EAAqB;AAC/C,EAAA,OAAO,GAAA,CAAI,OAAA,CAAQ,uBAAA,EAAyB,MAAM,CAAA;AACpD;ACcA,IAAI,iBAAA;AAKJ,IAAI,eAAA;AAMJ,SAAS,YAAA,GAAuB;AAC9B,EAAA,IAAI,eAAA,EAAiB;AACnB,IAAA,OAAO,eAAA;AAAA,EACT;AAIA,EAAA,IAAI,OAAO,SAAA,KAAc,QAAA,IAAY,SAAA,CAAU,SAAS,CAAA,EAAG;AACzD,IAAA,eAAA,GAAkB,SAAA;AAClB,IAAA,OAAO,eAAA;AAAA,EACT;AAKA,EAAA,IAAI;AAEF,IAAA,MAAM,UAA8B,MAAA,CAAA,IAAA,CAAY,GAAA;AAChD,IAAA,IAAI,OAAA,EAAS;AACX,MAAA,eAAA,GAAkB,OAAA,CAAQ,aAAA,CAAc,OAAO,CAAC,CAAA;AAChD,MAAA,OAAO,eAAA;AAAA,IACT;AAAA,EACF,CAAA,CAAA,MAAQ;AAAA,EAER;AAIA,EAAA,IAAI;AACF,IAAA,IAAI,OAAO,SAAA,KAAY,WAAA,IAAe,SAAA,EAAS,OAAA,EAAS;AACtD,MAAA,MAAM,QAAA,GAAW,SAAA,CAAQ,OAAA,CAAQ,iCAAiC,CAAA;AAClE,MAAA,eAAA,GAAkB,QAAQ,QAAQ,CAAA;AAClC,MAAA,OAAO,eAAA;AAAA,IACT;AAAA,EACF,CAAA,CAAA,MAAQ;AAAA,EAER;AAIA,EAAA,eAAA,GAAkB,QAAQ,GAAA,EAAI;AAC9B,EAAA,OAAO,eAAA;AACT;AAUO,SAAS,cAAA,GAAyB;AACvC,EAAA,IAAI,iBAAA,EAAmB;AACrB,IAAA,OAAO,iBAAA;AAAA,EACT;AAGA,EAAA,MAAM,OAAA,GAAU,OAAA,CAAQ,GAAA,CAAI,mBAAmB,CAAA;AAC/C,EAAA,IAAI,WAAW,UAAA,CAAW,IAAA,CAAK,OAAA,EAAS,cAAc,CAAC,CAAA,EAAG;AACxD,IAAA,iBAAA,GAAoB,OAAA;AACpB,IAAA,OAAO,iBAAA;AAAA,EACT;AAKA,EAAA,MAAM,YAAY,YAAA,EAAa;AAC/B,EAAA,MAAM,aAAA,GAAgB;AAAA,IACpB,IAAA,CAAK,SAAA,EAAW,IAAA,EAAM,IAAI,CAAA;AAAA;AAAA,IAC1B,IAAA,CAAK,WAAW,IAAI,CAAA;AAAA;AAAA,IACpB;AAAA;AAAA,GACF;AAEA,EAAA,KAAA,MAAW,QAAQ,aAAA,EAAe;AAChC,IAAA,MAAM,OAAA,GAAU,IAAA,CAAK,IAAA,EAAM,cAAc,CAAA;AACzC,IAAA,IAAI,UAAA,CAAW,OAAO,CAAA,EAAG;AACvB,MAAA,IAAI;AACF,QAAA,MAAM,MAAM,IAAA,CAAK,KAAA,CAAMC,YAAAA,CAAa,OAAA,EAAS,OAAO,CAAC,CAAA;AACrD,QAAA,IAAI,GAAA,CAAI,SAAS,oBAAA,EAAsB;AACrC,UAAA,iBAAA,GAAoB,IAAA;AACpB,UAAA,OAAO,iBAAA;AAAA,QACT;AAAA,MACF,CAAA,CAAA,MAAQ;AAAA,MAER;AAAA,IACF;AAAA,EACF;AAGA,EAAA,MAAM,QAAA,GAAW;AAAA,IACf,KAAK,OAAA,CAAQ,GAAA,EAAI,EAAG,cAAA,EAAgB,SAAS,cAAc,CAAA;AAAA,IAC3D,KAAK,OAAA,CAAQ,GAAA,EAAI,EAAG,UAAA,EAAY,UAAU,mBAAmB,CAAA;AAAA,IAC7D,QAAQ,GAAA;AAAI,GACd;AAEA,EAAA,KAAA,MAAW,cAAc,QAAA,EAAU;AACjC,IAAA,MAAM,OAAA,GAAU,IAAA,CAAK,UAAA,EAAY,cAAc,CAAA;AAC/C,IAAA,IAAI,UAAA,CAAW,OAAO,CAAA,EAAG;AACvB,MAAA,IAAI;AACF,QAAA,MAAM,MAAM,IAAA,CAAK,KAAA,CAAMA,YAAAA,CAAa,OAAA,EAAS,OAAO,CAAC,CAAA;AACrD,QAAA,IAAI,GAAA,CAAI,SAAS,oBAAA,EAAsB;AACrC,UAAA,iBAAA,GAAoB,UAAA;AACpB,UAAA,OAAO,iBAAA;AAAA,QACT;AAAA,MACF,CAAA,CAAA,MAAQ;AAAA,MAER;AAAA,IACF;AAAA,EACF;AAGA,EAAA,iBAAA,GAAoB,IAAA,CAAK,SAAA,EAAW,IAAA,EAAM,IAAI,CAAA;AAC9C,EAAA,OAAO,iBAAA;AACT;AAQO,SAAS,eAAA,GAA0B;AACxC,EAAA,MAAM,OAAO,cAAA,EAAe;AAC5B,EAAA,MAAM,YAAY,YAAA,EAAa;AAK/B,EAAA,MAAM,gBAAA,GAAmB,IAAA,CAAK,SAAA,EAAW,IAAA,EAAM,WAAW,WAAW,CAAA;AACrE,EAAA,IAAI,UAAA,CAAW,gBAAgB,CAAA,EAAG;AAChC,IAAA,OAAO,gBAAA;AAAA,EACT;AAGA,EAAA,MAAM,aAAA,GAAgB;AAAA,IACpB,IAAA,CAAK,IAAA,EAAM,MAAA,EAAQ,SAAA,EAAW,WAAW,CAAA;AAAA,IACzC,IAAA,CAAK,IAAA,EAAM,UAAA,EAAY,SAAA,EAAW,WAAW,CAAA;AAAA,IAC7C,IAAA,CAAK,IAAA,EAAM,gBAAA,EAAkB,SAAA,EAAW,WAAW,CAAA;AAAA,IACnD,IAAA,CAAK,IAAA,EAAM,gBAAA,EAAkB,SAAA,EAAW,WAAW;AAAA,GACrD;AAEA,EAAA,KAAA,MAAW,iBAAiB,aAAA,EAAe;AACzC,IAAA,IAAI,UAAA,CAAW,aAAa,CAAA,EAAG;AAC7B,MAAA,OAAO,aAAA;AAAA,IACT;AAAA,EACF;AAGA,EAAA,OAAO,cAAc,CAAC,CAAA,IAAK,KAAK,IAAA,EAAM,MAAA,EAAQ,WAAW,WAAW,CAAA;AACtE;AAKO,SAAS,gBAAgB,YAAA,EAA8B;AAC5D,EAAA,OAAO,IAAA,CAAK,eAAA,EAAgB,EAAG,YAAY,CAAA;AAC7C;;;AC7KA,IAAI,aAAA;AAUG,SAAS,iBAAA,GAA4B;AAE1C,EAAA,IAAI,aAAA,EAAe;AACjB,IAAA,OAAO,aAAA;AAAA,EACT;AAGA,EAAA,IAAI;AACF,IAAA,IAAI,OAAO,gBAAA,KAAqB,WAAA,IAAe,gBAAA,EAAkB;AAC/D,MAAA,aAAA,GAAgB,gBAAA;AAChB,MAAA,OAAO,aAAA;AAAA,IACT;AAAA,EACF,CAAA,CAAA,MAAQ;AAAA,EAER;AAGA,EAAA,MAAM,UAAA,GAAa,OAAA,CAAQ,GAAA,CAAI,cAAc,CAAA;AAC7C,EAAA,IAAI,UAAA,EAAY;AACd,IAAA,aAAA,GAAgB,UAAA;AAChB,IAAA,OAAO,aAAA;AAAA,EACT;AAGA,EAAA,IAAI;AACF,IAAA,MAAM,cAAc,cAAA,EAAe;AACnC,IAAA,MAAM,OAAA,GAAUC,IAAAA,CAAK,WAAA,EAAa,cAAc,CAAA;AAEhD,IAAA,IAAIC,UAAAA,CAAW,OAAO,CAAA,EAAG;AACvB,MAAA,MAAM,MAAM,IAAA,CAAK,KAAA,CAAMF,YAAAA,CAAa,OAAA,EAAS,OAAO,CAAC,CAAA;AACrD,MAAA,IAAI,IAAI,OAAA,EAAS;AACf,QAAA,aAAA,GAAgB,GAAA,CAAI,OAAA;AACpB,QAAA,OAAO,aAAA;AAAA,MACT;AAAA,IACF;AAAA,EACF,CAAA,CAAA,MAAQ;AAAA,EAER;AAEA,EAAA,aAAA,GAAgB,SAAA;AAChB,EAAA,OAAO,aAAA;AACT;AAKO,SAAS,qBAAA,GAAgC;AAC9C,EAAA,OAAA,iBAAO,IAAI,IAAA,EAAK,EAAE,WAAA,EAAY;AAChC;;;ACxDO,SAAS,aAAA,GAA6B;AAC3C,EAAA,MAAM,cAAA,GAAiB,OAAA,CAAQ,OAAA,CAAQ,KAAA,CAAM,CAAC,CAAA;AAC9C,EAAA,MAAM,WAAA,GAAc,SAAS,cAAA,CAAe,KAAA,CAAM,GAAG,CAAA,CAAE,CAAC,GAAG,EAAE,CAAA;AAG7D,EAAA,MAAM,KAAA,GAAQ,OAAO,MAAA,CAAA,IAAA,KAAgB,WAAA;AAErC,EAAA,IAAI,eAAe,EAAA,EAAI;AACrB,IAAA,OAAO;AAAA,MACL,EAAA,EAAI,QAAQ,YAAA,GAAe,YAAA;AAAA,MAC3B,WAAA;AAAA,MACA,YAAA,EAAc,QAAQ,KAAA,GAAQ,KAAA;AAAA,MAC9B,iBAAA,EAAmB,QAAA;AAAA,MACnB,QAAA,EAAU;AAAA,QACR,aAAA,EAAe,IAAA;AAAA,QACf,QAAA,EAAU,IAAA;AAAA,QACV,aAAA,EAAe,IAAA;AAAA,QACf,UAAA,EAAY;AAAA;AACd,KACF;AAAA,EACF,CAAA,MAAA,IAAW,eAAe,EAAA,EAAI;AAC5B,IAAA,OAAO;AAAA,MACL,EAAA,EAAI,WAAA;AAAA,MACJ,WAAA;AAAA,MACA,YAAA,EAAc,KAAA;AAAA,MACd,iBAAA,EAAmB,QAAA;AAAA,MACnB,QAAA,EAAU;AAAA,QACR,aAAA,EAAe,IAAA;AAAA,QACf,QAAA,EAAU,IAAA;AAAA,QACV,aAAA,EAAe,IAAA;AAAA,QACf,UAAA,EAAY;AAAA;AACd,KACF;AAAA,EACF,CAAA,MAAO;AACL,IAAA,OAAO;AAAA,MACL,EAAA,EAAI,WAAA;AAAA,MACJ,WAAA;AAAA,MACA,YAAA,EAAc,KAAA;AAAA,MACd,iBAAA,EAAmB,QAAA;AAAA,MACnB,QAAA,EAAU;AAAA,QACR,aAAA,EAAe,KAAA;AAAA,QACf,QAAA,EAAU,KAAA;AAAA,QACV,aAAA,EAAe,KAAA;AAAA,QACf,UAAA,EAAY;AAAA;AACd,KACF;AAAA,EACF;AACF;;;AC8BA,SAAS,aAAA,CACP,GAAA,EACA,OAAA,EACA,WAAA,EACA,aAAA,EACS;AACT,EAAA,MAAM,SAAA,GAAY,GAAA,CAAI,OAAA,CAAQ,QAAA,CAAS,OAAO,CAAA;AAC9C,EAAA,IAAI,CAAC,SAAA,IAAa,GAAA,CAAI,kBAAA,EAAoB;AACxC,IAAA,GAAA,CAAI,QAAA,CAAS,IAAA;AAAA,MACX,CAAA,WAAA,EAAc,aAAa,CAAA,OAAA,EAAU,WAAW,mBAAmB,qBAAA,CAAsB,OAAO,CAAC,CAAA,mBAAA,EAC3E,IAAI,OAAA,CAAQ,EAAE,CAAA,aAAA,EAAgB,GAAA,CAAI,QAAQ,iBAAiB,CAAA,CAAA;AAAA,KACnF;AAAA,EACF;AACA,EAAA,OAAO,SAAA;AACT;AAGO,IAAM,mBAAA,GAAsB;AAKnC,SAAS,sBAAsB,OAAA,EAAwC;AACrE,EAAA,QAAQ,OAAA;AAAS,IACf,KAAK,eAAA;AACH,MAAA,OAAO,6BAAA;AAAA,IACT,KAAK,UAAA;AACH,MAAA,OAAO,6BAAA;AAAA,IACT,KAAK,eAAA;AACH,MAAA,OAAO,qBAAA;AAAA,IACT,KAAK,YAAA;AACH,MAAA,OAAO,sBAAA;AAAA,IACT;AACE,MAAA,OAAO,iBAAA;AAAA;AAEb;AAKA,SAASG,cAAa,GAAA,EAAqB;AACzC,EAAA,OAAO,IACJ,OAAA,CAAQ,KAAA,EAAO,MAAM,CAAA,CACrB,OAAA,CAAQ,MAAM,KAAK,CAAA,CACnB,QAAQ,IAAA,EAAM,KAAK,EACnB,OAAA,CAAQ,KAAA,EAAO,KAAK,CAAA,CACpB,OAAA,CAAQ,OAAO,KAAK,CAAA;AACzB;AAKA,SAAS,YAAY,KAAA,EAA0B;AAC7C,EAAA,QAAQ,MAAM,IAAA;AAAM,IAClB,KAAK,SAAA;AACH,MAAA,OAAO,CAAA,CAAA,EAAIA,aAAAA,CAAa,KAAA,CAAM,KAAK,CAAC,CAAA,CAAA,CAAA;AAAA,IACtC,KAAK,OAAA;AACH,MAAA,OAAO,CAAA,MAAA,EAAS,MAAM,KAAK,CAAA,CAAA;AAAA,IAC7B,KAAK,OAAA;AACH,MAAA,OAAO,OAAA;AAAA,IACT,KAAK,WAAA;AACH,MAAA,OAAO,CAAA,EAAA,EAAK,MAAM,KAAK,CAAA,EAAA,CAAA;AAAA,IACzB,KAAK,UAAA;AACH,MAAA,OAAO,CAAA,SAAA,EAAY,MAAM,KAAK,CAAA,CAAA;AAAA,IAChC;AACE,MAAA,OAAO,CAAA,CAAA,EAAIA,aAAAA,CAAa,KAAA,CAAM,KAAK,CAAC,CAAA,CAAA,CAAA;AAAA;AAE1C;AAQA,SAAS,eAAA,CAAgB,SAAA,EAAwB,MAAA,GAAS,EAAA,EAAI,IAAA,EAA+B;AAC3F,EAAA,QAAQ,UAAU,IAAA;AAAM;AAAA,IAEtB,KAAK,MAAA;AACH,MAAA,OAAO,GAAG,MAAM,CAAA,iBAAA,EAAoBA,aAAAA,CAAa,SAAA,CAAU,GAAG,CAAC,CAAA,GAAA,CAAA;AAAA,IAEjE,KAAK,YAAA;AACH,MAAA,MAAM,UAAA,GAAa,OAAO,SAAA,CAAU,OAAA,KAAY,QAAA,GAC5C,CAAA,CAAA,EAAI,WAAA,CAAY,SAAA,CAAU,OAAO,CAAC,CAAA,CAAA,CAAA,GAClC,SAAA,CAAU,QAAQ,QAAA,EAAS;AAC/B,MAAA,OAAO,CAAA,EAAG,MAAM,CAAA,sBAAA,EAAyB,UAAU,CAAA,EAAA,CAAA;AAAA,IAErD,KAAK,iBAAA;AACH,MAAA,OAAO,GAAG,MAAM,CAAA,wDAAA,EAA2DA,aAAAA,CAAa,SAAA,CAAU,UAAU,CAAC,CAAA,IAAA,CAAA;AAAA,IAE/G,KAAK,wBAAA;AACH,MAAA,OAAO,GAAG,MAAM,CAAA,2CAAA,CAAA;AAAA,IAElB,KAAK,QAAA;AACH,MAAA,OAAO,GAAG,MAAM,CAAA,oBAAA,CAAA;AAAA,IAElB,KAAK,QAAA;AACH,MAAA,OAAO,GAAG,MAAM,CAAA,oBAAA,CAAA;AAAA,IAElB,KAAK,WAAA;AACH,MAAA,OAAO,GAAG,MAAM,CAAA,uBAAA,CAAA;AAAA;AAAA,IAGlB,KAAK,gBAAA;AACH,MAAA,MAAM,qBAAqB,SAAA,CAAU,OAAA,GAAU,CAAA,WAAA,EAAc,SAAA,CAAU,OAAO,CAAA,CAAA,GAAK,EAAA;AACnF,MAAA,OAAO,CAAA,EAAG,MAAM,CAAA,WAAA,EAAc,mBAAA,CAAoB,UAAU,OAAO,CAAC,8BAA8B,kBAAkB,CAAA,IAAA,CAAA;AAAA,IAEtH,KAAK,eAAA;AACH,MAAA,MAAM,oBAAoB,SAAA,CAAU,OAAA,GAAU,CAAA,WAAA,EAAc,SAAA,CAAU,OAAO,CAAA,CAAA,GAAK,EAAA;AAClF,MAAA,OAAO,CAAA,EAAG,MAAM,CAAA,WAAA,EAAc,mBAAA,CAAoB,UAAU,OAAO,CAAC,6BAA6B,iBAAiB,CAAA,IAAA,CAAA;AAAA,IAEpH,KAAK,gBAAA;AACH,MAAA,OAAO,CAAA,EAAG,MAAM,CAAA,0BAAA,EAA6B,SAAA,CAAU,EAAE,CAAA,EAAA,CAAA;AAAA,IAE3D,KAAK,oBAAA;AACH,MAAA,MAAM,qBAAqB,SAAA,CAAU,OAAA,GAAU,CAAA,aAAA,EAAgB,SAAA,CAAU,OAAO,CAAA,EAAA,CAAA,GAAO,EAAA;AACvF,MAAA,OAAO,CAAA,EAAG,MAAM,CAAA,yCAAA,EAA4C,kBAAkB,CAAA,EAAA,CAAA;AAAA;AAAA,IAGhF,KAAK,OAAA;AACH,MAAA,OAAO,GAAG,MAAM,CAAA,WAAA,EAAc,mBAAA,CAAoB,SAAA,CAAU,OAAO,CAAC,CAAA,SAAA,CAAA;AAAA,IAEtE,KAAK,UAAA;AACH,MAAA,OAAO,GAAG,MAAM,CAAA,WAAA,EAAc,mBAAA,CAAoB,SAAA,CAAU,OAAO,CAAC,CAAA,YAAA,CAAA;AAAA,IAEtE,KAAK,YAAA;AACH,MAAA,OAAO,GAAG,MAAM,CAAA,WAAA,EAAc,mBAAA,CAAoB,SAAA,CAAU,OAAO,CAAC,CAAA,4BAAA,CAAA;AAAA,IAEtE,KAAK,MAAA;AACH,MAAA,OAAO,CAAA,EAAG,MAAM,CAAA,WAAA,EAAc,mBAAA,CAAoB,SAAA,CAAU,OAAO,CAAC,CAAA,MAAA,EAAS,WAAA,CAAY,SAAA,CAAU,KAAK,CAAC,CAAA,EAAA,CAAA;AAAA,IAE3G,KAAK,QAAA;AACH,MAAA,OAAO,CAAA,EAAG,MAAM,CAAA,WAAA,EAAc,mBAAA,CAAoB,SAAA,CAAU,OAAO,CAAC,CAAA,eAAA,EAAkBA,aAAAA,CAAa,SAAA,CAAU,MAAM,CAAC,CAAA,GAAA,CAAA;AAAA,IAEtH,KAAK,OAAA;AACH,MAAA,OAAO,GAAG,MAAM,CAAA,WAAA,EAAc,mBAAA,CAAoB,SAAA,CAAU,OAAO,CAAC,CAAA,SAAA,CAAA;AAAA,IAEtE,KAAK,SAAA;AACH,MAAA,OAAO,GAAG,MAAM,CAAA,WAAA,EAAc,mBAAA,CAAoB,SAAA,CAAU,OAAO,CAAC,CAAA,WAAA,CAAA;AAAA,IAEtE,KAAK,OAAA;AACH,MAAA,IAAI,UAAU,OAAA,EAAS;AACrB,QAAA,OAAO,CAAA,EAAG,MAAM,CAAA,WAAA,EAAc,mBAAA,CAAoB,UAAU,OAAO,CAAC,CAAA,QAAA,EAAW,SAAA,CAAU,GAAG,CAAA,GAAA,CAAA;AAAA,MAC9F;AACA,MAAA,OAAO,CAAA,EAAG,MAAM,CAAA,2BAAA,EAA8B,SAAA,CAAU,GAAG,CAAA,GAAA,CAAA;AAAA,IAE7D,KAAK,OAAA;AACH,MAAA,OAAO,GAAG,MAAM,CAAA,WAAA,EAAc,mBAAA,CAAoB,SAAA,CAAU,OAAO,CAAC,CAAA,SAAA,CAAA;AAAA,IAEtE,KAAK,OAAA;AACH,MAAA,OAAO,GAAG,MAAM,CAAA,WAAA,EAAc,mBAAA,CAAoB,SAAA,CAAU,OAAO,CAAC,CAAA,SAAA,CAAA;AAAA,IAEtE,KAAK,OAAA;AACH,MAAA,OAAO,GAAG,MAAM,CAAA,WAAA,EAAc,mBAAA,CAAoB,SAAA,CAAU,OAAO,CAAC,CAAA,SAAA,CAAA;AAAA,IAEtE,KAAK,QAAA;AACH,MAAA,OAAO,CAAA,EAAG,MAAM,CAAA,WAAA,EAAc,mBAAA,CAAoB,UAAU,OAAO,CAAC,mBAAmB,SAAA,CAAU,KAAA,CAAM,IAAI,CAAA,CAAA,KAAK,CAAA,CAAA,EAAIA,cAAa,CAAC,CAAC,GAAG,CAAA,CAAE,IAAA,CAAK,IAAI,CAAC,CAAA,GAAA,CAAA;AAAA;AAAA,IAGpJ,KAAK,eAAA;AACH,MAAA,MAAM,iBAAiB,SAAA,CAAU,OAAA,GAAU,CAAA,WAAA,EAAc,SAAA,CAAU,OAAO,CAAA,EAAA,CAAA,GAAO,EAAA;AACjF,MAAA,OAAO,CAAA,EAAG,MAAM,CAAA,kBAAA,EAAqB,mBAAA,CAAoB,UAAU,OAAO,CAAC,iBAAiB,cAAc,CAAA,EAAA,CAAA;AAAA,IAE5G,KAAK,kBAAA;AACH,MAAA,OAAO,GAAG,MAAM,CAAA,kBAAA,EAAqB,mBAAA,CAAoB,SAAA,CAAU,OAAO,CAAC,CAAA,oBAAA,CAAA;AAAA,IAE7E,KAAK,cAAA;AACH,MAAA,OAAO,GAAG,MAAM,CAAA,kBAAA,EAAqB,mBAAA,CAAoB,SAAA,CAAU,OAAO,CAAC,CAAA,eAAA,CAAA;AAAA,IAE7E,KAAK,YAAA;AACH,MAAA,MAAM,WAAA,GAAc,OAAO,SAAA,CAAU,IAAA,KAAS,QAAA,GAC1C,CAAA,CAAA,EAAIA,aAAAA,CAAa,SAAA,CAAU,IAAI,CAAC,CAAA,CAAA,CAAA,GAChC,SAAA,CAAU,KAAK,QAAA,EAAS;AAC5B,MAAA,OAAO,CAAA,EAAG,MAAM,CAAA,kBAAA,EAAqB,mBAAA,CAAoB,UAAU,OAAO,CAAC,gBAAgB,WAAW,CAAA,EAAA,CAAA;AAAA,IAExG,KAAK,aAAA;AACH,MAAA,OAAO,CAAA,EAAG,MAAM,CAAA,kBAAA,EAAqB,mBAAA,CAAoB,SAAA,CAAU,OAAO,CAAC,CAAA,eAAA,EAAkBA,aAAAA,CAAa,SAAA,CAAU,KAAK,CAAC,CAAA,GAAA,CAAA;AAAA,IAE5H,KAAK,eAAA;AACH,MAAA,IAAI,SAAA,CAAU,YAAY,KAAA,EAAO;AAC/B,QAAA,OAAO,GAAG,MAAM,CAAA,kBAAA,EAAqB,mBAAA,CAAoB,SAAA,CAAU,OAAO,CAAC,CAAA,oBAAA,CAAA;AAAA,MAC7E;AACA,MAAA,OAAO,GAAG,MAAM,CAAA,kBAAA,EAAqB,mBAAA,CAAoB,SAAA,CAAU,OAAO,CAAC,CAAA,gBAAA,CAAA;AAAA,IAE7E,KAAK,eAAA;AACH,MAAA,OAAO,GAAG,MAAM,CAAA,kBAAA,EAAqB,mBAAA,CAAoB,SAAA,CAAU,OAAO,CAAC,CAAA,gBAAA,CAAA;AAAA,IAE7E,KAAK,gBAAA;AACH,MAAA,OAAO,GAAG,MAAM,CAAA,kBAAA,EAAqB,mBAAA,CAAoB,SAAA,CAAU,OAAO,CAAC,CAAA,iBAAA,CAAA;AAAA,IAE7E,KAAK,WAAA;AACH,MAAA,MAAM,gBAAA,GAAmB,OAAO,SAAA,CAAU,OAAA,KAAY,QAAA,GAClD,CAAA,CAAA,EAAI,WAAA,CAAY,SAAA,CAAU,OAAO,CAAC,CAAA,CAAA,CAAA,GAClC,SAAA,CAAU,QAAQ,QAAA,EAAS;AAC/B,MAAA,OAAO,CAAA,EAAG,MAAM,CAAA,6BAAA,EAAgC,gBAAgB,CAAA,EAAA,CAAA;AAAA,IAElE,KAAK,aAAA;AACH,MAAA,MAAM,YAAA,GAAe,OAAO,SAAA,CAAU,KAAA,KAAU,QAAA,GAC5C,CAAA,CAAA,EAAIA,aAAAA,CAAa,SAAA,CAAU,KAAK,CAAC,CAAA,CAAA,CAAA,GACjC,SAAA,CAAU,MAAM,QAAA,EAAS;AAC7B,MAAA,OAAO,CAAA,EAAG,MAAM,CAAA,+BAAA,EAAkC,YAAY,CAAA,EAAA,CAAA;AAAA,IAEhE,KAAK,aAAA;AACH,MAAA,OAAO,CAAA,EAAG,MAAM,CAAA,kBAAA,EAAqB,mBAAA,CAAoB,UAAU,OAAO,CAAC,CAAA,cAAA,EAAiB,SAAA,CAAU,KAAK,CAAA,EAAA,CAAA;AAAA,IAE7G,KAAK,oBAAA;AACH,MAAA,OAAO,CAAA,EAAG,MAAM,CAAA,kBAAA,EAAqB,mBAAA,CAAoB,SAAA,CAAU,OAAO,CAAC,CAAA,iBAAA,EAAoBA,aAAAA,CAAa,SAAA,CAAU,IAAI,CAAC,CAAA,GAAA,CAAA;AAAA;AAAA,IAG7H,KAAK,aAAA;AACH,MAAA,MAAM,aAAA,GAAgB,UAAU,OAAA,GAC5B,CAAA,WAAA,EAAcA,cAAa,SAAA,CAAU,OAAO,CAAC,CAAA,EAAA,CAAA,GAC7C,CAAA,kBAAA,CAAA;AACJ,MAAA,OAAO,CAAA,EAAG,MAAM,CAAA,kBAAA,EAAqB,aAAa,CAAA,gBAAA,CAAA;AAAA,IAEpD,KAAK,cAAA;AACH,MAAA,OAAO,GAAG,MAAM,CAAA,8FAAA,CAAA;AAAA,IAElB,KAAK,aAAA;AACH,MAAA,OAAO,GAAG,MAAM,CAAA,6CAAA,CAAA;AAAA,IAElB,KAAK,cAAA;AACH,MAAA,OAAO,GAAG,MAAM,CAAA,8CAAA,CAAA;AAAA;AAAA,IAGlB,KAAK,YAAA;AAEH,MAAA,MAAM,WAAA,GAAc,CAAA,MAAA,EAAS,SAAA,CAAU,MAAM,CAAA,CAAA;AAC7C,MAAA,MAAM,IAAA,GAAO,SAAA,CAAU,IAAA,GAAO,SAAA,CAAU,KAAK,GAAA,CAAI,CAAA,CAAA,KAAK,IAAA,CAAK,SAAA,CAAU,CAAC,CAAC,CAAA,CAAE,IAAA,CAAK,IAAI,CAAA,GAAI,EAAA;AAEtF,MAAA,OAAO,CAAA,EAAG,MAAM,CAAA,MAAA,EAAS,WAAW,UAAU,SAAA,CAAU,MAAM,IAAI,IAAI,CAAA,EAAA,CAAA;AAAA;AAAA,IAGxE,KAAK,SAAA;AACH,MAAA,OAAO,CAAA,EAAG,MAAM,CAAA,iBAAA,EAAoB,SAAA,CAAU,MAAM;AAAA,EAAK,MAAM,CAAA,WAAA,EAAcA,aAAAA,CAAa,SAAA,CAAU,UAAU,CAAC;AAAA,EAAK,MAAM,CAAA,+BAAA,EAAkCA,aAAAA,CAAa,SAAA,CAAU,MAAM,CAAC,CAAA,GAAA,CAAA;AAAA,IAE5L;AACE,MAAA,OAAO,CAAA,EAAG,MAAM,CAAA,2BAAA,EAA+B,SAAA,CAA+B,IAAI,CAAA,CAAA;AAAA;AAExF;AAMA,SAAS,2BAA2B,GAAA,EAA0E;AAG5G,EAAA,OAAO,CAAC,SAAA,EAAwB,MAAA,GAAS,OAAO,eAAA,CAAgB,SAAA,EAAW,MAAW,CAAA;AACxF;AAKA,SAAS,mBAAA,GAA8B;AACrC,EAAA,MAAM,YAAA,GAAe,gBAAgB,UAAU,CAAA;AAC/C,EAAA,OAAOH,YAAAA,CAAa,cAAc,OAAO,CAAA;AAC3C;AAQA,SAAS,eAAe,OAAA,EAAuC;AAC7D,EAAA,MAAM,UAA6B,EAAC;AAEpC,EAAA,MAAM,WAAA,uBAAkB,GAAA,EAAY;AAGpC,EAAA,KAAA,MAAW,IAAA,IAAQ,QAAQ,KAAA,EAAO;AAChC,IAAA,KAAA,MAAW,MAAA,IAAU,KAAK,OAAA,EAAS;AACjC,MAAA,IAAI,MAAA,CAAO,SAAS,YAAA,EAAc;AAChC,QAAA,WAAA,CAAY,GAAA,CAAI,OAAO,MAAM,CAAA;AAAA,MAC/B;AAAA,IACF;AAAA,EACF;AAGA,EAAA,KAAA,MAAW,UAAU,WAAA,EAAa;AAEhC,IAAA,MAAM,UAAA,GAAa,OAAO,MAAA,CAAO,CAAC,EAAE,WAAA,EAAY,GAAI,MAAA,CAAO,KAAA,CAAM,CAAC,CAAA;AAElE,IAAA,MAAM,WAAA,GAAc,SAAS,MAAM,CAAA,CAAA;AACnC,IAAA,OAAA,CAAQ,IAAA,CAAK;AAAA,MACX,OAAA,EAAS,CAAC,WAAW,CAAA;AAAA,MACrB,IAAA,EAAM,YAAY,UAAU,CAAA;AAAA,KAC7B,CAAA;AAAA,EACH;AAEA,EAAA,OAAO,OAAA;AACT;AAKA,SAAS,YAAY,QAAA,EAA8E;AACjG,EAAA,MAAM,aAAA,GAAgBC,IAAAA,CAAK,QAAA,EAAU,gBAAgB,CAAA;AAErD,EAAA,IAAI,CAACC,UAAAA,CAAW,aAAa,CAAA,EAAG;AAC9B,IAAA,OAAO,EAAE,WAAA,EAAa,IAAA,EAAM,WAAA,EAAa,IAAA,EAAK;AAAA,EAChD;AAEA,EAAA,IAAI;AACF,IAAA,MAAM,OAAA,GAAUF,YAAAA,CAAa,aAAA,EAAe,OAAO,CAAA;AACnD,IAAA,MAAM,SAAA,GAAY,IAAA,CAAK,KAAA,CAAM,OAAO,CAAA;AAKpC,IAAA,MAAM,cAAc,SAAA,CAAU,WAAA,IAAA,iBAAe,IAAI,IAAA,IAAO,WAAA,EAAY;AACpE,IAAA,MAAM,YAAA,GAAe,SAAA,CAAU,QAAA,EAAU,YAAA,IAAgB,CAAA;AACzD,IAAA,MAAM,eAAA,GAAkB,SAAA,CAAU,QAAA,EAAU,eAAA,IAAmB,CAAA;AAC/D,IAAA,MAAM,cAAc,YAAA,GAAe,eAAA;AAEnC,IAAA,OAAO,EAAE,aAAa,WAAA,EAAY;AAAA,EACpC,CAAA,CAAA,MAAQ;AACN,IAAA,OAAO,EAAE,WAAA,EAAa,IAAA,EAAM,WAAA,EAAa,IAAA,EAAK;AAAA,EAChD;AACF;AAKO,SAAS,YAAA,CACd,OAAA,EACA,OAAA,GAA+B,EAAC,EACZ;AACpB,EAAA,MAAM;AAAA,IACJ,YAAA;AAAA,IACA,OAAA,EAAS,oBAAoB,EAAC;AAAA,IAC9B,QAAA,GAAW,MAAA;AAAA,IACX,YAAA;AAAA,IACA,QAAA,GAAW,YAAA;AAAA,IACX,kBAAA,GAAqB,IAAA;AAAA,IACrB,aAAA;AAAA,IACA,kBAAA,GAAqB;AAAA,GACvB,GAAI,OAAA;AAGJ,EAAA,MAAM,OAAA,GAAU,iBAAiB,aAAA,EAAc;AAG/C,EAAA,MAAM,UAAA,GAA6B;AAAA,IAEjC,UAAU,EAEZ,CAAA;AAGA,EAAA,MAAM,WAAW,YAAA,GACbA,YAAAA,CAAa,YAAA,EAAc,OAAO,IAClC,mBAAA,EAAoB;AAGxB,EAAA,MAAM,UAAU,CAAC,GAAG,eAAe,OAAO,CAAA,EAAG,GAAG,iBAAiB,CAAA;AAGjE,EAAA,IAAI,WAAA,GAA6B,IAAA;AACjC,EAAA,IAAI,WAAA,GAA6B,IAAA;AAEjC,EAAA,IAAI,kBAAA,EAAoB;AACtB,IAAA,MAAM,QAAA,GAAW,YAAY,QAAQ,CAAA;AACrC,IAAA,WAAA,GAAc,QAAA,CAAS,WAAA;AACvB,IAAA,WAAA,GAAc,QAAA,CAAS,WAAA;AAAA,EACzB;AAGA,EAAA,MAAM,2BAAA,GAA8B,2BAAqC,CAAA;AAGzE,EAAA,IAAI,IAAA,GAAO,GAAA,CAAI,MAAA,CAAO,QAAA,EAAU;AAAA,IAC9B,OAAA;AAAA,IACA,OAAA;AAAA,IACA,eAAA,EAAiB,2BAAA;AAAA,IACjB,YAAA,EAAAG,aAAAA;AAAA,IACA,WAAA;AAAA,IACA,SAAS,iBAAA,EAAkB;AAAA,IAC3B,WAAW,qBAAA,EAAsB;AAAA,IACjC,WAAA;AAAA,IACA,WAAA;AAAA,IACA,SAAS,OAAA,CAAQ,EAAA;AAAA,IACjB,mBAAmB,OAAA,CAAQ;AAAA,GAC5B,CAAA;AAGD,EAAA,IAAI,QAAA,KAAa,YAAY,YAAA,EAAc;AAEzC,IAAA,MAAM,SAAA,GAAY;AAAA,MAChB,EAAA,EAAI,CAAA,KAAA,EAAQ,OAAA,CAAQ,EAAE,CAAA,CAAA;AAAA,MACtB,OAAA,EAAS,KAAK,IAAA;AAAK,KACrB;AAEA,IAAA,IAAA,GAAO,mBAAA,CAAoB;AAAA,MACzB,YAAA;AAAA,MACA,SAAA,EAAW,CAAC,SAAS;AAAA,KACtB,CAAA;AAAA,EACH,CAAA,MAAA,IAAW,QAAA,KAAa,KAAA,IAAS,YAAA,EAAc;AAG7C,IAAA,OAAA,CAAQ,KAAK,gFAAgF,CAAA;AAAA,EAC/F;AAGA,EAAA,MAAM,QAAA,GAAW,CAAA,EAAG,OAAA,CAAQ,EAAA,CAAG,aAAa,CAAA,QAAA,CAAA;AAG5C,EAAA,IAAI,OAAA,CAAQ,aAAA,IAAiB,OAAA,CAAQ,WAAA,EAAa;AAChD,IAAA,IAAI;AACF,MAAA,MAAM,QAAA,GAAW,QAAQ,UAAA,IAAc,QAAA;AAGvC,MAAA,MAAM,OAAA,GAAU;AAAA,QACd,UAAA,EAAY,OAAA,CAAQ,kBAAA,EAAoB,UAAA,IAAc,EAAC;AAAA,QACvD,QAAA,EAAU,OAAA,CAAQ,kBAAA,EAAoB,OAAA,IAAW;AAAC;AAAA,OACpD;AAEA,MAAA,wBAAA,CAAyB;AAAA,QACvB,aAAa,OAAA,CAAQ,WAAA;AAAA,QACrB,QAAA;AAAA,QACA,WAAA,EAAa,IAAA;AAAA,QACb;AAAA,OACD,CAAA;AAAA,IACH,SAAS,KAAA,EAAO;AAEd,MAAA,OAAA,CAAQ,KAAA;AAAA,QACN,kDAAkD,KAAA,YAAiB,KAAA,GAAQ,MAAM,OAAA,GAAU,MAAA,CAAO,KAAK,CAAC,CAAA;AAAA,OAC1G;AAAA,IACF;AAAA,EACF;AAEA,EAAA,OAAO;AAAA,IACL,IAAA;AAAA,IACA,WAAW,OAAA,CAAQ,EAAA;AAAA,IACnB,QAAA;AAAA,IACA,OAAA;AAAA,IACA,OAAA;AAAA,IACA,iBAAiB,UAAA,CAAW,QAAA,CAAS,MAAA,GAAS,CAAA,GAAI,WAAW,QAAA,GAAW;AAAA,GAC1E;AACF;AAKO,SAAS,iBAAiB,OAAA,EAA4B;AAC3D,EAAA,OAAO,YAAA,CAAa,OAAO,CAAA,CAAE,IAAA;AAC/B;AChcA,SAAS,aAAa,GAAA,EAAqB;AACzC,EAAA,OAAO,GAAA,CACJ,MAAM,SAAS,CAAA,CACf,IAAI,CAAA,IAAA,KAAQ,IAAA,CAAK,OAAO,CAAC,CAAA,CAAE,aAAY,GAAI,IAAA,CAAK,MAAM,CAAC,CAAA,CAAE,aAAa,CAAA,CACtE,KAAK,EAAE,CAAA;AACZ;AAKA,SAAS,YAAY,GAAA,EAAqB;AACxC,EAAA,MAAM,MAAA,GAAS,aAAa,GAAG,CAAA;AAC/B,EAAA,OAAO,MAAA,CAAO,OAAO,CAAC,CAAA,CAAE,aAAY,GAAI,MAAA,CAAO,MAAM,CAAC,CAAA;AACxD;AAKA,SAAS,mBAAA,CAAoB,MAAmB,aAAA,EAAoC;AAClF,EAAA,IAAI,QAAA;AAGJ,EAAA,QAAQ,KAAK,QAAA;AAAU,IACrB,KAAK,MAAA;AACH,MAAA,QAAA,GAAW,KAAK,OAAA,EAAS,IAAA,GACrB,GAAG,WAAA,CAAY,IAAA,CAAK,QAAQ,IAAI,CAAC,GAAG,YAAA,CAAa,IAAA,CAAK,KAAK,CAAC,CAAA,CAAA,GAC5D,GAAG,WAAA,CAAY,IAAA,CAAK,KAAK,CAAC,CAAA,OAAA,CAAA;AAC9B,MAAA;AAAA,IACF,KAAK,OAAA;AAAA,IACL,KAAK,aAAA;AAAA,IACL,KAAK,MAAA;AACH,MAAA,QAAA,GAAW,CAAA,EAAG,WAAA,CAAY,IAAA,CAAK,KAAK,CAAC,CAAA,KAAA,CAAA;AACrC,MAAA;AAAA,IACF,KAAK,QAAA;AACH,MAAA,QAAA,GAAW,WAAA,CAAY,KAAK,KAAK,CAAA;AACjC,MAAA;AAAA,IACF,KAAK,KAAA;AAEH,MAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,KAAA,CAAM,KAAA,CAAM,+BAA+B,CAAA;AAC9D,MAAA,QAAA,GAAW,KAAA,GAAQ,WAAA,CAAY,KAAA,CAAM,CAAC,CAAE,CAAA,GAAI,SAAA;AAC5C,MAAA;AAAA,IACF;AACE,MAAA,QAAA,GAAW,SAAA;AAAA;AAIf,EAAA,IAAI,IAAA,GAAO,QAAA;AACX,EAAA,IAAI,OAAA,GAAU,CAAA;AACd,EAAA,OAAO,aAAA,CAAc,GAAA,CAAI,IAAI,CAAA,EAAG;AAC9B,IAAA,IAAA,GAAO,CAAA,EAAG,QAAQ,CAAA,EAAG,OAAO,CAAA,CAAA;AAC5B,IAAA,OAAA,EAAA;AAAA,EACF;AACA,EAAA,aAAA,CAAc,IAAI,IAAI,CAAA;AAEtB,EAAA,OAAO,IAAA;AACT;AAKA,SAAS,gBAAgB,OAAA,EAAqC;AAC5D,EAAA,MAAM,WAA4B,EAAC;AACnC,EAAA,MAAM,aAAA,uBAAoB,GAAA,EAAY;AACtC,EAAA,MAAM,SAAA,uBAAgB,GAAA,EAA2B;AAGjD,EAAA,MAAM,gBAAA,GAAmB,CAAC,SAAA,KAA2B;AAEnD,IAAA,MAAM,cAAe,SAAA,CAAwC,OAAA;AAC7D,IAAA,IAAI,CAAC,WAAA,EAAa;AAGlB,IAAA,MAAM,OAAA,GAAU,IAAA,CAAK,SAAA,CAAU,WAAW,CAAA;AAC1C,IAAA,IAAI,SAAA,CAAU,GAAA,CAAI,OAAO,CAAA,EAAG;AAE5B,IAAA,MAAM,IAAA,GAAO,mBAAA,CAAoB,WAAA,EAAa,aAAa,CAAA;AAC3D,IAAA,MAAM,iBAAA,GAAoB,oBAAoB,WAAW,CAAA;AAEzD,IAAA,MAAM,OAAA,GAAyB;AAAA,MAC7B,IAAA;AAAA,MACA,UAAA,EAAY,iBAAA;AAAA,MACZ,IAAA,EAAM,WAAA;AAAA,MACN,aAAa,CAAA,YAAA,EAAe,WAAA,CAAY,QAAQ,CAAA,EAAA,EAAK,YAAY,KAAK,CAAA;AAAA,KACxE;AAEA,IAAA,QAAA,CAAS,KAAK,OAAO,CAAA;AACrB,IAAA,SAAA,CAAU,GAAA,CAAI,SAAS,OAAO,CAAA;AAAA,EAChC,CAAA;AAGA,EAAA,IAAI,QAAQ,KAAA,EAAO;AACjB,IAAA,KAAA,MAAW,SAAA,IAAa,QAAQ,KAAA,EAAO;AACrC,MAAA,gBAAA,CAAiB,SAAS,CAAA;AAAA,IAC5B;AAAA,EACF;AAGA,EAAA,KAAA,MAAW,IAAA,IAAQ,QAAQ,KAAA,EAAO;AAChC,IAAA,KAAA,MAAW,MAAA,IAAU,KAAK,OAAA,EAAS;AACjC,MAAA,gBAAA,CAAiB,MAAM,CAAA;AAAA,IACzB;AACA,IAAA,KAAA,MAAW,SAAA,IAAa,KAAK,UAAA,EAAY;AACvC,MAAA,gBAAA,CAAiB,SAAS,CAAA;AAAA,IAC5B;AAAA,EACF;AAGA,EAAA,IAAI,QAAQ,OAAA,EAAS;AACnB,IAAA,KAAA,MAAW,SAAA,IAAa,QAAQ,OAAA,EAAS;AACvC,MAAA,gBAAA,CAAiB,SAAS,CAAA;AAAA,IAC5B;AAAA,EACF;AAEA,EAAA,OAAO,QAAA;AACT;AAKA,SAAS,eAAA,CAAgB,SAAoB,QAAA,EAA2C;AACtF,EAAA,MAAM,UAA0B,EAAC;AACjC,EAAA,MAAM,UAAA,uBAAiB,GAAA,EAAoB;AAG3C,EAAA,KAAA,MAAW,WAAW,QAAA,EAAU;AAC9B,IAAA,MAAM,OAAA,GAAU,IAAA,CAAK,SAAA,CAAU,OAAA,CAAQ,IAAI,CAAA;AAC3C,IAAA,UAAA,CAAW,GAAA,CAAI,OAAA,EAAS,OAAA,CAAQ,IAAI,CAAA;AAAA,EACtC;AAGA,EAAA,MAAM,aAAA,GAAgB,CAAC,IAAA,KAA8B;AACnD,IAAA,MAAM,OAAA,GAAU,IAAA,CAAK,SAAA,CAAU,IAAI,CAAA;AACnC,IAAA,MAAM,WAAA,GAAc,UAAA,CAAW,GAAA,CAAI,OAAO,CAAA;AAC1C,IAAA,OAAO,cAAc,CAAA,KAAA,EAAQ,WAAW,KAAK,CAAA,UAAA,EAAa,mBAAA,CAAoB,IAAI,CAAC,CAAA,CAAA;AAAA,EACrF,CAAA;AAGA,EAAA,KAAA,MAAW,IAAA,IAAQ,QAAQ,KAAA,EAAO;AAChC,IAAA,MAAM,aAAa,WAAA,CAAY,IAAA,CAAK,GAAG,OAAA,CAAQ,eAAA,EAAiB,GAAG,CAAC,CAAA;AACpE,IAAA,MAAM,OAAiB,EAAC;AAGxB,IAAA,KAAA,MAAW,MAAA,IAAU,KAAK,OAAA,EAAS;AACjC,MAAA,MAAM,IAAA,GAAO,qBAAA,CAAsB,MAAA,EAAQ,aAAa,CAAA;AACxD,MAAA,IAAI,IAAA,EAAM;AACR,QAAA,IAAA,CAAK,KAAK,IAAI,CAAA;AAAA,MAChB;AAAA,IACF;AAGA,IAAA,KAAA,MAAW,SAAA,IAAa,KAAK,UAAA,EAAY;AACvC,MAAA,MAAM,IAAA,GAAO,qBAAA,CAAsB,SAAA,EAAW,aAAa,CAAA;AAC3D,MAAA,IAAI,IAAA,EAAM;AACR,QAAA,IAAA,CAAK,KAAK,IAAI,CAAA;AAAA,MAChB;AAAA,IACF;AAEA,IAAA,IAAI,IAAA,CAAK,SAAS,CAAA,EAAG;AACnB,MAAA,OAAA,CAAQ,IAAA,CAAK;AAAA,QACX,IAAA,EAAM,UAAA;AAAA,QACN,aAAa,IAAA,CAAK,WAAA;AAAA,QAClB,QAAQ,EAAC;AAAA,QACT,UAAA,EAAY,MAAA;AAAA,QACZ;AAAA,OACD,CAAA;AAAA,IACH;AAAA,EACF;AAEA,EAAA,OAAO,OAAA;AACT;AAKA,SAAS,qBAAA,CACP,WACA,aAAA,EACe;AACf,EAAA,QAAQ,UAAU,IAAA;AAAM;AAAA,IAEtB,KAAK,MAAA;AACH,MAAA,OAAO,CAAA,sBAAA,EAAyBA,aAAAA,CAAa,SAAA,CAAU,GAAG,CAAC,CAAA,GAAA,CAAA;AAAA,IAE7D,KAAK,YAAA;AACH,MAAA,MAAM,UAAA,GAAa,OAAO,SAAA,CAAU,OAAA,KAAY,QAAA,GAC5C,CAAA,CAAA,EAAIA,aAAAA,CAAa,SAAA,CAAU,OAAO,CAAC,CAAA,CAAA,CAAA,GACnC,SAAA,CAAU,QAAQ,QAAA,EAAS;AAC/B,MAAA,OAAO,8BAA8B,UAAU,CAAA,EAAA,CAAA;AAAA,IAEjD,KAAK,wBAAA;AACH,MAAA,OAAO,CAAA,gDAAA,CAAA;AAAA;AAAA,IAGT,KAAK,OAAA;AACH,MAAA,OAAO,CAAA,MAAA,EAAS,aAAA,CAAc,SAAA,CAAU,OAAO,CAAC,CAAA,SAAA,CAAA;AAAA,IAElD,KAAK,MAAA;AACH,MAAA,MAAM,KAAA,GAAQ,SAAA,CAAU,KAAA,CAAM,IAAA,KAAS,SAAA,GACnC,CAAA,CAAA,EAAIA,aAAAA,CAAa,SAAA,CAAU,KAAA,CAAM,KAAK,CAAC,CAAA,CAAA,CAAA,GACvC,UAAU,KAAA,CAAM,KAAA;AACpB,MAAA,OAAO,SAAS,aAAA,CAAc,SAAA,CAAU,OAAO,CAAC,SAAS,KAAK,CAAA,EAAA,CAAA;AAAA,IAEhE,KAAK,QAAA;AACH,MAAA,OAAO,CAAA,MAAA,EAAS,cAAc,SAAA,CAAU,OAAO,CAAC,CAAA,eAAA,EAAkBA,aAAAA,CAAa,SAAA,CAAU,MAAM,CAAC,CAAA,GAAA,CAAA;AAAA,IAElG,KAAK,OAAA;AACH,MAAA,OAAO,CAAA,MAAA,EAAS,aAAA,CAAc,SAAA,CAAU,OAAO,CAAC,CAAA,SAAA,CAAA;AAAA,IAElD,KAAK,SAAA;AACH,MAAA,OAAO,CAAA,MAAA,EAAS,aAAA,CAAc,SAAA,CAAU,OAAO,CAAC,CAAA,WAAA,CAAA;AAAA,IAElD,KAAK,OAAA;AACH,MAAA,IAAI,UAAU,OAAA,EAAS;AACrB,QAAA,OAAO,SAAS,aAAA,CAAc,SAAA,CAAU,OAAO,CAAC,CAAA,QAAA,EAAW,UAAU,GAAG,CAAA,GAAA,CAAA;AAAA,MAC1E;AACA,MAAA,OAAO,CAAA,gCAAA,EAAmC,UAAU,GAAG,CAAA,GAAA,CAAA;AAAA,IAEzD,KAAK,OAAA;AACH,MAAA,OAAO,CAAA,MAAA,EAAS,aAAA,CAAc,SAAA,CAAU,OAAO,CAAC,CAAA,SAAA,CAAA;AAAA,IAElD,KAAK,OAAA;AACH,MAAA,OAAO,CAAA,MAAA,EAAS,aAAA,CAAc,SAAA,CAAU,OAAO,CAAC,CAAA,SAAA,CAAA;AAAA,IAElD,KAAK,OAAA;AACH,MAAA,OAAO,CAAA,MAAA,EAAS,aAAA,CAAc,SAAA,CAAU,OAAO,CAAC,CAAA,SAAA,CAAA;AAAA;AAAA,IAGlD,KAAK,eAAA;AACH,MAAA,OAAO,CAAA,aAAA,EAAgB,aAAA,CAAc,SAAA,CAAU,OAAO,CAAC,CAAA,gBAAA,CAAA;AAAA,IAEzD,KAAK,kBAAA;AACH,MAAA,OAAO,CAAA,aAAA,EAAgB,aAAA,CAAc,SAAA,CAAU,OAAO,CAAC,CAAA,oBAAA,CAAA;AAAA,IAEzD,KAAK,YAAA;AACH,MAAA,MAAM,WAAA,GAAc,OAAO,SAAA,CAAU,IAAA,KAAS,QAAA,GAC1C,CAAA,CAAA,EAAIA,aAAAA,CAAa,SAAA,CAAU,IAAI,CAAC,CAAA,CAAA,CAAA,GAChC,SAAA,CAAU,KAAK,QAAA,EAAS;AAC5B,MAAA,OAAO,gBAAgB,aAAA,CAAc,SAAA,CAAU,OAAO,CAAC,gBAAgB,WAAW,CAAA,EAAA,CAAA;AAAA,IAEpF,KAAK,aAAA;AACH,MAAA,OAAO,CAAA,aAAA,EAAgB,cAAc,SAAA,CAAU,OAAO,CAAC,CAAA,eAAA,EAAkBA,aAAAA,CAAa,SAAA,CAAU,KAAK,CAAC,CAAA,GAAA,CAAA;AAAA,IAExG,KAAK,eAAA;AACH,MAAA,OAAO,CAAA,aAAA,EAAgB,aAAA,CAAc,SAAA,CAAU,OAAO,CAAC,CAAA,gBAAA,CAAA;AAAA,IAEzD,KAAK,gBAAA;AACH,MAAA,OAAO,CAAA,aAAA,EAAgB,aAAA,CAAc,SAAA,CAAU,OAAO,CAAC,CAAA,iBAAA,CAAA;AAAA;AAAA,IAGzD,KAAK,SAAA;AACH,MAAA,OAAO,CAAA,iBAAA,EAAoB,UAAU,MAAM;AAAA,mCAAA,EAAwC,UAAU,MAAM,CAAA,GAAA,CAAA;AAAA,IAErG;AACE,MAAA,OAAO,IAAA;AAAA;AAEb;AAKA,SAASA,cAAa,GAAA,EAAqB;AACzC,EAAA,OAAO,IACJ,OAAA,CAAQ,KAAA,EAAO,MAAM,CAAA,CACrB,OAAA,CAAQ,MAAM,KAAK,CAAA,CACnB,QAAQ,IAAA,EAAM,KAAK,EACnB,OAAA,CAAQ,KAAA,EAAO,KAAK,CAAA,CACpB,OAAA,CAAQ,OAAO,KAAK,CAAA;AACzB;AAKA,SAASC,oBAAAA,GAA8B;AACrC,EAAA,MAAM,YAAA,GAAe,gBAAgB,YAAY,CAAA;AACjD,EAAA,OAAOJ,YAAAA,CAAa,cAAc,OAAO,CAAA;AAC3C;AAKO,SAAS,cAAA,CACd,OAAA,EACA,OAAA,GAAiC,EAAC,EACZ;AACtB,EAAA,MAAM,EAAE,YAAA,EAAc,MAAA,GAAS,MAAA,EAAO,GAAI,OAAA;AAG1C,EAAA,MAAM,WAAW,YAAA,GACbA,YAAAA,CAAa,YAAA,EAAc,OAAO,IAClCI,oBAAAA,EAAoB;AAGxB,EAAA,MAAM,UAAA,GAAa,YAAA,CAAa,OAAA,CAAQ,KAAK,CAAA;AAC7C,EAAA,MAAM,SAAA,GAAY,CAAA,EAAG,UAAU,CAAA,EAAG,MAAM,CAAA,CAAA;AAGxC,EAAA,MAAM,QAAA,GAAW,gBAAgB,OAAO,CAAA;AACxC,EAAA,MAAM,OAAA,GAAU,eAAA,CAAgB,OAAA,EAAS,QAAQ,CAAA;AAGjD,EAAA,MAAM,SAAA,GAA8B;AAAA,IAClC,UAAA;AAAA,IACA,SAAA;AAAA,IACA,OAAO,OAAA,CAAQ,KAAA;AAAA,IACf,QAAA;AAAA,IACA;AAAA,GACF;AAGA,EAAA,MAAM,IAAA,GAAOC,GAAAA,CAAI,MAAA,CAAO,QAAA,EAAU;AAAA,IAChC,GAAG,SAAA;AAAA,IACH,SAAS,iBAAA,EAAkB;AAAA,IAC3B,WAAW,qBAAA;AAAsB,GAClC,CAAA;AAGD,EAAA,MAAM,QAAA,GAAW,CAAA,EAAG,OAAA,CAAQ,KAAA,CAAM,aAAa,CAAA,QAAA,CAAA;AAE/C,EAAA,OAAO;AAAA,IACL,IAAA;AAAA,IACA,UAAA;AAAA,IACA,QAAA;AAAA,IACA,QAAA;AAAA,IACA;AAAA,GACF;AACF;AAKO,SAAS,mBAAmB,OAAA,EAA4B;AAC7D,EAAA,OAAO,cAAA,CAAe,OAAO,CAAA,CAAE,IAAA;AACjC;AAKO,SAAS,uBAAA,CACd,OAAA,EACA,OAAA,GAAiC,EAAC,EAChB;AAClB,EAAA,MAAM,EAAE,MAAA,GAAS,MAAA,EAAO,GAAI,OAAA;AAE5B,EAAA,MAAM,UAAA,GAAa,YAAA,CAAa,OAAA,CAAQ,KAAK,CAAA;AAC7C,EAAA,MAAM,SAAA,GAAY,CAAA,EAAG,UAAU,CAAA,EAAG,MAAM,CAAA,CAAA;AACxC,EAAA,MAAM,QAAA,GAAW,gBAAgB,OAAO,CAAA;AACxC,EAAA,MAAM,OAAA,GAAU,eAAA,CAAgB,OAAA,EAAS,QAAQ,CAAA;AAEjD,EAAA,OAAO;AAAA,IACL,UAAA;AAAA,IACA,SAAA;AAAA,IACA,OAAO,OAAA,CAAQ,KAAA;AAAA,IACf,QAAA;AAAA,IACA;AAAA,GACF;AACF;ACvZO,SAAS,aAAA,GAAyB;AACvC,EAAA,OAAO,IAAI,OAAA,CAAQ;AAAA,IACjB,qBAAA,EAAuB,IAAA;AAAA,IACvB,eAAA,EAAiB;AAAA,MACf,QAAQ,YAAA,CAAa,MAAA;AAAA,MACrB,QAAQ,UAAA,CAAW,MAAA;AAAA,MACnB,MAAA,EAAQ;AAAA;AACV,GACD,CAAA;AACH;AAKO,SAAS,cAAA,CAAe,OAAA,EAAkB,IAAA,EAAc,QAAA,GAAW,SAAA,EAAuB;AAC/F,EAAA,OAAO,QAAQ,gBAAA,CAAiB,QAAA,EAAU,MAAM,EAAE,SAAA,EAAW,MAAM,CAAA;AACrE;AAKO,SAAS,SAAA,CAAU,YAAwB,SAAA,EAAiD;AACjG,EAAA,OAAO,UAAA,CAAW,SAAS,SAAS,CAAA;AACtC;AAKO,SAAS,UAAA,CAAW,WAA6B,UAAA,EAAmD;AACzG,EAAA,OAAO,SAAA,CAAU,UAAU,UAAU,CAAA;AACvC;AAKO,SAAS,YAAA,CAAa,WAA6B,YAAA,EAAuD;AAC/G,EAAA,OAAO,SAAA,CAAU,YAAY,YAAY,CAAA;AAC3C;AAKO,SAAS,SAAA,CAAU,YAAwB,eAAA,EAAkC;AAClF,EAAA,OAAO,UAAA,CAAW,uBAAsB,CAAE,IAAA;AAAA,IACxC,CAAA,GAAA,KAAO,GAAA,CAAI,uBAAA,EAAwB,KAAM;AAAA,GAC3C;AACF;AAKO,SAAS,SAAA,CAAU,YAAwB,eAAA,EAAwD;AACxG,EAAA,OAAO,UAAA,CAAW,uBAAsB,CAAE,IAAA;AAAA,IACxC,CAAA,GAAA,KAAO,GAAA,CAAI,uBAAA,EAAwB,KAAM;AAAA,GAC3C;AACF;AAKO,SAAS,cAAA,CACd,UAAA,EACA,eAAA,EACA,WAAA,EACS;AACT,EAAA,MAAM,cAAA,GAAiB,SAAA,CAAU,UAAA,EAAY,eAAe,CAAA;AAE5D,EAAA,IAAI,cAAA,EAAgB;AAElB,IAAA,MAAM,YAAA,GAAe,eAAe,eAAA,EAAgB;AACpD,IAAA,MAAM,SAAS,YAAA,CAAa,IAAA,CAAK,QAAM,EAAA,CAAG,OAAA,OAAc,WAAW,CAAA;AAEnE,IAAA,IAAI,CAAC,MAAA,EAAQ;AACX,MAAA,cAAA,CAAe,eAAe,WAAW,CAAA;AACzC,MAAA,OAAO,IAAA;AAAA,IACT;AACA,IAAA,OAAO,KAAA;AAAA,EACT;AAGA,EAAA,UAAA,CAAW,oBAAA,CAAqB;AAAA,IAC9B,eAAA;AAAA,IACA,YAAA,EAAc,CAAC,WAAW;AAAA,GAC3B,CAAA;AACD,EAAA,OAAO,IAAA;AACT;AAmBO,SAAS,kBAAA,CACd,SAAA,EACA,OAAA,EACA,OAAA,GAA0B,EAAC,EACT;AAClB,EAAA,MAAM,QAAA,GAAW,YAAA,CAAa,SAAA,EAAW,OAAA,CAAQ,IAAI,CAAA;AAErD,EAAA,IAAI,QAAA,EAAU;AACZ,IAAA,IAAI,QAAQ,gBAAA,EAAkB;AAC5B,MAAA,OAAO,EAAE,KAAA,EAAO,KAAA,EAAO,WAAA,EAAa,KAAA,EAAM;AAAA,IAC5C;AACA,IAAA,QAAA,CAAS,MAAA,EAAO;AAAA,EAClB;AAGA,EAAA,SAAA,CAAU,WAAA,CAAY;AAAA,IACpB,MAAM,OAAA,CAAQ,IAAA;AAAA,IACd,UAAA,EAAY,IAAA;AAAA,IACZ,IAAA,EAAM,SAAA;AAAA,IACN,IAAA,EAAM,QAAQ,WAAA,GAAc,CAAC,EAAE,WAAA,EAAa,OAAA,CAAQ,WAAA,EAAa,CAAA,GAAI;AAAA,GACtE,CAAA;AAED,EAAA,MAAM,gBAAgB,CAAA,KAAA,EAAQ,OAAA,CAAQ,IAAI,CAAA,QAAA,EAAW,QAAQ,UAAU,CAAA,CAAA,CAAA;AAGvE,EAAA,IAAI,WAAA,GAAc,SAAA,CAAU,eAAA,EAAgB,CAAE,CAAC,CAAA;AAC/C,EAAA,IAAI,CAAC,WAAA,EAAa;AAEhB,IAAA,WAAA,GAAc,UAAU,cAAA,CAAe;AAAA,MACrC,YAAY,CAAC,EAAE,MAAM,MAAA,EAAQ,IAAA,EAAM,QAAQ,CAAA;AAAA,MAC3C,UAAA,EAAY,CAAC,CAAA,iBAAA,CAAA,EAAqB,aAAa;AAAA,KAChD,CAAA;AAGD,IAAA,IAAI,CAAC,YAAA,CAAa,SAAA,EAAW,MAAM,CAAA,EAAG;AACpC,MAAA,SAAA,CAAU,eAAe,CAAA,EAAG;AAAA,QAC1B,IAAA,EAAM,MAAA;AAAA,QACN,UAAA,EAAY,IAAA;AAAA,QACZ,IAAA,EAAM;AAAA,OACP,CAAA;AAAA,IACH;AAEA,IAAA,OAAO,EAAE,KAAA,EAAO,IAAA,EAAM,WAAA,EAAa,IAAA,EAAK;AAAA,EAC1C;AAGA,EAAA,IAAI,IAAA,GAAO,YAAY,OAAA,EAAQ;AAC/B,EAAA,IAAI,CAAC,IAAA,EAAM;AAET,IAAA,WAAA,CAAY,YAAY,EAAE,CAAA;AAC1B,IAAA,IAAA,GAAO,YAAY,OAAA,EAAQ;AAC3B,IAAA,IAAI,CAAC,IAAA,EAAM;AACT,MAAA,OAAO;AAAA,QACL,KAAA,EAAO,IAAA;AAAA,QACP,WAAA,EAAa,KAAA;AAAA,QACb,OAAA,EAAS,CAAA,oCAAA,EAAuC,OAAA,CAAQ,IAAI,CAAA,gBAAA;AAAA,OAC9D;AAAA,IACF;AAAA,EACF;AAGA,EAAA,MAAM,eAAe,IAAA,CAAK,oBAAA,CAAqB,UAAA,CAAW,mBAAmB,EAC1E,IAAA,CAAK,CAAA,IAAA,KAAQ,IAAA,CAAK,OAAA,GAAU,QAAA,CAAS,CAAA,KAAA,EAAQ,OAAA,CAAQ,IAAI,EAAE,CAAC,CAAA;AAE/D,EAAA,IAAI,CAAC,YAAA,EAAc;AACjB,IAAA,WAAA,CAAY,cAAc,aAAa,CAAA;AAAA,EACzC;AAEA,EAAA,OAAO,EAAE,KAAA,EAAO,IAAA,EAAM,WAAA,EAAa,IAAA,EAAK;AAC1C;AAKO,SAAS,SAAA,CACd,SAAA,EACA,MAAA,EACA,OAAA,GAA0B,EAAC,EAClB;AACT,EAAA,MAAM,QAAA,GAAW,UAAA,CAAW,SAAA,EAAW,MAAA,CAAO,IAAI,CAAA;AAElD,EAAA,IAAI,QAAA,EAAU;AACZ,IAAA,IAAI,QAAQ,gBAAA,EAAkB;AAC5B,MAAA,OAAO,KAAA;AAAA,IACT;AACA,IAAA,QAAA,CAAS,MAAA,EAAO;AAAA,EAClB;AAGA,EAAA,SAAA,CAAU,SAAA,CAAU;AAAA,IAClB,MAAM,MAAA,CAAO,IAAA;AAAA,IACb,OAAA,EAAS,IAAA;AAAA,IACT,UAAA,EAAY,MAAA,CAAO,MAAA,CAAO,GAAA,CAAI,CAAA,CAAA,MAAM;AAAA,MAClC,MAAM,CAAA,CAAE,IAAA;AAAA,MACR,MAAM,CAAA,CAAE,IAAA;AAAA,MACR,kBAAkB,CAAA,CAAE,QAAA;AAAA,MACpB,aAAa,CAAA,CAAE;AAAA,KACjB,CAAE,CAAA;AAAA,IACF,UAAA,EAAY,CAAA,QAAA,EAAW,MAAA,CAAO,UAAU,CAAA,CAAA,CAAA;AAAA,IACxC,MAAM,CAAC,EAAE,WAAA,EAAa,MAAA,CAAO,aAAa,CAAA;AAAA,IAC1C,UAAA,EAAY,MAAA,CAAO,IAAA,CAAK,IAAA,CAAK,IAAI;AAAA,GAClC,CAAA;AAED,EAAA,OAAO,IAAA;AACT;AAKO,SAAS,iBACd,IAAA,EACA,SAAA,EACA,UACA,OAAA,EACA,OAAA,GAA0B,EAAC,EACZ;AACf,EAAA,MAAM,UAAU,aAAA,EAAc;AAC9B,EAAA,MAAM,UAAA,GAAa,cAAA,CAAe,OAAA,EAAS,IAAI,CAAA;AAC/C,EAAA,MAAM,UAAoB,EAAC;AAC3B,EAAA,MAAM,WAAqB,EAAC;AAG5B,EAAA,MAAM,SAAA,GAAY,SAAA,CAAU,UAAA,EAAY,SAAS,CAAA;AACjD,EAAA,IAAI,CAAC,SAAA,EAAW;AACd,IAAA,OAAO;AAAA,MACL,QAAA,EAAU,KAAA;AAAA,MACV,SAAS,EAAC;AAAA,MACV,IAAA;AAAA,MACA,QAAA,EAAU,CAAC,CAAA,OAAA,EAAU,SAAS,CAAA,0BAAA,CAA4B;AAAA,KAC5D;AAAA,EACF;AAGA,EAAA,IAAI,OAAA,CAAQ,eAAe,KAAA,EAAO;AAChC,IAAA,IAAI,cAAA,CAAe,UAAA,EAAY,kBAAA,EAAoB,SAAS,CAAA,EAAG;AAC7D,MAAA,OAAA,CAAQ,KAAK,sBAAsB,CAAA;AAAA,IACrC;AACA,IAAA,IAAI,cAAA,CAAe,UAAA,EAAY,kBAAA,EAAoB,QAAQ,CAAA,EAAG;AAC5D,MAAA,OAAA,CAAQ,KAAK,qBAAqB,CAAA;AAAA,IACpC;AAAA,EACF;AAGA,EAAA,KAAA,MAAW,WAAW,QAAA,EAAU;AAC9B,IAAA,MAAM,MAAA,GAAS,kBAAA,CAAmB,SAAA,EAAW,OAAA,EAAS,OAAO,CAAA;AAC7D,IAAA,IAAI,OAAO,KAAA,EAAO;AAChB,MAAA,OAAA,CAAQ,IAAA,CAAK,CAAA,eAAA,EAAkB,OAAA,CAAQ,IAAI,CAAA,CAAE,CAAA;AAC7C,MAAA,IAAI,OAAO,OAAA,EAAS;AAClB,QAAA,QAAA,CAAS,IAAA,CAAK,OAAO,OAAO,CAAA;AAAA,MAC9B;AAAA,IACF,CAAA,MAAA,IAAW,QAAQ,gBAAA,EAAkB;AACnC,MAAA,QAAA,CAAS,IAAA,CAAK,CAAA,0BAAA,EAA6B,OAAA,CAAQ,IAAI,CAAA,CAAE,CAAA;AAAA,IAC3D;AAAA,EACF;AAGA,EAAA,KAAA,MAAW,UAAU,OAAA,EAAS;AAC5B,IAAA,MAAM,KAAA,GAAQ,SAAA,CAAU,SAAA,EAAW,MAAA,EAAQ,OAAO,CAAA;AAClD,IAAA,IAAI,KAAA,EAAO;AACT,MAAA,OAAA,CAAQ,IAAA,CAAK,CAAA,cAAA,EAAiB,MAAA,CAAO,IAAI,CAAA,CAAE,CAAA;AAAA,IAC7C,CAAA,MAAA,IAAW,QAAQ,gBAAA,EAAkB;AACnC,MAAA,QAAA,CAAS,IAAA,CAAK,CAAA,yBAAA,EAA4B,MAAA,CAAO,IAAI,CAAA,CAAE,CAAA;AAAA,IACzD;AAAA,EACF;AAGA,EAAA,IAAI,OAAA,CAAQ,iBAAiB,KAAA,EAAO;AAClC,IAAA,UAAA,CAAW,UAAA,EAAW;AAAA,EACxB;AAEA,EAAA,OAAO;AAAA,IACL,QAAA,EAAU,QAAQ,MAAA,GAAS,CAAA;AAAA,IAC3B,OAAA;AAAA,IACA,IAAA,EAAM,WAAW,WAAA,EAAY;AAAA,IAC7B;AAAA,GACF;AACF;AAKA,SAAS,sBAAsB,MAAA,EAAmC;AAChE,EAAA,MAAM,IAAA,GAAO,OAAO,OAAA,EAAQ;AAC5B,EAAA,IAAI,CAAC,MAAM,OAAO,EAAA;AAGlB,EAAA,MAAM,QAAA,GAAW,KAAK,OAAA,EAAQ;AAE9B,EAAA,MAAM,QAAQ,QAAA,CAAS,KAAA,CAAM,CAAA,EAAG,EAAE,EAAE,IAAA,EAAK;AACzC,EAAA,OAAO,KAAA;AACT;AAKO,SAAS,iBACd,YAAA,EACA,OAAA,EACA,SAAA,EACA,OAAA,GAA0B,EAAC,EACZ;AACf,EAAA,MAAM,UAAU,aAAA,EAAc;AAC9B,EAAA,MAAM,YAAA,GAAe,cAAA,CAAe,OAAA,EAAS,YAAA,EAAc,aAAa,CAAA;AACxE,EAAA,MAAM,OAAA,GAAU,cAAA,CAAe,OAAA,EAAS,OAAA,EAAS,QAAQ,CAAA;AACzD,EAAA,MAAM,UAAoB,EAAC;AAC3B,EAAA,MAAM,WAAqB,EAAC;AAG5B,EAAA,MAAM,aAAA,GAAgB,SAAA,CAAU,YAAA,EAAc,SAAS,CAAA;AACvD,EAAA,MAAM,QAAA,GAAW,SAAA,CAAU,OAAA,EAAS,SAAS,CAAA;AAE7C,EAAA,IAAI,CAAC,aAAA,EAAe;AAClB,IAAA,OAAO;AAAA,MACL,QAAA,EAAU,KAAA;AAAA,MACV,SAAS,EAAC;AAAA,MACV,IAAA,EAAM,YAAA;AAAA,MACN,QAAA,EAAU,CAAC,CAAA,OAAA,EAAU,SAAS,CAAA,4BAAA,CAA8B;AAAA,KAC9D;AAAA,EACF;AAEA,EAAA,IAAI,CAAC,QAAA,EAAU;AACb,IAAA,OAAO;AAAA,MACL,QAAA,EAAU,KAAA;AAAA,MACV,SAAS,EAAC;AAAA,MACV,IAAA,EAAM,YAAA;AAAA,MACN,QAAA,EAAU,CAAC,CAAA,OAAA,EAAU,SAAS,CAAA,uBAAA,CAAyB;AAAA,KACzD;AAAA,EACF;AAGA,EAAA,MAAM,UAAA,GAAa,QAAQ,qBAAA,EAAsB;AACjD,EAAA,KAAA,MAAW,OAAO,UAAA,EAAY;AAC5B,IAAA,MAAM,UAAA,GAAa,IAAI,uBAAA,EAAwB;AAC/C,IAAA,KAAA,MAAW,QAAA,IAAY,GAAA,CAAI,eAAA,EAAgB,EAAG;AAC5C,MAAA,IAAI,eAAe,YAAA,EAAc,UAAA,EAAY,QAAA,CAAS,OAAA,EAAS,CAAA,EAAG;AAChE,QAAA,OAAA,CAAQ,KAAK,CAAA,cAAA,EAAiB,QAAA,CAAS,SAAS,CAAA,MAAA,EAAS,UAAU,CAAA,CAAE,CAAA;AAAA,MACvE;AAAA,IACF;AAAA,EACF;AAGA,EAAA,MAAM,aAAA,GAAgB,SAAS,aAAA,EAAc;AAC7C,EAAA,KAAA,MAAW,QAAQ,aAAA,EAAe;AAChC,IAAA,MAAM,QAAA,GAAW,KAAK,OAAA,EAAQ;AAC9B,IAAA,MAAM,YAAA,GAAe,YAAA,CAAa,aAAA,EAAe,QAAQ,CAAA;AAEzD,IAAA,IAAI,CAAC,YAAA,EAAc;AACjB,MAAA,aAAA,CAAc,WAAA,CAAY;AAAA,QACxB,IAAA,EAAM,QAAA;AAAA,QACN,UAAA,EAAY,KAAK,UAAA,EAAW;AAAA,QAC5B,IAAA,EAAM,IAAA,CAAK,OAAA,EAAQ,CAAE,OAAA;AAAQ,OAC9B,CAAA;AACD,MAAA,OAAA,CAAQ,IAAA,CAAK,CAAA,gBAAA,EAAmB,QAAQ,CAAA,CAAE,CAAA;AAAA,IAC5C,CAAA,MAAA,IAAW,CAAC,OAAA,CAAQ,gBAAA,EAAkB;AACpC,MAAA,YAAA,CAAa,MAAA,EAAO;AACpB,MAAA,aAAA,CAAc,WAAA,CAAY;AAAA,QACxB,IAAA,EAAM,QAAA;AAAA,QACN,UAAA,EAAY,KAAK,UAAA,EAAW;AAAA,QAC5B,IAAA,EAAM,IAAA,CAAK,OAAA,EAAQ,CAAE,OAAA;AAAQ,OAC9B,CAAA;AACD,MAAA,OAAA,CAAQ,IAAA,CAAK,CAAA,kBAAA,EAAqB,QAAQ,CAAA,CAAE,CAAA;AAAA,IAC9C,CAAA,MAAO;AACL,MAAA,QAAA,CAAS,IAAA,CAAK,CAAA,2BAAA,EAA8B,QAAQ,CAAA,CAAE,CAAA;AAAA,IACxD;AAAA,EACF;AAGA,EAAA,MAAM,UAAA,GAAa,SAAS,UAAA,EAAW;AACvC,EAAA,KAAA,MAAW,UAAU,UAAA,EAAY;AAC/B,IAAA,MAAM,UAAA,GAAa,OAAO,OAAA,EAAQ;AAClC,IAAA,MAAM,cAAA,GAAiB,UAAA,CAAW,aAAA,EAAe,UAAU,CAAA;AAE3D,IAAA,IAAI,CAAC,cAAA,EAAgB;AACnB,MAAA,aAAA,CAAc,SAAA,CAAU;AAAA,QACtB,IAAA,EAAM,UAAA;AAAA,QACN,OAAA,EAAS,OAAO,OAAA,EAAQ;AAAA,QACxB,UAAA,EAAY,MAAA,CAAO,aAAA,EAAc,CAAE,IAAI,CAAA,CAAA,MAAM;AAAA,UAC3C,IAAA,EAAM,EAAE,OAAA,EAAQ;AAAA,UAChB,IAAA,EAAM,CAAA,CAAE,OAAA,EAAQ,CAAE,OAAA,EAAQ;AAAA,UAC1B,gBAAA,EAAkB,EAAE,gBAAA,EAAiB;AAAA,UACrC,WAAA,EAAa,CAAA,CAAE,cAAA,EAAe,EAAG,OAAA;AAAQ,SAC3C,CAAE,CAAA;AAAA,QACF,UAAA,EAAY,MAAA,CAAO,aAAA,EAAc,CAAE,OAAA,EAAQ;AAAA,QAC3C,UAAA,EAAY,sBAAsB,MAAM;AAAA,OACzC,CAAA;AACD,MAAA,OAAA,CAAQ,IAAA,CAAK,CAAA,cAAA,EAAiB,UAAU,CAAA,CAAE,CAAA;AAAA,IAC5C,CAAA,MAAA,IAAW,CAAC,OAAA,CAAQ,gBAAA,EAAkB;AACpC,MAAA,cAAA,CAAe,MAAA,EAAO;AACtB,MAAA,aAAA,CAAc,SAAA,CAAU;AAAA,QACtB,IAAA,EAAM,UAAA;AAAA,QACN,OAAA,EAAS,OAAO,OAAA,EAAQ;AAAA,QACxB,UAAA,EAAY,MAAA,CAAO,aAAA,EAAc,CAAE,IAAI,CAAA,CAAA,MAAM;AAAA,UAC3C,IAAA,EAAM,EAAE,OAAA,EAAQ;AAAA,UAChB,IAAA,EAAM,CAAA,CAAE,OAAA,EAAQ,CAAE,OAAA,EAAQ;AAAA,UAC1B,gBAAA,EAAkB,EAAE,gBAAA,EAAiB;AAAA,UACrC,WAAA,EAAa,CAAA,CAAE,cAAA,EAAe,EAAG,OAAA;AAAQ,SAC3C,CAAE,CAAA;AAAA,QACF,UAAA,EAAY,MAAA,CAAO,aAAA,EAAc,CAAE,OAAA,EAAQ;AAAA,QAC3C,UAAA,EAAY,sBAAsB,MAAM;AAAA,OACzC,CAAA;AACD,MAAA,OAAA,CAAQ,IAAA,CAAK,CAAA,gBAAA,EAAmB,UAAU,CAAA,CAAE,CAAA;AAAA,IAC9C,CAAA,MAAO;AACL,MAAA,QAAA,CAAS,IAAA,CAAK,CAAA,yBAAA,EAA4B,UAAU,CAAA,CAAE,CAAA;AAAA,IACxD;AAAA,EACF;AAGA,EAAA,IAAI,OAAA,CAAQ,iBAAiB,KAAA,EAAO;AAClC,IAAA,YAAA,CAAa,UAAA,EAAW;AAAA,EAC1B;AAEA,EAAA,OAAO;AAAA,IACL,QAAA,EAAU,QAAQ,MAAA,GAAS,CAAA;AAAA,IAC3B,OAAA;AAAA,IACA,IAAA,EAAM,aAAa,WAAA,EAAY;AAAA,IAC/B;AAAA,GACF;AACF;AAKO,SAAS,qBAAA,CAAsB,MAAc,SAAA,EAI3C;AACP,EAAA,MAAM,UAAU,aAAA,EAAc;AAC9B,EAAA,MAAM,UAAA,GAAa,cAAA,CAAe,OAAA,EAAS,IAAI,CAAA;AAC/C,EAAA,MAAM,SAAA,GAAY,SAAA,CAAU,UAAA,EAAY,SAAS,CAAA;AAEjD,EAAA,IAAI,CAAC,SAAA,EAAW;AACd,IAAA,OAAO,IAAA;AAAA,EACT;AAEA,EAAA,OAAO;AAAA,IACL,UAAA,EAAY,UAAU,aAAA,EAAc,CAAE,IAAI,CAAA,CAAA,KAAK,CAAA,CAAE,SAAS,CAAA;AAAA,IAC1D,OAAA,EAAS,UAAU,UAAA,EAAW,CAAE,IAAI,CAAA,CAAA,KAAK,CAAA,CAAE,SAAS,CAAA;AAAA,IACpD,OAAA,EAAS,UAAA,CAAW,qBAAA,EAAsB,CACvC,QAAQ,CAAA,GAAA,KAAO,GAAA,CAAI,eAAA,EAAgB,CAAE,GAAA,CAAI,CAAA,EAAA,KAAM,EAAA,CAAG,OAAA,EAAS,CAAC;AAAA,GACjE;AACF;AAKO,SAAS,eAAe,IAAA,EAG7B;AACA,EAAA,MAAM,UAAU,aAAA,EAAc;AAE9B,EAAA,IAAI;AACF,IAAA,MAAM,UAAA,GAAa,cAAA,CAAe,OAAA,EAAS,IAAI,CAAA;AAC/C,IAAA,MAAM,WAAA,GAAc,WAAW,qBAAA,EAAsB;AAErD,IAAA,MAAM,MAAA,GAAS,WAAA,CACZ,MAAA,CAAO,CAAA,CAAA,KAAK,EAAE,WAAA,EAAY,KAAM,CAAC,CAAA,CACjC,IAAI,CAAA,CAAA,KAAK,CAAA,CAAE,cAAA,EAAe,CAAE,UAAU,CAAA;AAEzC,IAAA,OAAO;AAAA,MACL,KAAA,EAAO,OAAO,MAAA,KAAW,CAAA;AAAA,MACzB;AAAA,KACF;AAAA,EACF,SAAS,KAAA,EAAO;AACd,IAAA,OAAO;AAAA,MACL,KAAA,EAAO,KAAA;AAAA,MACP,MAAA,EAAQ,CAAE,KAAA,CAAgB,OAAO;AAAA,KACnC;AAAA,EACF;AACF;ACtcO,SAAS,aAAa,SAAA,EAA0C;AACrE,EAAA,IAAI,CAACH,UAAAA,CAAW,SAAS,CAAA,EAAG;AAC1B,IAAA,OAAO,IAAA;AAAA,EACT;AAEA,EAAA,MAAM,OAAA,GAAUF,YAAAA,CAAa,SAAA,EAAW,OAAO,CAAA;AAC/C,EAAA,MAAM,OAAA,GAAU,cAAA,CAAe,OAAkB,CAAA;AAEjD,EAAA,OAAO;AAAA,IACL,YAAA,EAAc,SAAA;AAAA,IACd,OAAA;AAAA,IACA,WAAA,sBAAiB,IAAA;AAAK,GACxB;AACF;AAKO,SAAS,cAAA,CAAe,SAAiB,UAAA,EAAsC;AACpF,EAAA,MAAM,UAA2B,EAAC;AAClC,EAAA,MAAM,UAAU,IAAIM,OAAAA,CAAQ,EAAE,qBAAA,EAAuB,MAAM,CAAA;AAC3D,EAAA,MAAM,UAAA,GAAa,OAAA,CAAQ,gBAAA,CAAiB,UAAA,EAAY,OAAO,CAAA;AAG/D,EAAA,MAAM,kBAAA,GAAqB,WAAW,qBAAA,EAAsB;AAE5D,EAAA,KAAA,MAAW,cAAc,kBAAA,EAAoB;AAC3C,IAAA,MAAM,eAAA,GAAkB,WAAW,uBAAA,EAAwB;AAC3D,IAAA,IAAI,CAAC,eAAA,EAAiB;AAEtB,IAAA,MAAM,YAAA,GAAe,WAAW,eAAA,EAAgB;AAEhD,IAAA,KAAA,MAAW,eAAe,YAAA,EAAc;AACtC,MAAA,MAAM,UAAA,GAAa,YAAY,OAAA,EAAQ;AACvC,MAAA,MAAM,SAAA,GAAY,YAAY,YAAA,EAAa;AAC3C,MAAA,MAAM,KAAA,GAAQ,SAAA,GAAY,SAAA,CAAU,OAAA,EAAQ,GAAI,UAAA;AAGhD,MAAA,IAAI,UAAA,GAA6C,OAAA;AACjD,MAAA,IAAI,WAAW,UAAA,CAAW,QAAQ,KAAK,UAAA,CAAW,QAAA,CAAS,SAAS,CAAA,EAAG;AACrE,QAAA,UAAA,GAAa,UAAA;AAAA,MACf,CAAA,MAAA,IAAW,UAAA,KAAe,UAAA,CAAW,WAAA,EAAY,EAAG;AAClD,QAAA,UAAA,GAAa,OAAA;AAAA,MACf;AAEA,MAAA,OAAA,CAAQ,IAAA,CAAK;AAAA,QACX,UAAA,EAAY,KAAA;AAAA,QACZ,SAAA,EAAW,UAAA;AAAA,QACX,QAAA,EAAU,eAAA;AAAA,QACV,KAAA,EAAO,aAAa,eAAe,CAAA;AAAA,QACnC;AAAA,OACD,CAAA;AAAA,IACH;AAAA,EACF;AAGA,EAAA,MAAM,WAAA,GAAc,OAAA,CAAQ,KAAA,CAAM,wCAAwC,CAAA;AAC1E,EAAA,IAAI,WAAA,EAAa;AACf,IAAA,KAAA,MAAW,SAAS,WAAA,EAAa;AAC/B,MAAA,MAAM,SAAA,GAAY,KAAA,CAAM,KAAA,CAAM,kBAAkB,CAAA;AAChD,MAAA,IAAI,SAAA,EAAW;AACb,QAAA,MAAM,UAAA,GAAa,UAAU,CAAC,CAAA;AAC9B,QAAA,OAAA,CAAQ,IAAA,CAAK;AAAA,UACX,UAAA,EAAY,kBAAkB,UAAU,CAAA;AAAA,UACxC,SAAA,EAAW,GAAA;AAAA,UACX,QAAA,EAAU,UAAA;AAAA,UACV,KAAA,EAAO,aAAa,UAAU,CAAA;AAAA,UAC9B,UAAA,EAAY;AAAA,SACb,CAAA;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAEA,EAAA,OAAO,OAAA;AACT;AAKA,SAAS,kBAAkB,QAAA,EAA0B;AACnD,EAAA,MAAM,OAAO,QAAA,CAAS,QAAA,EAAU,KAAK,CAAA,CAAE,OAAA,CAAQ,SAAS,EAAE,CAAA;AAC1D,EAAA,OAAOC,cAAa,IAAI,CAAA;AAC1B;AAKA,SAAS,aAAa,QAAA,EAA0B;AAE9C,EAAA,MAAM,GAAA,GAAMC,QAAQ,QAAQ,CAAA;AAC5B,EAAA,IAAI,GAAA,KAAQ,GAAA,IAAO,GAAA,KAAQ,IAAA,EAAM;AAC/B,IAAA,OAAO,SAAS,QAAA,EAAU,KAAK,CAAA,CAAE,OAAA,CAAQ,SAAS,EAAE,CAAA;AAAA,EACtD;AACA,EAAA,OAAO,SAAS,GAAG,CAAA;AACrB;AAKA,SAASD,cAAa,GAAA,EAAqB;AACzC,EAAA,OAAO,GAAA,CACJ,MAAM,SAAS,CAAA,CACf,IAAI,CAAA,IAAA,KAAQ,IAAA,CAAK,OAAO,CAAC,CAAA,CAAE,aAAY,GAAI,IAAA,CAAK,MAAM,CAAC,CAAA,CAAE,aAAa,CAAA,CACtE,KAAK,EAAE,CAAA;AACZ;AAKO,SAAS,oBAAA,CACd,OAAA,EACA,OAAA,GAA2B,EAAC,EACpB;AACR,EAAA,MAAM,KAAA,GAAkB;AAAA,IACtB,KAAA;AAAA,IACA,2CAAA;AAAA,IACA,qCAAA;AAAA,IACA;AAAA,GACF;AAGA,EAAA,MAAM,MAAA,uBAAa,GAAA,EAA6B;AAChD,EAAA,KAAA,MAAW,SAAS,OAAA,EAAS;AAC3B,IAAA,MAAM,WAAW,MAAA,CAAO,GAAA,CAAI,KAAA,CAAM,QAAQ,KAAK,EAAC;AAChD,IAAA,QAAA,CAAS,KAAK,KAAK,CAAA;AACnB,IAAA,MAAA,CAAO,GAAA,CAAI,KAAA,CAAM,QAAA,EAAU,QAAQ,CAAA;AAAA,EACrC;AAGA,EAAA,IAAI,SAAA,GAAY,KAAA,CAAM,IAAA,CAAK,MAAA,CAAO,MAAM,CAAA;AACxC,EAAA,IAAI,QAAQ,WAAA,EAAa;AACvB,IAAA,SAAA,GAAY,UAAU,IAAA,EAAK;AAAA,EAC7B;AAGA,EAAA,KAAA,MAAW,YAAY,SAAA,EAAW;AAChC,IAAA,MAAM,WAAA,GAAc,MAAA,CAAO,GAAA,CAAI,QAAQ,CAAA;AAGvC,IAAA,IAAI,YAAY,MAAA,KAAW,CAAA,IAAK,YAAY,CAAC,CAAA,CAAG,cAAc,GAAA,EAAK;AACjE,MAAA,KAAA,CAAM,IAAA,CAAK,CAAA,eAAA,EAAkB,QAAQ,CAAA,EAAA,CAAI,CAAA;AAAA,IAC3C,CAAA,MAAO;AAEL,MAAA,MAAME,SAAA,GAAU,WAAA,CAAY,GAAA,CAAI,CAAA,CAAA,KAAK;AACnC,QAAA,IAAI,CAAA,CAAE,UAAA,KAAe,CAAA,CAAE,SAAA,EAAW;AAChC,UAAA,OAAO,CAAA,EAAG,CAAA,CAAE,SAAS,CAAA,IAAA,EAAO,EAAE,UAAU,CAAA,CAAA;AAAA,QAC1C;AACA,QAAA,OAAO,CAAA,CAAE,SAAA;AAAA,MACX,CAAC,CAAA;AAED,MAAA,IAAI,QAAQ,WAAA,EAAa;AACvB,QAAAA,SAAA,CAAQ,IAAA,EAAK;AAAA,MACf;AAEA,MAAA,KAAA,CAAM,IAAA,CAAK,YAAYA,SAAA,CAAQ,IAAA,CAAK,IAAI,CAAC,CAAA,SAAA,EAAY,QAAQ,CAAA,EAAA,CAAI,CAAA;AAAA,IACnE;AAAA,EACF;AAEA,EAAA,OAAO,KAAA,CAAM,IAAA,CAAK,IAAI,CAAA,GAAI,IAAA;AAC5B;AAKO,SAAS,aAAA,CACd,QAAA,EACA,MAAA,EACA,QAAA,EACe;AACf,EAAA,MAAM,KAAA,GAAuB;AAAA,IAC3B,YAAY,MAAA,CAAO,UAAA;AAAA,IACnB,WAAW,MAAA,CAAO,SAAA;AAAA,IAClB,QAAA;AAAA,IACA,OAAO,MAAA,CAAO,KAAA;AAAA,IACd,UAAA,EAAY;AAAA,GACd;AAGA,EAAA,MAAM,aAAA,GAAgB,SAAS,OAAA,CAAQ,SAAA;AAAA,IACrC,OAAK,CAAA,CAAE,QAAA,KAAa,QAAA,IAAY,CAAA,CAAE,eAAe,MAAA,CAAO;AAAA,GAC1D;AAEA,EAAA,IAAI,iBAAiB,CAAA,EAAG;AACtB,IAAA,QAAA,CAAS,OAAA,CAAQ,aAAa,CAAA,GAAI,KAAA;AAAA,EACpC,CAAA,MAAO;AACL,IAAA,QAAA,CAAS,OAAA,CAAQ,KAAK,KAAK,CAAA;AAAA,EAC7B;AAEA,EAAA,QAAA,CAAS,WAAA,uBAAkB,IAAA,EAAK;AAChC,EAAA,OAAO,KAAA;AACT;AAKO,SAAS,kBAAA,CACd,UACA,gBAAA,EACS;AACT,EAAA,MAAM,aAAA,GAAgB,SAAS,OAAA,CAAQ,MAAA;AAEvC,EAAA,QAAA,CAAS,OAAA,GAAU,SAAS,OAAA,CAAQ,MAAA;AAAA,IAClC,CAAA,CAAA,KAAK,CAAA,CAAE,UAAA,KAAe,gBAAA,IAAoB,EAAE,QAAA,KAAa;AAAA,GAC3D;AAEA,EAAA,MAAM,OAAA,GAAU,QAAA,CAAS,OAAA,CAAQ,MAAA,GAAS,aAAA;AAC1C,EAAA,IAAI,OAAA,EAAS;AACX,IAAA,QAAA,CAAS,WAAA,uBAAkB,IAAA,EAAK;AAAA,EAClC;AAEA,EAAA,OAAO,OAAA;AACT;AAKO,SAAS,eAAA,CACd,SAAA,EACA,UAAA,EACA,OAAA,GAA2B,EAAC,EACN;AACtB,EAAA,IAAI,QAAA,GAAW,aAAa,SAAS,CAAA;AACrC,EAAA,MAAM,QAAkB,EAAC;AACzB,EAAA,MAAM,UAAoB,EAAC;AAE3B,EAAA,IAAI,CAAC,QAAA,EAAU;AACb,IAAA,IAAI,CAAC,QAAQ,eAAA,EAAiB;AAC5B,MAAA,OAAO;AAAA,QACL,QAAA,EAAU,KAAA;AAAA,QACV,OAAO,EAAC;AAAA,QACR,SAAS,EAAC;AAAA,QACV,OAAA,EAAS;AAAA,OACX;AAAA,IACF;AAEA,IAAA,QAAA,GAAW;AAAA,MACT,YAAA,EAAc,SAAA;AAAA,MACd,SAAS,EAAC;AAAA,MACV,WAAA,sBAAiB,IAAA;AAAK,KACxB;AAAA,EACF;AAGA,EAAA,MAAM,aAAA,GAAgB,IAAI,GAAA,CAAI,QAAA,CAAS,QAAQ,GAAA,CAAI,CAAA,CAAA,KAAK,CAAA,CAAE,UAAU,CAAC,CAAA;AAGrE,EAAA,KAAA,MAAW,EAAE,MAAA,EAAQ,QAAA,EAAS,IAAK,UAAA,EAAY;AAC7C,IAAA,MAAM,eAAe,QAAA,CAAS,UAAA,CAAW,GAAG,CAAA,GACxC,WACA,CAAA,EAAA,EAAK,QAAA,CAASD,OAAAA,CAAQ,SAAS,GAAG,QAAQ,CAAA,CAAE,OAAA,CAAQ,KAAA,EAAO,GAAG,CAAC,CAAA,CAAA;AAGnE,IAAA,MAAM,UAAA,GAAa,YAAA,CAAa,OAAA,CAAQ,OAAA,EAAS,KAAK,CAAA;AAEtD,IAAA,aAAA,CAAc,QAAA,EAAU,QAAQ,UAAU,CAAA;AAE1C,IAAA,IAAI,CAAC,aAAA,CAAc,GAAA,CAAI,MAAA,CAAO,UAAU,CAAA,EAAG;AACzC,MAAA,KAAA,CAAM,IAAA,CAAK,OAAO,UAAU,CAAA;AAAA,IAC9B;AAAA,EACF;AAGA,EAAA,MAAM,OAAA,GAAU,oBAAA,CAAqB,QAAA,CAAS,OAAA,EAAS,OAAO,CAAA;AAE9D,EAAA,OAAO;AAAA,IACL,QAAA,EAAU,KAAA,CAAM,MAAA,GAAS,CAAA,IAAK,QAAQ,MAAA,GAAS,CAAA;AAAA,IAC/C,KAAA;AAAA,IACA,OAAA;AAAA,IACA;AAAA,GACF;AACF;AAKO,SAAS,oBAAA,CACd,QAAA,EACA,QAAA,GAAW,WAAA,EACM;AAIjB,EAAA,OAAO,EAAC;AACV;AAKO,SAAS,eAAe,SAAA,EAAmC;AAChE,EAAA,OAAO;AAAA,IACL,YAAA,EAAc,SAAA;AAAA,IACd,SAAS,EAAC;AAAA,IACV,WAAA,sBAAiB,IAAA;AAAK,GACxB;AACF;AAKO,SAAS,YAAA,CACd,QAAA,EACA,OAAA,GAA2B,EAAC,EACtB;AACN,EAAA,MAAM,OAAA,GAAU,oBAAA,CAAqB,QAAA,CAAS,OAAA,EAAS,OAAO,CAAA;AAC9D,EAAAE,aAAAA,CAAc,QAAA,CAAS,YAAA,EAAc,OAAA,EAAS,OAAO,CAAA;AACvD;AAKO,SAAS,SAAA,CACd,UACA,UAAA,EAC2B;AAC3B,EAAA,OAAO,SAAS,OAAA,CAAQ,IAAA,CAAK,CAAA,CAAA,KAAK,CAAA,CAAE,eAAe,UAAU,CAAA;AAC/D;AAKO,SAAS,kBAAA,CACd,UACA,KAAA,EACiB;AACjB,EAAA,OAAO,SAAS,OAAA,CAAQ,MAAA,CAAO,CAAA,CAAA,KAAK,CAAA,CAAE,UAAU,KAAK,CAAA;AACvD;AAKO,SAAS,SAAA,CAAU,UAA0B,UAAA,EAA6B;AAC/E,EAAA,OAAO,SAAS,OAAA,CAAQ,IAAA,CAAK,CAAA,CAAA,KAAK,CAAA,CAAE,eAAe,UAAU,CAAA;AAC/D;AAKO,SAAS,eAAe,QAAA,EAAoC;AACjE,EAAA,OAAO,QAAA,CAAS,OAAA,CAAQ,GAAA,CAAI,CAAA,CAAA,KAAK,EAAE,UAAU,CAAA;AAC/C;AAKO,SAAS,iBAAiB,QAAA,EAI/B;AACA,EAAA,MAAM,UAAkC,EAAC;AACzC,EAAA,MAAM,SAAiC,EAAC;AAExC,EAAA,KAAA,MAAW,KAAA,IAAS,SAAS,OAAA,EAAS;AACpC,IAAA,OAAA,CAAQ,MAAM,KAAK,CAAA,GAAA,CAAK,QAAQ,KAAA,CAAM,KAAK,KAAK,CAAA,IAAK,CAAA;AACrD,IAAA,MAAA,CAAO,MAAM,UAAU,CAAA,GAAA,CAAK,OAAO,KAAA,CAAM,UAAU,KAAK,CAAA,IAAK,CAAA;AAAA,EAC/D;AAEA,EAAA,OAAO;AAAA,IACL,YAAA,EAAc,SAAS,OAAA,CAAQ,MAAA;AAAA,IAC/B,OAAA;AAAA,IACA;AAAA,GACF;AACF","file":"index.js","sourcesContent":["/**\n * Selector Priority - Playwright best practices for selector selection\n * @see research/2026-01-02_autogen-refined-plan.md Section 11\n *\n * Priority order (per Playwright docs):\n * 1. role - ARIA roles (most stable, semantic)\n * 2. label - Form labels (accessible)\n * 3. placeholder - Input placeholders\n * 4. text - Visible text content\n * 5. testid - data-testid attributes\n * 6. css - CSS selectors (last resort)\n */\nimport type { LocatorSpec, LocatorStrategy } from '../ir/types.js';\nimport type { AutogenConfig } from '../config/schema.js';\n\n/**\n * Default selector priority\n */\nexport const DEFAULT_SELECTOR_PRIORITY: LocatorStrategy[] = [\n  'role',\n  'label',\n  'placeholder',\n  'text',\n  'testid',\n  'css',\n];\n\n/**\n * Map from element type to preferred selector strategies\n */\nexport const ELEMENT_TYPE_STRATEGIES: Record<string, LocatorStrategy[]> = {\n  button: ['role', 'text', 'testid'],\n  link: ['role', 'text', 'testid'],\n  textbox: ['role', 'label', 'placeholder', 'testid'],\n  checkbox: ['role', 'label', 'testid'],\n  radio: ['role', 'label', 'testid'],\n  combobox: ['role', 'label', 'testid'],\n  heading: ['role', 'text', 'testid'],\n  listitem: ['role', 'text', 'testid'],\n  menuitem: ['role', 'text', 'testid'],\n  tab: ['role', 'text', 'testid'],\n  dialog: ['role', 'testid'],\n  alert: ['role', 'testid'],\n  generic: ['text', 'testid', 'css'],\n};\n\n/**\n * ARIA roles that can have accessible names\n */\nexport const NAMEABLE_ROLES = [\n  'button',\n  'link',\n  'textbox',\n  'checkbox',\n  'radio',\n  'combobox',\n  'heading',\n  'tab',\n  'menuitem',\n  'listitem',\n  'option',\n  'cell',\n  'row',\n  'columnheader',\n  'rowheader',\n];\n\n/**\n * Get selector priority from config or use defaults\n */\nexport function getSelectorPriority(config?: AutogenConfig): LocatorStrategy[] {\n  if (config?.selectorPolicy?.priority) {\n    // Map config selector strategies to LocatorStrategy\n    return config.selectorPolicy.priority.map((s) => {\n      // Handle strategy name mapping if needed\n      return s as LocatorStrategy;\n    });\n  }\n  return DEFAULT_SELECTOR_PRIORITY;\n}\n\n/**\n * Check if a selector strategy is forbidden by config\n */\nexport function isForbiddenSelector(\n  locator: LocatorSpec,\n  config?: AutogenConfig\n): boolean {\n  const forbiddenPatterns = config?.selectorPolicy?.forbiddenPatterns ?? [];\n\n  for (const pattern of forbiddenPatterns) {\n    const regex = new RegExp(pattern);\n    if (regex.test(locator.value)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Score a locator based on priority (lower is better)\n */\nexport function scoreLocator(\n  locator: LocatorSpec,\n  priority: LocatorStrategy[] = DEFAULT_SELECTOR_PRIORITY\n): number {\n  const index = priority.indexOf(locator.strategy);\n  return index >= 0 ? index : priority.length;\n}\n\n/**\n * Compare two locators and return the better one\n */\nexport function compareLocators(\n  a: LocatorSpec,\n  b: LocatorSpec,\n  priority: LocatorStrategy[] = DEFAULT_SELECTOR_PRIORITY\n): LocatorSpec {\n  const scoreA = scoreLocator(a, priority);\n  const scoreB = scoreLocator(b, priority);\n  return scoreA <= scoreB ? a : b;\n}\n\n/**\n * Select the best locator from alternatives\n */\nexport function selectBestLocator(\n  alternatives: LocatorSpec[],\n  config?: AutogenConfig\n): LocatorSpec | null {\n  if (alternatives.length === 0) {\n    return null;\n  }\n\n  const priority = getSelectorPriority(config);\n\n  // Filter out forbidden selectors\n  const allowed = alternatives.filter((loc) => !isForbiddenSelector(loc, config));\n\n  if (allowed.length === 0) {\n    // All forbidden, return first original\n    return alternatives[0] ?? null;\n  }\n\n  // Sort by priority\n  allowed.sort((a, b) => scoreLocator(a, priority) - scoreLocator(b, priority));\n\n  return allowed[0] ?? null;\n}\n\n/**\n * Check if a locator is a role locator\n */\nexport function isRoleLocator(locator: LocatorSpec): boolean {\n  return locator.strategy === 'role';\n}\n\n/**\n * Check if a locator uses semantic selectors (role, label, text)\n */\nexport function isSemanticLocator(locator: LocatorSpec): boolean {\n  return ['role', 'label', 'text', 'placeholder'].includes(locator.strategy);\n}\n\n/**\n * Check if a locator is a test ID locator\n */\nexport function isTestIdLocator(locator: LocatorSpec): boolean {\n  return locator.strategy === 'testid';\n}\n\n/**\n * Check if a locator is a CSS locator (last resort)\n */\nexport function isCssLocator(locator: LocatorSpec): boolean {\n  return locator.strategy === 'css';\n}\n\n/**\n * Get recommended strategies for an element type\n */\nexport function getRecommendedStrategies(elementType: string): LocatorStrategy[] {\n  return ELEMENT_TYPE_STRATEGIES[elementType] ?? ELEMENT_TYPE_STRATEGIES.generic!;\n}\n\n/**\n * Validate a locator against best practices\n */\nexport function validateLocator(\n  locator: LocatorSpec,\n  config?: AutogenConfig\n): { valid: boolean; warnings: string[] } {\n  const warnings: string[] = [];\n\n  // Check if forbidden\n  if (isForbiddenSelector(locator, config)) {\n    warnings.push(`Selector matches forbidden pattern: ${locator.value}`);\n  }\n\n  // Warn about CSS selectors\n  if (isCssLocator(locator)) {\n    warnings.push(\n      `CSS selector \"${locator.value}\" is fragile. Consider using role, label, or testid.`\n    );\n  }\n\n  // Warn about XPath-like patterns in CSS\n  if (locator.value.includes('//') || locator.value.includes('..')) {\n    warnings.push(`Selector \"${locator.value}\" appears to use XPath syntax in CSS.`);\n  }\n\n  // Warn about nth-child selectors\n  if (locator.value.includes('nth-child') || locator.value.includes('nth-of-type')) {\n    warnings.push(`Selector \"${locator.value}\" uses nth-child which is position-dependent.`);\n  }\n\n  // Warn about ID selectors that might be dynamic\n  if (locator.strategy === 'css' && /^#[a-z]+-\\d+$/i.test(locator.value)) {\n    warnings.push(`Selector \"${locator.value}\" appears to have a dynamic ID.`);\n  }\n\n  return {\n    valid: warnings.length === 0,\n    warnings,\n  };\n}\n\n/**\n * Generate Playwright locator code from LocatorSpec\n */\nexport function toPlaywrightLocator(locator: LocatorSpec): string {\n  switch (locator.strategy) {\n    case 'role': {\n      const opts: string[] = [];\n      if (locator.options?.name) {\n        opts.push(`name: '${escapeString(locator.options.name)}'`);\n      }\n      if (locator.options?.exact) {\n        opts.push('exact: true');\n      }\n      if (locator.options?.level) {\n        opts.push(`level: ${locator.options.level}`);\n      }\n      const optsStr = opts.length > 0 ? `, { ${opts.join(', ')} }` : '';\n      return `getByRole('${locator.value}'${optsStr})`;\n    }\n    case 'label': {\n      const exact = locator.options?.exact ? ', { exact: true }' : '';\n      return `getByLabel('${escapeString(locator.value)}'${exact})`;\n    }\n    case 'placeholder': {\n      const exact = locator.options?.exact ? ', { exact: true }' : '';\n      return `getByPlaceholder('${escapeString(locator.value)}'${exact})`;\n    }\n    case 'text': {\n      const exact = locator.options?.exact ? ', { exact: true }' : '';\n      return `getByText('${escapeString(locator.value)}'${exact})`;\n    }\n    case 'testid':\n      return `getByTestId('${escapeString(locator.value)}')`;\n    case 'css':\n      return `locator('${escapeString(locator.value)}')`;\n    default:\n      return `locator('${escapeString(locator.value)}')`;\n  }\n}\n\n/**\n * Escape string for use in generated code\n */\nfunction escapeString(str: string): string {\n  return str.replace(/'/g, \"\\\\'\").replace(/\\n/g, '\\\\n');\n}\n","/**\n * Managed Blocks - Alternative to AST editing for simpler code regeneration\n * @see research/2026-01-03_autogen-remaining-features-plan.md Feature 4\n */\n\n/**\n * Block markers for generated code boundaries\n */\nexport const BLOCK_START = '// ARTK:BEGIN GENERATED';\nexport const BLOCK_END = '// ARTK:END GENERATED';\nexport const BLOCK_ID_PATTERN = /ARTK:BEGIN GENERATED(?:\\s+id=([a-zA-Z0-9_-]+))?/;\n\n/**\n * Represents a managed block of generated code\n */\nexport interface ManagedBlock {\n  /** Optional identifier for the block */\n  id?: string;\n  /** Starting line number (0-indexed) */\n  startLine: number;\n  /** Ending line number (0-indexed) */\n  endLine: number;\n  /** Content between markers (excluding markers themselves) */\n  content: string;\n}\n\n/**\n * Information about a malformed block\n */\nexport interface BlockWarning {\n  /** Type of warning */\n  type: 'nested' | 'unclosed';\n  /** Line number where the issue occurred */\n  line: number;\n  /** Human-readable message */\n  message: string;\n}\n\n/**\n * Result of extracting managed blocks from code\n */\nexport interface BlockExtractionResult {\n  /** All managed blocks found */\n  blocks: ManagedBlock[];\n  /** Code outside of managed blocks */\n  preservedCode: string[];\n  /** Whether any blocks were found */\n  hasBlocks: boolean;\n  /** Warnings about malformed blocks */\n  warnings: BlockWarning[];\n}\n\n/**\n * Options for injecting managed blocks\n */\nexport interface InjectBlocksOptions {\n  /** Existing file content */\n  existingCode: string;\n  /** New blocks to inject */\n  newBlocks: Array<{\n    id?: string;\n    content: string;\n  }>;\n  /** Whether to preserve block order (default: true) */\n  preserveOrder?: boolean;\n}\n\n/**\n * Extract managed blocks from existing code\n *\n * @param code - Source code to analyze\n * @returns Extraction result with blocks and preserved code\n *\n * @example\n * ```typescript\n * const result = extractManagedBlocks(`\n *   // User code\n *   // ARTK:BEGIN GENERATED id=test-1\n *   test('example', () => {});\n *   // ARTK:END GENERATED\n *   // More user code\n * `);\n * // result.blocks.length === 1\n * // result.blocks[0].id === 'test-1'\n * ```\n */\nexport function extractManagedBlocks(code: string): BlockExtractionResult {\n  const lines = code.split('\\n');\n  const blocks: ManagedBlock[] = [];\n  const preservedCode: string[] = [];\n  const warnings: BlockWarning[] = [];\n\n  let inBlock = false;\n  let currentBlock: Partial<ManagedBlock> | null = null;\n  let blockContent: string[] = [];\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i]!;\n\n    // Check for block start\n    if (line.includes(BLOCK_START)) {\n      if (inBlock) {\n        // Nested block detected - close the previous block and record warning\n        warnings.push({\n          type: 'nested',\n          line: i + 1,\n          message: `Nested managed block detected at line ${i + 1}. Previous block starting at line ${(currentBlock?.startLine ?? 0) + 1} will be closed.`,\n        });\n        // Save the incomplete previous block\n        if (currentBlock) {\n          blocks.push({\n            ...currentBlock,\n            endLine: i - 1,\n            content: blockContent.join('\\n'),\n          } as ManagedBlock);\n        }\n      }\n      inBlock = true;\n      const match = line.match(BLOCK_ID_PATTERN);\n      currentBlock = {\n        id: match?.[1],\n        startLine: i,\n      };\n      blockContent = [];\n      continue;\n    }\n\n    // Check for block end\n    if (line.includes(BLOCK_END) && inBlock) {\n      inBlock = false;\n      if (currentBlock) {\n        blocks.push({\n          ...currentBlock,\n          endLine: i,\n          content: blockContent.join('\\n'),\n        } as ManagedBlock);\n      }\n      currentBlock = null;\n      blockContent = [];\n      continue;\n    }\n\n    // Collect content\n    if (inBlock) {\n      blockContent.push(line);\n    } else {\n      preservedCode.push(line);\n    }\n  }\n\n  // Handle unclosed block\n  if (inBlock && currentBlock) {\n    warnings.push({\n      type: 'unclosed',\n      line: (currentBlock.startLine ?? 0) + 1,\n      message: `Unclosed managed block starting at line ${(currentBlock.startLine ?? 0) + 1} - block will be ignored`,\n    });\n  }\n\n  return {\n    blocks,\n    preservedCode,\n    hasBlocks: blocks.length > 0,\n    warnings,\n  };\n}\n\n/**\n * Wrap content in managed block markers\n *\n * @param content - Code to wrap\n * @param id - Optional block identifier\n * @returns Wrapped content with markers\n *\n * @example\n * ```typescript\n * const wrapped = wrapInBlock(\"test('foo', () => {});\", 'test-foo');\n * // Returns:\n * // // ARTK:BEGIN GENERATED id=test-foo\n * // test('foo', () => {});\n * // // ARTK:END GENERATED\n * ```\n */\nexport function wrapInBlock(content: string, id?: string): string {\n  const startMarker = id\n    ? `${BLOCK_START} id=${id}`\n    : BLOCK_START;\n\n  return `${startMarker}\\n${content}\\n${BLOCK_END}`;\n}\n\n/**\n * Inject managed blocks into code, preserving user code outside blocks\n *\n * Behavior:\n * - If existing code has no blocks: append new blocks at end\n * - If existing code has blocks: replace matching blocks by ID\n * - If block ID not found: append new block at end\n * - All code outside blocks is preserved\n *\n * @param options - Injection options\n * @returns Updated code with injected blocks\n *\n * @example\n * ```typescript\n * const result = injectManagedBlocks({\n *   existingCode: `\n *     // User helper\n *     // ARTK:BEGIN GENERATED id=old-test\n *     test('old', () => {});\n *     // ARTK:END GENERATED\n *   `,\n *   newBlocks: [\n *     { id: 'old-test', content: \"test('new', () => {});\" }\n *   ]\n * });\n * // result contains replaced block with new content\n * ```\n */\nexport function injectManagedBlocks(options: InjectBlocksOptions): string {\n  const { existingCode, newBlocks } = options;\n\n  // If no existing code, just wrap new blocks\n  if (!existingCode.trim()) {\n    return newBlocks\n      .map(block => wrapInBlock(block.content, block.id))\n      .join('\\n\\n');\n  }\n\n  const { preservedCode, hasBlocks } =\n    extractManagedBlocks(existingCode);\n\n  if (!hasBlocks) {\n    // No existing blocks - append new blocks at end\n    const preserved = preservedCode.join('\\n').trim();\n    const newContent = newBlocks\n      .map(block => wrapInBlock(block.content, block.id))\n      .join('\\n\\n');\n\n    return preserved ? `${preserved}\\n\\n${newContent}` : newContent;\n  }\n\n  // Replace existing blocks by ID, preserve structure\n  const result: string[] = [];\n  const processedIds = new Set<string>();\n  // Track id-less blocks separately by position to avoid ambiguous matching\n  let idLessBlockIndex = 0;\n  const idLessNewBlocks = newBlocks.filter(b => !b.id);\n  const processedIdLessIndices = new Set<number>();\n\n  // Re-scan to maintain structure\n  const lines = existingCode.split('\\n');\n  let inBlock = false;\n  let currentBlockId: string | undefined;\n  let skipUntilEnd = false;\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i]!;\n\n    if (line.includes(BLOCK_START)) {\n      inBlock = true;\n      const match = line.match(BLOCK_ID_PATTERN);\n      currentBlockId = match?.[1];\n\n      // Find replacement block\n      let replacement;\n      if (currentBlockId) {\n        // Match by ID for blocks with IDs\n        replacement = newBlocks.find(b => b.id === currentBlockId);\n        if (replacement) {\n          processedIds.add(currentBlockId);\n        }\n      } else {\n        // Match id-less blocks by position\n        if (idLessBlockIndex < idLessNewBlocks.length) {\n          replacement = idLessNewBlocks[idLessBlockIndex];\n          processedIdLessIndices.add(idLessBlockIndex);\n        }\n        idLessBlockIndex++;\n      }\n\n      if (replacement) {\n        result.push(wrapInBlock(replacement.content, replacement.id));\n        skipUntilEnd = true;\n      } else {\n        // Keep original block\n        result.push(line);\n        skipUntilEnd = false;\n      }\n      continue;\n    }\n\n    if (line.includes(BLOCK_END) && inBlock) {\n      inBlock = false;\n      if (!skipUntilEnd) {\n        result.push(line);\n      }\n      currentBlockId = undefined;\n      skipUntilEnd = false;\n      continue;\n    }\n\n    // Add content\n    if (!inBlock) {\n      result.push(line);\n    } else if (!skipUntilEnd) {\n      result.push(line);\n    }\n  }\n\n  // Append new blocks that weren't replacements\n  for (let i = 0; i < newBlocks.length; i++) {\n    const block = newBlocks[i]!;\n    if (block.id) {\n      // Check if this ID was processed\n      if (!processedIds.has(block.id)) {\n        result.push('');\n        result.push(wrapInBlock(block.content, block.id));\n      }\n    } else {\n      // Check if this id-less block was processed (by its index in idLessNewBlocks)\n      const idLessIndex = idLessNewBlocks.indexOf(block);\n      if (!processedIdLessIndices.has(idLessIndex)) {\n        result.push('');\n        result.push(wrapInBlock(block.content, block.id));\n      }\n    }\n  }\n\n  return result.join('\\n');\n}\n","/**\n * Journey Frontmatter Updater - Enable bi-directional traceability\n * @see research/2026-01-03_autogen-remaining-features-plan.md Section 1\n */\nimport { readFileSync, writeFileSync } from 'node:fs';\nimport { parse as parseYaml, stringify as stringifyYaml } from 'yaml';\nimport { createHash } from 'node:crypto';\n\n/**\n * Journey test entry with generation metadata\n */\nexport interface JourneyTestEntry {\n  /** Path to generated test file (relative to project root) */\n  path: string;\n  /** Timestamp when test was generated */\n  generated: string;\n  /** Content hash for change detection (first 8 chars of SHA-256) */\n  hash: string;\n}\n\n/**\n * Options for updating journey frontmatter\n */\nexport interface JourneyUpdateOptions {\n  /** Path to the journey markdown file */\n  journeyPath: string;\n  /** Path to the generated test file */\n  testPath: string;\n  /** Content of the generated test (for hash calculation) */\n  testContent: string;\n  /** Module dependencies to add (foundation or feature module names) */\n  modules?: {\n    foundation?: string[];\n    features?: string[];\n  };\n}\n\n/**\n * Result of journey frontmatter update\n */\nexport interface JourneyUpdateResult {\n  /** Whether update succeeded */\n  success: boolean;\n  /** Previous tests array before update */\n  previousTests: JourneyTestEntry[];\n  /** Updated tests array after update */\n  updatedTests: JourneyTestEntry[];\n  /** Modules added (not previously in the list) */\n  modulesAdded: {\n    foundation: string[];\n    features: string[];\n  };\n}\n\n/**\n * Split journey content into frontmatter and body\n */\nfunction splitJourneyContent(content: string): {\n  frontmatter: string;\n  body: string;\n} {\n  const match = content.match(/^---\\r?\\n([\\s\\S]*?)\\r?\\n---\\r?\\n([\\s\\S]*)$/);\n\n  if (!match) {\n    throw new Error(\n      'Invalid Journey format: missing frontmatter delimiters (content should be wrapped in --- ... ---)'\n    );\n  }\n\n  return {\n    frontmatter: match[1]!,\n    body: match[2]!,\n  };\n}\n\n/**\n * Calculate SHA-256 hash of content (first 8 characters)\n */\nfunction calculateContentHash(content: string): string {\n  return createHash('sha256').update(content).digest('hex').substring(0, 8);\n}\n\n/**\n * Update Journey frontmatter with generated test info\n *\n * This enables bi-directional traceability by:\n * 1. Recording which tests were generated from this Journey\n * 2. Tracking when tests were generated\n * 3. Detecting test changes via content hash\n * 4. Linking module dependencies\n *\n * @param options - Update options\n * @returns Update result with previous and new state\n * @throws Error if journey file is invalid or cannot be written\n */\nexport function updateJourneyFrontmatter(\n  options: JourneyUpdateOptions\n): JourneyUpdateResult {\n  const {\n    journeyPath,\n    testPath,\n    testContent,\n    modules = { foundation: [], features: [] },\n  } = options;\n\n  // Read journey file\n  const content = readFileSync(journeyPath, 'utf-8');\n\n  // Split frontmatter and body\n  const { frontmatter, body } = splitJourneyContent(content);\n\n  // Parse YAML frontmatter\n  const parsed = parseYaml(frontmatter) as Record<string, unknown>;\n\n  // Store previous state (deep copy to avoid mutation)\n  const previousTests = Array.isArray(parsed.tests)\n    ? (parsed.tests as JourneyTestEntry[]).map((t) =>\n        typeof t === 'string' ? { path: t, generated: '', hash: '' } : { ...t }\n      )\n    : [];\n\n  // Calculate content hash\n  const hash = calculateContentHash(testContent);\n\n  // Create/update test entry\n  const testEntry: JourneyTestEntry = {\n    path: testPath,\n    generated: new Date().toISOString(),\n    hash,\n  };\n\n  // Ensure tests array exists\n  if (!Array.isArray(parsed.tests)) {\n    parsed.tests = [];\n  }\n\n  // Find existing test entry by path\n  const existingIndex = (parsed.tests as JourneyTestEntry[]).findIndex(\n    (t) =>\n      typeof t === 'string'\n        ? t === testPath\n        : (t as JourneyTestEntry).path === testPath\n  );\n\n  // Update or add test entry\n  if (existingIndex >= 0) {\n    (parsed.tests as JourneyTestEntry[])[existingIndex]! = testEntry;\n  } else {\n    (parsed.tests as JourneyTestEntry[]).push(testEntry);\n  }\n\n  // Update modules\n  const modulesAdded = {\n    foundation: [] as string[],\n    features: [] as string[],\n  };\n\n  // Ensure modules structure exists\n  if (!parsed.modules || typeof parsed.modules !== 'object') {\n    parsed.modules = { foundation: [], features: [] };\n  }\n\n  const parsedModules = parsed.modules as {\n    foundation?: string[];\n    features?: string[];\n  };\n\n  // Ensure foundation and features arrays exist\n  if (!Array.isArray(parsedModules.foundation)) {\n    parsedModules.foundation = [];\n  }\n  if (!Array.isArray(parsedModules.features)) {\n    parsedModules.features = [];\n  }\n\n  // Add foundation modules (deduplicate)\n  if (modules.foundation) {\n    const existingFoundation = new Set(parsedModules.foundation!);\n    for (const mod of modules.foundation) {\n      if (!existingFoundation.has(mod)) {\n        modulesAdded.foundation.push(mod);\n        parsedModules.foundation!.push(mod);\n      }\n    }\n    // Sort for consistency\n    parsedModules.foundation!.sort();\n  }\n\n  // Add feature modules (deduplicate)\n  if (modules.features) {\n    const existingFeatures = new Set(parsedModules.features);\n    for (const mod of modules.features) {\n      if (!existingFeatures.has(mod)) {\n        modulesAdded.features.push(mod);\n        parsedModules.features.push(mod);\n      }\n    }\n    // Sort for consistency\n    parsedModules.features.sort();\n  }\n\n  // Reconstruct file with updated frontmatter\n  const newFrontmatter = stringifyYaml(parsed, {\n    lineWidth: 0, // Prevent line wrapping\n    defaultKeyType: 'PLAIN',\n    defaultStringType: 'QUOTE_DOUBLE',\n  });\n\n  const newContent = `---\\n${newFrontmatter}---\\n${body}`;\n\n  // Write back to file\n  writeFileSync(journeyPath, newContent, 'utf-8');\n\n  return {\n    success: true,\n    previousTests,\n    updatedTests: parsed.tests as JourneyTestEntry[],\n    modulesAdded,\n  };\n}\n\n/**\n * Check if a Journey's test is up-to-date based on content hash\n *\n * @param journeyPath - Path to the journey file\n * @param testPath - Path to the test file to check\n * @param testContent - Current content of the test file\n * @returns True if the test hash matches the recorded hash\n */\nexport function isJourneyTestCurrent(\n  journeyPath: string,\n  testPath: string,\n  testContent: string\n): boolean {\n  const content = readFileSync(journeyPath, 'utf-8');\n  const { frontmatter } = splitJourneyContent(content);\n  const parsed = parseYaml(frontmatter) as Record<string, unknown>;\n\n  if (!Array.isArray(parsed.tests)) {\n    return false;\n  }\n\n  // Find test entry\n  const testEntry = (parsed.tests as JourneyTestEntry[]).find((t) =>\n    typeof t === 'string' ? t === testPath : t.path === testPath\n  );\n\n  if (!testEntry || typeof testEntry === 'string') {\n    return false;\n  }\n\n  // Calculate current hash\n  const currentHash = calculateContentHash(testContent);\n\n  return testEntry.hash === currentHash;\n}\n","/**\n * Shared escaping utilities for code generation.\n * Consolidates escapeRegex and escapeString from multiple locations.\n */\n\n/**\n * Escape special regex characters in a string.\n * Includes forward slash for URL patterns.\n */\nexport function escapeRegex(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\\\/]/g, '\\\\$&');\n}\n\n/**\n * Escape a string for use in generated JavaScript/TypeScript code.\n * Handles quotes, backslashes, newlines, and carriage returns.\n */\nexport function escapeString(str: string): string {\n  return str\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/'/g, \"\\\\'\")\n    .replace(/\"/g, '\\\\\"')\n    .replace(/\\n/g, '\\\\n')\n    .replace(/\\r/g, '\\\\r');\n}\n\n/**\n * Escape a selector string for use in Playwright locators.\n * Handles quotes that would break the selector syntax.\n */\nexport function escapeSelector(str: string): string {\n  return str.replace(/'/g, \"\\\\'\");\n}\n","/**\n * Cross-module-system path utilities\n *\n * Provides directory resolution that works in both ESM and CJS environments.\n *\n * IMPORTANT: This module uses a dual-strategy approach:\n * - In CJS: Uses __dirname (injected by Node.js module wrapper)\n * - In ESM: Uses import.meta.url (only available in ESM)\n *\n * The TypeScript source uses import.meta.url, which works for ESM builds.\n * For CJS builds, we detect that __dirname is available and use it instead.\n */\nimport { join, dirname } from 'node:path';\nimport { readFileSync, existsSync } from 'node:fs';\nimport { fileURLToPath } from 'node:url';\n\n// CJS-specific globals - these are injected by Node.js module wrapper in CJS context\n// They will be undefined in ESM context\ndeclare const __dirname: string | undefined;\n \ndeclare const require: ((_id: string) => any) & { resolve: (_id: string) => string } | undefined;\n\n/**\n * Cached package root to avoid repeated lookups\n */\nlet cachedPackageRoot: string | undefined;\n\n/**\n * Cached module directory\n */\nlet cachedModuleDir: string | undefined;\n\n/**\n * Get the directory where this module file is located.\n * Works in both ESM and CJS environments.\n */\nfunction getModuleDir(): string {\n  if (cachedModuleDir) {\n    return cachedModuleDir;\n  }\n\n  // In CJS, __dirname is injected by Node.js module wrapper\n  // It will be undefined in ESM context\n  if (typeof __dirname === 'string' && __dirname.length > 0) {\n    cachedModuleDir = __dirname;\n    return cachedModuleDir;\n  }\n\n  // In ESM, use import.meta.url directly\n  // For CJS builds, this block is removed by post-build script (not needed since __dirname works)\n  // __ESM_ONLY_START__\n  try {\n    // @ts-ignore - Valid in ESM, removed from CJS by post-build\n    const metaUrl: string | undefined = import.meta.url;\n    if (metaUrl) {\n      cachedModuleDir = dirname(fileURLToPath(metaUrl));\n      return cachedModuleDir;\n    }\n  } catch {\n    // import.meta not available\n  }\n  // __ESM_ONLY_END__\n\n  // Fallback: try to find via require.resolve (CJS only)\n  try {\n    if (typeof require !== 'undefined' && require?.resolve) {\n      const resolved = require.resolve('@artk/core-autogen/package.json');\n      cachedModuleDir = dirname(resolved);\n      return cachedModuleDir;\n    }\n  } catch {\n    // Package not found via require.resolve\n  }\n\n  // Last resort: use process.cwd()\n  // This is unreliable but better than crashing\n  cachedModuleDir = process.cwd();\n  return cachedModuleDir;\n}\n\n/**\n * Get the package root directory.\n *\n * Strategy:\n * 1. Check ARTK_AUTOGEN_ROOT env var (for testing/override)\n * 2. Use module location to find package root\n * 3. Fallback to cwd-based search\n */\nexport function getPackageRoot(): string {\n  if (cachedPackageRoot) {\n    return cachedPackageRoot;\n  }\n\n  // 1. Check environment variable override\n  const envRoot = process.env['ARTK_AUTOGEN_ROOT'];\n  if (envRoot && existsSync(join(envRoot, 'package.json'))) {\n    cachedPackageRoot = envRoot;\n    return cachedPackageRoot;\n  }\n\n  // 2. Find package root from module location\n  // This file is at: <package-root>/dist[-variant]/utils/paths.js\n  // So we go up 2 levels to find package root\n  const moduleDir = getModuleDir();\n  const possibleRoots = [\n    join(moduleDir, '..', '..'),     // from dist/utils/ or dist-cjs/utils/\n    join(moduleDir, '..'),           // from dist/ directly\n    moduleDir,                        // if already at root\n  ];\n\n  for (const root of possibleRoots) {\n    const pkgPath = join(root, 'package.json');\n    if (existsSync(pkgPath)) {\n      try {\n        const pkg = JSON.parse(readFileSync(pkgPath, 'utf-8'));\n        if (pkg.name === '@artk/core-autogen') {\n          cachedPackageRoot = root;\n          return cachedPackageRoot;\n        }\n      } catch {\n        // Continue searching\n      }\n    }\n  }\n\n  // 3. Fallback to cwd-based search (for vendored installations)\n  const cwdPaths = [\n    join(process.cwd(), 'node_modules', '@artk', 'core-autogen'),\n    join(process.cwd(), 'artk-e2e', 'vendor', 'artk-core-autogen'),\n    process.cwd(),\n  ];\n\n  for (const searchPath of cwdPaths) {\n    const pkgPath = join(searchPath, 'package.json');\n    if (existsSync(pkgPath)) {\n      try {\n        const pkg = JSON.parse(readFileSync(pkgPath, 'utf-8'));\n        if (pkg.name === '@artk/core-autogen') {\n          cachedPackageRoot = searchPath;\n          return cachedPackageRoot;\n        }\n      } catch {\n        // Continue searching\n      }\n    }\n  }\n\n  // Final fallback - use module directory's parent\n  cachedPackageRoot = join(moduleDir, '..', '..');\n  return cachedPackageRoot;\n}\n\n/**\n * Get the templates directory path.\n *\n * Templates are copied to dist/codegen/templates/ during build.\n * When installed, only one dist variant exists.\n */\nexport function getTemplatesDir(): string {\n  const root = getPackageRoot();\n  const moduleDir = getModuleDir();\n\n  // First, try relative to the module itself (most reliable)\n  // Module is at dist[-variant]/utils/paths.js\n  // Templates are at dist[-variant]/codegen/templates/\n  const relativeToModule = join(moduleDir, '..', 'codegen', 'templates');\n  if (existsSync(relativeToModule)) {\n    return relativeToModule;\n  }\n\n  // Fallback: check standard locations from package root\n  const possiblePaths = [\n    join(root, 'dist', 'codegen', 'templates'),\n    join(root, 'dist-cjs', 'codegen', 'templates'),\n    join(root, 'dist-legacy-16', 'codegen', 'templates'),\n    join(root, 'dist-legacy-14', 'codegen', 'templates'),\n  ];\n\n  for (const templatesPath of possiblePaths) {\n    if (existsSync(templatesPath)) {\n      return templatesPath;\n    }\n  }\n\n  // Final fallback\n  return possiblePaths[0] ?? join(root, 'dist', 'codegen', 'templates');\n}\n\n/**\n * Get the path to a specific template file.\n */\nexport function getTemplatePath(templateName: string): string {\n  return join(getTemplatesDir(), templateName);\n}\n\n/**\n * Clear cached paths (for testing)\n */\nexport function clearPathCache(): void {\n  cachedPackageRoot = undefined;\n  cachedModuleDir = undefined;\n}\n","/**\n * Version utilities for generated code branding\n *\n * Supports build-time version injection via:\n * - Environment variable: ARTK_VERSION\n * - Build tool define: __ARTK_VERSION__ (e.g., via esbuild/rollup define)\n *\n * Falls back to runtime package.json reading if not injected.\n */\nimport { readFileSync, existsSync } from 'node:fs';\nimport { join } from 'node:path';\nimport { getPackageRoot } from './paths.js';\n\n/**\n * Build-time injected version (can be replaced by bundlers like esbuild/rollup)\n * Usage: define({ '__ARTK_VERSION__': JSON.stringify('1.0.0') })\n */\ndeclare const __ARTK_VERSION__: string | undefined;\n\n/** Cached version to avoid repeated lookups */\nlet cachedVersion: string | undefined;\n\n/**\n * Get the package version\n *\n * Priority:\n * 1. Build-time define (__ARTK_VERSION__)\n * 2. Environment variable (ARTK_VERSION)\n * 3. Runtime package.json reading (fallback)\n */\nexport function getPackageVersion(): string {\n  // Return cached version if available\n  if (cachedVersion) {\n    return cachedVersion;\n  }\n\n  // 1. Check build-time define (set by bundlers)\n  try {\n    if (typeof __ARTK_VERSION__ !== 'undefined' && __ARTK_VERSION__) {\n      cachedVersion = __ARTK_VERSION__;\n      return cachedVersion;\n    }\n  } catch {\n    // __ARTK_VERSION__ not defined, continue to fallbacks\n  }\n\n  // 2. Check environment variable (useful for CI/CD)\n  const envVersion = process.env['ARTK_VERSION'];\n  if (envVersion) {\n    cachedVersion = envVersion;\n    return cachedVersion;\n  }\n\n  // 3. Fall back to runtime package.json reading\n  try {\n    const packageRoot = getPackageRoot();\n    const pkgPath = join(packageRoot, 'package.json');\n\n    if (existsSync(pkgPath)) {\n      const pkg = JSON.parse(readFileSync(pkgPath, 'utf-8')) as { version?: string };\n      if (pkg.version) {\n        cachedVersion = pkg.version;\n        return cachedVersion;\n      }\n    }\n  } catch {\n    // Package.json lookup failed\n  }\n\n  cachedVersion = 'unknown';\n  return cachedVersion;\n}\n\n/**\n * Get ISO timestamp for generated file headers\n */\nexport function getGeneratedTimestamp(): string {\n  return new Date().toISOString();\n}\n\n/**\n * Generate a standard header comment for generated files\n */\nexport interface GeneratedHeaderOptions {\n  title?: string;\n  journeyId?: string;\n  tags?: string[];\n  tier?: string;\n  scope?: string;\n  actor?: string;\n}\n\nexport function generateFileHeader(options: GeneratedHeaderOptions = {}): string {\n  const version = getPackageVersion();\n  const timestamp = getGeneratedTimestamp();\n\n  const lines = [\n    '/**',\n    options.title ? ` * ${options.title}` : ' * Generated file',\n    options.journeyId ? ` * Journey: ${options.journeyId}` : null,\n    ` *`,\n    ` * @generated by @artk/core-autogen v${version}`,\n    ` * @timestamp ${timestamp}`,\n    ` * @warning Generated regions (ARTK:BEGIN/END GENERATED) will be overwritten.`,\n    ` *          Code outside these blocks is preserved on regeneration.`,\n  ];\n\n  if (options.tags && options.tags.length > 0) {\n    lines.push(` * @tags ${options.tags.join(', ')}`);\n  }\n  if (options.tier) {\n    lines.push(` * @tier ${options.tier}`);\n  }\n  if (options.scope) {\n    lines.push(` * @scope ${options.scope}`);\n  }\n  if (options.actor) {\n    lines.push(` * @actor ${options.actor}`);\n  }\n\n  lines.push(' */');\n\n  return lines.filter(l => l !== null).join('\\n');\n}\n\n/**\n * Branding string for inline comments\n */\nexport function getBrandingComment(): string {\n  const version = getPackageVersion();\n  return `@artk/core-autogen v${version}`;\n}\n","/**\n * Variant detection and feature flags for AutoGen\n */\n\nexport interface VariantInfo {\n  id: 'modern-esm' | 'modern-cjs' | 'legacy-16' | 'legacy-14';\n  nodeVersion: number;\n  moduleSystem: 'esm' | 'cjs';\n  playwrightVersion: string;\n  features: VariantFeatures;\n}\n\nexport interface VariantFeatures {\n  ariaSnapshots: boolean;\n  clockApi: boolean;\n  topLevelAwait: boolean;\n  promiseAny: boolean;\n}\n\n/**\n * Detect the current runtime variant based on Node.js version\n */\nexport function detectVariant(): VariantInfo {\n  const nodeVersionStr = process.version.slice(1);\n  const nodeVersion = parseInt(nodeVersionStr.split('.')[0], 10);\n\n  // Check if running in ESM context\n  const isESM = typeof import.meta !== 'undefined';\n\n  if (nodeVersion >= 18) {\n    return {\n      id: isESM ? 'modern-esm' : 'modern-cjs',\n      nodeVersion,\n      moduleSystem: isESM ? 'esm' : 'cjs',\n      playwrightVersion: '1.57.x',\n      features: {\n        ariaSnapshots: true,\n        clockApi: true,\n        topLevelAwait: true,\n        promiseAny: true,\n      },\n    };\n  } else if (nodeVersion >= 16) {\n    return {\n      id: 'legacy-16',\n      nodeVersion,\n      moduleSystem: 'cjs',\n      playwrightVersion: '1.49.x',\n      features: {\n        ariaSnapshots: true,\n        clockApi: true,\n        topLevelAwait: true,\n        promiseAny: true,\n      },\n    };\n  } else {\n    return {\n      id: 'legacy-14',\n      nodeVersion,\n      moduleSystem: 'cjs',\n      playwrightVersion: '1.33.x',\n      features: {\n        ariaSnapshots: false,\n        clockApi: false,\n        topLevelAwait: false,\n        promiseAny: false,\n      },\n    };\n  }\n}\n\n/**\n * Get feature availability for current variant\n */\nexport function getFeatures(): VariantFeatures {\n  return detectVariant().features;\n}\n\n/**\n * Check if a specific feature is available\n */\nexport function hasFeature(feature: keyof VariantFeatures): boolean {\n  return detectVariant().features[feature];\n}\n","/**\n * Test Generator - Generate Playwright test files from IR\n * @see research/2026-01-02_autogen-refined-plan.md Section 12\n * @see research/2026-01-27_autogen-empty-stubs-implementation-plan.md (variant-aware generation)\n */\nimport { readFileSync, existsSync } from 'node:fs';\nimport { join } from 'node:path';\nimport ejs from 'ejs';\nimport type { IRJourney, IRPrimitive, ValueSpec } from '../ir/types.js';\nimport { toPlaywrightLocator } from '../selectors/priority.js';\nimport { injectManagedBlocks } from './blocks.js';\nimport { updateJourneyFrontmatter } from '../journey/updater.js';\nimport { escapeRegex } from '../utils/escaping.js';\nimport { getPackageVersion, getGeneratedTimestamp } from '../utils/version.js';\nimport { getTemplatePath } from '../utils/paths.js';\nimport { detectVariant, type VariantInfo, type VariantFeatures } from '../variants/index.js';\n\n// Re-export variant types for consumers\nexport type { VariantInfo, VariantFeatures };\n\n/**\n * Import statement for generated test\n */\nexport interface ImportStatement {\n  members: string[];\n  from: string;\n}\n\n/**\n * Options for test generation\n */\nexport interface GenerateTestOptions {\n  /** Custom template path */\n  templatePath?: string;\n  /** Whether to include source comments */\n  includeComments?: boolean;\n  /** Module imports to add */\n  imports?: ImportStatement[];\n  /** Custom test ID attribute */\n  testIdAttribute?: string;\n  /**\n   * Code generation strategy\n   * - 'full': Generate complete file (default)\n   * - 'blocks': Use managed blocks for partial regeneration\n   * - 'ast': Use AST editing to preserve structure\n   */\n  strategy?: 'full' | 'blocks' | 'ast';\n  /** Existing code (required for 'blocks' and 'ast' strategies) */\n  existingCode?: string;\n  /** Whether to update journey frontmatter with test metadata */\n  updateJourney?: boolean;\n  /** Path to the source journey file (required if updateJourney is true) */\n  journeyPath?: string;\n  /** Output path for the generated test file (for journey update) */\n  outputPath?: string;\n  /** LLKB root directory for version tracking (default: .artk/llkb) */\n  llkbRoot?: string;\n  /** Whether to include LLKB version in generated test header (default: true if LLKB exists) */\n  includeLlkbVersion?: boolean;\n  /** Target variant for code generation (auto-detected if not specified) */\n  targetVariant?: VariantInfo;\n  /** Whether to emit warnings for variant-incompatible features (default: true) */\n  warnOnIncompatible?: boolean;\n}\n\n/**\n * Result of test generation\n */\nexport interface GenerateTestResult {\n  /** Generated test code */\n  code: string;\n  /** Journey ID */\n  journeyId: string;\n  /** Suggested filename */\n  filename: string;\n  /** Imports used */\n  imports: ImportStatement[];\n  /** Variant used for generation */\n  variant?: VariantInfo;\n  /** Warnings about variant-incompatible features */\n  variantWarnings?: string[];\n}\n\n/**\n * Context for variant-aware code generation\n */\ninterface VariantContext {\n  /** Variant info for the target environment */\n  variant: VariantInfo;\n  /** Collected warnings for incompatible features */\n  warnings: string[];\n  /** Whether to emit warnings */\n  warnOnIncompatible: boolean;\n}\n\n/**\n * Check if a feature is available in the current variant\n * @internal Reserved for future variant-specific primitive handling\n */\nfunction _checkFeature(\n  ctx: VariantContext,\n  feature: keyof VariantFeatures,\n  featureName: string,\n  primitiveType: string\n): boolean {\n  const available = ctx.variant.features[feature];\n  if (!available && ctx.warnOnIncompatible) {\n    ctx.warnings.push(\n      `Primitive '${primitiveType}' uses ${featureName} which requires ${getFeatureRequirement(feature)}. ` +\n        `Current variant: ${ctx.variant.id} (Playwright ${ctx.variant.playwrightVersion})`\n    );\n  }\n  return available;\n}\n\n// Export for testing (prefixed to avoid unused warning in production)\nexport const __test_checkFeature = _checkFeature;\n\n/**\n * Get human-readable requirement for a feature\n */\nfunction getFeatureRequirement(feature: keyof VariantFeatures): string {\n  switch (feature) {\n    case 'ariaSnapshots':\n      return 'Playwright 1.49+ (Node 16+)';\n    case 'clockApi':\n      return 'Playwright 1.45+ (Node 18+)';\n    case 'topLevelAwait':\n      return 'Node 14.8+ with ESM';\n    case 'promiseAny':\n      return 'Node 15+ or polyfill';\n    default:\n      return 'unknown version';\n  }\n}\n\n/**\n * Escape string for use in generated code\n */\nfunction escapeString(str: string): string {\n  return str\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/'/g, \"\\\\'\")\n    .replace(/\"/g, '\\\\\"')\n    .replace(/\\n/g, '\\\\n')\n    .replace(/\\r/g, '\\\\r');\n}\n\n/**\n * Render a value spec to code\n */\nfunction renderValue(value: ValueSpec): string {\n  switch (value.type) {\n    case 'literal':\n      return `'${escapeString(value.value)}'`;\n    case 'actor':\n      return `actor.${value.value}`;\n    case 'runId':\n      return 'runId';\n    case 'generated':\n      return `\\`${value.value}\\``;\n    case 'testData':\n      return `testData.${value.value}`;\n    default:\n      return `'${escapeString(value.value)}'`;\n  }\n}\n\n/**\n * Render an IR primitive to Playwright code\n * @param primitive The IR primitive to render\n * @param indent Indentation string\n * @param _ctx Optional variant context for compatibility checking (reserved for future use)\n */\nfunction renderPrimitive(primitive: IRPrimitive, indent = '', _ctx?: VariantContext): string {\n  switch (primitive.type) {\n    // Navigation\n    case 'goto':\n      return `${indent}await page.goto('${escapeString(primitive.url)}');`;\n\n    case 'waitForURL':\n      const urlPattern = typeof primitive.pattern === 'string'\n        ? `/${escapeRegex(primitive.pattern)}/`\n        : primitive.pattern.toString();\n      return `${indent}await page.waitForURL(${urlPattern});`;\n\n    case 'waitForResponse':\n      return `${indent}await page.waitForResponse(resp => resp.url().includes('${escapeString(primitive.urlPattern)}'));`;\n\n    case 'waitForLoadingComplete':\n      return `${indent}await page.waitForLoadState('networkidle');`;\n\n    case 'reload':\n      return `${indent}await page.reload();`;\n\n    case 'goBack':\n      return `${indent}await page.goBack();`;\n\n    case 'goForward':\n      return `${indent}await page.goForward();`;\n\n    // Wait primitives\n    case 'waitForVisible':\n      const waitVisibleTimeout = primitive.timeout ? `, timeout: ${primitive.timeout}` : '';\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.waitFor({ state: 'visible'${waitVisibleTimeout} });`;\n\n    case 'waitForHidden':\n      const waitHiddenTimeout = primitive.timeout ? `, timeout: ${primitive.timeout}` : '';\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.waitFor({ state: 'hidden'${waitHiddenTimeout} });`;\n\n    case 'waitForTimeout':\n      return `${indent}await page.waitForTimeout(${primitive.ms});`;\n\n    case 'waitForNetworkIdle':\n      const networkIdleOptions = primitive.timeout ? `, { timeout: ${primitive.timeout} }` : '';\n      return `${indent}await page.waitForLoadState('networkidle'${networkIdleOptions});`;\n\n    // Interactions\n    case 'click':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.click();`;\n\n    case 'dblclick':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.dblclick();`;\n\n    case 'rightClick':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.click({ button: 'right' });`;\n\n    case 'fill':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.fill(${renderValue(primitive.value)});`;\n\n    case 'select':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.selectOption('${escapeString(primitive.option)}');`;\n\n    case 'check':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.check();`;\n\n    case 'uncheck':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.uncheck();`;\n\n    case 'press':\n      if (primitive.locator) {\n        return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.press('${primitive.key}');`;\n      }\n      return `${indent}await page.keyboard.press('${primitive.key}');`;\n\n    case 'hover':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.hover();`;\n\n    case 'focus':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.focus();`;\n\n    case 'clear':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.clear();`;\n\n    case 'upload':\n      return `${indent}await page.${toPlaywrightLocator(primitive.locator)}.setInputFiles([${primitive.files.map(f => `'${escapeString(f)}'`).join(', ')}]);`;\n\n    // Assertions\n    case 'expectVisible':\n      const visibleOptions = primitive.timeout ? `{ timeout: ${primitive.timeout} }` : '';\n      return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).toBeVisible(${visibleOptions});`;\n\n    case 'expectNotVisible':\n      return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).not.toBeVisible();`;\n\n    case 'expectHidden':\n      return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).toBeHidden();`;\n\n    case 'expectText':\n      const textPattern = typeof primitive.text === 'string'\n        ? `'${escapeString(primitive.text)}'`\n        : primitive.text.toString();\n      return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).toHaveText(${textPattern});`;\n\n    case 'expectValue':\n      return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).toHaveValue('${escapeString(primitive.value)}');`;\n\n    case 'expectChecked':\n      if (primitive.checked === false) {\n        return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).not.toBeChecked();`;\n      }\n      return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).toBeChecked();`;\n\n    case 'expectEnabled':\n      return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).toBeEnabled();`;\n\n    case 'expectDisabled':\n      return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).toBeDisabled();`;\n\n    case 'expectURL':\n      const urlExpectPattern = typeof primitive.pattern === 'string'\n        ? `/${escapeRegex(primitive.pattern)}/`\n        : primitive.pattern.toString();\n      return `${indent}await expect(page).toHaveURL(${urlExpectPattern});`;\n\n    case 'expectTitle':\n      const titlePattern = typeof primitive.title === 'string'\n        ? `'${escapeString(primitive.title)}'`\n        : primitive.title.toString();\n      return `${indent}await expect(page).toHaveTitle(${titlePattern});`;\n\n    case 'expectCount':\n      return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).toHaveCount(${primitive.count});`;\n\n    case 'expectContainsText':\n      return `${indent}await expect(page.${toPlaywrightLocator(primitive.locator)}).toContainText('${escapeString(primitive.text)}');`;\n\n    // Signals\n    case 'expectToast':\n      const toastSelector = primitive.message\n        ? `getByText('${escapeString(primitive.message)}')`\n        : `getByRole('alert')`;\n      return `${indent}await expect(page.${toastSelector}).toBeVisible();`;\n\n    case 'dismissModal':\n      return `${indent}await page.getByRole('dialog').getByRole('button', { name: /close|cancel|dismiss/i }).click();`;\n\n    case 'acceptAlert':\n      return `${indent}page.on('dialog', dialog => dialog.accept());`;\n\n    case 'dismissAlert':\n      return `${indent}page.on('dialog', dialog => dialog.dismiss());`;\n\n    // Module calls - use factory function to create instance\n    case 'callModule':\n      // Generate factory function name from module name (e.g., LoginModule -> createLoginModule)\n      const factoryName = `create${primitive.module}`;\n      const args = primitive.args ? primitive.args.map(a => JSON.stringify(a)).join(', ') : '';\n      // Create instance via factory and call method\n      return `${indent}await ${factoryName}(page).${primitive.method}(${args});`;\n\n    // Blocked - must throw to fail the test\n    case 'blocked':\n      return `${indent}// ARTK BLOCKED: ${primitive.reason}\\n${indent}// Source: ${escapeString(primitive.sourceText)}\\n${indent}throw new Error('ARTK BLOCKED: ${escapeString(primitive.reason)}');`;\n\n    default:\n      return `${indent}// Unknown primitive type: ${(primitive as { type: string }).type}`;\n  }\n}\n\n/**\n * Create a variant-aware render function for use in templates\n * @internal The ctx parameter is passed through for future variant-specific handling\n */\nfunction createVariantAwareRenderer(ctx: VariantContext): (primitive: IRPrimitive, indent?: string) => string {\n  // Note: ctx is passed to renderPrimitive for future variant-specific code generation\n  // Currently no primitives require variant checking, but the infrastructure is in place\n  return (primitive: IRPrimitive, indent = '') => renderPrimitive(primitive, indent, ctx);\n}\n\n/**\n * Load the default test template\n */\nfunction loadDefaultTemplate(): string {\n  const templatePath = getTemplatePath('test.ejs');\n  return readFileSync(templatePath, 'utf-8');\n}\n\n/**\n * Collect module imports from journey\n *\n * Imports factory functions (e.g., createLoginModule) for module calls.\n * The factory function naming follows the pattern: create{ModuleName}\n */\nfunction collectImports(journey: IRJourney): ImportStatement[] {\n  const imports: ImportStatement[] = [];\n  // Track unique module names to avoid duplicate imports\n  const usedModules = new Set<string>();\n\n  // Collect module calls from all steps\n  for (const step of journey.steps) {\n    for (const action of step.actions) {\n      if (action.type === 'callModule') {\n        usedModules.add(action.module);\n      }\n    }\n  }\n\n  // Convert to import statements - import factory functions\n  for (const module of usedModules) {\n    // Use lowercase-first path convention (e.g., @modules/loginModule for LoginModule)\n    const modulePath = module.charAt(0).toLowerCase() + module.slice(1);\n    // Import the factory function (e.g., createLoginModule)\n    const factoryName = `create${module}`;\n    imports.push({\n      members: [factoryName],\n      from: `@modules/${modulePath}`,\n    });\n  }\n\n  return imports;\n}\n\n/**\n * Get LLKB version and entry count if LLKB exists\n */\nfunction getLlkbInfo(llkbRoot: string): { llkbVersion: string | null; llkbEntries: number | null } {\n  const analyticsPath = join(llkbRoot, 'analytics.json');\n\n  if (!existsSync(analyticsPath)) {\n    return { llkbVersion: null, llkbEntries: null };\n  }\n\n  try {\n    const content = readFileSync(analyticsPath, 'utf-8');\n    const analytics = JSON.parse(content) as {\n      lastUpdated?: string;\n      overview?: { totalLessons?: number; totalComponents?: number };\n    };\n\n    const llkbVersion = analytics.lastUpdated || new Date().toISOString();\n    const totalLessons = analytics.overview?.totalLessons || 0;\n    const totalComponents = analytics.overview?.totalComponents || 0;\n    const llkbEntries = totalLessons + totalComponents;\n\n    return { llkbVersion, llkbEntries };\n  } catch {\n    return { llkbVersion: null, llkbEntries: null };\n  }\n}\n\n/**\n * Generate Playwright test code from IR Journey\n */\nexport function generateTest(\n  journey: IRJourney,\n  options: GenerateTestOptions = {}\n): GenerateTestResult {\n  const {\n    templatePath,\n    imports: additionalImports = [],\n    strategy = 'full',\n    existingCode,\n    llkbRoot = '.artk/llkb',\n    includeLlkbVersion = true,\n    targetVariant,\n    warnOnIncompatible = true,\n  } = options;\n\n  // Detect or use provided variant for variant-aware generation\n  const variant = targetVariant || detectVariant();\n\n  // Create variant context for compatibility checking\n  const variantCtx: VariantContext = {\n    variant,\n    warnings: [],\n    warnOnIncompatible,\n  };\n\n  // Load template\n  const template = templatePath\n    ? readFileSync(templatePath, 'utf-8')\n    : loadDefaultTemplate();\n\n  // Collect imports\n  const imports = [...collectImports(journey), ...additionalImports];\n\n  // Get LLKB version info if enabled\n  let llkbVersion: string | null = null;\n  let llkbEntries: number | null = null;\n\n  if (includeLlkbVersion) {\n    const llkbInfo = getLlkbInfo(llkbRoot);\n    llkbVersion = llkbInfo.llkbVersion;\n    llkbEntries = llkbInfo.llkbEntries;\n  }\n\n  // Create variant-aware renderer\n  const variantAwareRenderPrimitive = createVariantAwareRenderer(variantCtx);\n\n  // Render template with version branding and variant info\n  let code = ejs.render(template, {\n    journey,\n    imports,\n    renderPrimitive: variantAwareRenderPrimitive,\n    escapeString,\n    escapeRegex,\n    version: getPackageVersion(),\n    timestamp: getGeneratedTimestamp(),\n    llkbVersion,\n    llkbEntries,\n    variant: variant.id,\n    playwrightVersion: variant.playwrightVersion,\n  });\n\n  // Apply strategy-specific processing\n  if (strategy === 'blocks' && existingCode) {\n    // Use managed blocks strategy: inject generated code into existing file\n    const testBlock = {\n      id: `test-${journey.id}`,\n      content: code.trim(),\n    };\n\n    code = injectManagedBlocks({\n      existingCode,\n      newBlocks: [testBlock],\n    });\n  } else if (strategy === 'ast' && existingCode) {\n    // AST strategy would use astEdit.ts (not implemented in this task)\n    // For now, fall back to full regeneration\n    console.warn('AST strategy not yet implemented for blocks integration, using full generation');\n  }\n\n  // Generate filename\n  const filename = `${journey.id.toLowerCase()}.spec.ts`;\n\n  // Update journey frontmatter if requested\n  if (options.updateJourney && options.journeyPath) {\n    try {\n      const testPath = options.outputPath || filename;\n\n      // Extract module names from journey metadata\n      const modules = {\n        foundation: journey.moduleDependencies?.foundation || [],\n        features: journey.moduleDependencies?.feature || [], // Note: IR uses 'feature' (singular)\n      };\n\n      updateJourneyFrontmatter({\n        journeyPath: options.journeyPath,\n        testPath,\n        testContent: code,\n        modules,\n      });\n    } catch (error) {\n      // Log error but don't fail test generation\n      console.error(\n        `Warning: Failed to update journey frontmatter: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  return {\n    code,\n    journeyId: journey.id,\n    filename,\n    imports,\n    variant,\n    variantWarnings: variantCtx.warnings.length > 0 ? variantCtx.warnings : undefined,\n  };\n}\n\n/**\n * Generate test code as a string (convenience function)\n */\nexport function generateTestCode(journey: IRJourney): string {\n  return generateTest(journey).code;\n}\n","/**\n * Module Generator - Generate Page Object modules from IR\n * @see research/2026-01-02_autogen-refined-plan.md Section 12\n */\nimport { readFileSync } from 'node:fs';\nimport ejs from 'ejs';\nimport type { IRJourney, IRPrimitive, LocatorSpec } from '../ir/types.js';\nimport { toPlaywrightLocator } from '../selectors/priority.js';\nimport { getPackageVersion, getGeneratedTimestamp } from '../utils/version.js';\nimport { getTemplatePath } from '../utils/paths.js';\n\n/**\n * Locator definition for a module\n */\nexport interface ModuleLocator {\n  /** Property name for the locator */\n  name: string;\n  /** Playwright locator string */\n  playwright: string;\n  /** Original locator spec */\n  spec: LocatorSpec;\n  /** Human-readable description */\n  description?: string;\n}\n\n/**\n * Method parameter definition\n */\nexport interface MethodParam {\n  name: string;\n  type: string;\n  optional?: boolean;\n  defaultValue?: string;\n}\n\n/**\n * Method definition for a module\n */\nexport interface ModuleMethod {\n  /** Method name */\n  name: string;\n  /** Method description */\n  description: string;\n  /** Method parameters */\n  params: MethodParam[];\n  /** Return type */\n  returnType: string;\n  /** Method body lines */\n  body: string[];\n}\n\n/**\n * Module definition\n */\nexport interface ModuleDefinition {\n  /** Module name (PascalCase) */\n  moduleName: string;\n  /** Class name (PascalCase with suffix) */\n  className: string;\n  /** Module scope (feature area) */\n  scope: string;\n  /** Locators used by the module */\n  locators: ModuleLocator[];\n  /** Methods provided by the module */\n  methods: ModuleMethod[];\n}\n\n/**\n * Options for module generation\n */\nexport interface GenerateModuleOptions {\n  /** Custom template path */\n  templatePath?: string;\n  /** Module name suffix (default: 'Page') */\n  suffix?: string;\n  /** Whether to include JSDoc comments */\n  includeJsDoc?: boolean;\n}\n\n/**\n * Result of module generation\n */\nexport interface GenerateModuleResult {\n  /** Generated module code */\n  code: string;\n  /** Module name */\n  moduleName: string;\n  /** Suggested filename */\n  filename: string;\n  /** Locators defined */\n  locators: ModuleLocator[];\n  /** Methods defined */\n  methods: ModuleMethod[];\n}\n\n/**\n * Convert a scope/name to PascalCase class name\n */\nfunction toPascalCase(str: string): string {\n  return str\n    .split(/[-_\\s]+/)\n    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n    .join('');\n}\n\n/**\n * Convert a name to camelCase\n */\nfunction toCamelCase(str: string): string {\n  const pascal = toPascalCase(str);\n  return pascal.charAt(0).toLowerCase() + pascal.slice(1);\n}\n\n/**\n * Generate a unique locator name from a locator spec\n */\nfunction generateLocatorName(spec: LocatorSpec, existingNames: Set<string>): string {\n  let baseName: string;\n\n  // Generate base name from spec\n  switch (spec.strategy) {\n    case 'role':\n      baseName = spec.options?.name\n        ? `${toCamelCase(spec.options.name)}${toPascalCase(spec.value)}`\n        : `${toCamelCase(spec.value)}Element`;\n      break;\n    case 'label':\n    case 'placeholder':\n    case 'text':\n      baseName = `${toCamelCase(spec.value)}Field`;\n      break;\n    case 'testid':\n      baseName = toCamelCase(spec.value);\n      break;\n    case 'css':\n      // Extract meaningful name from CSS selector\n      const match = spec.value.match(/[#.]?([a-zA-Z][a-zA-Z0-9_-]*)/);\n      baseName = match ? toCamelCase(match[1]!) : 'element';\n      break;\n    default:\n      baseName = 'element';\n  }\n\n  // Ensure uniqueness\n  let name = baseName;\n  let counter = 1;\n  while (existingNames.has(name)) {\n    name = `${baseName}${counter}`;\n    counter++;\n  }\n  existingNames.add(name);\n\n  return name;\n}\n\n/**\n * Extract locators from journey primitives\n */\nfunction extractLocators(journey: IRJourney): ModuleLocator[] {\n  const locators: ModuleLocator[] = [];\n  const existingNames = new Set<string>();\n  const seenSpecs = new Map<string, ModuleLocator>();\n\n  // Helper to process a primitive\n  const processPrimitive = (primitive: IRPrimitive) => {\n    // Check if primitive has a locator\n    const locatorSpec = (primitive as { locator?: LocatorSpec }).locator;\n    if (!locatorSpec) return;\n\n    // Create a unique key for the locator spec\n    const specKey = JSON.stringify(locatorSpec);\n    if (seenSpecs.has(specKey)) return;\n\n    const name = generateLocatorName(locatorSpec, existingNames);\n    const playwrightLocator = toPlaywrightLocator(locatorSpec);\n\n    const locator: ModuleLocator = {\n      name,\n      playwright: playwrightLocator,\n      spec: locatorSpec,\n      description: `Locator for ${locatorSpec.strategy}: ${locatorSpec.value}`,\n    };\n\n    locators.push(locator);\n    seenSpecs.set(specKey, locator);\n  };\n\n  // Process setup\n  if (journey.setup) {\n    for (const primitive of journey.setup) {\n      processPrimitive(primitive);\n    }\n  }\n\n  // Process steps\n  for (const step of journey.steps) {\n    for (const action of step.actions) {\n      processPrimitive(action);\n    }\n    for (const assertion of step.assertions) {\n      processPrimitive(assertion);\n    }\n  }\n\n  // Process cleanup\n  if (journey.cleanup) {\n    for (const primitive of journey.cleanup) {\n      processPrimitive(primitive);\n    }\n  }\n\n  return locators;\n}\n\n/**\n * Generate methods from journey steps\n */\nfunction generateMethods(journey: IRJourney, locators: ModuleLocator[]): ModuleMethod[] {\n  const methods: ModuleMethod[] = [];\n  const locatorMap = new Map<string, string>();\n\n  // Build locator lookup map\n  for (const locator of locators) {\n    const specKey = JSON.stringify(locator.spec);\n    locatorMap.set(specKey, locator.name);\n  }\n\n  // Helper to get locator reference\n  const getLocatorRef = (spec: LocatorSpec): string => {\n    const specKey = JSON.stringify(spec);\n    const locatorName = locatorMap.get(specKey);\n    return locatorName ? `this.${locatorName}` : `this.page.${toPlaywrightLocator(spec)}`;\n  };\n\n  // Generate a method for each step\n  for (const step of journey.steps) {\n    const methodName = toCamelCase(step.id.replace(/[^a-zA-Z0-9]/g, '_'));\n    const body: string[] = [];\n\n    // Add actions\n    for (const action of step.actions) {\n      const line = primitiveToMethodLine(action, getLocatorRef);\n      if (line) {\n        body.push(line);\n      }\n    }\n\n    // Add assertions\n    for (const assertion of step.assertions) {\n      const line = primitiveToMethodLine(assertion, getLocatorRef);\n      if (line) {\n        body.push(line);\n      }\n    }\n\n    if (body.length > 0) {\n      methods.push({\n        name: methodName,\n        description: step.description,\n        params: [],\n        returnType: 'void',\n        body,\n      });\n    }\n  }\n\n  return methods;\n}\n\n/**\n * Convert a primitive to a method body line\n */\nfunction primitiveToMethodLine(\n  primitive: IRPrimitive,\n  getLocatorRef: (_spec: LocatorSpec) => string\n): string | null {\n  switch (primitive.type) {\n    // Navigation\n    case 'goto':\n      return `await this.page.goto('${escapeString(primitive.url)}');`;\n\n    case 'waitForURL':\n      const urlPattern = typeof primitive.pattern === 'string'\n        ? `'${escapeString(primitive.pattern)}'`\n        : primitive.pattern.toString();\n      return `await this.page.waitForURL(${urlPattern});`;\n\n    case 'waitForLoadingComplete':\n      return `await this.page.waitForLoadState('networkidle');`;\n\n    // Interactions\n    case 'click':\n      return `await ${getLocatorRef(primitive.locator)}.click();`;\n\n    case 'fill':\n      const value = primitive.value.type === 'literal'\n        ? `'${escapeString(primitive.value.value)}'`\n        : primitive.value.value;\n      return `await ${getLocatorRef(primitive.locator)}.fill(${value});`;\n\n    case 'select':\n      return `await ${getLocatorRef(primitive.locator)}.selectOption('${escapeString(primitive.option)}');`;\n\n    case 'check':\n      return `await ${getLocatorRef(primitive.locator)}.check();`;\n\n    case 'uncheck':\n      return `await ${getLocatorRef(primitive.locator)}.uncheck();`;\n\n    case 'press':\n      if (primitive.locator) {\n        return `await ${getLocatorRef(primitive.locator)}.press('${primitive.key}');`;\n      }\n      return `await this.page.keyboard.press('${primitive.key}');`;\n\n    case 'hover':\n      return `await ${getLocatorRef(primitive.locator)}.hover();`;\n\n    case 'focus':\n      return `await ${getLocatorRef(primitive.locator)}.focus();`;\n\n    case 'clear':\n      return `await ${getLocatorRef(primitive.locator)}.clear();`;\n\n    // Assertions (using expect)\n    case 'expectVisible':\n      return `await expect(${getLocatorRef(primitive.locator)}).toBeVisible();`;\n\n    case 'expectNotVisible':\n      return `await expect(${getLocatorRef(primitive.locator)}).not.toBeVisible();`;\n\n    case 'expectText':\n      const textPattern = typeof primitive.text === 'string'\n        ? `'${escapeString(primitive.text)}'`\n        : primitive.text.toString();\n      return `await expect(${getLocatorRef(primitive.locator)}).toHaveText(${textPattern});`;\n\n    case 'expectValue':\n      return `await expect(${getLocatorRef(primitive.locator)}).toHaveValue('${escapeString(primitive.value)}');`;\n\n    case 'expectEnabled':\n      return `await expect(${getLocatorRef(primitive.locator)}).toBeEnabled();`;\n\n    case 'expectDisabled':\n      return `await expect(${getLocatorRef(primitive.locator)}).toBeDisabled();`;\n\n    // Blocked - must throw to fail the test\n    case 'blocked':\n      return `// ARTK BLOCKED: ${primitive.reason}\\n    throw new Error('ARTK BLOCKED: ${primitive.reason}');`;\n\n    default:\n      return null;\n  }\n}\n\n/**\n * Escape string for code generation\n */\nfunction escapeString(str: string): string {\n  return str\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/'/g, \"\\\\'\")\n    .replace(/\"/g, '\\\\\"')\n    .replace(/\\n/g, '\\\\n')\n    .replace(/\\r/g, '\\\\r');\n}\n\n/**\n * Load the default module template\n */\nfunction loadDefaultTemplate(): string {\n  const templatePath = getTemplatePath('module.ejs');\n  return readFileSync(templatePath, 'utf-8');\n}\n\n/**\n * Generate Page Object module from IR Journey\n */\nexport function generateModule(\n  journey: IRJourney,\n  options: GenerateModuleOptions = {}\n): GenerateModuleResult {\n  const { templatePath, suffix = 'Page' } = options;\n\n  // Load template\n  const template = templatePath\n    ? readFileSync(templatePath, 'utf-8')\n    : loadDefaultTemplate();\n\n  // Generate module/class names\n  const moduleName = toPascalCase(journey.scope);\n  const className = `${moduleName}${suffix}`;\n\n  // Extract locators and generate methods\n  const locators = extractLocators(journey);\n  const methods = generateMethods(journey, locators);\n\n  // Create module definition\n  const moduleDef: ModuleDefinition = {\n    moduleName,\n    className,\n    scope: journey.scope,\n    locators,\n    methods,\n  };\n\n  // Render template with version branding\n  const code = ejs.render(template, {\n    ...moduleDef,\n    version: getPackageVersion(),\n    timestamp: getGeneratedTimestamp(),\n  });\n\n  // Generate filename\n  const filename = `${journey.scope.toLowerCase()}.page.ts`;\n\n  return {\n    code,\n    moduleName,\n    filename,\n    locators,\n    methods,\n  };\n}\n\n/**\n * Generate module code as a string (convenience function)\n */\nexport function generateModuleCode(journey: IRJourney): string {\n  return generateModule(journey).code;\n}\n\n/**\n * Extract module definition from journey without generating code\n */\nexport function extractModuleDefinition(\n  journey: IRJourney,\n  options: GenerateModuleOptions = {}\n): ModuleDefinition {\n  const { suffix = 'Page' } = options;\n\n  const moduleName = toPascalCase(journey.scope);\n  const className = `${moduleName}${suffix}`;\n  const locators = extractLocators(journey);\n  const methods = generateMethods(journey, locators);\n\n  return {\n    moduleName,\n    className,\n    scope: journey.scope,\n    locators,\n    methods,\n  };\n}\n","/**\n * AST-based Code Editing - Safely modify existing TypeScript files\n * @see research/2026-01-02_autogen-refined-plan.md Section 12\n */\nimport {\n  Project,\n  SourceFile,\n  ClassDeclaration,\n  MethodDeclaration,\n  PropertyDeclaration,\n  ImportDeclaration,\n  SyntaxKind,\n  ScriptTarget,\n  ModuleKind,\n} from 'ts-morph';\nimport type { ModuleLocator, ModuleMethod } from './generateModule.js';\n\n/**\n * Result of an AST edit operation\n */\nexport interface AstEditResult {\n  /** Whether any changes were made */\n  modified: boolean;\n  /** List of changes made */\n  changes: string[];\n  /** Updated source code */\n  code: string;\n  /** Any warnings generated */\n  warnings: string[];\n}\n\n/**\n * Options for AST editing\n */\nexport interface AstEditOptions {\n  /** Preserve existing methods (don't overwrite) */\n  preserveExisting?: boolean;\n  /** Add new imports automatically */\n  addImports?: boolean;\n  /** Format code after editing */\n  formatOutput?: boolean;\n}\n\n/**\n * Create a ts-morph project for editing\n */\nexport function createProject(): Project {\n  return new Project({\n    useInMemoryFileSystem: true,\n    compilerOptions: {\n      target: ScriptTarget.ESNext,\n      module: ModuleKind.ESNext,\n      strict: true,\n    },\n  });\n}\n\n/**\n * Load source file from code string\n */\nexport function loadSourceFile(project: Project, code: string, filename = 'temp.ts'): SourceFile {\n  return project.createSourceFile(filename, code, { overwrite: true });\n}\n\n/**\n * Find a class declaration by name\n */\nexport function findClass(sourceFile: SourceFile, className: string): ClassDeclaration | undefined {\n  return sourceFile.getClass(className);\n}\n\n/**\n * Find a method in a class\n */\nexport function findMethod(classDecl: ClassDeclaration, methodName: string): MethodDeclaration | undefined {\n  return classDecl.getMethod(methodName);\n}\n\n/**\n * Find a property in a class\n */\nexport function findProperty(classDecl: ClassDeclaration, propertyName: string): PropertyDeclaration | undefined {\n  return classDecl.getProperty(propertyName);\n}\n\n/**\n * Check if an import exists\n */\nexport function hasImport(sourceFile: SourceFile, moduleSpecifier: string): boolean {\n  return sourceFile.getImportDeclarations().some(\n    imp => imp.getModuleSpecifierValue() === moduleSpecifier\n  );\n}\n\n/**\n * Get import declaration for a module\n */\nexport function getImport(sourceFile: SourceFile, moduleSpecifier: string): ImportDeclaration | undefined {\n  return sourceFile.getImportDeclarations().find(\n    imp => imp.getModuleSpecifierValue() === moduleSpecifier\n  );\n}\n\n/**\n * Add a named import to a file\n */\nexport function addNamedImport(\n  sourceFile: SourceFile,\n  moduleSpecifier: string,\n  namedImport: string\n): boolean {\n  const existingImport = getImport(sourceFile, moduleSpecifier);\n\n  if (existingImport) {\n    // Check if the named import already exists\n    const namedImports = existingImport.getNamedImports();\n    const exists = namedImports.some(ni => ni.getName() === namedImport);\n\n    if (!exists) {\n      existingImport.addNamedImport(namedImport);\n      return true;\n    }\n    return false;\n  }\n\n  // Add new import declaration\n  sourceFile.addImportDeclaration({\n    moduleSpecifier,\n    namedImports: [namedImport],\n  });\n  return true;\n}\n\n/**\n * Result of adding a locator property\n */\nexport interface AddLocatorResult {\n  /** Whether the property was added */\n  added: boolean;\n  /** Whether initialization was complete */\n  initialized: boolean;\n  /** Warning message if initialization was incomplete */\n  warning?: string;\n}\n\n/**\n * Add a locator property to a class\n *\n * @returns Result object with added/initialized status and optional warning\n */\nexport function addLocatorProperty(\n  classDecl: ClassDeclaration,\n  locator: ModuleLocator,\n  options: AstEditOptions = {}\n): AddLocatorResult {\n  const existing = findProperty(classDecl, locator.name);\n\n  if (existing) {\n    if (options.preserveExisting) {\n      return { added: false, initialized: false };\n    }\n    existing.remove();\n  }\n\n  // Add readonly property declaration\n  classDecl.addProperty({\n    name: locator.name,\n    isReadonly: true,\n    type: 'Locator',\n    docs: locator.description ? [{ description: locator.description }] : undefined,\n  });\n\n  const initStatement = `this.${locator.name} = page.${locator.playwright};`;\n\n  // Find or create constructor\n  let constructor = classDecl.getConstructors()[0];\n  if (!constructor) {\n    // Create constructor with page parameter\n    constructor = classDecl.addConstructor({\n      parameters: [{ name: 'page', type: 'Page' }],\n      statements: [`this.page = page;`, initStatement],\n    });\n\n    // Add page property if it doesn't exist\n    if (!findProperty(classDecl, 'page')) {\n      classDecl.insertProperty(0, {\n        name: 'page',\n        isReadonly: true,\n        type: 'Page',\n      });\n    }\n\n    return { added: true, initialized: true };\n  }\n\n  // Ensure constructor has a body\n  let body = constructor.getBody();\n  if (!body) {\n    // Add empty body to constructor\n    constructor.setBodyText('');\n    body = constructor.getBody();\n    if (!body) {\n      return {\n        added: true,\n        initialized: false,\n        warning: `Cannot add body to constructor for '${locator.name}' initialization`,\n      };\n    }\n  }\n\n  // Check if initialization already exists\n  const existingInit = body.getDescendantsOfKind(SyntaxKind.ExpressionStatement)\n    .find(stmt => stmt.getText().includes(`this.${locator.name}`));\n\n  if (!existingInit) {\n    constructor.addStatements(initStatement);\n  }\n\n  return { added: true, initialized: true };\n}\n\n/**\n * Add a method to a class\n */\nexport function addMethod(\n  classDecl: ClassDeclaration,\n  method: ModuleMethod,\n  options: AstEditOptions = {}\n): boolean {\n  const existing = findMethod(classDecl, method.name);\n\n  if (existing) {\n    if (options.preserveExisting) {\n      return false;\n    }\n    existing.remove();\n  }\n\n  // Add the method\n  classDecl.addMethod({\n    name: method.name,\n    isAsync: true,\n    parameters: method.params.map(p => ({\n      name: p.name,\n      type: p.type,\n      hasQuestionToken: p.optional,\n      initializer: p.defaultValue,\n    })),\n    returnType: `Promise<${method.returnType}>`,\n    docs: [{ description: method.description }],\n    statements: method.body.join('\\n'),\n  });\n\n  return true;\n}\n\n/**\n * Update an existing module file with new locators and methods\n */\nexport function updateModuleFile(\n  code: string,\n  className: string,\n  locators: ModuleLocator[],\n  methods: ModuleMethod[],\n  options: AstEditOptions = {}\n): AstEditResult {\n  const project = createProject();\n  const sourceFile = loadSourceFile(project, code);\n  const changes: string[] = [];\n  const warnings: string[] = [];\n\n  // Find the class\n  const classDecl = findClass(sourceFile, className);\n  if (!classDecl) {\n    return {\n      modified: false,\n      changes: [],\n      code,\n      warnings: [`Class '${className}' not found in source file`],\n    };\n  }\n\n  // Ensure Locator import exists\n  if (options.addImports !== false) {\n    if (addNamedImport(sourceFile, '@playwright/test', 'Locator')) {\n      changes.push('Added Locator import');\n    }\n    if (addNamedImport(sourceFile, '@playwright/test', 'expect')) {\n      changes.push('Added expect import');\n    }\n  }\n\n  // Add locators\n  for (const locator of locators) {\n    const result = addLocatorProperty(classDecl, locator, options);\n    if (result.added) {\n      changes.push(`Added locator: ${locator.name}`);\n      if (result.warning) {\n        warnings.push(result.warning);\n      }\n    } else if (options.preserveExisting) {\n      warnings.push(`Skipped existing locator: ${locator.name}`);\n    }\n  }\n\n  // Add methods\n  for (const method of methods) {\n    const added = addMethod(classDecl, method, options);\n    if (added) {\n      changes.push(`Added method: ${method.name}`);\n    } else if (options.preserveExisting) {\n      warnings.push(`Skipped existing method: ${method.name}`);\n    }\n  }\n\n  // Format if requested\n  if (options.formatOutput !== false) {\n    sourceFile.formatText();\n  }\n\n  return {\n    modified: changes.length > 0,\n    changes,\n    code: sourceFile.getFullText(),\n    warnings,\n  };\n}\n\n/**\n * Extract method body text safely\n */\nfunction extractMethodBodyText(method: MethodDeclaration): string {\n  const body = method.getBody();\n  if (!body) return '';\n\n  // Get the text between { and }\n  const fullText = body.getText();\n  // Remove the braces and trim\n  const inner = fullText.slice(1, -1).trim();\n  return inner;\n}\n\n/**\n * Merge two module files, preferring the second for conflicts\n */\nexport function mergeModuleFiles(\n  existingCode: string,\n  newCode: string,\n  className: string,\n  options: AstEditOptions = {}\n): AstEditResult {\n  const project = createProject();\n  const existingFile = loadSourceFile(project, existingCode, 'existing.ts');\n  const newFile = loadSourceFile(project, newCode, 'new.ts');\n  const changes: string[] = [];\n  const warnings: string[] = [];\n\n  // Find classes\n  const existingClass = findClass(existingFile, className);\n  const newClass = findClass(newFile, className);\n\n  if (!existingClass) {\n    return {\n      modified: false,\n      changes: [],\n      code: existingCode,\n      warnings: [`Class '${className}' not found in existing file`],\n    };\n  }\n\n  if (!newClass) {\n    return {\n      modified: false,\n      changes: [],\n      code: existingCode,\n      warnings: [`Class '${className}' not found in new file`],\n    };\n  }\n\n  // Merge imports\n  const newImports = newFile.getImportDeclarations();\n  for (const imp of newImports) {\n    const moduleSpec = imp.getModuleSpecifierValue();\n    for (const namedImp of imp.getNamedImports()) {\n      if (addNamedImport(existingFile, moduleSpec, namedImp.getName())) {\n        changes.push(`Added import: ${namedImp.getName()} from ${moduleSpec}`);\n      }\n    }\n  }\n\n  // Merge properties\n  const newProperties = newClass.getProperties();\n  for (const prop of newProperties) {\n    const propName = prop.getName();\n    const existingProp = findProperty(existingClass, propName);\n\n    if (!existingProp) {\n      existingClass.addProperty({\n        name: propName,\n        isReadonly: prop.isReadonly(),\n        type: prop.getType().getText(),\n      });\n      changes.push(`Added property: ${propName}`);\n    } else if (!options.preserveExisting) {\n      existingProp.remove();\n      existingClass.addProperty({\n        name: propName,\n        isReadonly: prop.isReadonly(),\n        type: prop.getType().getText(),\n      });\n      changes.push(`Updated property: ${propName}`);\n    } else {\n      warnings.push(`Skipped existing property: ${propName}`);\n    }\n  }\n\n  // Merge methods\n  const newMethods = newClass.getMethods();\n  for (const method of newMethods) {\n    const methodName = method.getName();\n    const existingMethod = findMethod(existingClass, methodName);\n\n    if (!existingMethod) {\n      existingClass.addMethod({\n        name: methodName,\n        isAsync: method.isAsync(),\n        parameters: method.getParameters().map(p => ({\n          name: p.getName(),\n          type: p.getType().getText(),\n          hasQuestionToken: p.hasQuestionToken(),\n          initializer: p.getInitializer()?.getText(),\n        })),\n        returnType: method.getReturnType().getText(),\n        statements: extractMethodBodyText(method),\n      });\n      changes.push(`Added method: ${methodName}`);\n    } else if (!options.preserveExisting) {\n      existingMethod.remove();\n      existingClass.addMethod({\n        name: methodName,\n        isAsync: method.isAsync(),\n        parameters: method.getParameters().map(p => ({\n          name: p.getName(),\n          type: p.getType().getText(),\n          hasQuestionToken: p.hasQuestionToken(),\n          initializer: p.getInitializer()?.getText(),\n        })),\n        returnType: method.getReturnType().getText(),\n        statements: extractMethodBodyText(method),\n      });\n      changes.push(`Updated method: ${methodName}`);\n    } else {\n      warnings.push(`Skipped existing method: ${methodName}`);\n    }\n  }\n\n  // Format\n  if (options.formatOutput !== false) {\n    existingFile.formatText();\n  }\n\n  return {\n    modified: changes.length > 0,\n    changes,\n    code: existingFile.getFullText(),\n    warnings,\n  };\n}\n\n/**\n * Extract class structure from source code\n */\nexport function extractClassStructure(code: string, className: string): {\n  properties: string[];\n  methods: string[];\n  imports: string[];\n} | null {\n  const project = createProject();\n  const sourceFile = loadSourceFile(project, code);\n  const classDecl = findClass(sourceFile, className);\n\n  if (!classDecl) {\n    return null;\n  }\n\n  return {\n    properties: classDecl.getProperties().map(p => p.getName()),\n    methods: classDecl.getMethods().map(m => m.getName()),\n    imports: sourceFile.getImportDeclarations()\n      .flatMap(imp => imp.getNamedImports().map(ni => ni.getName())),\n  };\n}\n\n/**\n * Validate TypeScript code syntax\n */\nexport function validateSyntax(code: string): {\n  valid: boolean;\n  errors: string[];\n} {\n  const project = createProject();\n\n  try {\n    const sourceFile = loadSourceFile(project, code);\n    const diagnostics = sourceFile.getPreEmitDiagnostics();\n\n    const errors = diagnostics\n      .filter(d => d.getCategory() === 1) // Error category\n      .map(d => d.getMessageText().toString());\n\n    return {\n      valid: errors.length === 0,\n      errors,\n    };\n  } catch (error) {\n    return {\n      valid: false,\n      errors: [(error as Error).message],\n    };\n  }\n}\n","/**\n * Module Registry - Track and update module index files\n * @see research/2026-01-02_autogen-refined-plan.md Section 12\n */\nimport { readFileSync, writeFileSync, existsSync } from 'node:fs';\nimport { basename, dirname, relative } from 'node:path';\nimport { Project } from 'ts-morph';\nimport type { ModuleDefinition } from './generateModule.js';\n\n/**\n * Module registry entry\n */\nexport interface RegistryEntry {\n  /** Module name (PascalCase) */\n  moduleName: string;\n  /** Class name */\n  className: string;\n  /** File path relative to registry */\n  filePath: string;\n  /** Module scope */\n  scope: string;\n  /** Export type */\n  exportType: 'class' | 'function' | 'const';\n}\n\n/**\n * Module registry state\n */\nexport interface ModuleRegistry {\n  /** Registry file path */\n  registryPath: string;\n  /** Registered modules */\n  entries: RegistryEntry[];\n  /** Last updated timestamp */\n  lastUpdated: Date;\n}\n\n/**\n * Options for registry operations\n */\nexport interface RegistryOptions {\n  /** Create registry file if it doesn't exist */\n  createIfMissing?: boolean;\n  /** Preserve manual exports in index file */\n  preserveManualExports?: boolean;\n  /** Sort exports alphabetically */\n  sortExports?: boolean;\n}\n\n/**\n * Result of registry update\n */\nexport interface RegistryUpdateResult {\n  /** Whether the registry was modified */\n  modified: boolean;\n  /** Entries added */\n  added: string[];\n  /** Entries removed */\n  removed: string[];\n  /** Updated registry content */\n  content: string;\n}\n\n/**\n * Load module registry from an index file\n */\nexport function loadRegistry(indexPath: string): ModuleRegistry | null {\n  if (!existsSync(indexPath)) {\n    return null;\n  }\n\n  const content = readFileSync(indexPath, 'utf-8');\n  const entries = parseIndexFile(content, indexPath);\n\n  return {\n    registryPath: indexPath,\n    entries,\n    lastUpdated: new Date(),\n  };\n}\n\n/**\n * Parse an index.ts file to extract module entries\n */\nexport function parseIndexFile(content: string, _indexPath?: string): RegistryEntry[] {\n  const entries: RegistryEntry[] = [];\n  const project = new Project({ useInMemoryFileSystem: true });\n  const sourceFile = project.createSourceFile('index.ts', content);\n\n  // Parse export declarations\n  const exportDeclarations = sourceFile.getExportDeclarations();\n\n  for (const exportDecl of exportDeclarations) {\n    const moduleSpecifier = exportDecl.getModuleSpecifierValue();\n    if (!moduleSpecifier) continue;\n\n    const namedExports = exportDecl.getNamedExports();\n\n    for (const namedExport of namedExports) {\n      const exportName = namedExport.getName();\n      const aliasNode = namedExport.getAliasNode();\n      const alias = aliasNode ? aliasNode.getText() : exportName;\n\n      // Determine export type from name convention\n      let exportType: 'class' | 'function' | 'const' = 'class';\n      if (exportName.startsWith('create') || exportName.endsWith('Factory')) {\n        exportType = 'function';\n      } else if (exportName === exportName.toUpperCase()) {\n        exportType = 'const';\n      }\n\n      entries.push({\n        moduleName: alias,\n        className: exportName,\n        filePath: moduleSpecifier,\n        scope: extractScope(moduleSpecifier),\n        exportType,\n      });\n    }\n  }\n\n  // Parse re-exports (export * from './module')\n  const starExports = content.match(/export\\s+\\*\\s+from\\s+['\"]([^'\"]+)['\"]/g);\n  if (starExports) {\n    for (const match of starExports) {\n      const pathMatch = match.match(/['\"]([^'\"]+)['\"]/);\n      if (pathMatch) {\n        const modulePath = pathMatch[1]!;\n        entries.push({\n          moduleName: extractModuleName(modulePath),\n          className: '*',\n          filePath: modulePath,\n          scope: extractScope(modulePath),\n          exportType: 'class',\n        });\n      }\n    }\n  }\n\n  return entries;\n}\n\n/**\n * Extract module name from file path\n */\nfunction extractModuleName(filePath: string): string {\n  const base = basename(filePath, '.js').replace('.page', '');\n  return toPascalCase(base);\n}\n\n/**\n * Extract scope from file path\n */\nfunction extractScope(filePath: string): string {\n  // e.g., './auth/login.page.js' -> 'auth'\n  const dir = dirname(filePath);\n  if (dir === '.' || dir === './') {\n    return basename(filePath, '.js').replace('.page', '');\n  }\n  return basename(dir);\n}\n\n/**\n * Convert to PascalCase\n */\nfunction toPascalCase(str: string): string {\n  return str\n    .split(/[-_\\s]+/)\n    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n    .join('');\n}\n\n/**\n * Generate index file content from entries\n */\nexport function generateIndexContent(\n  entries: RegistryEntry[],\n  options: RegistryOptions = {}\n): string {\n  const lines: string[] = [\n    '/**',\n    ' * Module Registry - Auto-generated index',\n    ' * @generated by @artk/core-autogen',\n    ' */',\n  ];\n\n  // Group entries by file path\n  const byFile = new Map<string, RegistryEntry[]>();\n  for (const entry of entries) {\n    const existing = byFile.get(entry.filePath) || [];\n    existing.push(entry);\n    byFile.set(entry.filePath, existing);\n  }\n\n  // Sort if requested\n  let filePaths = Array.from(byFile.keys());\n  if (options.sortExports) {\n    filePaths = filePaths.sort();\n  }\n\n  // Generate exports\n  for (const filePath of filePaths) {\n    const fileEntries = byFile.get(filePath)!;\n\n    // Check if it's a star export\n    if (fileEntries.length === 1 && fileEntries[0]!.className === '*') {\n      lines.push(`export * from '${filePath}';`);\n    } else {\n      // Named exports\n      const exports = fileEntries.map(e => {\n        if (e.moduleName !== e.className) {\n          return `${e.className} as ${e.moduleName}`;\n        }\n        return e.className;\n      });\n\n      if (options.sortExports) {\n        exports.sort();\n      }\n\n      lines.push(`export { ${exports.join(', ')} } from '${filePath}';`);\n    }\n  }\n\n  return lines.join('\\n') + '\\n';\n}\n\n/**\n * Add a module to the registry\n */\nexport function addToRegistry(\n  registry: ModuleRegistry,\n  module: ModuleDefinition,\n  filePath: string\n): RegistryEntry {\n  const entry: RegistryEntry = {\n    moduleName: module.moduleName,\n    className: module.className,\n    filePath,\n    scope: module.scope,\n    exportType: 'class',\n  };\n\n  // Check if already exists\n  const existingIndex = registry.entries.findIndex(\n    e => e.filePath === filePath || e.moduleName === module.moduleName\n  );\n\n  if (existingIndex >= 0) {\n    registry.entries[existingIndex] = entry;\n  } else {\n    registry.entries.push(entry);\n  }\n\n  registry.lastUpdated = new Date();\n  return entry;\n}\n\n/**\n * Remove a module from the registry\n */\nexport function removeFromRegistry(\n  registry: ModuleRegistry,\n  moduleNameOrPath: string\n): boolean {\n  const initialLength = registry.entries.length;\n\n  registry.entries = registry.entries.filter(\n    e => e.moduleName !== moduleNameOrPath && e.filePath !== moduleNameOrPath\n  );\n\n  const removed = registry.entries.length < initialLength;\n  if (removed) {\n    registry.lastUpdated = new Date();\n  }\n\n  return removed;\n}\n\n/**\n * Update index file with new modules\n */\nexport function updateIndexFile(\n  indexPath: string,\n  newModules: Array<{ module: ModuleDefinition; filePath: string }>,\n  options: RegistryOptions = {}\n): RegistryUpdateResult {\n  let registry = loadRegistry(indexPath);\n  const added: string[] = [];\n  const removed: string[] = [];\n\n  if (!registry) {\n    if (!options.createIfMissing) {\n      return {\n        modified: false,\n        added: [],\n        removed: [],\n        content: '',\n      };\n    }\n\n    registry = {\n      registryPath: indexPath,\n      entries: [],\n      lastUpdated: new Date(),\n    };\n  }\n\n  // Track existing entries if preserving\n  const existingNames = new Set(registry.entries.map(e => e.moduleName));\n\n  // Add new modules\n  for (const { module, filePath } of newModules) {\n    const relativePath = filePath.startsWith('.')\n      ? filePath\n      : `./${relative(dirname(indexPath), filePath).replace(/\\\\/g, '/')}`;\n\n    // Remove .ts extension and add .js for ESM\n    const importPath = relativePath.replace(/\\.ts$/, '.js');\n\n    addToRegistry(registry, module, importPath);\n\n    if (!existingNames.has(module.moduleName)) {\n      added.push(module.moduleName);\n    }\n  }\n\n  // Generate updated content\n  const content = generateIndexContent(registry.entries, options);\n\n  return {\n    modified: added.length > 0 || removed.length > 0,\n    added,\n    removed,\n    content,\n  };\n}\n\n/**\n * Scan directory for module files and build registry\n */\nexport function scanModulesDirectory(\n  _dirPath: string,\n  _pattern = '*.page.ts'\n): RegistryEntry[] {\n  // This is a simplified implementation\n  // In production, would use glob to find files\n  // For now, return empty array - actual scanning happens via glob in CLI\n  return [];\n}\n\n/**\n * Create a new empty registry\n */\nexport function createRegistry(indexPath: string): ModuleRegistry {\n  return {\n    registryPath: indexPath,\n    entries: [],\n    lastUpdated: new Date(),\n  };\n}\n\n/**\n * Save registry to disk\n */\nexport function saveRegistry(\n  registry: ModuleRegistry,\n  options: RegistryOptions = {}\n): void {\n  const content = generateIndexContent(registry.entries, options);\n  writeFileSync(registry.registryPath, content, 'utf-8');\n}\n\n/**\n * Find entry by module name\n */\nexport function findEntry(\n  registry: ModuleRegistry,\n  moduleName: string\n): RegistryEntry | undefined {\n  return registry.entries.find(e => e.moduleName === moduleName);\n}\n\n/**\n * Find entry by scope\n */\nexport function findEntriesByScope(\n  registry: ModuleRegistry,\n  scope: string\n): RegistryEntry[] {\n  return registry.entries.filter(e => e.scope === scope);\n}\n\n/**\n * Check if module exists in registry\n */\nexport function hasModule(registry: ModuleRegistry, moduleName: string): boolean {\n  return registry.entries.some(e => e.moduleName === moduleName);\n}\n\n/**\n * Get all module names\n */\nexport function getModuleNames(registry: ModuleRegistry): string[] {\n  return registry.entries.map(e => e.moduleName);\n}\n\n/**\n * Get registry statistics\n */\nexport function getRegistryStats(registry: ModuleRegistry): {\n  totalModules: number;\n  byScope: Record<string, number>;\n  byType: Record<string, number>;\n} {\n  const byScope: Record<string, number> = {};\n  const byType: Record<string, number> = {};\n\n  for (const entry of registry.entries) {\n    byScope[entry.scope] = (byScope[entry.scope] || 0) + 1;\n    byType[entry.exportType] = (byType[entry.exportType] || 0) + 1;\n  }\n\n  return {\n    totalModules: registry.entries.length,\n    byScope,\n    byType,\n  };\n}\n"]}